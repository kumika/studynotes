name	title	details	created_date
kumika	1时间复杂度定义：	"#  1时间复杂度定义：

------

**评估执行程序所需的时间。可以估算出程序对处理器的使用程度。**
设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度。

# 2 时间复杂度：
--------

2.1时间频度：
--------

一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的**语句执行次数**称为**语句频度**或**时间频度**。记为T(n)。


*什么嘛，这里的频度其实就是数学上的指数，然后在实际中，我们是只设定循环判断的输入变量的初始值和判断范围值，输入变量在经过判断后增加数值的指数是机器计算的，现在我们需要人工估算，进行改进。*



2.2时间复杂度：
---------

时间频度T(n)中，n称为**问题的规模**，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有**某个辅助函数f(n)**，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称**f(n)是T(n)的同数量级函数**，

> 记作T(n)=O(f(n))

，它称为算法的渐进时间复杂度，简称**时间复杂度**。
*T(n) = 循环体运行次数 * （循环体语句频度 + 循环判定语句频度）经验公式？！目前好像感觉不行。先记着*

# 3大o表示法：
-------

前面用O( )来体现算法时间复杂度的记法，我们称之为大O表示法。
算法复杂度可以从最理想情况、平均情况和最坏情况三个角度来评估，由于平均情况大多和最坏情况持平，而且评估最坏情况也可以避免后顾之忧，因此一般情况下，我们设计算法时都要直接估算最坏情况的复杂度。 
大O表示法O(f(n)中的f(n)的值可以为1、n、logn、n²等，因此我们可以将O(1)、O(n)、O(logn)、O(n²)分别可以称为常数阶、线性阶、对数阶和平方阶，那么如何推导出f(n)的值呢？我们接着来看推导大O阶的方法。

3.1推导大O阶
--------

推导大O阶，我们可以按照如下的规则来进行推导，得到的结果就是大O表示法： 
1.用常数1来取代运行时间中所有加法常数。 
2.修改后的运行次数函数中，**只保留最高阶项** 
3.如果***最高阶项存在且不是1，则去除与这个项相乘的常数。***

3.1.1常数阶
--------

      int sum = 0,n = 100; //执行一次  
      sum = (1+n)*n/2; //执行一次  
      System.out.println (sum); //执行一次


上面算法的运行的次数的函数为f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为O(1)。如果sum = （1+n）*n/2这条语句再执行10遍，因为这与问题大小n的值并没有关系，所以这个算法的时间复杂度仍旧是O(1)，我们可以称之为常数阶

3.1.2线性阶和立方阶
------------

T(n) 或者f(n)  = 循环体运行次数 * （循环体语句频度 + 循环判定语句频度）
下面的例子判断语句都是加减法，所以算1

    例子1 ：
    for(int i=0;i<n;i++){           //循环次数为n
    printf(“faker is mid god!!!”)  //时间复杂度为O(1)的算法
    ...
    }

上面算法循环体中的代码执行了n次，因此时间复杂度为O(n * 1) 即为O(n)。

例子2 ：
对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c...，则这个循环的时间**复杂度为 O(n×a×b×c...)**。分析的时候应该由里向外分析这些循环。

    void aFunc(int n) {
        for(int i = 0; i < n; i++) {         // 循环次数为 n
            for(int j = 0; j < n; j++) {       // 循环次数为 n
                printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
            }
        }
    }

此时时间复杂度为 O(n × n × 1)，即 O(n^2)。


例子3：对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度

    void aFunc(int n) {
        // 第一部分时间复杂度为 O(n^2)
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                printf("Hello, World!\n");
            }
        }
        // 第二部分时间复杂度为 O(n)
        for(int j = 0; j < n; j++) {
            printf("Hello, World!\n");
        }
    }

此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)


例子4：对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度

    void aFunc(int n) {
        if (n >= 0) {
            // 第一条路径时间复杂度为 O(n^2)
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < n; j++) {
                    printf("输入数据大于等于零\n");
                }
            }
        } else {
            // 第二条路径时间复杂度为 O(n)
            for(int j = 0; j < n; j++) {
                printf("输入数据小于零\n");
            }
        }
    }

此时时间复杂度为 **max(O(n^2), O(n))，即 O(n^2)，**
时间复杂度分析的基本策略是**：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析**。


3.1.3对数阶
--------

> T(n) 或者f(n)  = 循环体运行次数 * （循环体语句频度 + 循环判定语句频度）

下面例子的判断语句是乘除法，需要进行算出指数，这个指数就是所需要的时间复杂度
麻蛋，几把例子的输入变量都是在循环体内进行更新，有什么意思
例子1：

    int number=1;
    while(number<n) 
    {
       number=number*2;
    //时间复杂度为O(1)的算法
    ...
    }

可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。
**为什么记做O（log n） ？**
因为：

> 算法的 T(n) = O(log n)，则称其具有**对数时间**。由于计算机使用二进制的记数系统，对数常常以10为底（即log10 n，有时写作
> lg n）。然而，由对数的换底公式，loga n和 logb n只有一个常数因子不同，这个因子在大O记法中被丢弃。因此记作O(log
> n)，而不论对数的底是多少，是对数时间算法的标准记法

另外的解释：假设循环次数为 t，则循环条件满足 2^t < n。
可以得出，执行次数t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。

另外的解释 ：
记得f(n)是辅助函数
number=number*2语句频度是f(n),   
则：2^f(n)<=n;      f(n)<=log2n    
取最大值f(n)=log2n,
T(n)=O(log2n )

3.1.3 其他阶
---------

**f(n)=nlogn时，时间复杂度为O(nlogn)，可以称为nlogn阶。 
f(n)=n³时，时间复杂度为O(n³)，可以称为立方阶。 
f(n)=2ⁿ时，时间复杂度为O(2ⁿ)，可以称为指数阶。 
f(n)=n!时，时间复杂度为O(n!)，可以称为阶乘阶。 
f(n)=(√n时，时间复杂度为O(√n)，可以称为平方根阶。**


# 4 复杂度的比较

n	|	logn |	√n|	nlogn|	n²|	2ⁿ|	n!
- | :-: | -: 
5 |		2|	2|	10|	25|	32|	120
10		|3	|3|	30	|100	|1024|	3628800
50		|5|	7|	250|	2500|	约10^15|	约3.0*10^64
100		|6	|10	|600	|10000|	约10^30	|约9.3*10^157
1000	|	9|	31|	9000|	1000 000	|约10^300	|约4.0*10^2567


从上表可以看出，O(n)、O(logn)、O(√n )、O(nlogn )随着n的增加，复杂度提升不大，因此这些复杂度属于效率高的算法，反观O(2ⁿ)和O(n!)当n增加到50时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，因此在动手编程时要评估所写算法的最坏情况的复杂度。


时间1.1图
![时间1.1图][1]
时间1.2图
![时间1.2图][2]

> O(1)< O(logn) < O(n)< O(nlogn)< O(n²)< O(n³)< O(2ⁿ)< O(n!)

指数时间的关系为：
  

>   O(2n) < O(n!) < O(nn)



# 5 而外的例子
T(n) 或者f(n)  = 循环体运行次数 * （循环体语句频度 + 循环判定语句频度）
一定要记得项数前的常量是可以消除的，毕竟是估算

    int num1, num2;
    
    for(int i=0; i<n; i++){ 
    	num1 += 1;
    
    	for(int j=1; j<=n; j*=2){ 
    
    		num2 += num1;
    
    	}
    }


参考：https://www.zhihu.com/question/20503898
for(int j=1; j<=n; j*=2)
这个循环最终执行的次数假设为x，则x次的时候j=2^x 
当j>n时停止执行，于是2^x>n 则可以认为该循环一共执行了log2(n)次
所以该循环的时间复杂度为o(log2(n))简记为o(log n) 忽略掉2的底数

另外的解释：
如果不看循环内执行语句，单单看循环本身的话，这个问题是不是就很好理解。
首先，我们来看外循环for（i=0；i<n；i++），按照i++的递加速度，直到这个循环退出，一共是n次。
再来看看内部循环，for（j=1；j<n;j*=2）,这个内部循环的累加速度是j=j*2，假设循环x次之后，这个循环退出，2^x>n===》x=log(2)N 
ps:(2)代表底数，请原谅我打不出正确的数学符号，sorry
如果把两个循环合在一起看的话，也就是一共循环了n个x次，也就是n*log(2)N

> 递归算法的时间复杂度计算：递归总次数*每次递归次数.

练习题http://c.biancheng.net/cpp/html/2653.html
参考：https://blog.csdn.net/firefly_2002/article/details/8008987

时间2.1图
![时间2.1图][3]
时间2.2图
![时间2.2图][4]



理解好：i+1,i+2 到n ，用长度就好理解了


 


  [1]: https://i.loli.net/2018/07/16/5b4c7fc3732b3.png
  [2]: https://i.loli.net/2018/07/16/5b4c7fc36ff30.png
  [3]: https://i.loli.net/2018/07/16/5b4c7fc37132a.png
  [4]: https://i.loli.net/2018/07/16/5b4c7fc3719e2.png"	2018-07-16 18:31:11
kumika	空间复杂度：	"# 空间复杂度：

定义：

---

似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。
    空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\"进行的，是节省存储的算法，如这一节介绍过的几个算法都是如此；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如将在第九章介绍的快速排序和归并排序算法就属于这种情况。
如**当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)**；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量


**算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的公式是S(n)=O(f(n)),n是问题规模，f(n)是关于n的存储空间的函数。
一般情况下，一个程序在机器上执行时，除了存储本身需要的指令、常量、变量和输入数据以外，还需要一些对数据进行操作的辅助存储空间。其中，对于输入数据所占用的具体存储量取决于问题本身，与算法无关，这样只需要分析该算法在实现时所需要的辅助空间单元个数即可。**

算法1：

    for(i=0;i<n;i++){
        b[i]=a[n-i-1];
    }
    for(i=0;i<n;i++){
        a[i]=b[i]
    }

算法2：

    for(i=0;i<n/2;i++){
        t=a[i];
        a[i]=a[n-i-1];
        a[n-i-1]=t;
    }

算法1的空间复杂度为O(n),需要一个大小为n的辅助数组b。
算法2的空间复杂度为O(1),需要一个变量t，与问题规模无关


想使一个算法既占用存储空间少，又运行时间短，在现实中是很难做到的，要节约算法的执行时间往往要牺牲更多空间作为代价，而为了节省空间可能要消耗更多的计算时间，因此，具体的情况要看具体的需求来分析。

#简单解释
----

https://blog.csdn.net/qq_29503203/article/details/52464306
空间复杂度
空间复杂度，它是对一个算法在运行过程中临时占用存储空间大小的量度。所以它强调的是

> 使用的辅助空间的的大小，而不是指所有的数据所占用的空间。

要注意的是**递归算法的空间复杂度**，假如**递归深度**为N*每次递归的辅助空间大小，如果每次递归的辅助空间为常数，则空间复杂度为O(N)。

由于大部分算法的空间复杂度问题并不严重，并且算法的空间复杂度分析方法和算法的时间复杂度分析方法基本相同，所以一般数据结构只讨论算法的时间复杂度，不讨论算法的空间复杂度

下面通过斐波那契数列对时间，空间复杂度进行分析一下：

    1.	long long* fib(long long n)  
    2.	{  
    3.	    assert(n>=0);  
    4.	    long long* ptr=new long long[n+1];  
    5.	    ptr[0]=0;  
    6.	    ptr[1]=1;  
    7.	    for(int i=2;i<=n;++i)  
    8.	    {  
    9.	        ptr[i]=ptr[i-1]+ptr[i-2];  
    10.	    }  
    11.	    return ptr;  
    12.	}

对于这种算法，函数真正执行次数为n-1,所以忽略常数后，时间复杂度为O(n);
因为开辟了n+1个空间，有n+1个辅助空间，所以空间复杂度为O(n).




    1.	long long fib(long long n)  
    2.	{  
    3.	    assert(n>=0);  
    4.	    long long first=0;  
    5.	    long long second=1;  
    6.	    long long ret=0;  
    7.	        for(int i=2;i<=n;i++)  
    8.	    {  
    9.	        ret=first+second;  
    10.	        first=second;  
    11.	        second=ret;  
    12.	    }  
    13.	    return ret;  
    14.	} 

这是非递归的另一种算法，函数真正执行次数依然为n-1,所以忽略常数后，时间复杂度还是O(n);
由于采用变量交换的方式，所以在这里辅助空间个数为一个常数，空间复杂度为O(1).


再看一下递归算法

    1.	#include<assert.h>  
    2.	#include<iostream>  
    3.	using namespace std;  
    4.	long long fib(long long n)  
    5.	{  
    6.	    assert(n>=0);  
    7.	    return (n<2)?(n):(fib(n-1)+fib(n-2));  
    8.	}  
    9.	int main()  
    10.	{  
    11.	        long long value=fib(15);  
    12.	    cout<< value <<endl;  
    13.	    system("pause");  
    14.	    return 0;  
    15.	}  

递归算法的时间复杂度计算方法是:递归总次数*每次递归次数；
递归算法的空间复杂度计算方法是：递归深度*每次递归所需的辅助空间个数.

最早斐波那契研究该数列时，为了描述清楚就以兔子生长情况为例：
.第一个月有一对刚诞生的兔子；
.第二个月后可生育；
.每月每对可生育的兔子会诞生下一对新兔子；
.假设兔子永不死去。

空间1.1
![空间1.1][1]
由上图可以得出斐波那契递归算法时间复杂度：O（2^N），空间复杂度为:O(N)


下面再看一个有关二分查找的的例子：
递归情况

    1.	int BinarySearch2(const int* ptr,const int x,const int left,const int right)  
    2.	{  
    3.	    int mid=(left+right)/2;  
    4.	    while(left<=right)  
    5.	    {  
    6.	        if(x<ptr[mid])  
    7.	        {  
    8.	            return BinarySearch2(ptr,x,left,mid-1);  
    9.	        }  
    10.	        else if(x>ptr[mid])  
    11.	        {  
    12.	            return BinarySearch2(ptr,x,mid+1,right);  
    13.	        }  
    14.	        return mid;  
    15.	    }  
    16.	} 

1)假设以最坏情况考虑，二分查找第一次在n/2中查找(n为元素个数)；第二次在一半的一半中查找，即n/2/2=n/4;
**……第x次在n/2^x范围内查找，即2^x=n(x=log2^n),所以时间复杂度为O(log2^n).
2)递归情况下的空间复杂度：递归深度为N*每次递归的辅助空间大小，如果每次递归的辅助空间为常数，则空间复杂度为O(N)。
对于递归的二分查找，递归深度是log2^n，每次递归的辅助空间为常数，所以空间复杂度为O(log2^N)**

非递归情况

    1.	int BinarySearch1(const int* ptr,const int x,const int len)  
    2.	{  
    3.	    int left=0;  
    4.	    int right=len-1;  
    5.	    int mid=(left+right)/2;  
    6.	    while(left<=right)  
    7.	    {  
    8.	        if(x<ptr[mid])  
    9.	        {  
    10.	            right=mid-1;  
    11.	        }  
    12.	        else if(x>ptr[mid])  
    13.	        {  
    14.	            left=mid+1;  
    15.	        }  
    16.	        else  
    17.	        {  
    18.	            return mid;  
    19.	        }  
    20.	    }  
    21.	    return -1;  
    22.	}  

对于非递归的二分查找与递归查找的时间复杂度一样的分析方法,所以时间复杂度为O(log2^n)；
但是在这个过程中，辅助空间为常数级别，所以空间复杂度为O(1)

# 一般解释：
-----

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。
一个算法在计算机存储器上所占用的存储空间，
包括程序代码所占用的空间，输入数据所占用的空间和辅助变量所占用的空间这三个方面。
算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，
它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，
就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，
而且不随问题规模的大小而改变，我们称这种算法是“就地"进行的，是节省存储的算法，如这些介绍过的几个算法都是如此；
有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，
例如将在第九章介绍的快速排序和归并排序算法就属于这种情况。
    分析一个算法所占用的存储空间要从各方面综合考虑。如对于递归算法来说，一般都比较简短，算法本身所占用的存储空间较少，但运行时需要一个附加堆栈，从而占用较多的临时工作单元；若写成非递归算法，一般可能比较长，算法本身占用的存储空间较多，但运行时将可能需要较少的存储单元。
    一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。若一个算法为递归算法，其空间复杂度为递归所使用的堆栈空间的大小，它等于一次调用所分配的临时存储空间的大小乘以被调用的次数(即为递归调用的次数加1，这个1表不开始进行的一次非递归调用)。算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(log2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。
    对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当=i自求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。

 
空间复杂度是程序运行所以需要的额外消耗存储空间,也用o()来表示

　　比如插入排序的时间复杂度是o(n2),空间复杂度是o(1)
　　而一般的递归算法就要有o(n)的空间复杂度了,因为每次递归都要存储返回信息
　　一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量，算法执行时间的度量不是采用算法执行的绝对时间来计算的，因为一个算法在不同的机器上执行所花的时间不一样，在不同时刻也会由于计算机资源占用情况的不同，使得算法在同一台计算机上执行的时间也不一样，所以对于算法的时间复杂性，采用算法执行过程中其基本操作的执行次数，称为计算量来度量。
　　算法中基本操作的执行次数一般是与问题规模有关的，对于结点个数为n的数据处理问题，用T(n)表示算法基本操作的执行次数.在评价算法的时间复杂性时，不考虑两算法执行次数之间的细小区别，而只关心算法的本质差别:
　　为此，引入一个所谓的O() 记号，则T1(n)=2n=O(n),T2(n)=n+1=O(n)。一个函数f(n)是O(g(n))的，则一定存在正常数c和m，使对所有的n>m，都满足f(n)<c*g(n)。

参考：https://www.cnblogs.com/zakers/archive/2015/09/14/4808821.html


  [1]: https://i.loli.net/2018/07/16/5b4ca67c4236e.png"	2018-07-16 19:30:48
kumika	1 线性表	"# 1 线性表

引子：多项式的表示

---

引出一个事物的表述可以有不同方法进行存储进计算机中


![此处输入图片的描述][1]

![此处输入图片的描述][2]

![此处输入图片的描述][3]

![此处输入图片的描述][4]

![此处输入图片的描述][5]
线性表定义：
------

由同类型数据元素构成有序序列的线性结构

> 1 表中元素个数称为线性表的长度 
2 线性表没有元素时，称为空表 
3 表起始位置称表头，表结束位置称表尾


***这里介绍轮子是最底层的，就是说是最原始的需要自己写的，不像java，我就直接是使用别人大师级别的接口，不需要自己在写一遍类似的接口。就像作为司机，汽车是不需要自己会造，但是要会用，同时懂得汽车内部结构是更好的。***

Java这里是没有指针的，所以在想象链表结构的时候想象成一条绳子状是不准确的，更好的理解应该是类似于俄罗斯嵌套娃娃的

线性表的基本操作集合（个人理解为函数）：
--------------------
对于不同的应用，线性表的基本操作是不同的，下述操作是最基本的。
对于实际问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。

> 1.求元素个数    int Length( List L )：返回线性表L的长度n

> 2.插入          void Insert( ElementType X, int i, List L)：在位序i前插入一个新元素X

> 3.删除 			void Delete( int  i, List L )：删除指定位序i的元素

> 4.查找   int Find( ElementType X, List L )：在线性表L中查找X的第一次出现位置 		 ElementType FindKth( int K, List L )：根据位序K，返回相应元素

> 5.判断是否为空 使记录线性表长度L长度n为0就是空

> 6. 初始化线性表  List MakeEmpty()：初始化一个空线性表L


# 2 线性表存储实现：
--------

> 有2种存储实现 ： 		
1 顺序存储：  利用数组的连续存储空间顺序存放线性表的各元素 		
2 链式存储：  不要求逻辑上相邻的两个元素物理上也相邻；通过“链”建 立起数据元素之间的逻辑关系。 • 插入、删除不需要移动数据元素，只需要修改“链”。


1 顺序存储：
-------

顺序表是指顺序存储结构的线性表，指的是用一段地址连续的存储单元依次存储线性表的数据元素。
顺序表表现在物理内存中，也就是物理上的存储方式，事实上就是在内存中找个初始地址，然后通过占位的形式，把一定的内存空间给占了，然后把相同数据类型的数据元素依次放在这块空地中。注意，这块物理内存的地址空间是连续的。


![此处输入图片的描述][6]


举个例子，比如C语言中的基本变量的存储就是连续的存储在内存中的，比如声明一个整数i，在64位系统中整数i在内存中占8字节，那么系统就会在内存中为这 个整型变量分配一个长度为8个字节的连续的地址空间，然后把这个i的二进制形式从高地址向低地址存储，长度不足时候，最高位用0补齐。


对顺序存储内部构成进行解析：
--------------
**线性表能够按顺序存储的关键判断是什么？**

理解4个基本操作，**建立线性表，查找元素，插入元素，删除元素**，这4个基本操作混搭构成顺序存储

1.1 建立线性表： （实现代码java
--------------------

    private static int T002[];// 使用一位数组来存储
    private static  int n;// 记载顺序表长度
    
    /**
     *  功能1 初始化顺序表
     *  //顺序表的初始化 为顺序表分配n个存储单元；顺序表初始长度为0；
     *  可以看出顺序表的封装需要三个属性：
    
     1.存储空间的起始位置。数组data的存储位置就是线性表存储空间的存储位置
     2.线性表的最大存储容量。数组长度MAXSIZE
     3.线性表的当前长度。length
     */
    public SqLinearList(int maxsize) {
        T002 = new int[maxsize];
        this.n = 0;
    }

注意：数组的长度与线性表的当前长度是不一样的。数组的长度是存放线性表的存储空间的总长度，一般初始化后不变。而线性表的当前长度是线性表中元素的个数，是会改变的。
使数组按顺序放入值的函数**，重点是在判断上：i 从1开始，n是从0开始，当i＜=n的时候就进行数组赋值，然后进行更新，**

    public void setElement(int i, int k) {
        try {
            if (i > 0 && i <= (n + 1)) {//根据线性表当前长度n  按顺序进行一一赋值，    i > n则跳过
                T002[i - 1] = k;
                if (i == n + 1) {//对顺序表的当前长度进行更新
                    n++;
                }
            }
        } catch (Exception e) {
            System.out.println("您设置的第  " + i + "   个元素数组越界");
        }
    }

下面就是进行赋值操作：

    SqLinearList sl = new SqLinearList(9);
    sl.setElement(1,5);
    sl.setElement(2, 4);
    sl.setElement(6, 189);
    sl.setElement(7,23);
    sl.setElement(3, 3);
    sl.setElement(4, 2);
    sl.setElement(5, 1);


1.2查找元素：
--------

这里有2个方法，1个是for循环，1个是wihle循环，但是**查成功的比较次数是不一样的，for是n次，while是(n+1)/2次**，平均性能一样都是O(n)，所以**while方法好一点**。其中，这里面的差别就是判断语句不一样造成的。留心一点。

    /**
     * 功能8  查找元素
     * @param k
     * @return
     */
    public boolean findElement(int k) {
        boolean flag = false;
        for (int i = 0; i < n; i++) {
            if (T002[i] == k) {
                flag = true;
            }
        }
        System.out.println("查找1  flag= "+flag);
        return flag;
    }
    
    
    public int  findElement2(int k, int[] T002) {
        int i = 0;
        while (i <= T002.length &&  T002[i] != k)
            i++;
        if(i > T002.length) return -1;
        else
            System.out.println("output 数组里面的值  "+ T002[i]+" 数组下标的值 是 "+i);
            return i;
    }


1.3插入元素：
--------
在第i个位置插入新元素，需要先把ai里面的值向后移动，再赋值，整个长度+1
**重点是一定要把T002[i-1] 里面的值移动出来，保证T002[i-1]是空的**


![此处输入图片的描述][7]

![此处输入图片的描述][8]

**注意，数组下标是i – 1 是表示第i个元素
插入操作思路：**
1.如果插入位置不合理，抛出异常；
2.如果线性表长度大于等于数组长度，则抛出异常或动态增加数组容量；
3.从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；
4.将要插入元素填入位置i处；
5.线性表长+1。

    /**
     * 功能9  在第i个位置插入元素k
     * @param i
     * @param k
     */
    public void insertElement(int i, int k) {
        if (!isFull()) { //判断顺序表是否为满
            if (i <= 0) i = 1; //当插入位置  < 0 的时候就放在表头
            if (i > n ) i = n + 1; //当插入位置  > 表当前最大长度 的时候就放在表尾
            for (int j = n; j > i - 1; j--) { //j是表尾，停止是当j = i的时候
                T002[j] = T002[j - 1];//从表尾开始移动元素，一个个向后移动 平均移动次数位n/2, 平均时间性能为O(n)
            }
            T002[i - 1] = k; //向第i个位置插入元素k，数组下标要-1 忘记啦？
            n++;//线性表更新当前长度
        }else
            System.out.println("数组已满，无法插入K值");
    }

**在将ai----an倒叙向后移动的时候，平均移动次数位n/2, 平均时间性能为O(n)**

    /**
     * 功能3  判断顺序表是否为满
     * @return
     */
    public boolean isFull() {
        return  n >= T002.length;
    }

另外的写法：主要是判断边界的不一样


    public static int maxsize = 100 ;//表最大长度
    public void insert(int x, int i, int[] T002) {
        int j;
        if( T002.length == maxsize -1 ) {
            System.out.println("表满");
            return ;
        }
        if (i < 1 || i > T002.length + 2) {
            System.out.println("位置不合法");
            return ;
        }
    
        for (j = maxsize ; j >= i - 1; j--) {
            T002[j + 1] = T002[j];//和上面的是一样的，将j = i - 1带入进去，上面是j = i
            //重点是一定要把T002[i-1] 里面的值移动出来，保证T002[i-1]是空的
        }
        T002[i -1] = x;
        maxsize++;
    }


1.4删除元素：
--------

将ai+1 -----an 顺序向前移动

线性1.9
![此处输入图片的描述][9]
线性1.10
![此处输入图片的描述][10]
删除思路：
1.如果删除元素的位置不合理，抛出异常。比如用户删除第0个位置的元素（线性表是从1开始的）、删除元素的位置大于线性表的长度也要抛出异常。
2.删除第i个位置的元素。
3.把第i个位置的元素后面的所有的元素的位置加一。
4.线性表长度减一。

    /**
     * 功能 10  删除第i 个元素
     * @param i
     */
    public void deleElement(int i) {
        if (!isEmpty()) {//判断是否为空
            if (i <= 0 || i > n) {//判断元素是否在范围内
                System.out.println("输入不合法");
                return ;
            }
            for (int j = i -1; j < n; j++) { //从下标i 开始  数组值一步步向前覆盖
                T002[j] = T002[j + 1]; //用覆盖代替删除啊
            }
    	/*  另外的写法，只是j = i 更直观点 从下标i 开始
     		 for (int j = i ; j < n ;j++) {
     		   T002[j - 1] = T002[j]; 后一个数组元素的值覆盖前一个
                     }
             */
                n--;
        }else System.out.println("顺序表为空");
    }

**重点在T002[j] = T002[j+1]的语句上，保证T002[i]上原来的值不在
平均移动次数位(n-1)/2   平均时间性能为O(n)**

线性表的顺序存储结构，在存、读取数据时，不管是在哪个位置，时间复杂度都是O(1)。而在插入或者删除时，时间复杂度都是O(n)。
这也就是线性表的顺序存储结构比较适合存取数据，不适合经常插入和删除数据的应用。
优点：
1.无需为了表示表中元素之间的逻辑关系而增加额外的存储空间（相对于链式存储而言）。
2.可以快速的存取表中任意位置的元素。
缺点：
1.插入和删除操作需要移动大量的元素。
2.当线性表长度变化较大时，难以确定存储空间的容量。
3.容易造成存储空间的“碎片”(因为线性表的顺序存储结构申请的内存空间都以连续的，如果因为某些操作（比如删除操作）导致某个部分出现了一小块的不连续内存空间，因为这一小块内存空间太小不能够再次被利用/分配，那么就造成了内存浪费，也就是“碎片”)


## 2.2 链式存储：


不要求逻辑上相邻的两个元素物理上也相邻；通过“链”建 立起数据元素之间的逻辑关系。 
• 插入、删除不需要移动数据元素，只需要修改“链

> 链式存储结构是基于指针实现的。我们把**一个数据元素和一个指针**称为结点。
> 链式存储结构是**用指针把相互直接关联的结点**（即直接前驱结点或直接后继结点）链接起来。链式存储结构的线性表称为链表。

链表的定义是递归的，它或者为空null，或者指向另一个节点node的引用，这个节点含有下一个节点或链表的引用。
与顺序存储相比，允许存储空间不连续，插入删除时不需要移动大量的元素，只需修改指针即可，但查找某个元素，只能从头遍历整个链表。


**基本操作也是有： 1 插入 ， 2 查找   3 删除** 

根据链表的构造方式的不同可以分为：
-----------------

1.	单向链表

![此处输入图片的描述][11]
2.	单向循环链表

![此处输入图片的描述][12]
3.  双向循环链表

![此处输入图片的描述][13]
单链表结构
-----
	单链表是构成链表的每个结点只有一个指向直接后继结点的指针。
	单链表的表示方法：
	单链表中每个结点的结构：
	

![此处输入图片的描述][14]

	单链表有带头结点结构和不带头结点结构两种。我们把指向单链表的指针称为单链表的头指针。头指针所指的不存放数据元素的第一个结点称作头结点。存放第一个数据元素的结点称作第一个数据元素结点，或称首元结点。
![此处输入图片的描述][15]

不管有没有头结点，头指针都指向链表的第一个节点（有头结点指向头结点）。
头结点：数值域可不设任何信息，头结点的指针域指向链表的第一个元素。
带头节点的好处有：
（1）链表第一位置节点上的操作和其它位置上的操作一致
（2）无论链表是否为空，头指针都指向头结点（非空），空表和非空表处理一样
（这里我没有使用头结点）
注：链表麻烦的地方是插入和删除时指针的修改，保证不断链，一般先断后链。
![线性链表2.6][16]

Java中使用嵌套类来定义节点的抽象数据类型：

    private class Node{
        // 链表节点的嵌套类
        T item; // 节点内容
        Node next; // 后继节点
    }

单链表基本操作
-------
Java版的基本操作：
1  首先要做好接口：

    public interface MyList<T> {
        /**
         * 定义添加接口
         * @param element
         */
        public void add(T element);
        /**
         * 定义clear接口
         */
        public void clear();
        /**
         * 删除接口
         * @param index
         * @return
         */
        public boolean remove(int index);
        /**
         * 查找，判断对象是否存在
         * @param element
         * @return
         */
        public boolean find(T element);
        /**
         * 根绝索引查找
         * @param index
         * @return
         */
        public T get(int index);
        /**
         * 获取当前的链表的个数
         * @return
         */
        public int size();
    }

2 写好实体类： 意思是把节点包装好属性，属性有2个，数据和指针。
把数据和指针包装在节点里面，指针-------下一个节点对象，也就是递归的关系。
A节点对象里面包装着数据1和节点B，
然后节点B里面包装着数据2和节点C，这样递归下去。Java是没有指针的。

    public class Node<T> {
        //数据
        private T data;
        
    
        //下一个节点的对象
        private Node<T> next;
    
        public Node() {
            data = null;
            next = null;
        }
    
        public Node(T data) {
            this.data = data;
            this.next = null;
        }
    
        public Node(T data, Node<T> next) {
            this.data = data;
            this.next = next;
        }
    
        public T getData() {
            return data;
        }
    
        public void setData(T data) {
            this.data = data;
        }
    
        public Node<T> getNext() {
            return next;
        }
    
        public void setNext(Node<T> next) {
            this.next = next;
        }
    }

3 实现类：是下面java实现操作的定义

    /**
     * 实现类  实现自己前面写的接口
     * @param <T>
     */
    public class MyLinkedList<T> implements MyList<T> {
    
        //存储节点
        private  Node<T> head;
        
    Node current;//当前结点对象
    
    
        //存储每一个当前的节点
        private Node<T> tail;
    
        //存储当前链表的size
        private int size;
    
        public MyLinkedList() {
            //初始化头结点，让头指针指向头结点。并且让当前结点对象等于头结点
            this.head = current = new Node(null);
            this.tail = null;
            //单向链表，初始长度为零
    this.size = 0;
        }
    
        public MyLinkedList(T data) {
            this.head = new Node<T>(data);
            this.tail = null;
            this.size = 0;
        }

2.1.1 插入----头插法
---------------

将新节点插入到当前链表的表头，（头结点之后），插入的顺序与链表中的顺序相反，关键点就是记住旧的表头，生成一个新的放到旧表头前面，如图：

![线性链表2.7][17]
     **核心伪代码：**
>     public void headInsert(T item) {
>         Node old = first;  不明白这句的意思
>         first = new Node();
>         first.item = item;
>         first.next = old;
>         count++;
>     }



java实现代码

    public void headInsert(T ele) {
        //生成一个新的节点
        Node<T> newNode = new Node<T>(ele);
        //新的节点上的指针域赋值头节点的数据域,这句话可以理解为新节点连接旧表头
        newNode.setNext(head);
        //新节点更新为表头，也可以理解为表头里面的数据域赋值新节点的数据
        head = newNode;
        this.size++;
    }

2.1.2 尾插法
---------
增加一个尾指针，新节点插到链表的尾部，插入的顺序和链表的顺序一致，如图：
![线性链表2.8][18]

    核心伪代码：
    public void tailInsert(T item) {
        Node old = last; 不明白这句的意思
        last = new Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            old.next = last;
        }
        count++;
    }

节点的插入和删除，要点**是先断后连**，关键就是不要断链了，以插入为例（把s插入p和q之间），先断意思是先把p->q断了，变成s->q，后连，最后再把p和s连接起来。

Java实现版：

    @Override
    public void add(T element) {
        //生成当前节点的对象
        Node<T> node = new Node<T>(element);
    
        //首次操作将两个存储对象指向同一个内存空间
        //判断此时是否为空链表
        if (this.head == null) {
            //如果是空链表，头和尾指向同一个节点
            this.head = node;
            this.tail = node;
        } else {
            //将新的note节点指向tail节点（head的尾端节点），相当于指针域赋值
            this.tail.setNext(node);
            //将note节点重新赋值给tail，tail就会变成head的最后一个节点
    //相当于数据域放入数据
            this.tail = node;
        }
        this.size++;//当前长度+1
    }


2.1.3 插入节点
----------
待插入节点为s，一般采用后插法，即先找到插入位置节点的前驱节点，然后插入，时间复杂度O(n)。
![线性链表2.9][19]


**核心伪代码为：后插法，前后是根据查询位置来判断**

    p=getNodeByIndex(i-1); 使用函数找到插入所在位置的前一个位置
    s.next = p.next;
    p.next = s;


java实现操作：

    public void insert(int index, T data) {
        if (index < 0 || index > size) {
            System.out.println("参数错误！");
        }
        index(index - 1);
        current.setNext(new Node(data, current.getNext()));
        size++;
    }
    /**
     * 定位函数，实现当前操作对象的前一个结点，
     * 也就是让当前结点对象定位到要操作结点的前一个结点。
      比如我们要在a2这个节点之前进行插入操作，
     那就先要把当前节点对象定位到a1这个节点，然后修改a1节点的指针域
     */
        public void index(int index) {
            if (index < -1 || index > size - 1) {
                System.out.println("越界了，请重新输入");
            }
            //说明在头结点之后操作
            if (index == -1)
                return; //因为第一个数据元素结点的下标是0，那么头结点的下标自然就是-1了
            //当前结点对象
            current = head.getNext();
            int j=0;//循环变量
            while (current != null && j < index) {
                //因为在index-1位置停止下来，所以当前节点current就是index的前一个节点
                current = current.getNext();
                j++;
            }
        }

还有一种方法是，直接插入到位置的后面（前插法），然后交换两个节点的值，插入的节点到了指定位置，时间复杂度O(1)：？？？有疑问，为什么时间复杂度是1？还是要查询的啊


**核心代码：**

    s.next = p.next;
    p.next = s;
    temp = p.item;    // 交换内容
    p.item = s.item;
    s.item = temp;

2.2.1 查找find
------------
根据得到的检索值，用for 或者while 循环一个个进行判断，然后得到值进行返回
**按值查找：伪代码**

    List Find( ElementType X, List PtrL ) {        
    List  p = PtrL;     
    while ( p!=NULL && p->Data != X )            
    p = p->Next;       
    return p;
    }


**按序号查找： 伪代码**

    List  FindKth( int K, List PtrL ) {      
    List  p = PtrL;         
    int  i = 1;         
    while (p !=NULL && i < K ){                
    p = p->Next;                
    i++;           }        
    if ( i == K ) return p;                      /* 找到第K个，返回指针 */        
    else  return NULL;                                 /* 否则返回空 */
    }

**Java实现按值查找：**

    public T get(int index) {
        T t = null;
        //index不超过size的限制
        if (index >= 0 && index < size) {
            Node<T> point = head;
            int count = 0;
            //循环找到所在的节点
            while (count < size) {
                if (count == index) {
                    t = point.getData();
                    break;
                }
                point = point.getNext();
                count++;
            }
        }
        return t;
    }

或者按照序号查找：

    /**
     * 定位函数，实现当前操作对象的前一个结点，
     * 也就是让当前结点对象定位到要操作结点的前一个结点。
      比如我们要在a2这个节点之前进行插入操作，
     那就先要把当前节点对象定位到a1这个节点，然后修改a1节点的指针域
     */
        public void index(int index) {
            if (index < -1 || index > size - 1) {
                System.out.println("越界了，请重新输入");
            }
            //说明在头结点之后操作
            if (index == -1)
                return; //因为第一个数据元素结点的下标是0，那么头结点的下标自然就是-1了   因为是表头所以退出查询
            //当前结点对象
            current = head.getNext();
            int j=0;//循环变量
            while (current != null && j < index) {
                //因为在index-1位置停止下来，所以当前节点current就是index的前一个节点
                current = current.getNext();
                j++;
            }
        }



2.3.1删除
-------

（删除链表的第 i (1≤i≤n)个位置上的结点)

（1）先找到链表的第 i-1个结点，用p指向； 
（2）再用指针s指向要被删除的结点（p的下一个结点）;
（3）然后修改指针，删除s所指结点; 
（4）最后释放s所指结点的空间。
![线性链表2.10][20]

单链表的效率分析
删除单链表的一个数据元素时比较数据元素的平均次数为：
![线性链表2.11][21]
因此，**单链表插入和删除操作的时间复杂度均为O（n）。另外，单链表取数据元素操作的时间复杂度也为O（n）。**

删除实现C语言思路

    List Delete( int  i, List PtrL ) {       
    List  p, s;          
    if ( i == 1 ) {      /* 若要删除的是表的第一个结点 */                
    s = PtrL;      /*s指向第1个结点*/                
    if (PtrL!=NULL)  
    PtrL = PtrL->Next;   /*从链表中删除*/                
    else 
    return NULL;                 
    free(s);     /*释放被删除结点 */                
    return PtrL;
    }          
    p = FindKth( i-1, PtrL );  /*查找第i-1个结点*/          
    if ( p == NULL ) {                  
    printf(“第%d个结点不存在”, i-1);  return NULL;          
    } else  if ( p->Next == NULL ){                  
    printf(“第%d个结点不存在”, i);  return NULL;          
    } else  {                
    s = p->Next;      /*s指向第i个结点*/                
    p->Next = s->Next;    /*从链表中删除*/                
    free(s);            /*释放被删除结点 */                
    return PtrL;
    }

Java实现删除操作：

    //删除索引中的指定的节点
    @Override
    public void remove(int index) {
        if (index < 0 || index > size - 1) {
            System.out.println("超出查询范围");
        }
        if (head == null) {
            System.out.println("链表为空！");
        }
        //判断是不是删除第一个节点
        if (index == 0) {
            //改变头节点
            head = head.getNext();
            size--;
        } else {
            //获取删除的节点哈
            Node<T> deletNote = getNodeByIndex(index);
    
            //获取删除节点的前一个节点
            Node<T> prev = getNodeByIndex(index - 1);
            prev.setNext(deletNote.getNext());
            size--;
        }
    }


2.4测试类：（单链表的应用）

使用单链表建立一个线性表，依次输入十个0-99之间的随机数，删除第5个元素，打印输出该线性表。

    public class test {
        public static void main(String[] args) {
            MyLinkedList myl = new MyLinkedList();
            for (int i = 0; i < 10; i++) {
                int temp = (int) ((Math.random()* 100 ) % 100);
                myl.insert(i,temp);
    
                System.out.print(myl.get(i) + "   ");
            }
            System.out.println("\n"+myl.size());
            myl.remove(4);
            System.out.println("\n------删除第五个元素之后-------");
            System.out.println(myl.size());
            for (int i = 0; i < myl.size(); i++) {
                System.out.print(myl.get(i)+"   ");
            }
        }
    }

效果：

![线性链表2.12][22]

分析：
---
目前自己没有想法的是打出输入十个0-99之间的随机数

>   int temp = (int) ((Math.random()* 100 ) % 100);

建立线性表就需要上面所写的  插入，删除，查询操作
那么首先就需要
1 接口  里面放着插入，删除，查询操作方法
2 实体类  里面放着节点的属性，同时就类进行多种结构体赋值

    public class Node<T> {
    public Node() {
        data = null;
        next = null;
    }
    
    public Node(T data) {
        this.data = data;
        this.next = null;
    }
    
    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }

3 实现类：继承接口，然后对方法进行重写
查询：（while循环比较好
根据值查询。得到输入值，进行循环判段语句是节点里的值与输入值不一致，循环体是更新节点为下一节点，最后记得要返回节点

根据序号查询。得到序号，判断循环语句是节点不为null，K != P，循环体是节点更新，序号更新下一个

插入：（主要思想是交换数据，
目标节点：F
1 查询F节点的previous节点P
2把F节点的指针域更新为P节点的指针域
3把P节点的指针域改成F 节点的数据域 

删除：
目标节点：F
1 查询F节点的previous节点P
2把P节点的指针域更新为F节点的指针域
3把F节点释放 



# 3 顺序表和单链表的比较

	**顺序表的主要优点是*支持随机读取*，以及内存空间利用效率高；顺序表的主要缺点是需要预先给出数组的最大数据元素个数，而这通常很难准确作到。当实际的数据元素个数超过了预先给出的个数，会发生异常。另外，顺序表插入和删除操作时需要移动较多的数据元素。
	和顺序表相比，*单链表的主要优点是不需要预先给出数据元素的最大个数。另外，单链表插入和删除操作时不需要移动数据元素*。
	*单链表的主要缺点是每个结点中要有一个指针，因此单链表的空间利用率略低于顺序表的。*另外，单链表不支持随机读取，单链表取数据元素操作的时间复杂度为O（n）；而顺序表支持随机读取，顺序表取数据元素操作的时间复杂度为O（1）。**

**线性表的两种实现比较
顺序表：**
查找O（1）、插入和删除O（n）

**链式表：**
查找O（n）、插入和删除O（1）

**空间性能：**
顺序表：顺序表的存储空间是静态分布的，需要一个长度固定的数组，因此总有部分数组元素被浪费。 
链表：链表的存储空间是动态分布的，因此不会空间浪费。但是由于链表需要而外的空间来为每个节点保存指针，因此要牺牲一部分空间。
**时间性能：**
顺序表：顺序表中元素的逻辑顺序与物理存储顺序是保持一致的，而且支持随机存取。因此顺序表在查找、读取时性能很好。 
链表：链表采用链式结构来保存表内元素，因此在插入、删除元素时性能要好

# 4 单项循环链表的应用举例：
概念：
单向循环链表是单链表的另一种形式，其结构特点是链表中最后一个结点的指针不再是结束标记，而是指向整个链表的第一个结点，从而使单链表形成一个环。
和单链表相比，循环单链表的长处是从链尾到链头比较方便。当要处理的数据元素序列具有环型结构特点时，适合于采用循环单链表。
和单链表相同，循环单链表也有带头结点结构和不带头结点结构两种，带头结点的循环单链表实现插入和删除操作时，算法实现较为方便。
![线性链表4.1][23]

带头结点的循环单链表的操作实现方法和带头结点的单链表的操作实现方法类同，差别仅在于：
（1）在构造函数中，要加一条head.next = head 语句，把初始时的带头结点的循环单链表设计成上图中（a）所示的状态。
（2）在index(i)成员函数中，把循环结束判断条件current != null改为current != head。


参考：http://www.cnblogs.com/smyhvae/p/4768538.html

**编写击鼓传花小游戏。 游戏规则：N个人围成一个圈，从第一个人开始传花，当数到M时，该人退出游戏，直到剩下最后一个人**
---------------------------------------------------------

代码实现：
Interface.java

    public interface list22 {
        public int size();
    
        public boolean isEmpty();
    
        public void insert(int index, Object object) throws Exception;
    
        public void delete(int index) throws Exception;
    
        public Object get(int index) throws Exception;
    }

node.java

    public class Node {
        Object element;//数据域
        Node next;//指针域
    
    
        public Node(Node next) {
            this.next = next;
        }
    
    
        public Node(Object element, Node next) {
            this.element = element;
            this.next = next;
        }
    
        public Object getElement() {
            return element;
        }
    
        public void setElement(Object element) {
            this.element = element;
        }
    
        public Node getNext() {
            return next;
        }
    
        public void setNext(Node next) {
            this.next = next;
        }
    
        @Override
        public String toString() {
            return this.element.toString();
        }
    }

LinkList.java:

    public class LinkList implements list22 {
    
        Node head;
        Node current;
        int size;
    
        public LinkList() {
            //初始化头结点，让头指针指向头结点。并且让当前结点对象等于头结点。
            this.head = current = new Node(null);
            //单向链表，初始长度为零。
            this.size = 0;
            //单向不循环是没有下面这语句的
            this.head.next = this.head;
        }
    
        //定位函数，实现当前操作对象的前一个结点，也就是让当前结点对象定位到要操作结点的前一个结点。
        //比如我们要在a2这个节点之前进行插入操作，那就先要把当前节点对象定位到a1这个节点，然后修改a1节点的指针域
        public void index(int index) throws Exception {
            if (index < -1 || index > size - 1) {
                throw new Exception("错误！！！");
            }
            //说明在头结点之后操作。
            //因为第一个数据元素结点的下标是0，那么头结点的下标自然就是-1了。
            if (index == -1) return;
            current = head.next;
            //循环变量
            int j = 0;
            //while (current != null && j < index)这是单向不循环
            while (current != head && j < index) {
                current = current.next;
                j++;
            }
        }
    
    
    
        @Override
        public int size() {
            return this.size;
        }
    
        @Override
        public boolean isEmpty() {
            return size==0;
        }
    
        @Override
        public void insert(int index, Object object) throws Exception {
            if (index < 0 || index > size) {
                throw new Exception("错误！！参数！");
            }
            //这里是找出插入新节点A所要插入位置index的前一个节点B，然后更改节点B的指针域，指向A
    //现在是要将B.next set 为A节点的data, 同时将A.next设为null
            index(index - 1);
    //这里是current是A还是B？ 是B ，此时new Node这个才是A ，因为数据没有包装成A节点
    // current是B，先执行new Node()的，新节点A，A.next是B.next == head，所以B 的next是A节点
    //就是将 B  A两个节点进行连接，同时A节点的next是要保持head的 现在是循环单链表
    
    	current.setNext(new Node(object, current.next));
            size++;
        }
    
        @Override
        public void delete(int index) throws Exception {
            //判断链表是否为空
            if (isEmpty()) {
                throw new Exception("链表是空的，无法删除！");
            }
            if (index < 0 || index > size) {
                throw new Exception("参数错误！");
            }
            //定位到要操作结点的前一个结点对象。
            index(index - 1);
    	//得到删除节点的下一个节点的next，也就是指向下下个节点
            current.setNext(current.next.next);
            size--;
        }
    
        @Override
        public Object get(int index) throws Exception {
            if (index < -1 || index > size - 1) {
                throw new Exception("错误！！！");
            }
            index(index);
            return current.getElement();
        }
    }


game1.java

    public class game1 {
        LinkList list = new LinkList();
    
        //总人数
        int num;
    
        //数到几退出
        int key;
    
        public game1(int num, int key) {
            this.num = num;
            this.key = key;
        }
    
        public void play() throws Exception {
            for (int i = 0; i < num ;i++) {
                list.insert(i, i);
            }
    
            System.out.println("/n-------游戏开始之前-----------/n");
            for (int i =0; i< list.size;i++) {
                System.out.print(list.get(i)+ "   ");
            }
            System.out.println();
            System.out.println("/n-------游戏开始-----------/n");
            int iCount = num;//开始等于总人数num
            int  j= 0; //累加器，计算是否能被key整除
            Node node =  list.head;
    
            while (iCount != 1) {
                if (node.getElement() != null && Integer.parseInt(node.getElement().toString()) != -1) {
                    j++;
                    if (j % key == 0) {
                        node.setElement(-1);
                        iCount--;
                        System.out.println();
                        for (int i =0;i<list.size;i++) {
                            System.out.print(list.get(i) + "  ");
                        }
                        System.out.println();
                    }
                }
                node = node.next;
            }
    
            System.out.println("/n-------游戏结束-----------/n");
            for (int i =0;i<list.size;i++) {
                System.out.print(list.get(i) + "  ");
            }
        }

**test：**

    public class test {
        public static void main(String[] args) throws Exception {
            game1 ggg = new game1(10, 3);
            ggg.play();
        }

结果：
![线性链表4.2][24]

# 总结：
知道链表的一个节点，知道全部，因为可以用。Next表示后面的节点

删除A节点，需要3个必要步骤,  1 断连接,  2 节点内容设置为null，3长度-1
1 查找到A-1的节点（此时A节点是不知道的），设置一个临时变量B装载从A-1节点的next得到的删除节点A
2 从A-1节点处断连接， A-1的next修改成B的next，这就是断连接了
3 然后，将B的next = null，这就是设置null 了
4  size-1


增加A节点， 增加连接   长度+1
查找到A-1节点，临时变量B  = A-1。Next   A-1。Next = A   A 。next = B   size++

# 参考：
https://www.cnblogs.com/smyhvae/p/4761593.html （重要参考点
https://www.cnblogs.com/yaowen/p/4272310.html
https://www.cnblogs.com/smyhvae/p/4768538.html
https://www.cnblogs.com/yangluping/p/6504672.html
https://blog.csdn.net/javaxiaojian/article/details/46679747
https://blog.csdn.net/daguairen/article/details/52738510

https://www.cnblogs.com/wincai/p/5893475.html（双链表，2个指针域，一前一后


  [1]: https://i.loli.net/2018/07/16/5b4cbb5926f40.png
  [2]: https://i.loli.net/2018/07/16/5b4cbb6e86943.png
  [3]: https://i.loli.net/2018/07/16/5b4cbb8211596.png
  [4]: https://i.loli.net/2018/07/16/5b4cbb820c780.png
  [5]: https://i.loli.net/2018/07/16/5b4cbb8209b29.png
  [6]: https://i.loli.net/2018/07/16/5b4cbc37069ce.png
  [7]: https://i.loli.net/2018/07/16/5b4cbc6f62802.png
  [8]: https://i.loli.net/2018/07/16/5b4cbc6f61218.png
  [9]: https://i.loli.net/2018/07/16/5b4cbcbd97e28.png
  [10]: https://i.loli.net/2018/07/16/5b4cbcbd96cb7.png
  [11]: https://i.loli.net/2018/07/16/5b4cbcef44a40.png
  [12]: https://i.loli.net/2018/07/16/5b4cbcef42ed8.png
  [13]: https://i.loli.net/2018/07/16/5b4cbcef4132a.png
  [14]: https://i.loli.net/2018/07/16/5b4cbd67f2a94.jpg
  [15]: https://i.loli.net/2018/07/16/5b4cbd67f15d4.jpg
  [16]: https://i.loli.net/2018/07/16/5b4cbd67efe68.jpg
  [17]: https://i.loli.net/2018/07/16/5b4cbdcda7ead.png
  [18]: https://i.loli.net/2018/07/16/5b4cbded28d9c.png
  [19]: https://i.loli.net/2018/07/16/5b4cbe03c80e2.png
  [20]: https://i.loli.net/2018/07/16/5b4cbe30406d4.png
  [21]: https://i.loli.net/2018/07/16/5b4cbe422fe1c.jpg
  [22]: https://i.loli.net/2018/07/16/5b4cbe6b624c1.png
  [23]: https://i.loli.net/2018/07/16/5b4cbeab0d90c.png
  [24]: https://i.loli.net/2018/07/16/5b4cbeab0cbc8.png"	2018-07-16 22:40:04
kumika	双向链表	# 双向链表


---
![双向链表1.1][1]

这是java使用线性表的图
双向链表：（java实现：节点里面的属性也是节点，嵌套实现的，没指针没办法）
单链表节点的缺点是只有一个后继节点，访问前驱节点只能从头遍历（如插入、删除），时间复杂度为O(n)。双链表，即添加一个指向前驱的节点，节点类型如下：
private class Node{
    // 链表节点的嵌套类
    T item; // 节点内容
    Node prior, next; // 前驱节点和后继节点
}

![双向链表1.2][2]
![双向链表1.3][3]
自己总结：
          前指针  指向  前一个节点的数据域， 后指针 指向 后一个指针的前指针

![双向链表1.4][4]

和单向链表相比有以下优势：
插入删除不需要移动元素外，可以原地插入删除
可以双向遍历

初始化+尾插法图示：//head始终指向头结点，p指向尾节点，方便后续算法使用

![双向链表1.5][5]

![双向链表1.6][6]

![双向链表1.7][7]

删除单个图示：

![双向链表1.8][8]

1 创建节点类
-------

    public class Node {
        private Object data;
        private Node prev;
        private Node next;
    
        public Node() {
        }
    
        public Node(Object data, Node prev, Node next) {
            super();
            this.data = data;
            this.prev = prev;
            this.next = next;
        }
    
        public Object getData() {
            return data;
        }
    
        public void setData(Object data) {
            this.data = data;
        }
    
        public Node getPrev() {
            return prev;
        }
    
        public void setPrev(Node prev) {
            this.prev = prev;
        }
    
        public Node getNext() {
            return next;
        }
    
        public void setNext(Node next) {
            this.next = next;
        }
    }

2 链表的具体实现
---------

    public class myDoubleLinkImpl {
        int length = 0;
        private Node header;
        private Node tail;
    
        public myDoubleLinkImpl() {
            header = null;
            tail = null;
            length = 0;
        }

2.1 添加

    //向链表中添加值
    public void add(Object data) {
        //判断链表是否是空的哈
        if (header == null) {
            header = new Node(data, null, null);
            tail = header;
            length++;
        } else {
            //非空链表哈
            Node tempNode = new Node(data, tail, null);
            tail.setNext(tempNode);
            tail = tempNode;
            length++;
        }
    }

2.2查询

    //根据节点获取节点所在的值哈
    public Object getDataByIndex(int index) {
        return getNodeByIndex(index).getData();
    }
    
    查找有2个方法，这个是二分法，从中间开始分开，根据数值判断从头还是尾开始
    //获取特定的index的节点
    public Node getNodeByIndex(int index) {
        //根据索引的值不同是选择是从后向前查找还是
        //选择从前往后查找
        if (index < 0 || index > length - 1) {
            throw new IndexOutOfBoundsException("索引超出了边界！");
        } else if (index <= length / 2) {
            Node current = header;
            for (int i = 0; i<length & current != null;i++,current = current.getNext()) {
                if (index == i) {
                    return  current;
                }
            }
        } else if (index > length / 2) {
            Node current = tail;
            for (int i = length -1;i > 0 & current != null;i--,current = current.getPrev()) {
                if (index == i) {
                    return current;
                }
            }
        }
        return  null;
    }

这个是顺序查找，从一开始查找到末尾

    public Node getNodeByIndex_new(int index) {
        if (index < 0 || index > length - 1) {
            throw new IndexOutOfBoundsException("索引超出了边界！");
        } else {
            Node current = header;
            for (int i=0;i <length & current!= null;i++,current = current.getNext()) {
                if (index == i) {
                    return  current;
                }
            }
        }
        return null;
    }


2.3遍历

    //遍历节点的值哈
    public void allPrint(){
        if (header == null) {
            throw new NullPointerException("链表为空");
        } else {
            for (int i = 0; i < length; i++) {
                Node current = getNodeByIndex_new(i);
                System.out.println(current.getData());
            }
        }
    }
    //遍历节点的方法2
    public void allPrint_new() {
        if (header == null) {
            throw new NullPointerException("链表为空");
        } else {
            Node current = tail;
            while (current != null) {
                System.out.println(current.getData());
                current = current.getPrev();
            }
        }
    }

2.4插入

    //在特定的位置上插入一个数据哈
    public void insertDataByIndex(Object data, int index) {
        //在特定的位置上面插入一个节点哈
        if (index > length - 1 || index < 0) {
            throw new IndexOutOfBoundsException("索引超出了边界！");
        } else if (header == null) {
            add(data);
            length++;
        } else if (index == 0) {
            Node current = new Node(data, null, header);
            header = current;
            header.setPrev(current);
            length++;
        } else {
            //获取前一个节点哈
            Node prevNode = getNodeByIndex(index - 1);
            Node current = new Node(data, prevNode, prevNode.getNext());
            prevNode.getNext().setPrev(current);
            prevNode.setNext(current);
            length++;
        }
    }

2.5删除

    //删除某一个特定的index的节点
    public void deleteNodeByIndex(int index) {
        if (index > length - 1 || index < 0) {
            throw new IndexOutOfBoundsException("索引超出了边界！");
        } else if (header == null) {
            throw new NullPointerException("链表为空！");
        } else if (index == 0) {
            //如果删除的是头节点时候
            Node current = header.getNext();
            current.setPrev(null);
            header = current;
            length--;
        } else if (index == length - 1) {
            //如果删除的是最后一个节点的话。
            //获取前一个节点
            Node prevNode = getNodeByIndex(index - 1);
            //修改前一个节点的next节点
            Node deleteNode = prevNode.getNext();
            prevNode.setNext(deleteNode.getNext());
            tail = prevNode;
            length--;
        } else {
            //删除一般的节点的
            //获取前一个节点
            Node prevNode = getNodeByIndex(index - 1);
            //修改前一个节点的next节点
            Node deletNode = prevNode.getNext();
            prevNode.setNext(deletNode.getNext());
            if (deletNode.getNext() != null) {
    //就是修改deleteNode的下一个节点的指针，原本指向deleteNode,现在修改成指向prevNode
                deletNode.getNext().setPrev(prevNode);
            }
            deletNode.setNext(null);
            deletNode.setPrev(null);
            length--;
        }
    }

3 测试

    public class text {
        public static void main(String[] args) {
    
            myDoubleLinkImpl myl = new myDoubleLinkImpl();
            myl.add("2314238947823957");
            myl.add(4396);
            myl.add("fansi");
            myl.add("443");
            myl.add("999");
            myl.insertDataByIndex("clearLove",3);
            myl.insertDataByIndex("clearLove77",3);
            System.out.println("++++++++++++删除前++++++++++++");
            myl.allPrint();
            myl.deleteNodeByIndex(5);
            System.out.println("++++++++++++删除后++++++++++++");
            myl.allPrint();
            System.out.println("++++++++++++取值++++++++++++");
            System.out.println(myl.getDataByIndex(5));
        }
    }

# 总结：
**要是双向链表的删除：**
所要删除节点A
修改两个指针，一个指向A后面节点的指针prevNode.setNext(deletNode.getNext())，
一个指向A前面节点的指针deletNode.getNext().setPrev(prevNode)
举例子：

           //删除一般的节点的
            //获取前一个节点
            Node prevNode = getNodeByIndex(index - 1);
            //修改前一个节点的next节点
            Node deletNode = prevNode.getNext();
            prevNode.setNext(deletNode.getNext());
            if (deletNode.getNext() != null) {
    //就是修改deleteNode的下一个节点的指针，原本指向deleteNode,现在修改成指向prevNode
                deletNode.getNext().setPrev(prevNode);
            }

# 参考：

https://www.cnblogs.com/wincai/p/5893475.html（双链表，2个指针域，一前一后
http://www.jb51.net/article/123483.htm（双链表的实现
http://www.cnblogs.com/ECJTUACM-873284962/p/7485590.html
https://www.cnblogs.com/smyhvae/p/4768538.html
https://blog.csdn.net/fenglibing/article/details/669456
https://blog.csdn.net/lovoo/article/details/51771321


可能题目：
http://www.cnblogs.com/huangxincheng/p/4051854.html
https://www.cnblogs.com/wuhao1991/p/4054809.html


  [1]: https://i.loli.net/2018/07/17/5b4cce0d99be7.jpg
  [2]: https://i.loli.net/2018/07/17/5b4ccefeb59a7.png
  [3]: https://i.loli.net/2018/07/17/5b4ccee0d85fc.png
  [4]: https://i.loli.net/2018/07/17/5b4ccf16a7cae.png
  [5]: https://i.loli.net/2018/07/17/5b4ccf16a8209.png
  [6]: https://i.loli.net/2018/07/17/5b4ccf16b7870.png
  [7]: https://i.loli.net/2018/07/17/5b4ccf63ce6c1.png
  [8]: https://i.loli.net/2018/07/17/5b4ccf63d1dd8.png	2018-07-16 23:51:44
kumika	队列	"# 队列



---

队列(Queue)：具有一定操作约束的线性表
插入和删除操作：只能在一端插入，而在另一端删除。

数据插入：入队列（AddQ）
数据删除：出队列（DeleteQ）

**先进先出**

![队列1.1][1]

# 队列的顺序存储实现：
----------

参考：https://blog.csdn.net/apathecrazyfan/article/details/53082628

队列的顺序存储结构通常由一个一维数组和一个记录队列头元 素位置的变量front以及一个记录队列尾元素位置的变量rear组成。

![队列1.2][2]

系统采用一组连续的存储单元来依次保存队列的rear端到front端的所有数据元素，程序只需front和rear两个整形变量来记录队列的front端的元素索引和rear端的元素索引。顺序存储结构的队列简称为顺序队列。如下图所示顺序队列示意图：

![队列1.3][3]

从图中可以看出，顺序队列的front总是保存着队列中即将出列的数据元素的索引；顺序队列中的rear总是保存着下一个即将进入队列的元素的索引。队列中的元素的个数为rear-front。

代码实现：
-----

    public class sequencequeue<T> {
        //默认队列容量为10
        private final  int Default_capacity = 0;
        //底层数组
        private Object[] elementData;
        //容量
        private int capacity;
    
        private int front = 0;
    
        private int rear = 0;
    
    
        public sequencequeue() {
            this.capacity = Default_capacity;
            elementData = new Object[capacity];
        }
    
    
        public sequencequeue(T element) {
            this();
            elementData[0] = element;
            rear++;
        }
    
        public sequencequeue(T element, int initCapacity) {
            this.capacity = initCapacity;
            elementData = new Object[capacity];
            elementData[0] = element;
            rear++;
        }
    
        //队列长度
        public int length() {
            return rear - front;
        }
    
        //判是否为空
        public boolean isEmpty() {
            return  rear == front;
        }
    
        //向队列rear端插入元素
        public void add(T element) {
            indexOutOfBoundsForAdd(rear);
            elementData[rear++] = element;
        }
    
        public  void indexOutOfBoundsForAdd(int index) {
            if (index > capacity - 1) {
                throw new IndexOutOfBoundsException("exception for SequenceQueue is filled：index of add is " + index);
            }
        }
    
        //向队列front端删除并返回 该元素
        public T remove() {
            noneElementForRemove();
            T t = (T) elementData[front];
            elementData[front++] = null;
            return t;
        }
    
        public void noneElementForRemove() {
            if (isEmpty()) {
                throw new IndexOutOfBoundsException("none any element in SequenceQueue!");
            }
        }
    
        //element()返回但不删除front端元素
        public T element() {
            noneElementForRemove();
            return (T) elementData[front];
        }
    
        //清空队列
        public void clear() {
            Arrays.fill(elementData, null);
            front = 0;
            rear = 0;
        }
    
    
        public String toString() {
            if (isEmpty()) {
                return "[]";
            } else {
                StringBuilder sb = new StringBuilder("[");
                for (int i = front; i < rear;i++) {
                    sb.append(elementData[i].toString() + ",");
                }
                return sb.toString().substring(0, sb.length() - 1)+"]";
            }
        }


Test：
-----

    public class sTest {
        public static void main(String[] args) {
            sequencequeue<String> queue = new sequencequeue<String>("aaaa", 4);
    
            queue.add("bbb");
            queue.add("ccc");
            queue.add("dddd");
            System.out.println("队列为：    " + queue);
            System.out.println();
    
            String sElement = queue.element();
            System.out.println("队首为：    " + sElement);
            System.out.println("队列为：    " + queue);
            System.out.println();
    
            String sRemove = queue.remove();
            System.out.println("队首为：    " + sRemove);
            System.out.println("队列为：    " + queue);
            System.out.println();
    
            queue.add("4396");
        }
    }



![队列1.4][4]

从上面的运行结果来看，当程序执行 String sRemove = queue.remove();这句后，队首的值  aaa 从队列移除，此时队列有3个元素，讲道理程序再执行add.("eee");是可行的，
但出现了上面的异常，这也是这个实现的代码的不足之处：出现**“假满”**现象


对于顺序队列而言，队列底层将采用数组来保存队列元素，每个元素在队列中的位置是固定不变的，变的只是rear和front两个整形变量。但有元素进入队列时，rear变量的值 +1；当有元素出列是，front的值 +1。（他妈的，这样做好像并没有释放底层数组里的元素引用啊！？）

对于上面的顺序队列的程序实现，数据元素在底层数组中的位置是固定的，改变的只是rear、front两个整形变量的值。这个队列可能出现所谓的“假满”现象。如下图所示：


![队列1.5][5]

从图中可以看出，此时rear等于该队列底层的数组容量capacity，如果此时试图向队列中添加元素，将会引起“队列已满”异常。其实这是一种“假满”现象。
此时该队列底层的数组依然有6个空位可以存储数据元素，但程序已经加不进去了。
对于假满问题，程序有如下解决方法：
（1）**每次讲元素移除对了时都将队列中的所有元素向front端移动一位，这种方式下front值永远为 0 ，有元素每次插入队列时rear值+1，有元素移除时队列rear值-1**.但这种方式非常浪费时间，
因为每次将元素从队列中删除时都需要进行“整体搬家”。
（2）**将数组存储区看成是一个收尾相连的环形区域，当存放到数组的最大地址之后，rear的值再次变为 0** 。采用这种技巧存储的队列称为循环队列。



环形队列：

参考：https://blog.csdn.net/u011446177/article/details/42390465
对于一个容量为3的顺序存储的队列，先入队a，b，c然后出队a，b，c

![队列1.6][6]

**此时，虽然队列中没有元素，但是显示的是队列已满，此时不能再存储数据，也就是出现了“假溢出” 现象，此时会造成存储空间的浪费**


循环顺序队列就是为了防止出现假溢出现象而出现的，其功能类似于一个环形，如图，但实际上还是一个线性存储的结构

![队列1.7][7]

这样就不会出现“假溢出”的现象了，因为每次无论是出队还是入队时，移动指向队首和队尾元素的指针是循环变化的，也就是

> front=(front+1)%maxSize 
  rear=(rear+1)%maxSize

![队列1.8][8]

空栈和满栈的条件都是front==rear 

解决的方法有三个：

> ①少用一个存储空间： 
空：front==rear   
       满：front==（rear+1）% maxSize
> 
> ②设置一个标志变量（flag）记录是否有元素  
空：front==rear&&flag==0  
满：front==rear&&flag==1
> 
> ③设置一个计数器（number）记录有多少个元素 
空：number==0 
满：number>0&&front==rear


代码实现：
参考：https://blog.csdn.net/jiutianhe/article/details/18606295
但是里面的条件判断，现在我的水平判断就是 不是用的上面3种，但是内容好像是第1个空一个栈， 完全使用1 判断条件的是这里
https://blog.csdn.net/u011446177/article/details/42390465 （感觉这个代码好点，明显突出判断条件）**少用一个存储空间的方式 MQueue就是接口，看overRide有多少个重写**

    1.	public class CircleSqQueue implements MQueue {  
    2.	  
    3.	    /** 
    4.	     * @queueElem存储队列中的元素 
    5.	     */  
    6.	    private Object queueElem[];  
    7.	    /** 
    8.	     * @front指向队首 
    9.	     */  
    10.	    private int front;  
    11.	    /** 
    12.	     * @rear指向队尾 
    13.	     */  
    14.	    private int rear;  
    15.	  
    16.	    /** 
    17.	     * 　@Title构造器 
    18.	     */  
    19.	    public CircleSqQueue(int maxSieze) {  
    20.	        this.front = this.rear = 0;  
    21.	        queueElem = new Object[maxSieze];  
    22.	    }  
    23.	  
    24.	    @Override  
    25.	    public void clear() {  
    26.	        front = rear;  
    27.	    }  
    28.	  
    29.	    @Override  
    30.	    public boolean isEmpty() {  
    31.	        return front == rear;  
    32.	    }  
    33.	  
    34.	    @Override  
    35.	    public int length() {  
    36.	        /* 
    37.	         * 因为rear-front有可能为负数，如果为负数，则其绝对值表示的是空的存储空间的个数（出现假溢出了）， 
    38.	         * 加上maxSize，则就能求有多少元素.如果为正数，则其值直接就是队列中存储元素的个数 
    39.	         */  
    40.	        return (rear - front + queueElem.length) % queueElem.length;  
    41.	    }  
    42.	  
    43.	    @Override  
    44.	    public Object peek() {  
    45.	        if (isEmpty()) {  
    46.	            return queueElem[front];  
    47.	        } else {  
    48.	            return null;  
    49.	        }  
    50.	    }  
    51.	  
    52.	    @Override  
    53.	    public void offer(Object data) throws Exception {  
    54.	        if((rear+1)%queueElem.length==front){//满了  
    55.	            throw new Exception("队列已满");  
    56.	        }else{  
    57.	            queueElem[rear]=data;  
    58.	            rear=(rear+1)%queueElem.length;  
    59.	        }  
    60.	    }  
    61.	  
    62.	    @Override  
    63.	    public Object poll()  {  
    64.	        if (!isEmpty()) {  
    65.	            Object elem = queueElem[front];  
    66.	            front = (front + 1) % queueElem.length;  
    67.	            return elem;  
    68.	        } else {  
    69.	            return null;  
    70.	        }  
    71.	    }  
    72.	  
    73.	    public void disPlay() {  
    74.	        if (!isEmpty()) {  
    75.	            for (int i = front; i != rear; i = (i + 1) % queueElem.length) {  
    76.	                System.out.println(queueElem[i].toString() + "    ");  
    77.	            }  
    78.	        } else {  
    79.	            System.out.println("队列为空！！！！！");  
    80.	        }  
    81.	    }  
    82.	  
    83.	} 


LoopQueue:

    public class LoopQueue<T> implements Serializable{
    
        private int Default_size = 10;
        //保存数组的长度
        private int capacity;
        //定义一个数组用于保存循环队列的元素
        private Object[] elementData;
        //队头
        private int front = 0;
        //队尾
        private int rear = 0;
    
        //以默认数组长度创建空循环队列
        public LoopQueue() {
            capacity = Default_size;
            elementData = new Object[capacity];
        }
    
        //以一个初始化元素来创建循环队列
        public LoopQueue(T element) {
            this();
            elementData[0] = element;
            rear++;
        }
        /**
         * 以指定长度的数组来创建循环队列
         * @param element 指定循环队列中第一个元素
         * @param initSize 指定循环队列底层数组的长度
         */
        public LoopQueue(T element, int initSize) {
            this.capacity = initSize;
            elementData = new Object[capacity];
            elementData[0] = element;
            rear++;
        }
        //获取循环队列的大小
        public int size() {
            if (isEmpty()) {
                return 0;
            }
    //rear - front是顺序队列，也可以理解为front < rear
    //capacity - (front - rear)是循环队列，也可以理解为front > rear ,过圈了
    //front - rear 是表示队列空的栈数量
            return rear > front ? rear - front : capacity - (front - rear);
        }
    
        public void add(T element) {
    //rear == front判断是否空栈，后面的是判断是否满栈
    //少用一个存储空间  满栈：front==（rear+1）% maxSize
            if (rear == front && elementData[front] != null) {
                throw new IndexOutOfBoundsException("队列已满的异常");
            }
            elementData[rear++] = element;
            //如果rear已经到头，那就转头
            rear = rear == capacity ? 0 : rear;
        }
    
        //移除队列
        public T remove() {
            if (isEmpty()) {
                throw new IndexOutOfBoundsException("空队列异常");
            }
            //保留队列的rear端的元素的值
            T oldValue = (T) elementData[front];
            //释放队列的rear端的元素
            elementData[front++] = null;
            //如果front已经到头，那就转头
            front = front == capacity ? 0 : front;
            return  oldValue;
        }
    
    
    
    
    
        //返回队列顶元素，但不删除队列顶元素
        public T element() {
            if (isEmpty()) {
                throw new IndexOutOfBoundsException("空队列异常");
            }
            return (T) elementData[front];
        }
    
    
    
        //判断循环队列是否为空队列
        private boolean isEmpty() {
            //rear==front且rear处的元素为null
            return rear == front && elementData[rear] == null;
        }
    
        //清空循环队列
        public void clear() {
            Arrays.fill(elementData, null);
            front = 0;
            rear = 0;
        }
    
        public String toString() {
            if (isEmpty()) {
                return "[]";
            } else {
                //如果front < rear，有效元素就是front到rear之间的元素
                if (front < rear) {
                    StringBuilder sb = new StringBuilder("[");
                    for (int i = front; i < rear; i++) {
                        sb.append(elementData[i].toString() + ",");
                    }
                    int len = sb.length();
                    return sb.delete(len - 2, len).append("]").toString();
                }
                //如果front >= rear，有效元素为front->capacity之间、0->front之间的
                else {
                    StringBuilder sb = new StringBuilder("[");
                    for (int i = front; i < capacity; i++) {
                        sb.append(elementData[i].toString() + ",");
                    }
                    for (int i = 0; i < rear; i++) {
                        sb.append(elementData[i].toString() + ",");
                    }
                    int len = sb.length();
                    return sb.delete(len - 2, len).append("]").toString();
                }
            }
        }
    }


Ltest:

    public class LTest {
        public static void main(String[] args) {
            LoopQueue<String> lp = new LoopQueue<String>("aaaa", 3);
            lp.add("bbbb");
            lp.add("cccc");
            //此时队列已满
            System.out.println(lp);
    
            //删除一个元素后，队列可以再多加一个元素
            lp.remove();
            System.out.println("删除一个元素后的队列："+lp);
    
            //再次添加一个元素，此时队列又满
            lp.add("dddd");
            System.out.println(lp);
            System.out.println("队列满时的长度：" + lp.size());
    
            //删除一个元素后，队列可以再多加一个元素
            lp.remove();
            //再次加入一个元素，此时队列又满
            lp.add("eeee");
            System.out.println(lp);
        }


结果：

![队列1.9][9]

# 循环队列应用：
参考：http://www.cnblogs.com/smyhvae/p/4793339.html

使用顺序循环队列和多线程实现一个排队买票的例子。而且，我们只允许这个队伍中同时排队的只有10个人，那就需要用到队列了。
　　　　生产者（等候买票）
　　　　消费者 (买票离开)

如何判断循环队列究竟是空的还是满的：
------------------

　　现在问题又来了，我们之前说，空队列时，front指针等于rear指针，那么现在循环队列满的时候，也是front等于rear，那么如何判断循环队列究竟是空的还是满的？有如下办法：
　　

> •	办法1：设置一个标志位flag。 初始时置flag=0；每当入队列操作成功就置flag=1；每当出队列操作成功就置flag=0。
> 则队列空的判断条件为：rear == front && tag==0； 队列满的判断条件为：rear == front && tag==1。
> 
> 
> 
> •	办法2：保留一个元素的存储空间。<br>此时，队列满时的判断条件为  (rear + 1) % maxSize == front；
> 队列空的判断条件还是front == rear。
> 
> •	办法3：设计一个计数器count，统计队列中的元素个数。 <br>此时，队列满的判断条件为：count > 0 && rear == front；
队列空的判断条件为count == 0。 

**我们在接下来的代码中采用方法3来实现。**
-----------------------

代码实现：
接口Queue:

    public interface Queue {
        //入队
        public void append(Object object) throws Exception;
        //出队
        public Object delete() throws Exception;
        //获得队头元素
        public Object getFront();
        //判断对列是否为空
        public boolean isEmpty();
    }

实体类 循环队列：

    public class CircleSequenceQueue implements Queue {
    
        static final int defaultSize = 10;
        int front;//队头
        int rear;//队尾
        int count;//统计元素个数的计数器
        int maxSize;//队的最大长度
        Object[] queue; //队列
    
        public CircleSequenceQueue() {
            init(defaultSize);
        }
    
        public void init(int defaultSize) {
            maxSize = defaultSize;
            front = rear = 0;
            count = 0;
            queue = new Object[defaultSize];
        }
    
        public CircleSequenceQueue(int defaultSize) {
            init(defaultSize);
        }
    
    
    
        @Override
        public void append(Object object) throws Exception {
            if (count > 0 && front == rear) {
                throw new Exception("队列已满");
            }
            queue[rear] = object;
            //入队
            rear = (rear + 1) % maxSize;
            count++;
        }
    
        @Override
        public Object delete() throws Exception {
            if (isEmpty()) {
                throw new Exception("队列为空");
            }
            Object obj = queue[front];
            front = (front + 1) % maxSize;
            count--;
            return obj;
        }
    
        @Override
        public Object getFront() {
            if (!isEmpty()) {
                return queue[front];
            } else {
                return null;
            }
        }
    
    
        @Override
        public boolean isEmpty() {
            return count == 0;
        }
    }



篮子类（卖票窗口）：

    //卖票窗口
    public class WindowQueue {
        //卖票的队列的长度
        int maxSize = 10;
        //卖票的队列
        CircleSequenceQueue queue = new CircleSequenceQueue(maxSize);
        //统计卖票的数量，一天最多卖100张票
        int num = 0;
        //判断是否继续卖票。
        boolean isAlive = true;
    
        //排队买票
        public synchronized void producer() throws Exception {
            if (queue.count < maxSize) {
                queue.append(num++);//等待买票的数量加1
                System.out.println("第" + num + "个客户排队等待买票！");
                //this.notify 其实唤醒一个线程就是重新允许这个线程去获得对象锁并向下运行
                //notifyall，虽然是对每个wait的对象都调用一次notify，
                // 但是这个还是有顺序的，每个对象都保存这一个等待对象链，调用的顺序就是这个链的顺序
                this.notifyAll();//唤醒卖票的线程
            } else {
                try {
                    System.out.println("队列已满...请等待！");
                    this.wait();//队列满时，排队买票线程等待。
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        }
        //卖票
        public synchronized void consumer() throws Exception {
            if (queue.count > 0) {
                Object object = queue.delete();
                int temp = Integer.parseInt(object.toString());
                System.out.println("第" + (temp + 1) + "个客户买到票离开队列！");
                //如果当前队列为空，并且卖出票的数量大于等于100，说明卖票结束
                if (queue.isEmpty() && this.num >= 100) {
                    this.isAlive = false;
                }
                this.notifyAll();//唤醒排队买票的线程
            } else {
                try {
                    System.out.println("队列已空...请等待！");
                    this.wait();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }


消费者类（拿票离开）：

    public class Consumer implements  Runnable{
    
        WindowQueue queue;
    
        public Consumer(WindowQueue queue) {
            this.queue = queue;
        }
    
        @Override
        public void run() {
            //根据消费者的线程是否终止来判断，接下来是否停止消费者在离开队列
            while (queue.isAlive) {
                try {
                    queue.consumer();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }


生产者类（等候买票）：

    public class Producer implements  Runnable{
    
        WindowQueue queue;
    
        public Producer(WindowQueue queue) {
            this.queue = queue;
        }
    
        @Override
        public void run() {
            while (queue.num < 100) {
                try {
                    queue.producer();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }


Test：

    public class Test {
        public static void main(String[] args) {
            WindowQueue queue = new WindowQueue();
            //注意一定要传同一个窗口对象
            Producer p = new Producer(queue);
            Consumer c = new Consumer(queue);
    
            //排队买票线程
            Thread pThread = new Thread(p);
            //卖票线程
            Thread cThread = new Thread(c);
    
            pThread.start();//开始排队买票
            cThread.start();//开始卖票
        }
    }


结果：

![队列1.10][10]

多线程的小总结：
--------

接口类


篮子类

篮子属性
1	最大长度 maxSize
2	技术牌子 int  count
3	入栈 int  rear
4	出栈 int  front
5	存放数据数组 shuzu [ ]

篮子结构体初始化
	Lanzi( int 随便数字)   {对篮子属性12345全部赋予值（初始化嘛）}
	Lanzi( )              {对篮子属性12345全部赋予值（初始化嘛）}

篮子方法
  1  放入篮子东西       push(Object  anything) 
	  2  拿出篮子东西       Object  pop()


Push (Object  anything)
1 判断是否队列满了  条件 front == rear && count  >  0
2 东西放入数组   shuzu [ rear ] = object
3 更新rear 指针的值 rear = (rear + 1) % maxSize
4 更新 count++


Pop()
1 判断是否队列为空  看count 是否为空
2 东西拿出数组   object = shuzu [ front ] 
3 更新front 指针的值 front  = (front  + 1) % maxSize
4 更新 count--



isEmpty
判断 count ==  0 






窗口类：

新建篮子类 lanzi
	设置卖票队伍最大长度 int  maxSize
	Lanzi lanzi  =  new Lanzi(maxSize);
	统计卖出票数 int  number （用来判断是否关闭窗口的条件
	判断是否继续卖票条件 Boolean  isAlive  =  true


同步synchronized  paidui() 排队方法
 	1 判断队列lanzi里的计数板count 《  卖票排队最大长度maxSize
		lanzi.push(  number ++  ) 向队列中加入数字，同时更新数字
		this.notifyAll() ;  //线程进入可启动状态
	2 不符合上面条件就是队列满员的情况，线程进入等待状态
This.wait()  //线程进入等待状态


同步synchronized  likai() 离开队列方法
	1 判断队列lanzi里的计数板count  >  0 //只要队列存在数据，就继续出栈数据
		Object   obj  = lanzi.pop(); //出栈数据，有入一定有出
		Int   temp  = Integer.parseInt( obj.toString())  对出栈的数据进行分解成Int
		//要是队列没有人了，而且票已经卖出200张，就关闭整个窗口
		If(lanzi.count == 0 &&　number > =200 ){
			This.isAlive = false;
}
	This.notifyAll();//线程进入可启动状态

	2 要是上面条件不满足，则是队列已经是空的
		This.wait()  //线程进入等待状态




线程类（有2个线程，一个是入栈线程---排队，一个是出栈线程---离队）


入栈线程---排队 paidui 类
	执行Runnable接口
	属性：
			篮子类：Lanzi  lanzi 
			初始化结构体  ：public paidui(  Lanzi  xxx ) {  this.lanzi  =  xxx}

重写Runnable方法 run
	1 判断队列的计数板count 是否＜ 卖票最大长度maxSize  （注意这里是用while循环
		lanzi.padui()




出栈线程---离队lidui类
执行Runnable接口
	属性：
		

	篮子类：Lanzi  lanzi  	
	初始化结构体  ：public lidui(  Lanzi  xxx ) {  this.lanzi  =  xxx }

重写Runnable方法 run
	1 判断窗口是否关闭 条件就是那个isAlive是否true
		lanzi.likai();




最后测试类：
	一个篮子类  lanzi  OB = new  lanzi(maxSize)
  一个窗口类  chuangkou  ck  = new  chuangkou(OB)

  1个入栈线程   Thread  ruzhan = new Thread(ck)

1个出栈线程   Thread  chuzhan = new Thread(ck);


	2个线程都开始

	Ruzhan.start();
	Chuzhan.start();

篮子类，队列类先准备好

R线程首先开始，1 判断运行条件判断是否运行（while循环）
2运行篮子类的方法
				3 篮子类方法里面有notifyAll()  和 wait()方法进行放锁和上锁
				4 运行到notifyAll()就意味着放锁，全部线程进入可读状态

C线程开始，1 判断运行条件判断是否运行（while循环）
2运行篮子类的方法
				3 篮子类方法里面有notifyAll()  和 wait()方法进行放锁和上锁
				4 运行到notifyAll()就意味着放锁，全部线程进入可读状态


自己写的时候出现问题的解答：
--------------

    //线程没有自动关闭？？ 为什么
     // ====>当num == 200时候， 窗口判断关闭条件没有设置对 ，导致消费者线程进入等待，
     // 同时生产者线程因为继续运行判断条件是num < 200，无法运行，消费者线程拿到锁，继续运行离开队列程序
     // 又因为，num不满足 > 200条件，无法进入关闭窗口判断体，消费者线程一直运行，一直是空的
     // 所以最后生产者线程停止，消费者线程还在运行，一直pop，无法关闭
     // 窗口判断关闭条件应该是>=200
    
     // 要是线程出现问题？
     // 解决：1 看线程运行判断条件 2 线程结束运行条件 3 逻辑内容
     // 整个 线程流程 是怎么样的？
    /*
     R线程首先开始，
     1 判断运行条件判断是否运行（while循环）
     2 运行篮子类的方法
     3 篮子类方法里面有notifyAll()  和 wait()方法进行放锁和上锁
     4 运行到notifyAll()就意味着放锁，全部线程进入可读状态
    
     C线程开始，
     1 判断运行条件判断是否运行（while循环）
     2 运行篮子类的方法
     3 篮子类方法里面有notifyAll()  和 wait()方法进行放锁和上锁
     4 运行到notifyAll()就意味着放锁，全部线程进入可读状态
    
     */
    
     //问题是   notifyAll 是唤醒全部的线程进入可读状态，
     //         wait是让线程进入等待状态，
     // 锁是怎么回事，synchronized是锁？是Notify后拿到锁的，还是wait是拿到锁？
     // 锁是java对象的隐式属性（JVM虚拟机监视器），执行代码的权限，锁就是获得监视器的权限
     //  不明白锁的含义，
     //  是因为synchronize 是同步的意思，描述的是数据在不同线程之间进行更新的过程（包括了锁的过程），
     //   完全没有锁的含义，描述的对象不同，
    
     // 以后不懂的情况，就要分析它所描述的是什么，含义是什么
    
     // 先是wait，释放锁，进入等待状态，然后别的线程拿到锁，
     // 然后拿到锁的线程执行到notify(),此时没有释放锁，synchronize代码块执行完才放锁


# 队列的链式存储实现：

参考：https://blog.csdn.net/jiutianhe/article/details/18606295

队列的链式存储结构也可以用一个单链表实现。
插入和删除操作 分别在链表的两头进行；
队列指针front和rear应该分别指向链表的哪一头？
struct QNode{           /* 链队列结构  */      
struct Node  *rear;      /* 指向队尾结点 */      
struct Node  *front;     /* 指向队头结点 */ 
};


代码实现：
-----

linkQueue:

    public class LinkQueue<T> implements Serializable {
        //定义一个内部类Node，Node实例代表链队列的节点
        private class Node {
            private T data;//保存节点的数据
            private Node next;//指向下个节点的引用
    
            public Node() {
            }
    
            public Node(T data, Node next) {
                this.data = data;
                this.next = next;
            }
        }
    
        private Node front;//保存该链队列的头节点
        private Node rear;//保存该链队列的尾节点
        private int size;//保存该链队列中已包含的节点数
    
    
        public LinkQueue(){
            //空链队列，front和rear都是null
            front = null;
            rear = null;
        }
    
        /**
         * <p>Title: LinkQueue </p>
         * <p>Description: 以指定数据元素来创建链队列，该链队列只有一个元素</p>
         */
        public LinkQueue(T element) {
            front = new Node(element, null);
            //只有一个节点，front、rear都指向该节点
            rear = front;
            size++;
        }
    
        /**
         * @Title: size
         * @Description: 获取顺序队列的大小
         * @return
         */
        public int size() {
            return size;
        }
    
    
        /**
         * @param element
         * @Title: offer
         * @Description: 入队
         */
        public void offer(T element) {
            //如果该链队列还是空链队列
            if (front == null) {
                front = new Node(element, null);
                rear = front;//只有一个节点，front、rear都指向该节点
            } else {
                Node newNode = new Node(element, null);//创建新节点
                rear.next = newNode;//让尾节点的next指向新增的节点
                rear = newNode;//以新节点作为新的尾节点
            }
            size++;
        }
    
        /**
         * @return
         * @Title: poll
         * @Description: 出队
         */
        public T poll() {
            Node oldFront = front;
            front = front.next;
            oldFront.next = null;
            size--;
            return oldFront.data;
        }
    
        /**
         * @return
         * @Title: peek
         * @Description: 返回队列顶元素，但不删除队列顶元素
         */
        public T peek() {
            return rear.data;
        }
    
        /**
         * @return
         * @Title: isEmpty
         * @Description: 判断顺序队列是否为空队列
         */
        public boolean isEmpty() {
            return size==0;
        }
    
        /**
         * @Title: clear
         * @Description: 清空顺序队列
         */
        public void clear() {
            //将front、rear两个节点赋为null
            front = null;
            rear = null;
            size = 0;
        }
    
        public String toString() {
            //链队列为空链队列时
            if (isEmpty()) {
                return "[]";
            } else {
                StringBuilder sb = new StringBuilder("[");
                for (Node current = front; current != null; current = current.next) {
                    sb.append(current.data.toString()+ ", ");
                }
                int len = sb.length();
                return sb.delete(len - 2, len).append("]").toString();
            }
        }
    }


LTest:

    public class LTest {
        public static void main(String[] args) {
            LinkQueue<String> queue = new LinkQueue<String>("aaaa");
            queue.offer("bbbb");
            queue.offer("cccc");
            System.out.println(queue);
    
            //删除一个元素后
            queue.poll();
            System.out.println("删除一个元素后的队列：" + queue);
    
            //再次添加一个元素
            queue.offer("ddddd");
            System.out.println("再次添加元素后的队列：" + queue);
            //删除一个元素后，队列可以再多加一个元素
            queue.poll();
            //再次加入一个元素
            queue.offer("eeeee34");
            System.out.println(queue);
        }


# 链式队列的应用：

参考： http://www.cnblogs.com/smyhvae/p/4793339.html

题目：
　　编写一个判断一个字符串是否是回文的算法。
思路：
　　设字符数组str中存放了要判断的字符串。把字符数组中的字符逐个分别存入一个队列和栈中，然后逐个出队和出栈比较出队的字符与出栈的字符是否相同，若全部相等则该字符串为回文。


代码实现：
-----
节点类

    //结点类
    public class Node {
        Object element; //数据域
        Node next;      //指针域
    
        //头结点的构造方法
        public Node(Node nextvalue) {
            this.next = nextvalue;
        }
    
        //非头结点的构造方法
        public Node(Object obj, Node nextvalue) {
            this.element = obj;
            this.next = nextvalue;
        }
        //获得当前的数据域的值
        public Object getElement() {
            return this.element;
        }
        //设置当前结点的数据域
        public void setElement(Object element) {
            this.element = element;
        }
        //获得当前结点的后继结点
        public Node getNext() {
            return this.next;
        }
        //设置当前结点的指针域
        public void setNext(Node next) {
            this.next = next;
        }
    
        public String toString() {
            return this.element.toString();
        }
    }


接口 栈：

    public interface Stack {
        public void push(Object object);
    
        public Object pop() throws Exception;
        //获得栈顶元素
        public Object getTop();
    
        public boolean isEmpty();
    
    }


接口 队列：

    //队列接口
    public interface Queue {
        //入队
        public void append(Object object);
        //出队
        public Object delete();
        //获得队头元素
        public Object getFront();
        //判断对列是否为空
        public boolean isEmpty();
    }


实体类： 栈

    public class LinkStack implements Stack{
    
        Node head;  //栈顶指针
        int size;  //结点的个数
    
        public LinkStack() {
            head = null;
            size = 0;
        }
    
    
    
        @Override
        public void push(Object object) {
            head = new Node(object, head);
            size++;
        }
    
        @Override
        public Object pop() throws Exception {
            if (isEmpty()) {
                throw new Exception("栈为空");
            }
            Object object = head.getElement();
            head = head.getNext();
            size--;
            return object;
        }
    
        @Override
        public Object getTop() {
            return head.getElement();
        }
    
        @Override
        public boolean isEmpty() {
            return head == null;
        }
    }


实体类： 队列

    public class LinkQueue implements Queue {
    
        Node front;
        Node rear;
        int count;
    
        public LinkQueue() {
            init();
        }
    
        public void init() {
            front = rear = null;
            count = 0;
        }
    
        @Override
    
        public void append(Object object) {
            Node node = new Node(object, null);
    
            if (rear != null) {
                rear.next = node;//队尾结点指向新结点
            }
    
            rear = node; //设置队尾结点为新结点
    
            //说明要插入的结点是队列的第一个结点
            if (front == null) {
                front = node;
            }
            count++;
        }
    
        @Override
        public Object delete() {
            if (isEmpty()) {
                new Exception("队列已空！");
            }
            Node node = front;
            front  =  front.next;
            count--;
            return node.getElement();
        }
    
        @Override
        public Object getFront() {
            if (!isEmpty()) {
                return front.getElement();
            } else {
                return null;
            }
        }
    
        @Override
        public boolean isEmpty() {
            return count == 0;
        }
    
    public static void main(String[] args) {
            LinkQueue qq = new LinkQueue();
            qq.append("sdjakldjk");
            qq.append("a");
            qq.append("b");
            qq.append("c");
            qq.append("d");
    
            qq.delete();
            qq.delete();
    
            qq.append("g");
    
            while (!qq.isEmpty()) {
                System.out.println(qq.delete());
            }
        }
    }


Test:
2个string 语句随便改

    public class Test {
        public static void main(String[] args) {
            String str1 = "ABCDCBA";
            String str2 = "ABCDECBA";
            try {
                if (Test.isHuiWen(str1)) {
                    System.out.println(str1 + "是回文");
                } else {
                    System.out.println(str1 + " 不是回文");
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        //方法：判断字符串是否回文
        public static boolean isHuiWen(String str) throws Exception {
            int n = str.length();
            LinkStack stack = new LinkStack();//创建堆栈
            LinkQueue queue = new LinkQueue();//创建队列
            for (int i = 0;i <n ;i++) {
                stack.push(str.subSequence(i, i + 1));//把字符串每个字符压进堆栈
                queue.append(str.subSequence(i, i + 1));//把字符串每个字符压入队列
            }
            while (!queue.isEmpty() && !stack.isEmpty()) {
                if (!queue.delete().equals(stack.pop())) { //出队列，出栈，同时判断是否相同
                    return false;
                }
            }
            return true;
        }
    }

结果：

> **ABCDCBA是回文**


# 循环队列和链式队列的比较：
（1）从**时间**上看，它们的**基本操作都是常数时间，即O(1)**的。不过循环队列是事先申请好空间，使用期间不释放；而链式队列，每次申请和释放结点也会存在一定的时间开销，如果入栈和出栈比较频繁，则两者还是有细微的差别。
（2）从**空间**上看，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链式队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链式队列更加灵活。

总结：**总的来说，在可以确定队列长度的最大值的情况下，建议用循环队列，如果你无法估计队列的长度，那就用链式队列。**


# 总结：
参考：https://blog.csdn.net/ggxxkkll/article/details/8661569

队列的顺序存储结构——循环队列
---------------

循环队列的长度为（rear-front+QueueSize）%QueueSize

顺序队列空满条件：
---------

队空的条件： front==rear
队满的条件是： （rear+1）%QueueSize==front

入队： rear = (rear+1) % maxSize
出队： front = (front + 1) % maxSize


# 自己的总结：

顺序和循环队列区别：
Add函数的判断条件不一致

循环：

    //rear == front判断是否空栈，后面的是判断是否满栈
    //少用一个存储空间  满栈：front==（rear+1）% maxSize
    if (rear == front && elementData[front] != null) {

顺序：

    if (index > capacity - 1) {



判断队列是否为空的函数

循环：

    private boolean isEmpty() {
        //rear==front且rear处的元素为null
        return rear == front && elementData[rear] == null;
    }


顺序：

    public boolean isEmpty() {
        return  rear == front;
    }


获取循环队列的长度
循环：

    //rear - front是顺序队列，也可以理解为front < rear
    //capacity - (front - rear)是循环队列，也可以理解为front > rear ,过圈了
    //front - rear 是表示队列空的栈数量
    return rear > front ? rear - front : capacity - (front - rear);

顺序：

    public int length() {
        return rear - front;
    }



顺序的长度是2个变量控制：开始front，结束rear
链表的长度是1个变量控制：整个表当前长度size  (有node节点)

顺序的长度是2个变量控制：开始front，结束rear
链表的长度是1个变量控制：整个表当前长度size  (有node节点)


顺序的删除操作： 直接把序号的data设置为null  
elementData[front++] = null

链表的删除操作： （此链表删除位置是表头，所以不用
front 是删除节点，有属性data,  next节点 ，
1．	将复制front节点，取名A节点
2．	front节点内容完全覆盖成 front – 1的节点，也就是断连接
3．	将A节点的next设置为null ，也是断连接
4．	Size减少1

**知道链表的一个节点，知道全部，因为可以用。Next表示后面的节点
删除A节点，需要3个必要步骤,  1 断连接,  2 节点内容设置为null，3长度-1
1 查找到A-1的节点（此时A节点是不知道的），设置一个临时变量B装载从A-1节点的next得到的删除节点A
2 从A-1节点处断连接， A-1的next修改成B的next，这就是断连接了
3 然后，将B的next = null，这就是设置null 了
4  size-1
增加A节点， 增加连接   长度+1
查找到A-1节点，临时变量B  = A-1。Next   A-1。Next = A   A 。next = B   size++**

图片详解：
-----

![队列1.11][11]


![队列1.12][12]


  [1]: https://i.loli.net/2018/07/17/5b4da7839d0f3.png
  [2]: https://i.loli.net/2018/07/17/5b4da78390a93.png
  [3]: https://i.loli.net/2018/07/17/5b4da7839f3f4.png
  [4]: https://i.loli.net/2018/07/17/5b4da85b4f4c2.png
  [5]: https://i.loli.net/2018/07/17/5b4da86d657c2.png
  [6]: https://i.loli.net/2018/07/17/5b4da88b1da44.png
  [7]: https://i.loli.net/2018/07/17/5b4da8a250210.png
  [8]: https://i.loli.net/2018/07/17/5b4da8b9b78cc.png
  [9]: https://i.loli.net/2018/07/17/5b4da8ded7a51.png
  [10]: https://i.loli.net/2018/07/17/5b4da8f14a6cb.png
  [11]: https://i.loli.net/2018/07/17/5b4da9099600c.png
  [12]: https://i.loli.net/2018/07/17/5b4da93838f37.png"	2018-07-17 10:10:43
kumika	堆栈	# 堆栈



---

![堆栈1.1][1]


![堆栈1.2][2]


使用数学算法来表示堆栈是怎么进行工作的。



堆栈的抽象数据类型描述
-----------
堆栈（Stack）：具有一定操作约束的线性表 
 只在一端（栈顶，Top）做 插入、删除
     插入数据：入栈（Push）
    删除数据：出栈（Pop） 
    后入先出：Last In First Out（LIFO

栈的顺序存储实现：
---------

栈的顺序存储结构通常由一个一维数组和一个记录 栈顶元素位置的变量组成
或者这样解释：
顺序栈是利用一组地址连续的存储单元依次存放从栈底到栈顶的数据元素，栈底位置固定不变，它的栈顶元素可以直接通过顺序栈底层数组的数组元素arr[size - 1]来访问

参考 ：https://www.cnblogs.com/Dylansuns/p/6788919.html

    public class SequenceStack<T> {
        private int Default_Size = 10;
        // 保存数组的长度
        private  int capacity;
        // 定义当底层数组容量不够时，程序每次增加的数组长度
        private int capaciIncrement = 0;
        // 定义一个数组用于保存顺序栈的元素
        private Object[] elementData;
        // 保存顺序栈中元素的当前个数
        private  int size = 0;
    
        // 以默认数组长度创建空顺序栈
        public SequenceStack() {
            capacity = Default_Size;
            elementData = new Object[capacity];
        }
    
        // 以一个初始化元素来创建顺序栈
        public SequenceStack(T element) {
            this();
            elementData[0] = element;
            size++;
        }
    
        /**
         * 以指定长度的数组来创建顺序线性表
         *
         * @param element  指定顺序栈中第一个元素
         * @param initSize 指定顺序栈底层数组的长度
         */
        public SequenceStack(T element, int initSize) {
            this.capacity = initSize;
            elementData = new Object[capacity];
            elementData[0] =  element;
            size++;
        }
        /**
             * 以指定长度的数组来创建顺序栈
              *
              * @param element 指定顺序栈中第一个元素
              * @param initSize 指定顺序栈底层数组的长度
               * @param capacityIncrement 指定当顺序栈底层数组的长度不够时，底层数组每次增加的长度
               */
        public SequenceStack(T element, int initSize,int capacityIncrement) {
            this.capacity = initSize;
            this.capaciIncrement = capacityIncrement;
            elementData = new Object[capacity];
            elementData[0] =  element;
            size++;
        }
    
        /**
         * 获取顺序栈的大小
         * @return
         */
        public int lengeth() {
            return  size;
        }
    
    
        public void push(T element) {
            ensureCapacity(size + 1);
            elementData[size++] = element;
        }
    
    
        /**
         96      * 确认数组的长度是否满足push之后的长度
         97      *
         98      * @param minCapacity 数组需要的最小长度
         99      */
        public void ensureCapacity(int i) {
            // 如果数组的原有长度小于目前所需要的长度
            if (i > capacity) {
                if (capaciIncrement > 0) {
                    while (capacity < i) {
                        // 不断地将capacity长度加capacityIncrement
                        // 直到capacity大于minCapacity为止
                        capacity += capaciIncrement;
                    }
                } else {
                    // 不断地将capacity * 2，直到capacity大于minCapacity为止
                    while (capacity < i) {
                        capacity <<= 1;
                    }
                }
                elementData = Arrays.copyOf(elementData, capacity);
            }
        }
    
        /**
         * 出栈
         * @return
         */
        public T pop() {
            T oldValue = (T) elementData[size - 1];
            elementData[--size] = null;
            return oldValue;
        }
    
        // 返回栈顶元素，但不删除栈顶元素
        public T peek() {
            return (T) elementData[size - 1];
        }
        // 判断顺序栈是否为空
        public boolean empty() {
            return size == 0;
        }
    
        // 清空顺序栈
        public void clear() {
            // 将底层数组所有元素赋值为null
            Arrays.fill(elementData, null);
            size = 0;
        }
    
        public String toString() {
            if (size == 0) {
                return "[]";
            } else {
                StringBuilder sb = new StringBuilder("[");
                for (int i = size -1 ;i > -1; i--) {
                    sb.append(elementData[i].toString() + ",");
                }
                int len = sb.length();
                return sb.delete(len - 2, len).append("]").toString();
    
            }
        }
    }
    
    public class STest {
        public static void main(String[] args) {
            SequenceStack<String> stack = new SequenceStack<String>();
    
            stack.push("aaaa");
            stack.push("bbbb");
            stack.push("cccc");
            stack.push("dddd");
            System.out.println(stack);
            System.out.println("访问栈顶元素：" + stack.peek());
            System.out.println("第一次弹出栈顶元素：" + stack.pop());
            System.out.println("第二次弹出栈顶元素：" + stack.pop());
            System.out.println("两次pop之后的栈：" + stack);
        }
    }


结果：

![堆栈1.3][3]

按顺序出栈•••••••还以为是什么顺序呢 阿西吧

堆栈的链式存储实现
---------

栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删 除操作只能在链栈的栈顶进行。栈顶指针Top应该在链表的哪一头？

采用单链表来保存栈中所有元素，这种链式结构的栈称为链栈

    public class LinkStack<T> {
        // 定义一个内部类Node，Node实例代表链栈的节点
        private class Node {
            // 保存节点的数据
            private T data;
            // 指向下个节点的引用
            private Node next;
            // 无参构造器
            public Node(){}
            // 初始化全部属性的构造器
            public Node(T data, Node next) {
                this.data = data;
                this.next = next;
            }
        }
    
        // 保存该链栈的栈顶元素
        private  Node top;
    
        // 保存该链栈中已包含的节点数
        private int size;
    
        // 创建空链栈
        public LinkStack() {
            // 空链栈，top的值为null
            top = null;
        }
    
        // 以指定数据元素来创建链栈，该链栈只有一个元素
        public LinkStack(T element) {
            top = new Node(element, null);
            size++;
        }
    
        //返回链栈的长度
        public int length() {
            return size;
        }
    
        //进栈
        public void push(T element) {
            top = new Node(element, top);
            size++;
        }
    
        //出栈
        public T pop() {
            Node oldTop = top;
            // 让top引用指向原栈顶元素的下一个元素
            top = top.next;
            // 释放原栈顶元素的next引用
            oldTop.next = null;
            size--;
            return oldTop.data;
        }
    
        // 访问栈顶元素，但不删除栈顶元素
        public T peek() {
            return top.data;
        }
    
        // 判断链栈是否为空栈
        public boolean empty() {
            return  size == 0;
        }
    
        // 请空链栈
        public void clear() {
            top = null;
            size = 0;
        }
    
        public String toString() {
            //链栈为空栈
            if (empty()) {
                return "[]";
            } else {
                StringBuilder sb = new StringBuilder("[");
                for (Node current = top;current != null; current = current.next) {
                    sb.append(current.data.toString()+" , ");
                }
                int len = sb.length();
                return sb.delete(len - 2, len).append("]").toString();
            }
        }
    }
    
    
    
    
    
    public class LTest {
        public static void main(String[] args) {
            LinkStack<String> stack = new LinkStack<String>();
    
            stack.push("aaaa");
            stack.push("bbbb");
            stack.push("cccc");
            stack.push("dddd");
            System.out.println(stack);
            System.out.println("访问栈顶元素：" + stack.peek());
            System.out.println("第一次弹出栈顶元素：" + stack.pop());
            System.out.println("第二次弹出栈顶元素：" + stack.pop());
            System.out.println("两次pop之后的栈：" + stack);
        }
    }

结果： 

![堆栈1.4][4]


# 后缀表达式：
------

![堆栈1.5][5]

利用堆栈顺序存储的运算过程：

  1===》 入栈（push） 6，2
  2===》 push  符号 / 
  3===》 这3个数据出栈(pop)计算，然后算出结果  3 ，再push 3
4===》push 3
5===》push 符号 – 
6===》这3个数据出栈(pop)计算，然后算出结果  0 ,再push 0
7===》push   4
8===》push   2
9===》push  符号 * 
10==》pop  4，2，* 这3个数据，得到结果8 ，再push 8
11==》push  符号  + 
12==》pop  0 , 8 ,+ 这3个数据，得到结果8 


回忆：
应用堆栈实现后缀表达式求值的基本过程：        
从左到右读入后缀表达式的各项（运算符或运算数）
**1. 运算数：入栈； 
2. 运算符：从堆栈中弹出适当数量的运算数，计算并结果入栈； 
3. 最后，堆栈顶上的元素就是表达式的结果值**

![堆栈1.6][6]

**中缀表达式：**
----------

基本策略：
-----
将中缀表达式转换为后缀表达式，然后求值 如何将中缀表达式转换为后缀？

观察一个简单例子： 2+9/3-5    ===》   2 9 3  /  +  5  -
1===》pop  2
2===》push  +
3===》pop  9
4===》Push  / （因为栈中符号 + 的优先级《 符号 / 的优先级 所以压栈 /
5===》Pop  3
6===》Pop  /  +（因为栈中符号 /  的优先级 》 符号 – 的优先级 所以出栈 /  + 然后压栈 - 
7===》Push  5
8===》Pop  -

1. 运算数相对顺序不变

2. 运算符号顺序发生改变

需要存储“等待中”的运算符号====》使用到堆栈
要将当前运算符号与“等待中”的最后一个运算符号比较

中缀转换成后缀：
--------
堆栈1.7://i.loli.net/2018/07/17/5b4db63f4752e.png

从左到右，这样看

堆栈1.8://i.loli.net/2018/07/17/5b4db64dc0ebc.png

中缀表达式求值

![堆栈1.9][7]

![堆栈1.10][8]



**中缀表达式如何转换为后缀表达式**
-------------------

从头到尾读取**中缀表达式的每个对象**，对不同对象按不同的情况处理。
1运算数：直接输出；
2左括号：压入堆栈；
3右括号：将栈顶的运算符弹出并输出，直到遇到左括号（出栈，不输出）；
4运算符：
4.1：若优先级大于栈顶运算符时，则把它压栈
  4.2：若优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出；再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然 后将该运算符压栈
5若各对象处理完毕，则把堆栈中存留的运算符一并输出。


![堆栈1.11][9]


  [1]: https://i.loli.net/2018/07/17/5b4db573ee16d.png
  [2]: https://i.loli.net/2018/07/17/5b4db57aa419d.png
  [3]: https://i.loli.net/2018/07/17/5b4db5836a54d.png
  [4]: https://i.loli.net/2018/07/17/5b4db5ce60f19.png
  [5]: https://i.loli.net/2018/07/17/5b4db5ce685be.png
  [6]: https://i.loli.net/2018/07/17/5b4db5f758f62.png
  [7]: https://i.loli.net/2018/07/17/5b4db65eed4f9.png
  [8]: https://i.loli.net/2018/07/17/5b4db674d7fd4.png
  [9]: https://i.loli.net/2018/07/17/5b4db68717ebb.png	2018-07-17 16:31:50
kumika	树	# 树

树是什么：（引子）
---------

---

分层次组织在管理上具有更高的效率! 
数据管理的基本操作之一：查找      

如何实现有效率的查找？


查找（Searching）
-------------

查找：根据某个给定关键字K ，从集合R中找出关键字与K相同的记录

静态查找：集合中记录是固定的 ，没有插入和删除操作，只有查找 
动态查找：集合中记录是动态变化的 ， 除查找，还可能发生插入和删除


静态查找
----

方法1：顺序查找

    int SequentialSearch (StaticTable *Tbl, ElementType K) {
     /*在表Tbl[1]~Tbl[n]中查找关键字为K的数据元素*/   
    int i;     
    Tbl->Element[0] = K;   /*建立哨兵*/     
    for(i = Tbl->Length; Tbl->Element[i]!= K; i--);     
    return i; /*查找成功返回所在单元下标；不成功返回0*/ 
    } 

![树1.1][1]

顺序查找算法的时间复杂度为O(n)。

方法2：二分查找（Binary Search)
-----------------------

假设n个数据元素的关键字满足有序（比如：小到大） 

![树1.2][2]

并且是连续存放（数组），那么可以进行二分查找

其实意思是在已经按顺序排列好的队列里快速查询，满足按顺序排列这个条件就可以用二分查找了


[例] 假设有13个数据元素，按关键字由小到大顺序存放.        
二分查找关健字为444的数据元素过程如下：

![树1.3][3]


> 1、left = 1,  right = 13; <br> mid = (1+13)/2 = 7; 
  **100 < 444;**
> 2、left = mid+1=8,  right = 13;<br>mid = (8+13)/2 = 10;     
**321 < 444;**
> 3、left = mid+1=11,  right = 13;<br>mid = (11+13)/2 = 12;  
**查找结束;**



[例] 仍然以上面13个数据元素构成的有序线性表为例         
二分查找关健字为 43 的数据元素如下：

![树1.4][4]

> 1、left = 1,     right = 13;      mid = (1+13)/2 = 7；     
    
100 > 43;
> 2、left = 1,     right = mid-1= 6;    mid = (1+6)/2 = 3；   


39 < 43; 
> 3、left = mid+1=4,  right = 6;       mid = (4+6)/2 = 5；   


51 > 43;  
> 4、left  = 4,  right = mid-1= 4;     mid = (4+4)/2 = 4；   


45 > 43;  
> 5、left  = 4,  right = mid-1= 3;     left > right ?          

查找失败，结束;



二分查找算法
------

    int  BinarySearch ( StaticTable * Tbl, ElementType K) {   /*在表Tbl中查找关键字为K的数据元素*/     
    int left, right, mid, NoFound=-1;       
    left = 1;                            /*初始左边界*/     
    right = Tbl->Length;      /*初始右边界*/     
    while ( left  <= right )     {         
    mid = (left+right)/2;    /*计算中间元素坐标*/         
    if( K < Tbl->Element[mid])         right = mid-1;    /*调整右边界*/         
    else if( K > Tbl->Element[mid])     left = mid+1;      /*调整左边界*/         
    else  return  mid;      /*查找成功，返回数据元素的下标*/     
    }     
    return  NotFound;         /*查找不成功，返回-1*/
     }

**二分查找算法具有对数的时间复杂度O(logN)

11个元素的二分查找判定树

判定树上每个结点需要的查找次数刚好 为该结点所在的层数; 

查找成功时查找次数不会超过判 定树的深度 

 n个结点的判定树的深度 为[log2n]+1. 
 
ASL = (4*4+4*3+2*2+1)/11 = 3**

![树1.5][5]

# 树的定义

树（Tree）: n（n≥0）个结点构成的有限集合。      
当n=0时，称为空树；      
对于任一棵非空树（n> 0），它具备以下性质： 
 1 树中有一个称为“根（Root）”的特殊结点，用 r 表示； 
2 其余结点可分为m(m>0)个互不相交的有限集T1，T2，... ，Tm，其 中每个集合本身又是一棵树，称为原来树的“子树（SubTree）”

![树1.6][6]![树1.7][7]![树1.8][8]
![树1.9][9]![树1.10][10]


树与非树?
-----
![树1.11][11]

 1 子树是不相交的； 
 2 除了根结点外，每个结点有且仅有一个父结点； 
 3 一棵N个结点的树有N-1条边


![树1.12][12]



树的一些基本术语
--------

**1. 结点的度（Degree）：结点的子树个数 
2. 树的度：树的所有结点中最大的度数 
3. 叶结点（Leaf）：度为0的结点 
4. 父结点（Parent）：有子树的结点是其子树 的根结点的父结点 
5. 子结点（Child）：若A结点是B结点的父结 点，则称B结点是A结点的子结点；子结点也 称孩子结点。 
6. 兄弟结点（Sibling）：具有同一父结点的各 结点彼此是兄弟结点**

![树1.13][13]


**七. 路径和路径长度：从结点n1到nk的路径为一 个结点序列n1 , n2 ,… , nk , ni是 ni+1的父结 点。路径所包含边的个数为路径的长度。 
8.  祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。 
9.  子孙结点(Descendant)：某一结点的子树中的所有结点是这个结点的子孙。 
10. 结点的层次（Level）：规定根结点在1层， 其它任一结点的层数是其父结点的层数加1。 
11. 树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度**

小的知识点：

一棵树N个结点的树有n-1 条边（分支数）

终端/叶子结点： 度为0 的结点

非终端/分支结点： 度不为0 的结点

所有结点的度之和 = 总分支数


**树的表示**

![树1.14][14]

![树1.15][15]

儿子-兄弟表示法
![树1.16][16]

![树1.17][17]

![树1.18][18]

![树1.19][19]


  [12loli.net/2018/07/17/5b4dc1d6750c3.png


  [1]: https://i.loli.net/2018/07/17/5b4dc41177200.png
  [2]: https://i.loli.net/2018/07/17/5b4dc3ffe6451.png
  [3]: https://i.loli.net/2018/07/17/5b4dc3eef3ac6.png
  [4]: https://i.loli.net/2018/07/17/5b4dc3c26a140.png
  [5]: https://i.loli.net/2018/07/17/5b4dc3b51c3df.png
  [6]: https://i.loli.net/2018/07/17/5b4dc368cc9c2.png
  [7]: https://i.loli.net/2018/07/17/5b4dc35727ae0.png
  [8]: https://i.loli.net/2018/07/17/5b4dc33ed510b.png
  [9]: https://i.loli.net/2018/07/17/5b4dc324b1b93.png
  [10]: https://i.loli.net/2018/07/17/5b4dc313e50c1.png
  [11]: https://i.loli.net/2018/07/17/5b4dc2d9c8d77.png
  [12]: https://i.loli.net/2018/07/17/5b4dc290f1300.png
  [13]: https://i.loli.net/2018/07/17/5b4dc26d48244.png
  [14]: https://i.loli.net/2018/07/17/5b4dc1d66b3ac.png
  [15]: https://i.loli.net/2018/07/17/5b4dc1d66f4d9.png
  [16]: https://i.loli.net/2018/07/17/5b4dc1d670ccf.png
  [17]: https://i.loli.net/2018/07/17/5b4dc1d673b96.png
  [18]: https://i.loli.net/2018/07/17/5b4dc1d6722fc.png
  [19loli.net/2018/07/17/5b4dc1d6722fc.png
  [18]: https://i.loli.net/2018/07/17/5b4dc1d6722fc.png	2018-07-17 17:29:25
kumika	二叉树及存储结构	"# 二叉树及存储结构

二叉树的定义

---

二叉树T：一个有穷的结点集合。       
这个集合可以为空       
若不为空，则它是由根结点和称为其左子树TL和右子树TR的 两个不相交的二叉树组成。 
二叉树具体五种基本形态

![二叉树1.1][1]


二叉树的**子树有左右顺序之分**

![二叉树1.2][2]

特殊二叉树
斜二叉树(Skewed Binary Tree)

![二叉树1.3][3]

完美二叉树(Perfect Binary Tree)    
满二叉树(Full Binary Tree）

> **(2^k) -1，k≥1**

![二叉树1.4][4]

完全二叉树     (Complete Binary Tree) 
有n个结点的二叉树，对树中结点按 从上至下、从左到右顺序进行编号， 
编号为i（1 ≤ i ≤ n）结点与满二叉树 中编号为 i 结点在二叉树中位置相同
深度为

> (log2 n)+1 ， 2是底数

证明：
![二叉树1.5][5]

这里第一个不等式不明白，后面的能明白怎么转到Log上


![二叉树1.6][6]


下图就不是完全二叉树， 区别就是完全二叉树是4结点D 下面的8结点右边有兄弟节点9的，但是假如8结点右边没有就不是完全二叉树； 

![二叉树1.7][7]

二叉树几个重要性质
---------

一个二叉树第 i 层的最大结点数为：

>  (2^i)-1，i ≥ 1

![二叉树1.8][8]

深度为k的二叉树有最大结点总数为：

> 1+2^1+2^2+•••••••+2^(k-1) = (2^k)-1 ===>  (2^k)-1，k≥1

用的是等比数列公式：

> an = a1 X q^(n-1) <br> Sn = (a1X(1- q^(n-1)) )/(1-q)


对任何非空二叉树 T，若n0表示终端叶结点的个数、n2是 度为2的非叶结点个数，那么两者满足关系

> n0 = n2 +1

求证过程： 终端叶结点数n0, 单分支结点数为n1,双分支结点数n2,

> 总结点数A = n0 +n1 +n2  
总分支数B = n1  + 2 n2 
A-1 = B

![二叉树1.9][9]


二叉树的抽象数据类型定义
------------

类型名称：二叉树 
数据对象集：一个有穷的结点集合。      
若不为空，则由根结点和其左、右二叉子树组成。 
 
操作集： BT∈ BinTree, Item∈ ElementType，
重要操作有： 
1、Boolean IsEmpty( BinTree BT )： 判别BT是否为空； 
2、void Traversal( BinTree BT )：遍历，按某顺序访问每个结点； 
3、BinTree CreatBinTree( )：创建一个二叉树


常用的遍历方法有： 
void PreOrderTraversal( BinTree BT )：   先序----根、左子树、右子树；
void InOrderTraversal( BinTree BT )：    中序---左子树、根、右子树；
void PostOrderTraversal( BinTree BT )：  后序---左子树、右子树、根 
void LevelOrderTraversal( BinTree BT )： 层次遍历，从上到下、从左到右


# 二叉树的存储结构

顺序存储结构
------

完全二叉树**：按从上至下、从左到右顺序存储        
n个结点的完全二叉树的结点父子关系**
非根结点（序号 i > 1）的**父结点**的序号是 **[ i / 2 ];**

结点（序号为 i ）的**左孩子结点**的序号是  **2i**，                 
（若2 i <= n，否则没有左孩子）;

结点（序号为 i ）的**右孩子结点**的序号是  **2i+1**，                 
（若2 i +1<= n，否则没有右孩子）;


![二叉树1.10][10]

![二叉树1.11][11]


一般二叉树也可以采用这种结构，但会造成空间浪费……

![二叉树1.12][12]

![二叉树1.13][13]

2. 链表存储
-------

就是java的一般双向链表结点结构 node  ~0~

    typedef  struct  TreeNode *BinTree; 
    typedef  BinTree Position; 
    struct  TreeNode{  
    ElementType  Data;  
    BinTree  Left;  
    BinTree  Right;
     }

![二叉树1.14][14]

![二叉树1.15][15]

![二叉树1.16][16]

![二叉树1.17][17]


二叉树的遍历（链式）
----------

参考： https://www.cnblogs.com/qiuyong/p/6675492.html
链式Java实现代码：
	二叉树结点：
    public class BinaryTreeNode {
        private int data;
        private BinaryTreeNode left;
        private BinaryTreeNode right;
    
        public BinaryTreeNode() {
        }
    
        public BinaryTreeNode(int data, BinaryTreeNode left, BinaryTreeNode right) {
            super();
            this.data = data;
            this.left = left;
            this.right = right;
        }
    
        public int getData() {
            return data;
        }
    
        public void setData(int data) {
            this.data = data;
        }
    
        public BinaryTreeNode getLeft() {
            return left;
        }
    
        public void setLeft(BinaryTreeNode left) {
            this.left = left;
        }
    
        public BinaryTreeNode getRight() {
            return right;
        }
    
        public void setRight(BinaryTreeNode right) {
            this.right = right;
        }
    }

结点的实现：（注意new出结点的顺序）


    BinaryTreeNode node10 = new BinaryTreeNode(10, null, null);
    BinaryTreeNode node9 = new BinaryTreeNode(9, null, node10);
    BinaryTreeNode node8 = new BinaryTreeNode(8, null, null);
    BinaryTreeNode node7 = new BinaryTreeNode(7, null, null);
    BinaryTreeNode node6 = new BinaryTreeNode(6, null, null);
    BinaryTreeNode node5 = new BinaryTreeNode(5, node8, node9);
    BinaryTreeNode node4 = new BinaryTreeNode(4, null, null);
    BinaryTreeNode node3 = new BinaryTreeNode(3, node6, node7);
    BinaryTreeNode node2 = new BinaryTreeNode(2, node4, node5);
    BinaryTreeNode node1 = new BinaryTreeNode(1, node2, node3);



# 二叉树的遍历（递归）
----------
二叉树使用递归===》**要对递归理解正确，一层层执行下去，返回执行的时候也是从最下（里）面一层层执行上来**
在实现函数调用的时候，系统底层就是用栈来保存函数运行现场的；具体来说，每次调用函数时，会把当前函数的局部变量和返回地址都压栈保存起来，当函数调用结束返回的时候，再把局部变量从栈里弹出来。
    而**递归的核心就是重复的函数调用**。因此如果要变成非递归，就可能**需要自己实现栈数据结构用来保存一些状态变量**；这其实就是在模拟函数调用

递归工作栈里面包括返回地址、本层的局部变量和递归调用的形参代换用实参，所以正常情况下，无论递归过程有没有使用局部变量，转换为非递归过程都需要用栈来模拟这个递归调用过程
当然，有一些特殊递归不用栈就可以直接转换，比如尾递归、常系数递推等，无论是否有局部变量。


如何调用递归： 类里面的属性对象也是该类的对象
先后顺序的判别是根据根结点的访问位置决定的。

（1）先序遍历
-------

遍历过程为： ① 访问根结点； ② 先序遍历其左子树； ③ 先序遍历其右子树。

![二叉树1.18][18]

一般以3个结点为1个树作为例子解释：
ABC 是一个树， 因为先访问 根 所以先输出 树根A ，又因为B是左子树，先访问B，B也是一个树根，先输出B，再访问B的左子树D，输出D，接着访问B的右子树F，因为F也是个树，先输出树根F，先访问左子树E，输出E，E没有有子树，就原路返回直到A的右子树C。
	按照上面的套路接着访问C子树••••先根，后左，最后右
	原因是先完成递归语句PreOrderTraversal( BT->Left );，才可以执行下一条语句


![二叉树1.19][19]

伪代码：

    void PreOrderTraversal( BinTree BT ) {     
    if( BT ) {         
    printf(“%d”, BT->Data);         
    PreOrderTraversal( BT->Left );         
    PreOrderTraversal( BT->Right );     
    } }

先序实现代码：

    //前序遍历递归的方式
    public void preOrder(BinaryTreeNode root) {
        if (null != root) {
            System.out.println(root.getData()+ "\t");
            preOrder(root.getLeft());
            preOrder(root.getRight());
        }
    }

结果 ：

![二叉树1.20][20]


（2）中序遍历
-------

遍历过程为： ① 中序遍历其左子树； ② 访问根结点； ③ 中序遍历其右子树

![二叉树1.21][21]


一般以3个结点为1个树作为例子解释：
	先从左子树开始访问（提前从A一直向左访问左子树），读取到最左的叶结点D，输出D，返回D的根结点B，输出B，接着访问B的右子树F，因为F是树，有左子树/左叶结点，所以先访问F最左的叶结点E，输出E ，返回树根F ，输出F，F树没有右子树，原路返回到根结点A ，输出A
接着开始访问右子树C，因为C子树有左子树G，但是G没有左叶结点，所以输出根结点G，访问右子树H，输出H，原路返回到C树根结点C ，输出C，如此访问下去，先左再到根最后是右•••••••

![二叉树1.22][22]

伪代码：

    void InOrderTraversal( BinTree BT ) {     
    if( BT ) {         
    InOrderTraversal( BT->Left );         
    printf(“%d”, BT->Data);         
    InOrderTraversal( BT->Right );     
    } } 

中序实现代码：

    //中序遍历采用递归的方式
    public void inOrder(BinaryTreeNode root) {
        if (null != root) {
            inOrder(root.getLeft());
            System.out.println(root.getData() + "\t");
            inOrder(root.getRight());
        }
    }


结果：


![二叉树1.23][23]


（3）后序遍历
-------

遍历过程为： ① 后序遍历其左子树； ② 后序遍历其右子树； ③ 访问根结点

![二叉树1.24][24]

一般以3个结点为1个树作为例子解释：
	先读取左子树（一直向左找），输出左子叶结点D，输出D，再访问该树的右子叶结点F，F也是树，先访问左子叶结点E，输出E，接着返回F树的根结点F，输出F，接着返回到F作为叶结点的树的根结点B，输出B，接着返回到根节点A，接下来是要访问右子树C，所以访问C的左子树，•••••这样！一层层嵌套，一层层解套，先左，后右，最后根


![二叉树1.25][25]

伪代码：

    **void PostOrderTraversal( BinTree BT ) {     
    if( BT ) {         
    PostOrderTraversal( BT->Left );         
    PostOrderTraversal( BT->Right);         
    printf(“%d”, BT->Data);      
    } }**

后序实现代码：

    //后序遍历采用递归的方式
    public void postOrder(BinaryTreeNode root) {
        if (root != null) {
            postOrder(root.getLeft());
            postOrder(root.getRight());
            System.out.println(root.getData() + "\t");
        }
    }
结果：

![二叉树1.26][26]


**先序、中序和后序遍历过程：遍历过程中经过结点的路线一 样，只是访问各结点的时机不同。 
图中在从入口到出口的曲线上用X，三角形和星形三种符号分别标 记出了先序、中序和后序访问各结点的时刻**

![二叉树1.27][27]



#二叉树的非递归遍历
---------

中序遍历非递归遍历算法 
非递归算法实现的基本思路：使用堆栈

![二叉树1.28][28]


中序非递归遍历算法
---------

遇到一个结点，就把它压栈，并去遍历它的左子树； 
当左子树遍历结束后，从栈顶弹出这个结点并访问它； 
然后按其右指针再去中序遍历该结点的右子树

伪代码：

    void InOrderTraversal( BinTree BT ) {  
    BinTree T=BT; 
    Stack S = CreatStack( MaxSize ); /*创建并初始化堆栈S*/ 
    while( T || !IsEmpty(S) ){     
    while(T){   /*一直向左并将沿途结点压入堆栈*/         
    Push(S,T);          
    T = T->Left;      
    }     
    if(!IsEmpty(S)){         
    T = Pop(S); /*结点弹出堆栈*/         
    printf(“%5d”, T->Data); /*（访问）打印结点*/         
    T = T->Right; /*转向右子树*/     
    } }}

个人理解：

> 	递归的底层实现也是堆栈存储过程，方法自己描述了数据在堆栈出入的方式，调用自身的同时减少了描述过程和代码量

	 **使用堆栈，就是具体表述递归过程，区别在于递归是自动使用堆栈，这里是需要另外自己new一个堆栈来使用**

代码实现：

    //中序遍历采用非递归的方式
    public void inOrderNonRecursive(BinaryTreeNode root) {
        Stack<BinaryTreeNode> stack = new Stack<BinaryTreeNode>();
        while (true) {
            while (root != null) {
                stack.push(root);//压栈
                root = root.getLeft();//进行root更新，指针移动到下一个左子树
            }
            if (stack.isEmpty()) break;
            root = stack.pop();//出栈
            System.out.println(root.getData() + "\t");//输出数据
            root = root.getRight();//访问右子树
        }
    }


先序遍历的非递归遍历算法？
-------------

**注意和中序遍历的区别**

    void InOrderTraversal( BinTree BT ) {  
    BinTree T=BT; 
    Stack S = CreatStack( MaxSize ); /*创建并初始化堆栈S*/ 
    while( T || !IsEmpty(S) ){     
    while(T){   /*一直向左并将沿途结点压入堆栈*/         
    Push(S,T);
    ***printf(“%5d”, T->Data); /*（访问）打印结点*/***            
    T = T->Left;      
            }     
    if(!IsEmpty(S)){         
    T = Pop(S); /*结点弹出堆栈*/         
           
    T = T->Right; /*转向右子树*/     
    } }}


实现代码：

    //前序遍历非递归的方式
    public void preOrderNonRecursive(BinaryTreeNode root) {
        Stack<BinaryTreeNode> stack = new Stack<BinaryTreeNode>();
        while (true) {
            while (root != null) {
                System.out.println(root.getData() + "\t");
                stack.push(root);
                root = root.getLeft();
            }
            if (stack.isEmpty()) break;
            root = stack.pop();
            root = root.getRight();
        }
    }


后序遍历非递归遍历算法
-----------

**后序遍历的非递归实现是三种遍历方式中最难的一种**。因为在后序遍历中，**要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点**，这就为流程的控制带来了难题。下面介绍两种思路。

**第一种思路：**对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，**此时该结点出现在栈顶，但是此时不能将其出栈并访问**， 因此其右孩子还没被访问。所以接下来按照相同的规则对其右子树进行相同的处理**，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问**。这样就 保证了正确的访问顺序。可以看出，在这个过程中**，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。**因此需要多设置一个变量标识该结点是 否是第一次出现在栈顶


    //后序遍历采用非递归的方式  2个后序非递归方法的区别在于描述的结点（主角结点）不一致
    public void postOrderNonRecursive(BinaryTreeNode root) {
        Stack<BinaryTreeNode> stack = new Stack<BinaryTreeNode>();
        //判断左子树是否输出，判断右子树是否输出，将这2个子树判断切合在一起
        while (true) {
            if (root != null) {
                stack.push(root);
                root = root.getLeft();
            } else {//走完左子树，此时结点root是 Null
                if (stack.isEmpty()) return; //退出整个方法
                //判断栈顶元素有没有右子树，也就是结点root的上个结点有没有右子树
                // 此时的主角视角是堆栈，看的是堆栈上栈顶元素（结点）有没有右子树
                if (null == stack.lastElement().getRight()) {//判断访问左子树是否有右子树，有则跳出判断继续更新
                    //要是没有，则说明此时的栈顶元素（结点）是最左的结点，可以输出最左结点
                    root = stack.pop(); //出栈，同时更新结点root
                    System.out.println(root.getData() + "\t");//输出结点
                    // 注意堆栈是先进后出的，栈顶输出一个后，顶替的元素就是树的上一个结点
                    // 栈顶的元素和root不是同一个元素，此时root是此时栈顶元素（结点）访问过的右结点，可以输出
                    //判断访问右子树结束的点，也可以说判断右子树是否已经被访问过，要是被访问过则要输出
                    while (root == stack.lastElement().getRight()) {
                        System.out.println(stack.lastElement().getData() + "\t");
                        root = stack.pop();//输出栈顶元素，更新Root，此时root是上一个结点数据
                        if (stack.isEmpty()) {
                            break;
                        }
                    }
                }
                //当上面判断完左右子树是否输出，这里就继续进行更新向子树访问
                if (!stack.isEmpty()) {
                    root = stack.lastElement().getRight();
                } else {
                    root = null;
                }
            }
        }
    }


**第二种思路：****要保证根结点在左孩子和右孩子访问之后才能访问**，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存 在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了 每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。
**（简单的意思就是： 根节点访问输出，是要在左子树和右子树都输出完之后进行的。所有当前结点的右子树需要从栈点拿出来检查判断是不是与上次访问结点一不一样，
解释：当前结点的右子树拿出来与上次一致时候，说明已经访问过了，没有必要重复访问，此时只需要输出当前结点-----根结点）**


    /**
     * 后序遍历递归定义：先左子树，后右子树，再根节点。
    后序遍历的难点在于：需要判断上次访问的节点是位于左子树，还是右子树。
    若是位于左子树，则需跳过根节点，先进入右子树，再回头访问根节点；
    若是位于右子树，则直接访问根节点。
    个人理解： 关键是需要理解，
               分岔口（根结点）是需要出入栈2次的，
               第1次是查询最左子树的时候顺便入栈的
               第2次是 返回到分岔口（其实对每一个结点）都要出栈判断一次是否存在右子树，右子树是否访问过；
    存在而且被访问过就入栈。
    第2次就是判断的难点，
    
     **/
    public void PPSOrder(BinaryTreeNode root) {
        if (root == null) {
            return;
        }
        Stack<BinaryTreeNode> stack = new Stack<BinaryTreeNode>();
    
        BinaryTreeNode curNode = root;  //当前访问的结点
        BinaryTreeNode lastVisitNode = null;  //上次访问的结点
    
        //把currentNode移到左子树的最下边，要是左子树为空，则是最左，退出循环
        while (curNode != null) {
            stack.push(curNode);
            curNode = curNode.getLeft();
        }
    
        while (!stack.empty()) {
            //弹出栈顶元素，因为curNode在上面的左子树搜索结束时是null
    //也是用于更新curNode，
    //要是curNode有右子树,则根据下面的判断条件可以再次入栈，不相等则说明没访问过
            curNode = stack.pop();
            //一个根节点被访问的前提是：无右子树或右子树被访问过
    	// 向下访问的条件，有右子树，并且没有访问过
            if (curNode.getRight() != null && curNode.getRight() != lastVisitNode) {
                //根节点再次入栈
                stack.push(curNode);
                //进入右子树，且可肯定右子树一定不为空
                curNode = curNode.getRight();
               //继续判断右子树是否有左子树，有则入栈 
    		while (curNode != null) {
                    //再走到右子树的最左边
                    stack.push(curNode);
                    curNode = curNode.getLeft();
                }
            } else {
                //访问
                System.out.println(curNode.getData());
                //修改最近被访问的节点
                lastVisitNode = curNode;
            }
        }
    }


当我们后序遍历某个结点时，我们上一个访问的元素必然是其右子节点,所以我们可以用

> lastVisitNode

来记录上一个访问的元素，进行条件判断。

这种遍历，有一个好玩的地方，就是：在代码运行到

> lastVisitNode = curNode;

**那里时，栈中的元素，刚好是curNode的所有祖先 。
这是因为：① 当我们遍历某节点时，其“右上方”的任何节点，还没有被经过（pass）。
这其实是‘先序’的入栈方式决定的。**

**② 当我们遍历右节点时，其左节点必然已经出栈。
这是由后序遍历的出栈方式决定的。**

**思路2是采用回溯的思想，利用lastVisitNode节点，把每个父节点入栈（pass）了两次。**


参考：https://blog.csdn.net/zhuqiuhui/article/details/51319165
		https://zhuanlan.zhihu.com/p/34586271
https://www.cnblogs.com/SHERO-Vae/p/5800363.html

**个人推荐思路2**


# 层序遍历
----

二叉树遍历的核心问题：**二维结构的线性化** 
从结点访问其左、右儿子结点 
访问左儿子后，右儿子结点怎么办？ 
 需要一个存储结构保存暂时不访问的结点 
 存储结构：堆栈、队列

**队列实现：**遍历从根结点开始，首先将**根结点入队**，然后开始执 行循环：结点出队、访问该结点、其左右儿子入队


![二叉树1.29][29]

![二叉树1.30][30]


层序基本过程：先根结点入队，然后：

1从队列中取出一个元素； 
2 访问该元素所指结点； 
3 若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队。

伪代码：

    void LevelOrderTraversal ( BinTree BT ) {   
    Queue Q;  
    BinTree T; 
    if ( !BT ) return; /* 若是空树则直接返回 */ 
    Q = CreatQueue( MaxSize ); /*创建并初始化队列Q*/
    AddQ( Q, BT ); 
    while ( !IsEmptyQ( Q ) ) {     
    T = DeleteQ( Q ); 
    printf(“%d\n”, T->Data); /*访问取出队列的结点*/
     	if ( T->Left )  AddQ( Q, T->Left ); 
    if ( T->Right )  AddQ( Q, T->Right ); 
    }}

实现代码：

    //层序遍历
    public void levelOrder(BinaryTreeNode root) {
        BinaryTreeNode temp;
        Queue<BinaryTreeNode> queue = new LinkedList<BinaryTreeNode>();
    
        queue.offer(root);
        while (!queue.isEmpty()) {
            temp = queue.poll();
            System.out.println(temp.getData() + "\t");
            if (null != temp.getLeft()) {
                queue.offer(temp.getLeft());
            }
            if (null != temp.getRight()) {
                queue.offer(temp.getRight());
            }
        }
    }

https://www.cnblogs.com/qiuyong/p/6675492.html


#一些二叉树例子

遍历二叉树的应用：输出二叉树中的叶子结点
在二叉树的遍历算法中增加检测结点的“左右子树是否都为空”。

伪代码：

    void PreOrderPrintLeaves( BinTree BT ) {     
    if( BT ) {         
        if ( !BT-Left && !BT->Right )             
            printf(“%d”, BT->Data );         
            PreOrderPrintLeaves ( BT->Left );         
            PreOrderPrintLeaves ( BT->Right );     
      }
    }


java实现代码：

    public void PreLeves(BinaryTreeNode node) {
        if (null != node) {
            if (null != node.getLeft() && null != node.getRight()) {
                    System.out.println("左右结点都不为空 " + node.getData());
                    PreLeves(node.getLeft());
                    PreLeves(node.getRight());
            }
        }
    }

调用方法：

    System.out.println("-----输出叶子结点------");
    tree.PreLeves(node1);
    System.out.println();

结果：

![二叉树1.31][31]


求二叉树的高度
-------

![二叉树1.32][32]

伪代码：

    int PostOrderGetHeight( BinTree BT ) {   
    int HL, HR, MaxH;     
    if( BT ) {         
        HL = PostOrderGetHeight(BT->Left);  /*求左子树的深度*/         
        HR = PostOrderGetHeight(BT->Right); /*求右子树的深度*/         
        MaxH = （HL > HR）? HL : HR; /*取左右子树较大的深度*/         
        return ( MaxH + 1 ); /*返回树的深度*/     
    }     
    else  return 0; /* 空树深度为0 */
    }


Java代码实现：

    public int getHeight(BinaryTreeNode node) {
        int HL, HR, max;
    
        if (node != null) {
            HL = getHeight(node.getLeft()); //求左子树深度
            HR = getHeight(node.getRight());//求右子树深度
            max = (HL > HR)? HL : HR;//左右子树比较大的深度
            return max + 1;//加上总根结点
        } else return 0;
    }


调用方法

    System.out.println("-----输出树的深度------");
    System.out.println(tree.getHeight(node1));
    System.out.println();


结果：

> -----输出树的深度------ 
5

求二叉树宽度
------

**使用队列，层次遍历二叉树**。在上一层遍历完成后，下一层的所有节点已经放到队列中，
**此时队列中的元素个数就是下一层的宽度**。以此类推，依次遍历下一层即可求出二叉树的最大宽度。

实现代码：

    /**
     * 使用队列，层次遍历二叉树。在上一层遍历完成后，下一层的所有节点已经放到队列中，
     * 此时队列中的元素个数就是下一层的宽度。以此类推，依次遍历下一层即可求出二叉树的最大宽度。
     * 
     *
     * 参考：https://www.cnblogs.com/xudong-bupt/p/4036190.html
     */
    public int getMaxwidth(BinaryTreeNode node) {
        if (node == null) {
            return 0;
        }
        Queue<BinaryTreeNode> queue = new ArrayDeque<BinaryTreeNode>();
        int maxWidth = 1; // 最大宽度
        queue.add(node);// 入队
    
        while (queue!=null) {
            int len = queue.size(); // 当前层的节点个数
            if (len == 0) {
                break;
            }
            while (len > 0) {// 如果当前层，还有节点
                BinaryTreeNode node2 = queue.poll();
                len--;
                if (node2.getLeft() != null) { // 下一层节点入队
                    queue.add(node2.getLeft());
                }
                if (node2.getRight() != null) {// 下一层节点入队
                    queue.add(node2.getRight());
                }
            }
            maxWidth = Math.max(maxWidth, queue.size());
        }
        return maxWidth;
    }



输出：

    System.out.println("-----输出树的宽度------");
    System.out.println(tree.getMaxwidth(node1));
    System.out.println();




求左右都不空的叶结点
----------

    public void PreLeves(BinaryTreeNode node) {
        if (null != node) {
            if (null != node.getLeft() && null != node.getRight()) {
                System.out.println("左右结点都不为空 " + node.getData());
                PreLeves(node.getLeft());
                PreLeves(node.getRight());
            }
        }
    }


    System.out.println("-----输出叶子结点------");
    tree.PreLeves(node1);
    System.out.println();




求左右都空的叶结点
---------

    public void biLeves(BinaryTreeNode node) {
        if (null != node) {
            if (node.getLeft() == null && node.getRight() == null) {
                System.out.println("左右结点都为空 " + node.getData());
            }
            biLeves(node.getLeft());
            biLeves(node.getRight());
        }
    }






    System.out.println("-----输出叶子结点都是空的------");
    tree.biLeves(node1);
    System.out.println();



#由两种遍历序列确定二叉树
------------

任意2种遍历中，一定要有中序遍历

为什么？
没有中序的困扰：  先序遍历序列：A  B 
后序遍历序列：B  A


![二叉树1.33][33]

先序和中序遍历序列来确定一棵二叉树
    

> 根据**先序**遍历序列第一个结点**确定根结点**； 
>     根据根结点在**中序遍历**序列中分割出左右两个子序列 
>     对**左子树和右子树分别递归**使用相同的方法继续分解


![二叉树1.34][34]

![二叉树1.35][35]


  [23i.net/2018/07/18/5b4e25287735c.png


  [1]: https://i.loli.net/2018/07/18/5b4e28f974c94.png
  [2]: https://i.loli.net/2018/07/18/5b4e28f973674.png
  [3]: https://i.loli.net/2018/07/18/5b4e28b61c54c.png
  [4]: https://i.loli.net/2018/07/18/5b4e28b61dd9c.png
  [5]: https://i.loli.net/2018/07/18/5b4e2929cb5df.jpg
  [6]: https://i.loli.net/2018/07/18/5b4e2898450bd.png
  [7]: https://i.loli.net/2018/07/18/5b4e28984397f.png
  [8]: https://i.loli.net/2018/07/18/5b4e285a1fbef.png
  [9]: https://i.loli.net/2018/07/18/5b4e285a1e49a.png
  [10]: https://i.loli.net/2018/07/18/5b4e282eb1a37.png
  [11]: https://i.loli.net/2018/07/18/5b4e282eb0364.png
  [12]: https://i.loli.net/2018/07/18/5b4e27ee2db98.png
  [13]: https://i.loli.net/2018/07/18/5b4e27ee2ef9b.png
  [14]: https://i.loli.net/2018/07/18/5b4e27b2ddbf5.png
  [15]: https://i.loli.net/2018/07/18/5b4e27b2dc4dc.png
  [16]: https://i.loli.net/2018/07/18/5b4e278edf33f.png
  [17]: https://i.loli.net/2018/07/18/5b4e278ee09a7.png
  [18]: https://i.loli.net/2018/07/18/5b4e275fd1616.png
  [19]: https://i.loli.net/2018/07/18/5b4e275fe0db6.png
  [20]: https://i.loli.net/2018/07/18/5b4e265f75829.png
  [21]: https://i.loli.net/2018/07/18/5b4e265f740c0.png
  [22]: https://i.loli.net/2018/07/18/5b4e265f771a6.png
  [23]: https://i.loli.net/2018/07/18/5b4e25f9b84e5.png
  [24]: https://i.loli.net/2018/07/18/5b4e25f9b6ab6.png
  [25]: https://i.loli.net/2018/07/18/5b4e25f9b9a48.png
  [26]: https://i.loli.net/2018/07/18/5b4e25cd0851c.png
  [27]: https://i.loli.net/2018/07/18/5b4e25cd0a550.png
  [28]: https://i.loli.net/2018/07/18/5b4e25cd12c74.png
  [29]: https://i.loli.net/2018/07/18/5b4e259b9357c.png
  [30]: https://i.loli.net/2018/07/18/5b4e259b94c7b.png
  [31]: https://i.loli.net/2018/07/18/5b4e2575185b9.png
  [32]: https://i.loli.net/2018/07/18/5b4e257519a58.png
  [33]: https://i.loli.net/2018/07/18/5b4e25286e894.png
  [34]: https://i.loli.net/2018/07/18/5b4e25287efa5.png
  [35]: https://i.loli.net/2018/07/18/5b4e25287efa5.png"	2018-07-17 18:25:57
kumika	二叉搜索树	"# 二叉搜索树

什么是二叉搜索树

---

查找问题: 
1 静态查找与动态查找 
2 针对动态查找，数据如何组织

> 二叉搜索树（BST，Binary Search Tree）， 也称二叉排序树或二叉查找树



二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：

> 1. 非空左子树的所有键值小于其根结点的键值。 
> 2. 非空右子树的所有键值大于其根结点的键值。 
> 3. 左、右子树都是二叉搜索树

个人理解： 就是 

> **左子树 < 根结点 < 右子树**

 ，而且所有左右子树也都是这样的规则

![搜索1.1][1]

![搜索1.2][2]

二叉搜索树的查找操作：Find
---------------

查找从根结点开始，如果树为空，返回NULL



若搜索树非空，则根结点关键字和X进行比较，并进行不同处理：

> 1 若X小于根结点键值，只需在左子树中继续搜索；  
2 如果X大于根结点的键值，在右子树中进行继续搜索；  
3若两者比较结果是相等，搜索完成，返回指向此结点的指针。


![搜索1.3][3]


二叉搜索树的查找操作Find 
伪代码：

    Position Find( ElementType X, BinTree BST ) 
    { 
    if( !BST ) return NULL; /*查找失败*/ 
    if( X > BST->Data )  
        return Find( X, BST->Right ); /*在右子树中继续查找 这句属于尾递归*/
    Else if( X < BST->Data )  
        return Find( X, BST->Left ); /*在左子树中继续查找 这句也属于尾递归*/
    
    else /* X == BST->Data */ 
        return BST; /*查找成功，返回结点的找到结点的地址*/

**尾递归====》最后尾巴的递归 -0-**

由于非递归函数的执行效率高，可将“尾递归”函数改为迭代函数
伪代码：

    Position IterFind( ElementType X, BinTree BST ) {     
    while( BST ) {       
      if( X > BST->Data )       
    BST = BST->Right; /*向右子树中移动，继续查找*/         
    else if( X < BST->Data )       
    BST = BST->Left;  /*向左子树中移动，继续查找*/         
    else /* X == BST->Data */             
    return BST; /*查找成功，返回结点的找到结点的地址*/     
    }     
    return NULL; /*查找失败*/ 
    }


**查找的效率决定于树的高度**

java代码：

    public Node Find2(int ele, Node root) {
        while (root != null) {
            if (ele > root.value) {
                root = root.rightNode;
            }
            else if (ele < root.value){
                root = root.leftNode;
            }
            else {
                return root; //ele == root.value的情况
            }
        }
        System.out.println("查询结果为空，请重新输入");
        return null;
    }

调用：

    Node s = tree.Find2(122, tree.root);
    System.out.println("输出结点++++++  value= "+s.value+ " key = "+s.key);


另外的写法：

    public Node find(int key) {
        Node currentNode = root;
        while (currentNode != null && currentNode.key != key) {
            if (key < currentNode.key)
                currentNode = currentNode.leftNode;
            else
                currentNode = currentNode.rightNode;
        }
        return currentNode;
    }

调用

    System.out.println("写法随便 "+tree.find(222).value);

结果：

> 写法随便 222



例子：查找最大和最小元素
------------

**最大元素**一定是在树的**最右分枝的端结点**上
**最小元素**一定是在树的**最左分枝的端结点**上


![搜索1.4][4]



查找**最小**元素的**递归**函数

伪代码：

    Position FindMin( BinTree BST ) {     
    if( !BST ) return NULL; /*空的二叉搜索树，返回NULL*/ 
        else if( !BST->Left ) 
              return BST;  /*找到最左叶结点并返回*/     
    else         
    return FindMin( BST->Left ); /*沿左分支继续查找*/
    }

java代码：

    public Node findMin(Node root) {
        if (null == root) {/*空的二叉搜索树，返回NULL*/
            return null;
        } else if (null == root.leftNode) {/*找到最左叶结点并返回*/
            return root;
        } else {
            return findMin(root.leftNode);/*沿左分支继续查找*/
        }
    }

调用：

    System.out.println("查找最小的node");
    Node s2 = tree.findMin(tree.root);
    System.out.println("输出结点++++++  value= "+s2.value+ " key = "+s2.key);


查找**最大**元素的**迭代**函数
伪代码：

    Position FindMax( BinTree BST ) {     
    if(BST )           
    while( BST->Right )  
    BST = BST->Right; /*沿右分支继续查找，直到最右叶结点*/ 
         return BST; 
    }

调用：

    System.out.println("查找最大的node");
    Node s3 = tree.findMax(tree.root);
    System.out.println("输出结点++++++  value= "+s3.value+ " key = "+s3.key);



# 二叉搜索树的简单插入
----------

〖分析〗关键是要找到元素应该插入的**位置**，可以采用与**Find类似的方法**

![搜索1.5][5]

![搜索1.6][6]


二叉搜索树的插入算法
----------

伪代码：

    BinTree Insert( ElementType X, BinTree BST ) {     
    if( !BST ){              /*若原树为空，生成并返回一个结点的二叉搜索树*/         
    BST = malloc(sizeof(struct TreeNode));         
    BST->Data = X;         
    BST->Left = BST->Right = NULL;     
    }else  /*开始找要插入元素的位置*/         
    if( X < BST->Data )             
    BST->Left = Insert( X, BST->Left);  /*递归插入左子树*/         
    else  if( X > BST->Data )             
    BST->Right = Insert( X, BST->Right); /*递归插入右子树*/         
    /* else X已经存在，什么都不做 */     
    return BST;
    }


重点理解： 

> 当递归到最后一个结点时候，递归调用函数Insert2(ele, node.rightNode)，此时node的右子树是空的结点，也就是说
> （用YY代替node.rightNode） 在递归最内（最底层）一次调用的参数是ele 和 YY ，此时YY 是空的，

当时我理解的node是最外层的（装根结点的node），实际上不是，其实Node会随着递归调用用的是树上的node。在递归最内层结束后，返回到倒数第2层时候，指针已经连接了（为什么，怎么连接的，不知道）
 **最内层的递归过程**，调用函数，参数是ele，结点YY， 因为此时YY是空的，**所以生成一个结点的搜索树（其实也是叶结点，换个说法而已），随后执行return node返回到上一层递归**
，此时就把新的数据插入到树上了（怎么连接的，指针怎么更新的不知道）


java代码：

    public Node insert2(int ele, Node node) {
        if (null == node) { /*若原树为空，生成并返回一个结点的二叉搜索树*/
            node = new Node(ele);
            node.leftNode = node.rightNode = null;
        } else { /*开始找要插入元素的位置*/
            if (ele < node.key) { /*递归插入左子树*/
                node.leftNode = insert2(ele, node.leftNode);
            } else if (ele > node.key) { /*递归插入右子树*/
                node.rightNode = insert2(ele, node.rightNode);
            } /* else ele已经存在，什么都不做 */
        }
        return node;
    }

调用：

    System.out.println("插入数据后遍历结果");
    tree.insert2(23, tree.root);
    tree.inOrder(tree.root);

结果：
![搜索1.7][7]



# 例子
以一年十二个月的英文缩写为键值，按从一月到十二月顺序输 入，即输入序列为**（Jan, Feb, Mar, Apr, May, Jun, July, Aug, Sep, Oct, Nov, Dec）**

现在这个阶段我还不能解决，不知道用什么算法，这里恐怕是显示有这个搜索功能，才用这个题目吧


![搜索1.8][8]

二叉搜索树的删除
--------

考虑三种情况：
-------

情况1：
----

要删除的是叶结点：直接删除，并再修改其父结点指针---置为NULL

〖例〗：删除 35

![搜索1.9][9]


情况2：
----

要删除的结点**只有一个孩子**结点: 
将**其父结点**的指针**指向**要**删除结点的孩子结点**
〖例〗：删除 33

![搜索1.10][10]

![搜索1.11][11]

情况3：
----

要删除的结点**有左、右两棵子树**： 
用另一结点替代被删除结点：

> 右子树的最小元素

 或者

>  左子树的最大元素


〖例〗：删除 41

![搜索1.13][12]

![搜索1.12][13]


> 就是41结点作为**被删除结点**，拿被删除结点41的**右子树**的**最小元素 50**代替41结点

![搜索1.15][14]

![搜索1.14][15]




> 就是41结点作为**被删除结点**，拿被删除结点41的**左子树**的**最大元素 35**代替41结点



使用最小元素代替方法的伪代码：

    BinTree Delete( ElementType X, BinTree BST )  {   
    Position Tmp;      
    if( !BST ) printf("要删除的元素未找到");      
    else if( X < BST->Data )              
    BST->Left = Delete( X, BST->Left); /* 左子树递归删除 */     
    else if( X > BST->Data )              
    BST->Right = Delete( X, BST->Right); /* 右子树递归删除 */     
    else /*找到要删除的结点 */           
    if( BST->Left && BST->Right ) { 
    /*被删除结点有左右两个子结点 */               
    Tmp = FindMin( BST->Right );                             
    /*在右子树中找最小的元素填充删除结点*/              
    BST->Data = Tmp->Data;
    BST->Right = Delete( BST->Data, BST->Right);                                     
           /*在删除结点的右子树中删除最小元素*/   
    } else { /*被删除结点有一个或无子结点*/              
    Tmp = BST;               
    if( !BST->Left ) /* 有右孩子或无子结点*/                   
    BST = BST->Right;               
    else if( !BST->Right ) /*有左孩子或无子结点*/                   
    BST = BST->Left;              
    free( Tmp );          
    }     
    return BST; 
    }


套用上面的伪代码，写出来的，递归删除
删除的过程： 
		具体的来说就是类似链表上的删除，
		1是叶结点删除，
		2是被删除结点有一个或无子结点， 
		3是被删除结点有左右2个子结点

1 对结点上数据的清除----设置为null，这是最简单的情况
2 就是对结点上的指针进行更改，然后对结点上数据清除（在1上增加）
**使用了递归，直接结点的赋值就可以进行指针的更改和原数据的清除**

3 使用临时变量，把**覆盖结点对删除结点的内容进行覆盖**，然后**删除覆盖结点**，完成删除

删除方法里面要包含3种情况：
java代码：

    public Node delete2(int ele, Node deletenode) {
        Node temp;
        if (null == deletenode) {
            System.out.println("要删除的元素未找到");
        } else if (ele < deletenode.key) {/* 左子树递归删除 */
            deletenode.leftNode = delete2(ele,deletenode.leftNode);
        } else if (ele > deletenode.key) {/* 右子树递归删除 */
            deletenode.rightNode = delete2(ele, deletenode.rightNode);
        } else {/*找到要删除的结点 */
    
            /*被删除结点有左右两个子结点  ==这里只是用了最小元素，最大元素的那个情况没有使用，findMax（） */
            if (null != deletenode.leftNode && null != deletenode.rightNode) {
                temp = findMin(deletenode.rightNode);/*在右子树中找最小的元素填充删除结点*/
    		//右子树上最小元素对删除结点进行更新替代
                deletenode.value = temp.value;
                 /*在删除结点的右子树中删除最小元素---就是因为已经完成替代操作了，要删除原来位置上的那个最小元素的那个结点，因为这里是递归，所以也包含着指针的更改，所以树的结点位置也会调整*/
                deletenode.rightNode = delete2(deletenode.value, deletenode.rightNode);
    
            } else { /*被删除结点有一个或无子结点*/
                temp = deletenode;
                if (deletenode.leftNode == null) {/* 有右孩子或无子结点*/
                    deletenode = deletenode.rightNode;
                } else if (deletenode.rightNode == null) {
                    deletenode = deletenode.leftNode;
                }
            }
            free(temp);
        }
        return deletenode;
    }
    private void free(Node temp) {
        if (temp == null) {
            return;
        }
        if (temp.rightNode != null) {
            free(temp.rightNode);
        }
        if (temp.leftNode != null) {
            free(temp.leftNode);
        }
        temp = null;
    }


调用：

    System.out.println("删除节点222之后遍历结果");
    tree.delete2(222, tree.root);
    tree.inOrder(tree.root);

结果：

![搜索1.16][16]



另外的写法，这里是使用迭代进行删除的
------------------
java代码：

        public boolean delete(int key) {
            Node currentNode = root;//用来保存待删除节点
            Node parentNode = root;//用来保存待删除节点的父亲节点
            boolean isLeftNode = true;//用来确定待删除节点是父亲节点的左孩子还是右孩子
    
            while (currentNode != null && currentNode.key != key) {
                parentNode = currentNode;
                if (key < currentNode.key) {
                    currentNode = currentNode.leftNode;
                    isLeftNode = true;
                } else {
                    currentNode = currentNode.rightNode;
                    isLeftNode = false;
                }
            }
    
            if (currentNode == null) {
                return false;
            }
            //要删除的节点为叶子节点
            if (currentNode.leftNode == null && currentNode.rightNode == null) {
                if (currentNode == root) {
                    root = null;
                } else if (isLeftNode) {
                    parentNode.leftNode = null;
                }else parentNode.rightNode = null;
            }
            //待删除节点只有一个孩子节点
            //也就是删除只有左叶结点，或者删除只有右叶结点
            else if (currentNode.rightNode == null) {//要删除的节点只有左孩子
                if (currentNode == root) {
                    root = currentNode.leftNode;
                } else if (isLeftNode) {
                    parentNode.leftNode = currentNode.leftNode;
                }else
                    parentNode.rightNode = currentNode.leftNode;
            } else if (currentNode.leftNode == null) {//要删除的节点只有右孩子
                if (currentNode == root) {
                    root = currentNode.rightNode;
                } else if (isLeftNode) {
                    parentNode.leftNode = currentNode.rightNode;
                } else
                    parentNode.rightNode = currentNode.rightNode;
            }
    
    //要删除的节点既有左孩子又有右孩子
    //思路：用待删除节点右子树中的key值最小节点的值来替代要删除的节点的值,然后删除右子树中key值最小的节点
    //右子树key最小的节点一定不含左子树,所以删除这个key最小的节点一定是属于叶子节点或者只有右子树的节点
            else {
                Node derectPostNode = getDirectPostNode(currentNode);
                currentNode.key = derectPostNode.key;
                currentNode.value = derectPostNode.value;
            }
            return true;
        }
    private Node getDirectPostNode(Node delNode) {//方法作用为得到待删除节点的直接后继节点
        Node parentNode = delNode;//用来保存待删除节点的直接后继节点的父亲节点
        Node directPostNode = delNode;//用来保存待删除节点的直接后继节点
        Node currentNode = delNode.rightNode;
    
        while (currentNode != null) {
            parentNode = directPostNode;
            directPostNode = currentNode;
            currentNode = currentNode.leftNode;
        }
        if (directPostNode != delNode.rightNode) {//从树中删除此直接后继节点
            parentNode.leftNode = directPostNode.rightNode;
            directPostNode.rightNode = null;
        }
        return directPostNode;//返回此直接后继节点
    }

调用：

    System.out.println("删除节点10之后遍历结果");
    tree.delete(10);
    tree.inOrder(tree.root);

结果：

![搜索1.17][17]



#参考：
 https://www.cnblogs.com/Michaelwjw/p/6384428.html
	有图容易插入和删除理解 https://www.cnblogs.com/MrListening/p/5782752.html



多个算法稳定性的解释：https://www.oschina.net/question/565065_86352


  [1]: https://i.loli.net/2018/07/18/5b4e384313629.png
  [2]: https://i.loli.net/2018/07/18/5b4e38313de4e.png
  [3]: https://i.loli.net/2018/07/18/5b4e382191262.png
  [4]: https://i.loli.net/2018/07/18/5b4e3806c6b96.png
  [5]: https://i.loli.net/2018/07/18/5b4e37f0d6848.png
  [6]: https://i.loli.net/2018/07/18/5b4e37e08bf5f.png
  [7]: https://i.loli.net/2018/07/18/5b4e37c3dd586.png
  [8]: https://i.loli.net/2018/07/18/5b4e37ae34fd4.png
  [9]: https://i.loli.net/2018/07/18/5b4e379694e94.png
  [10]: https://i.loli.net/2018/07/18/5b4e3781d3aef.png
  [11]: https://i.loli.net/2018/07/18/5b4e36309e732.png
  [12]: https://i.loli.net/2018/07/18/5b4e356218842.png
  [13]: https://i.loli.net/2018/07/18/5b4e356592ffb.png
  [14]: https://i.loli.net/2018/07/18/5b4e35c625f60.png
  [15]: https://i.loli.net/2018/07/18/5b4e35c62b4cf.png
  [16]: https://i.loli.net/2018/07/18/5b4e326c684c4.png
  [17]: https://i.loli.net/2018/07/18/5b4e3256f3389.png"	2018-07-18 01:37:31
kumika	搭建工程的配置文件	"# 搭建工程的配置文件

1 创建项目
------

要是不明白配置问题，拿就直接百度XXXX配置说明，因为这是工具，Mybatis Generator 是工具，eg：Mybatis Generator 最完整配置详解

所有配置问题，都是工具的问题，不是算法，逻辑问题

逆向工程就是自动生成3类文件 dao (mapper)类， mapper.xml文件，po类（就是实体类）
---

目的： 捋顺哪个首先开始搭建的思路，从哪个文件开始，比如从spring到myBtais,最后配置springMvc


2 开始搭建Mybaits的逆向工程的配置文件： generatorConfig.xml
-------------

简单点说，就是通过数据库中的单表，自动生成java代码

出现问题：
-----

Exception in thread "main" java.io.FileNotFoundException: config\generatorConfig.xml (系统找不到指定的路径。)
 
 1  pom.xml里面的plugin标签里面的写的位置不对
 2  逆向工程生产文件Generator 里面读取的xml位置不对


引出 idea的路径和eclipse的路径 好像我一点都不了解，classpath是哪个文件开始的

idea的test是怎么调出来


最后发现其实是idea使用逆向工程的方式和eclipse是不一致的
-----------------------------------

idea 是需要org.mybatis-maven-plugin这个插件来完成逆向工程

eclipse是自带有mybatis-generator专用的插件

所以每次用Idea的逆向工程的时候都要配置一遍maven这个插件

idea配置org.mybatis-maven-plugin插件
--------------------------------




3 spring-mybatis配置文件
------------

3.1  加载连接数据库信息的文件: properties文件

    <!-- 第一种方式：加载一个properties文件 -->
    <bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="location" value="classpath:jdbc.properties"/>
    </bean>

     <!-- 第二种方式：加载多个properties文件
        <bean id="configProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
            <property name="locations">
                <list>
                    <value>classpath:jdbc.properties</value>
                    <value>classpath:common.properties</value>
                </list>
            </property>
            <property name="fileEncoding" value="UTF-8"/>
        </bean>
        <bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer">
            <property name="properties" ref="configProperties"/>
        </bean>
        -->



3.2  配置Properties文件里的数据库信息
 

        <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
              destroy-method="close">
            <property name="driverClassName" value="${driverClasss}"/>
            <property name="url" value="${jdbcUrl}"/>
            <property name="username" value="${username}"/>
            <property name="password" value="${password}"/>
    </bean>

3.3  配置spring和Mybatis的整合文件

    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
            <property name="dataSource" ref="dataSource"/>
            <!-- 自动扫描mapping.xml文件 -->
            <property name="mapperLocations" value="classpath:mapping/*.xml"></property>
        </bean>

3.4  配置Dao包，作用是使spring会自动查询包里面的类

    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="CMS.Dao"/>
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
    </bean>

3.5  配置事务管理，作用是与数据库信息交换的时候，确保4个原则，逻辑上一组操作，要么全都成功，要么全都失败。
默认情况下，

      <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
            <property name="dataSource" ref="dataSource"/>
        </bean>


    <tx:annotation-driven>会自动使用名称为transactionManager的事务管理器。
            所以，如果定义的事务管理器名称为transactionManager，那么就可以直接使用<tx:annotation-driven/>

事务的4个特性： 
    原子性， 事务要么全部提交成功，要么全部失败。
    隔离性， 事务提交的时候，不会影响另外一个事务提交。
    一致性， 事务提交数据到数据库的前后，数据状态都不会改变。
    持久性， 事务提交到数据库后，数据状态持久化。

###3.6 spring-mybaits在WEB.xml的配置


    
     <!-- spring配置文件位置 -->
      <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-mybatis.xml</param-value>
      </context-param>




4 springMVC配置文件
---------------
没有处境像类似的同龄人，有的话别人也不会注意到你。
对于比你高经济等级的同龄人是怎么样的态度：
       我不需要关注他，他也不会特别的关注我。肯定，加油鼓气之类的是不可能存在的，为什么？ 因为他们的世界里面是存在  等价交换  这铁律。
       甚至幻想在游戏里面肯定一下，也是不可能的。所以我为什么要贴冷屁股呢？
       同时也要告诫自己，不要和他们比较，追不上就追不上了，焦虑也是欲望的分类，认真做好自己就可以了。
那不得不面对交谈的情况：
       随便扯东扯西，不要发表自己的看法，装怂，在自己擅长的领域也要装怂。
记住一点：
       他们唯一肯定的一点，只要你能带给他经济利益，那就是朋友了，那就是可以相互肯定，可以进行相互精神扶持的同等阶级的人。
习惯，理解，最后成为孤独，这是唯一的道路。
在资本主义的社会里，控制好自己的欲望程度，资本永远都会使人嘲笑孙笑川，可是在资本控制下人人都是孙笑川。
Java的类，其实是和资本社会里面的产品分类是一致的，所以守护好本心。

###4.1 用户发送请求在springMVC中执行的过程：
---------------------------
一共有5个处理请求工具，有12步。
   1    前端控制器DispatcherServlet  

       ===》web.xml文件里面的
       <servlet>
            <serlvet-name>springMVC</serlvet-name>
            <servlet-class>DispatcherServlet</servlet-class>
       </servlet>

   2    XXXHandlerMapping处理器映射器 
  
  寻找执行类（controller），返回执行类地址，请求对controller位置的映射。

     ==》对 /hello.do 进行处理，寻找到注解名为 hello的@RequestMapping，在XXXController的方法上。完成寻找任务，返回请求结果到DispatcherServlet上。

   
   3    XXXHandlerAdapter处理器适配器
   
   对执行类进行调用，然后返回结果，请求对controller进行执行，称为适配过程（为什么称为适配）

       ===》从DisPatcherServlet上得到映射器返回的请求，然后接收请求，调用controller的方法，得到ModeAndView ，返回ModeAndView到DispatcherServlet上。

   
   4    ViewResolver 视图解析器
   
   分解modeAndView, 分解出mode 和view 

    ===》解析ModeAndView，分解出真正物理视图View，返回View
   
   5  View 视图

    ===》从DispatchServlet得到View ，然后对View进行渲染，返回jstl结果

最后DispatcherServlet返回结果到网页上，用户得到结果。

5个工具之间进行输入输出，共有10步了，然后再调用Controller方法的输入输出也算进去，最后用户的请求，响应结果，共加起来12步。

###4.2 SpringMVC在 web。xml的配置


    <!-- 前端控制器 -->
      <servlet>
        <servlet-name>SpringMVC</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
     <!--  加载springmvc配置 默认加载方式
  	   默认加载必须规范：
  	   文件命名：servlet-name-servlet.xml====springmvc-servlet.xml
  	   路径规范：必须在WEB-INF目录下-->
        <init-param>
          <param-name>contextConfigLocation</param-name>
          <param-value>classpath:spring-mvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
        <async-supported>true</async-supported>
      </servlet>
      
      
      <servlet-mapping>
      <!-- 可以配置/ ，此工程 所有请求全部由springmvc解析，此种方式可以实现 RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析 
			可以配置*.do或*.action，所有请求的url扩展名为.do或.action由springmvc解析，此种方法常用 不可以/*，如果配置/*，返回jsp也由springmvc解析，这是不对的。 -->
        <servlet-name>SpringMVC</servlet-name>
        <url-pattern>/</url-pattern>
      </servlet-mapping>

在web.xml中的无论是servlet还是filter配置完了，都要配置mapping ,大概就是mapping 的意思吧（匹配），contextConfigLocation也是都要的，这是固定名称




###4.3 SpringMVC配置中必须要的


1 包扫描：

    <context:component-scan base-package="com.cms"/>

2 处理器映射器

    <!-- 配置注解处理器映射器 功能：寻找执行类Controller --> 
    <!--只是随便一个例子，展示映射器 -->
    <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"></bean>


3 处理器适配器

    <!-- 配置注解处理器适配器 功能：调用controller方法，执行controller -->
    		 <!--只是随便一个例子，展示适配器 -->
    		<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"></bean>

或者这样的

    <bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter">
            <property name="messageConverters">
                <list>
                    <ref bean="mappingJacksonHttpMessageConverter"/>
                </list>
            </property>
        </bean>


4 视图解析器

    <!-- 配置sprigmvc视图解析器：解析逻辑试图 
    			 后台返回逻辑试图：index
    			视图解析器解析出真正物理视图：前缀+逻辑试图+后缀====/WEB-INF/jsps/index.jsp
    		-->
       <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
            <property name="prefix" value="/WEB-INF/jsp/" />
            <property name="suffix" value=".jsp"/>
        </bean>
         <!--文件上传解析器-->
         <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
            <property name="defaultEncoding" value="UTF-8"/>
            <property name="maxUploadSize" value="32505856"/>
            <property name="maxInMemorySize" value="4096"/>
        </bean>

四个配置完成springMVC的配置。当然，要注意注解的时候，springMVC的注解配置。



5 配置web.xml文件
-------------

    <!-- 1 配置spring文件位置 -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-mybatis.xml</param-value>
    </context-param>
    <!-- 2 配置spring容器监听器 -->
    <listener>
        <listener-class>ContextLoaderListener</listener-class>
    </listener>
    <!-- 配置spring文件位置 -->
      <context-param>
        <param-name>log4jConfigLocation</param-name>
        <param-value>classpath:log4j.properties</param-value>
      </context-param>
    
    <!-- 3 配置springMVC文件位置 -->
    <servlet>
       <servlet-name>springMVC</servlet-name>
       <servlet-class>DispatcherServlet</servlet-class>
       <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springMVC.xml</param-value>
       </init-param>
    </servlet>
    <!-- 4 spring解析所有请求 -->
    <servlet-mapping>
        <servlet-name>springMVC</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    <!-- 可以配置/ ，此工程 所有请求全部由springmvc解析，此种方式可以实现 RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析 
    			可以配置*.do或*.action，所有请求的url扩展名为.do或.action由springmvc解析，此种方法常用 不可以/*，如果配置/*，返回jsp也由springmvc解析，这是不对的。 -->
    
    <!-- 因为一般网页url访问不进web-Inf里面的文件，这样就可以之间打开项目就直接访问web-inf里面的文件了 -->
    <welcome-file-list>
        <welcome-file>/WEB-INF/jsp/login.jsp</welcome-file>
    </welcome-file-list>			
	
	<error-page>
	    <location>/WEB-INF/jsp/error.jsp</location>
    </error-page>


1---4的配置是必须的。



"	2018-07-20 19:44:04
kumika	项目开始了，坏起来了	# 项目开始了，坏起来了

标签（空格分隔）： 从Jsp注册登录开始

---

1 jsp 上的注册登录表格
----------


```
     <script type="application/x-javascript"> 
            addEventListener(
                "load", 
                function() { 
                            setTimeout(hideURLbar, 0); 
                           }, 
                false); 
            function hideURLbar(){ 
                window.scrollTo(0,1); 
            } 
    </script>
```

========================分隔符===========================
```
    <h2>登录</h2>
    <form action="#" method="post" id="loginform" onsubmit="return false">
        <input type="text" id="username" name="username" class="name" style="width: 477px;" placeholder="用户名" required="">
        
        <input type="password" id="password" name="password" class="password" style="width:477px;" placeholder="密码" required=""><br>
        
        <span id="msg"** style="color:#F00;font-size:14px;"></span>
        <a href="/regester">注册</a><br>
        <div class="clear"></div>
        <input type="button" id="submit" value="登录" onclick="login()">
    </form>
```


登录的script,注意学习的是onclick = "login()"，
action = ”#“ 是提交到本页的意思，要进入regeterController了
`<a href="/regester">注册</a>`


=========================分隔符=========================
```
    <script type="text/javascript">
            function login(that) {
                var username = $("#username").val();
                var password = $("#password").val();
                if(username == "" || password == ""){
                    $("#msg").text("请输入用户名或密码");
                    return false;
                }
                else{
                    $("#msg").text("");
                }
                document.getElementById("submit").value = "请稍后";
                document.getElementById("submit").style.background = "#00E909";
                $.ajax({
                    data: {
                        username:$("#username").val(),
                        password:$("#password").val()
                    },
                    type: "post",
                    url: "/checklogin",
                    dataType: "json",
                    error: function (data) {
                        alert("系统错误 请重试");
                    },
                    success: function (response) {
                        if (response == "error") {
                            $("#msg").text("用户名或密码错误");
                            document.getElementById("submit").value = "登录";
                            document.getElementById("submit").style.background = "#e91e63";
                        } else {
                            document.getElementById("msg").style.cssText = "color:#00FF06;font-size:14px;";
                            $("#msg").text("用户验证成功 请稍后");
                            window.location.href = "/login";
                        }
                    }
                });
            }
    </script>
```



2 到注册Controller
-------------
先注册，在登录

在controller中，就跳到注册页面嘛

```
    @RequestMapping("regester")
    public String regester(HttpSession session) {
        return "regester";
    }
```    

###2.1 在注册页面中，注意学习checksubmit（），action="/regestersubmit"，数据提交到regesterController的@requestMapping（”/regestersubmit“）方法中


```
    <form action="/regestersubmit" method="post" onsubmit="return checksubmit()">
                        <div class="form-group">
                            <label>学号(学号将是您的用户名)</label>&nbsp;&nbsp;<span id="existcheck" style="color:#F00;font-size:14px;text-align: center"></span>
                            <input id="username" onkeyup="existcheck()" name="username" class="form-control" type="text">
                        </div>
                        <div class="form-group">
                            <label>密码</label>
                            <input **id="password" name="password"** class="form-control" **type="password"**>
                        </div>
                        <div class="form-group">
                            <label>确认密码</label>
                            <input **id="passwordcheck" name="passwordcheck"** class="form-control" **type="password"**>
                        </div>
                        <div class="form-group">
                            <label>学生姓名</label>
                            <input **id="name" name="name"** class="form-control" **type="text"**>
                        </div>
                        <div class="form-group">
                            <label>性别</label>
                            **<select **id="sex" name="sex"** class="form-control">
                                <option value="男">男</option>
                                <option value="女">女</option>
                            </select>**
                        </div>
                        <div class="form-group">
                            <label>联系电话</label>&nbsp;&nbsp;&nbsp;<select name="isphonesecret"><option value="1">保密</option><option value="0">公开</option></select>
                            <input **id="phone" name="phone"** class="form-control" type="text">
                        </div>
                        <div class="form-group">
                            <label>E-Mail</label>&nbsp;&nbsp;&nbsp;<select name="ismailsecret"><option value="1">保密</option><option value="0">公开</option></select>
                            <input **id="email" name="email"** class="form-control" type="text">
                        </div>
                        <div class="form-group">
                            <label>所在学院</label>
                            <input **id="collage" name="collage"** class="form-control" type="text">
                        </div>
                        <div class="form-group">
                            <label>就读专业</label>
                            <input **id="major" name="major"** class="form-control" type="text">
                        </div>
                        <div class="form-group">
                            <label>所在年级</label>
                            **<select id="grade" name="grade" class="form-control">
                                <option value="2018">2018</option>
                                <option value="2017">2017</option>
                                <option value="2016">2016</option>
                                <option value="2015">2015</option>
                                <option value="2014">2014</option>
                                <option value="2013">2013</option>
                                <option value="2012">2012</option>
                                <option value="2011">2011</option>
                                <option value="2010">2010</option>
                            </select>**
                        </div>
                        <div class="form-group">
                            <label>班级</label>
                            <select **id="classno" name="classno"** class="form-control">
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <span id="msg" style="color:#F00;font-size:14px;text-align: center"></span>
                        <center>**<button type="submit" class="btn btn-info">提交注册</button>**</center>
                    </form>
```


上面的代码提交了属性数据给controller
学号

      <input id="username" onkeyup="existcheck()" name="username" class="form-control" type="text">

密码
 

    <input id="password" name="password" class="form-control" type="password">

确认密码

     <input id="passwordcheck" name="passwordcheck" class="form-control" type="password">

学生姓名

    <input id="name" name="name" class="form-control" type="text">

性别
 

    <select id="sex" name="sex" class="form-control">
            <option value="男">男</option>
            <option value="女">女</option>
    </select>

联系电话

    <select name="isphonesecret">
        <option value="1">保密</option>
        <option value="0">公开</option>
    </select>
                               
     <input id="phone" name="phone" class="form-control" type="text">

E-mail

    <select name="ismailsecret">
        <option value="1">保密</option>
        <option value="0">公开</option>
    </select>
                                
    <input id="email" name="email" class="form-control" type="text">

所在学院

    <input id="collage" name="collage" class="form-control" type="text">

就读专业

    <input id="major" name="major" class="form-control" type="text">

所在年级

     <select id="grade" name="grade" class="form-control">
                                    <option value="2018">2018</option>
                                    <option value="2017">2017</option>
                                    <option value="2016">2016</option>
                                    <option value="2015">2015</option>
                                    <option value="2014">2014</option>
                                    <option value="2013">2013</option>
                                    <option value="2012">2012</option>
                                    <option value="2011">2011</option>
                                    <option value="2010">2010</option>
    </select>

班级

     <select id="classno" name="classno" class="form-control">
                                    <option value="1">1</option>
                                    <option value="2">2</option>
                                    <option value="3">3</option>
                                    <option value="4">4</option>
    </select>

提交

    <button type="submit" class="btn btn-info">提交注册</button>

===========================分隔符============================


```
    <script type="text/javascript">
        var isexist;
        
        function checksubmit() {
            var emailcheck = new RegExp("^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$", "").test($("#email").val());
            var passwordcheck = new RegExp("^[a-zA-z][a-zA-Z0-9]{5,16}$", "").test($("#password").val());
            var phonecheck = new RegExp("0?(13|14|15|18)[0-9]{9}", "").test($("#phone").val());
            var namecheck = new RegExp("[\u4e00-\u9fa5]", "").test($("#name").val());
            
            if($("#username").val() == "" || $("#passwordcheck").val() == "" || $("#password").val() == "" || $("#name").val() == ""
                || $("#collage").val() == "" || $("#major").val() == "" || $("#email").val() == "" || $("#phone").val() == ""){
                $("#msg").text("请填写完整信息");
                return false;
            }
            else if($("#password").val() != $("#passwordcheck").val()){
                $("#msg").text("两次输入密码不一致，请确认后输入");
                return false;
            }
            else if(isexist == true){
                $("#msg").text("此学号已注册 请确认后重试");
                return false;
            }
            else if(!passwordcheck){
                $("#msg").text("请输入6-16位由英文字母、数字和下划线组成的密码");
                return false;
            }
            else if(!emailcheck){
                $("#msg").text("请输入正确的邮箱");
                return false;
            }
            else if(!phonecheck){
                $("#msg").text("请输入正确的国内手机号");
                return false;
            }
            else if(!namecheck){
                $("#msg").text("请输入正确的姓名");
                return false;
            }
            else{
                $("#msg").text("");
                alert("注册成功 进入登录页面");
                return true;
            }
            
        }
    
    
        function existcheck() {
            $.ajax({
                data:{
                    username:$("#username").val()
                },
                type:"post",
                dataType:"json",
                url:"/checkusername",
                error: function (data) {
                    $("#msg").text("系统错误,请重试");
                    $(that).removeClass("processing");
                },
                success: function (response) {
                    if(response == "exist"){
                        isexist = true;
                        $("#existcheck").text("此学号已存在, 请确认");
                    }
                    else{
                        isexist = false;
                        $("#existcheck").text("");
                    }
                }
            });
        }
    </script>
```



###2.2 在controller中
```
     @RequestMapping("regestersubmit")
        public String regestersubmit(HttpSession session,
                                     @RequestParam("username") String username,
                                     @RequestParam("password") String password,
                                     @RequestParam("passwordcheck") String passwordcheck,
                                     @RequestParam("name") String name,
                                     @RequestParam("sex") String sex,
                                     @RequestParam("phone") String phone,
                                     @RequestParam("email")String email ,
                                     @RequestParam("collage") String collage,
                                     @RequestParam("major") String major,
                                     @RequestParam("grade") int grade,
                                     @RequestParam("classno") int classno,
                                     @RequestParam("isphonesecret") int isphonesecret,
                                     @RequestParam("ismailsecret") int ismailsecret
                                     ) {
            User user = new User();
            user.setUsername(username);
            user.setPassword(password);
            user.setClassno(classno);
            user.setCollage(collage);
            user.setEmail(email);
            user.setPhone(phone);
            user.setSex(sex);
            user.setMajor(major);
            user.setGrade(grade);
            user.setName(name);
            user.setIsmailsecret(ismailsecret);
            user.setIsphonesecret(isphonesecret);
            
            
            userService.Regester(user);
            courseService.regester(user.getUsername());
            return "/login";
        }
```

###2.3 跳转到XXXService上


```
    Logger log = Logger.getLogger(this.getClass());
    @Autowired
    private UserDao userDao;
    public void Regester(User user) {
        log.info("注册账号");
        userDao.Regester(user);
    }
```

###2.4 跳转到XXXDao接口，然后XXXMapping.xml上

XXXDao接口：
```
    @Repository
    public interface UserDao {
        /*自己开始写的*/
        /*登录方法*/
        void Regester(User user);
    }
```

###插入数据库数据XXXMapping.xml： 

因为是注册，所以要用插入（没有add）insert,用户id 每个课程都插入一次

```
    <select id="regester" parameterType="String">
        INSERT INTO coursetable(studentid,classNo,) VALUES (#{studentid},1);
        INSERT INTO coursetable(studentid,classNo,) VALUES (#{studentid},2);
        INSERT INTO coursetable(studentid,classNo,) VALUES (#{studentid},3);
        INSERT INTO coursetable(studentid,classNo,) VALUES (#{studentid},4);
        INSERT INTO coursetable(studentid,classNo,) VALUES (#{studentid},5);
      </select>
```



###2.5 正则表达式
因为注册需要验证，所以用到来正则表达式。
  个人理解： 在前端里对数字，符号，字母进行匹配验证的算法
基本的例子：

> 整个完整的表达式：/^[A-Za-z_][A-Za-z0-9_]{5,15}$/

> /^$/ : 完整表达式
> ^ : 表示以什么开始，或者取反
> $ :结束

> ^[A-Za-z_] : 以字母开始，无论大小都可以；
> [^A-Za-z_] :非字母就可以；

> [A-Za-z0-9_] ：可以是字母数、字下、划线
 
> {5,15} ：可以包含6到16个字符


[a-zA-Z0-9]
a-z匹配小写字母
A-Z匹配大写字母
0-9匹配数字
更多的定义：

> http://www.runoob.com/regexp/regexp-syntax.html



/*
        邮箱的一般格式为：名称@域名。
        这里需要匹配的邮箱中名称可以包含汉字、字母、数字，域名只允许为英文和数字：例如：张三zs333@domain.com
        字母和数字表示为

> A-Za-z0-9

汉字在正则中表示为
```
 [\u4e00-\u9fa5]

   \u4e00   \u9fa5  这两个unicode值正好是Unicode表中的所有汉字的头和尾。
[A-Za-z0-9\u4e00-\u9fa5] ===》大小写字母，0--9 数字和至少匹配一个汉字的写法
          [A-Za-z0-9\u4e00-\u9fa5]+ ===》这是邮箱名称部分的正则表达式  还有后面的+ 就是java一般情况下连接的+号的意思
```          
**最终邮箱名称部分表达式：**
```
[A-Za-z0-9\u4e00-\u9fa5]
```
**邮箱域名部分了**
        
一般域名的规律为“[N级域名][三级域名.]二级域名.顶级域名”，
        比如“qq.com”、“www.qq.com”、“mp.weixin.qq.com”、“12-34.com.cn”，
        分析可得域名类似“xx .xx .xx .xx”组成
        所以@可以看作直接和用户输入的@相匹配的字符，
        重点看@后面的文本是否一致
        xx .xx .xx .xx
        从域名拆分开看，可以看作xx 和3个 .xx部分组成

    使用.字符，用\.表示

        xx部分 ===》表示为          [a-zA-Z0-9_-]+
        .xx部分 ===》表示为       \.[a-zA-Z0-9_-]+
        多个.xx部分 ===》表示为  (\.[a-zA-Z0-9_-]+)+

**所以最终邮箱域名是下面的表达式：**
```
 @[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+
```
那完整的：
```
 ^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$
```
*/
使用上面表达式来验证邮箱：
```
var emailcheck = new RegExp("^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$", "").test($("#email").val());
```
**表示6~17位以字母开头的，字母,数字组成的密码**
```
var passwordcheck = new RegExp("^[a-zA-Z][a-zA-Z0-9_]{5,16}$", "").test($("#password").val());
```
    
    
/*
    手机验证

      

> [0-9]{9}：任意 9位数字，[0-9] 可以用d表示，d{9} == [0-9]{9}
> 
>？ ：等价于 {0，1}
>0？ ：等价于 0{0，1}，
eg:  0{0，1}将匹配 200000中的 第1个0或者没有匹配到0，
又比如  "e{1,3}" 将匹配 "feeeeeeed" 中的前三个 e
> 
> 0?(13|14|15|18) : 将匹配1次或者不需要匹配到手机号13，14，15，18开头的

所以我理解为随便写手机号（位数也不要求）：

>0?(13|14|15|18)[0-9]{9}

*/
```
var phonecheck = new RegExp("0?(13|14|15|18)[0-9]{9}", "").test($("#phone").val());
```
**所有汉字**
```
var namecheck = new RegExp("[\u4e00-\u9fa5]", "").test($("#name").val());
```



3 login登录功能
-----------

jsp上登录提交按钮：

```
<input type="button" id="submit" value="登录" onclick="login()">
```

注意onclick="login()",这个是js的函数，先进行验证，然后再登录。
```
    <script type="text/javascript">
            function login(that) {
                var username = $("#username").val();
                var password = $("#password").val();
                **if(username == "" || password == "")**{
                    $("#msg").text("请输入用户名或密码");
                    return false;
                }
                else{
                    $("#msg").text("");
                }
                document.getElementById("submit").value = "请稍后";
                document.getElementById("submit").style.background = "#00E909";
                
                $.ajax({
                    data: {
                        username:$("#username").val(),
                        password:$("#password").val()
                    },
                    type: "post",
                    **url: "/checklogin",**
                    dataType: "json",
                    /*
                error： ajax属性（参数）里的 Function/Array类型
                指定请求失败时执行的回调函数。
                    该函数有3个参数：
                    jqXHR对象、
                    请求状态字符串(null、 'timeout'、 'error'、 'abort'和'parsererror')、
                    错误信息字符串(响应状态的文本描述部分，例如'Not Found'或'Internal Server Error')。
                    这是一个Ajax事件。跨域脚本和跨域JSONP请求不会调用该函数。
                  */
                    error: function (data) {
                        alert("系统错误 请重试");
                    },
                    /*
                success ajax属性（参数）里的 Function/Array类型
                指定请求成功后执行的回调函数。该函数有3个参数：请求返回的数据、响应状态字符串、jqXHR对象
                */
                    success: function (response) {
                        if (response == "error") {
                            $("#msg").text("用户名或密码错误");
                            document.getElementById("submit").value = "登录";
                            document.getElementById("submit").style.background = "#e91e63";
                        } else {
                            document.getElementById("msg").style.cssText = "color:#00FF06;font-size:14px;";
                            $("#msg").text("用户验证成功 请稍后");
                            window.location.href = "/login";
                        }
                    }
                });
            }
    </script>
```

这里注意学习ajax异步调用，怎么异步调用的？
ajax是一个方法，AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。
简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。

**要是拆开分析，有2次判断，一次是对提示语句判断，一次是登录判断，用的是ajax方法**
对提示语句的判断：
1 判断是否输入为空，要是空，出现提示语句
```
    if(username == "" || password == "")
```
2 输入都不为空，清空提示语句
```
        else{
            $("#msg").text("");//清空msg的文本内容，msg就是一般出现的提示语句
       }
```
ajax方法：

这里更多的是套用方法里面的属性，用了6个ajax的属性

data
type
url
dataType
error
success
```
     data: {
            username:$("#username").val(),
            password:$("#password").val()
           },
    type: "post",
    url: "/checklogin",
    dataType: "json",
    error: function (data) {} //data是临时变量，名字而已
    success: function (response) {}//response是临时变量，名字而已
```



LoginController上：

```
User user = userService.login(username, password);
```

UserService上：

```
    public User login(String username, String password) {
        log.info("用户登录");
        return userDao.login(username, password);
    }
```

UserDao:

```
    User login(String username, String password);
```

###查询数据库UserMapping：

根据用户名和密码，查询用户信息，选择字段是 * ，表格是user ,条件是 用户名 ，密码
```
  <select id="login" parameterType="string" resultType="CMS.Entity.User">
    SELECT * from user where username=#{username} AND password=#{password}
  </select>
```





	2018-08-11 17:56:20
kumika	在此处输入标题	# 在此处输入标题

标签（空格分隔）： 未分类

---

在此输入正文




	2018-08-15 09:31:35
kumika	坏起来了，项目功能2，承接项目功能1	"# 坏起来了，项目功能2，承接项目功能1

在loginController中：需要几个Service，爬虫Informdigger，考试examschedules,主页homememo,课程表course

---

1 爬虫InformDigger
----------------
爬虫Jsoup简单介绍 ：
Jsoup 是一个 Java 的开源HTML解析器，可直接解析某个URL地址、HTML文本内容，Jsoup官网jar包下载地址https://jsoup.org/download。

Jsoup主要有以下功能： 
1. 从一个URL，文件或字符串中解析HTML 
2. 使用DOM或CSS选择器来查找、取出数据 
3. 对HTML元素、属性、文本进行操作 
4. 清除不受信任的HTML (来防止XSS攻击)

###爬虫的思路

 1. 得到自己想要爬取数据的url. 
 2. 通过Jsoup的jar包中的方法将Html解析成Document，
 3. 使用Document中的一些列get、first、children等方法获取自己想要的数据，如图片地址、名称、时间。
 4. 将得到的数据封装成自己的实体类。 
 5. 将实体中的数据在页面加载出来。

###爬虫小例子：
------

前端表单代码：
``` java
<table>  
    <tr> 
        <td>user</td>
        <td>cc</td>  
    </tr>  
    <tr> 
        <td>pass</td>
        <td>123</td> 
    </tr> 
</table>
```



后台代码：

``` java
public class Test {
    public static void main(String[] args) {
         String str = "<table><tr><td>user</td><td>cc</td></tr><tr><td>pass</td><td>123</td></tr></table>";
 
        Document doc = Jsoup.parse(str);
        Elements trs = doc.select("table").select("tr");
        for(int i = 0;i<trs.size();i++){
            Elements tds = trs.get(i).select("td");
            for(int j = 0;j<tds.size();j++){
                String text = tds.get(j).text();
                System.out.println(text);
            }
        }
    }
}
```

具体实际：
InformDigger后台代码：
``` java
List<Inform> informs = new ArrayList<Inform>();
        /*
        * 爬虫的过程思路：
        *           1 输入（4个方法）
                            法1：解析一个html字符串
                            法2：解析一个body片断
                            法3：从一个URL加载一个Document对象
                            法4：根据一个文件加载Document对象
        *           2 数据抽取（抽取内容方法）
            *               法1：使用dom方法来遍历一个Document对象
                            法2：使用选择器语法来查找元素
                            法3：从元素集合抽取属性、文本和html内容
                            法4：URL处理
        *           3 数据修改
        *           4 HTML清理
        * */

        //得到自己想要爬的url，同时将从一个URL加载一个Document。
        //connect(String url) 方法创建一个新的 Connection, 和 get() 取得和解析一个HTML文件。
        // 如果从该URL获取HTML时发生错误，便会抛出 IOException，应适当处理。
        Document doc = Jsoup.connect("http://my.dlmu.edu.cn/student/oaxstz.h?pageNo=1").get();
        //使用选择器语法来查找元素 ， 拿到寻找与指定css选择器匹配的元素
        // 元素集合里面拿出带有"table"标签 的元素，拿出元素中拿出第5个table标签，再拿出"a"标签的内容
        Elements content = doc.select("table").get(4).select("a");

        for (int i=0;i<20;i++) {
            //System.out.println("http://my.dlmu.edu.cn" + content.get(i).attr("href") + " --- " + content.get(i).attr("title"));
            informs.add(this.getInform("http://my.dlmu.edu.cn" + content.get (i).attr("href")));
        }

        return informs;
    }
    
    
public Inform getInform(String url) throws IOException {
        Inform inform = new Inform();
        //Jsoup是爬虫

        Document doc = Jsoup.connect(url).get();


        Elements title = doc.getElementsByClass("ctitle1");
        Elements info = doc.getElementsByClass("ctitleinfo");
        Elements pbox = doc.getElementsByClass("pbox");

        inform.setTitle(title.text());
        inform.setInfo(info.text());
        inform.setPbox(pbox.text());

        return inform;
    }
```




2查询考试时间ExamScheduleService
--------------------------

简单说下流程，然后重点描述数据库的查询，增加，删除，更改操作

然后看welcome页面上的前端脚本

在LoginController中代码：
``` java
//根据用户id查询考试安排，用户Id就是用户登录名
List<Examschdule> examschdules = examschduleService.QueryExamscheduleById(user.getUsername());

session.setAttribute("examschdules", examschdules);
```

在examScheduleService中的代码：

```
    public List<Examschdule> QueryExamscheduleById(String studentid) {
        logger.info("获取考试安排");
        return examschduleDao.QueryExamscheduleById(studentid);
    }
```

在examScheduleDao上：

```
 List<Examschdule> QueryExamscheduleById(String studentid);
```


###examScheduleMapping上：
**根据id查询考试安排，返回对象类型是考试安排类**
选择返回内容是  *   ，数据表选择examSchedule, 条件是学生id 
```
  <select id="QueryExamscheduleById" parameterType="String" resultType="CMS.Entity.Examschdule">
      SELECT  * from examschedule where studentid=#{studentid}
  </select>

```


3 查询今天课程表CourseService
---------------------
在LoginController中代码：
根据用户名查询 今天课程表
```
 List<String> todayClass = courseService.QueryDaytableById(user.getUsername());
 
 session.setAttribute("todaytable", todayClass);
```

在CourseService中：

根据用户名，当前星期几，查询课程表，数据库存储是根据星期几区分的
注意日期 的格式和类型，是String 和小写
```
    public List<String> QueryDaytableById(String studentId) {
        SimpleDateFormat sdf = new SimpleDateFormat("E", Locale.ENGLISH);
        Date date = new Date();
        String day = sdf.format(date).toLowerCase();

        log.info("获取" + studentId + "-" + day + "课程表");

        return courseDao.QueryDaytableById(day,studentId);
    }
```

在CourceDao上
```
    List<String> QueryDaytableById(String day, String studentId);
```

###在CourceMapping上：
根据**用户名**和**今天是星期几**来查询，选择的字段是今天的星期，判断条件是用户id
```
  <select id="QueryDaytableById" parameterType="String" resultType="String">
    SELECT ${day} from coursetable where studentid = #{studentid}
  </select>
```

一般看课程表都是根据星期几来看的，周一什么课，周2什么课，周3什么课，所以选择的是星期作为字段，条件就是用户名了。



4 备忘录mememoService
------------------

在loginController上：

```
List<Memo> homememo = memoService.QueryHomeMemoById(user.getUsername());

session.setAttribute("homememo", homememo);
```

在memoService上：

```
    public List<Memo> QueryHomeMemoById(String studentid) {
        log.info("获取备忘录");
        return memoDao.QueryHomeMemoById(studentid);
    }
```

在memoDao上：

```
List<Memo> QueryHomeMemoById(String studentid);
```

###在memoMapping上：
**选择所有字段，数据库表是memo，条件是用户名和字段home = 1的**
```
  <select id="QueryHomeMemoById" parameterType="String" resultType="CMS.Entity.Memo">
    SELECT * from memo where studentid=#{studentid} and home='1'
  </select>
```
选择该用户的备忘录第一页上所有的数据


5 logincontroller上session域
--------------------------
UserService从数据库返回user的数据
```
User user = userService.login(username, password);
```
session 增加 用户User 
```
session.setAttribute("user", user);
```
session 增加 课程表，备忘录，考试时间
```
 session.setAttribute("homememo", homememo);
 session.setAttribute("informlist", informs);
 session.setAttribute("examschdules", examschdules);
 session.setAttribute("todaytable", todayClass);
```

5.5 出现问题
--------
###5.5.1 Autowried 封装是怎么回事？


###5.5.2 @ResponseBody作用是什么？ 
@Responsebody 注解表示该方法的返回的结果直接写入 HTTP 响应正文（ResponseBody）中**，一般在异步获取数据时使用，通常是在使用 @RequestMapping 后，返回值通常解析为跳转路径**，加上 @Responsebody 后返回结果不会被解析为跳转路径，而是直接写入HTTP 响应正文中。 
作用： 
该注解用于将Controller的方法返回的对象，通过**适当的HttpMessageConverter转换为指定格式后**，写入到Response对象的body数据区。 
使用时机： 
返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；

当页面发出异步请求：
```
function login() {
    var datas = '{"username":"' + $('#username').val() + '","userid":"' + $('#userid').val() + '","status":"' + $('#status').val() + '"}';
    $.ajax({
        type : 'POST',
        contentType : 'application/json',
        url : "${pageContext.request.contextPath}/user/login",
        processData : false,
        dataType : 'json',
        data : datas,
        success : function(data) {
            alert("userid: " + data.userid + "username: " + data.username + "status: "+ data.status);
        },
        error : function(XMLHttpRequest, textStatus, errorThrown) {
            alert("出现异常，异常信息："+textStatus,"error");
        }
    });
};
```
例如：
```
@RequestMapping(value = "user/login")
@ResponseBody
// 将ajax（datas）发出的请求写入 User 对象中,返回json对象响应回去
public User login(User user) {   
    User user = new User();
    user .setUserid(1);
    user .setUsername("MrF");
    user .setStatus("1");
    return user ;
}
```
异步获取 json 数据，加上 @Responsebody 注解后，就会直接返回 json 数据。

####**5.5.2.1 这里项目springMVC为什么要用到FastJsonHttpMessageConverter，MappingJackson2HttpMessageConverter？**

将后台返回的Java对象转换为Json字符串传递给前台，

但是当数据库字段为date类型时，@ResponseBody注解在转换日期类型时会默认把日期转换为时间戳（例如： date：2017-10-25  转换为 时间戳：15003323990）。

此时有两种方式可以解决日期转换Json问题：

1、（不推荐）局部修改，自定义注解进行将日期类型转换为Date类型。

2、（强烈推荐）全局修改，用MappingJackson2HttpMessageConverter配置在XML（SpringMVC）或者配置在Application.Java启动类（Spring boot、Spring cloud）。

配置在Application.Java启动类（Spring boot、Spring cloud）：
```

@Bean
    public MappingJackson2HttpMessageConverter getMappingJackson2HttpMessageConverter() {
    	MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter();
    	//设置日期格式
    	ObjectMapper objectMapper = new ObjectMapper();
    	SimpleDateFormat smt = new SimpleDateFormat("yyyy-MM-dd");
    	objectMapper.setDateFormat(smt);
    	mappingJackson2HttpMessageConverter.setObjectMapper(objectMapper);
    	//设置中文编码格式
    	List<MediaType> list = new ArrayList<MediaType>();
    	list.add(MediaType.APPLICATION_JSON_UTF8);
    	mappingJackson2HttpMessageConverter.setSupportedMediaTypes(list);
    	return mappingJackson2HttpMessageConverter;
    }
```
注意：Spring3.x 用MappingJacksonHttpMessageConverter
      Spring4.x 用MappingJackson2HttpMessageConverter
   
**配置在XML（SpringMVC）**
```
<mvc:annotation-driven>  
    <mvc:message-converters>  
        <bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter">  
            <property name="objectMapper" ref="customObjectMapper"></property>  
        </bean>  
    </mvc:message-converters>  
</mvc:annotation-driven> 
```
在java代码中：
```
<code class="language-html">@Component("customObjectMapper")    
public class CustomObjectMapper extends ObjectMapper {    
    
    public CustomObjectMapper() {    
        CustomSerializerFactory factory = new CustomSerializerFactory();    
        factory.addGenericMapping(Date.class, new JsonSerializer<Date>() {    
            @Override    
            public void serialize(Date value, JsonGenerator jsonGenerator,    
                    SerializerProvider provider) throws IOException, JsonProcessingException {    
                SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    
                jsonGenerator.writeString(sdf.format(value));    
            }    
        });    
        this.setSerializerFactory(factory);    
    }    
}  </code> 
```
**所以这里的2个JsonHttpMessageConverter的作用分别是：**
FastJsonHttpMessageConverter
是springboot的fastJson，也是转换器，也可以实现下面MappingJackson2HttpMessageConverter的设置UTF-8，和日期格式的功能，但是这里没有用到,恐怕只想到用Java对象转换成json字符串功能吧

FastJson举例子：
```
<mvc:annotation-driven>
        <mvc:message-converters register-defaults="true">
            <bean class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter">
                <property name="supportedMediaTypes">
                    <list>
                        <value>text/html;charset=UTF-8</value>
                        <value>application/json</value>
                    </list>
                </property>
                <property name="features">
                    <list>
                        <value>WriteMapNullValue</value>
                        <value>QuoteFieldNames</value>
                    </list>
                </property>
                <property name="dateFormat" value="yyyy-MM-dd HH:mm:ss"/>
            </bean>
        </mvc:message-converters>
</mvc:annotation-driven>
```
以上配置定义了 @responsebody 支持的返回类型， json对空键值的处理方式 和 统一的日期返回格式

，
MappingJackson2HttpMessageConverter
是单纯进行UTF-8编码的设置,设置响应支持的类型


###5.5.3在Mapping.xml的哪些参数可以不在dao的方法上添加@Param ()?

**jsp页面上脚本出现空指针情况，第一要想到 前端  和  后端的attribute的名称是否一致，最好都是直接复制，粘贴，不然眼花的时候很难发现的。**


###5.5.4 session的域是怎么回事？


### 5.5.5 HTTP的3次握手




6 到Jsp页面上
---------


在页面上增加引用：

    编译器指示 <%@ 编译器指示 %>
    声明 <%! 声明 %>
    表达式 <%= 表达式 %>
    程序代码段/小型指令 <% 程序代码片段 %>
    注释 <%-- 注释 --%> 客户端不可见
         <%!-- 注释 --%>  客户端可见

<%= %> 将表达式结果转换成字符串，在页面输出，相当于 <%out.print();%>
<% %> 里边放的是java代码，可以说是脚本





提交注册
```
 <form action="/regestersubmit" method="post" onsubmit="return checksubmit()">
```


检测用户名是否重复
```
<label>学号(学号将是您的用户名)</label>&nbsp;&nbsp;
<span id="existcheck" style="color:#F00;font-size:14px;text-align: center"></span>

<input id="username" onkeyup="existcheck()" name="username" class="form-control" type="text">
```

注意2个script方法，js方法
 function checksubmit() {
 function existcheck() {
 
 最终提交按钮
 
```
    <button type="submit" class="btn btn-info">提交注册</button>
```


login.jsp
---------


```
 <form action="#" method="post" id="loginform" onsubmit="return false">
    <input type="button" id="submit" value="登录" onclick="login()">
</form>
```
 
 function login(that) {
 
 
 登录的简易流程图：
 
 ![登录注册][1]
 
 
简陋思路的登录：
Controller:
public String logincheck(HttpSession session ,
                        @RequestParam("username") String username,
                        @RequestParam("password") String password){


User user = userService.QueryUserByIdAndPassword(username,password);
session.setAttribute("user",user);

Service:

return UserDao.login(studentid,password);

Mapping:
<select id="login" parameterType="String" resultType="XX.XX.User">
select * from user where studentid=#{} and password=#{}
 


  [1]: https://i.loli.net/2018/08/21/5b7b6f2b07fbf.jpg"	2018-08-15 09:32:34
kumika	项目功能3	# 项目功能3

主页： 开始设计每个版块
------------

![版块][1]
赛文77是用户名


1 从我的学习版块开始：
----------
学习版块需要课表和考试时间的显示，要求（业务）：课程表具有更改，删除课程功能，考试倒计时具有增加考试安排，删除，更新功能
主页页面：
```
                <li>
                    <a href="#">我的学习<span class="fa arrow"></span></a>
                    <ul class="nav nav-second-level">
                        <li>
                            <a href="/coursetable">我的课表</a>
                        </li>
                        <li>
                            <a href="/examschedule">我的考试倒计时</a>
                        </li>
                    </ul>
                </li>
```
### 1.1 先从 课程表开始：
查看课程表流程：**点击我的课表，查询返回成功后，跳转到详细课程表页面。**
####1.1.1主页页面：
```
 <a href="/coursetable">我的课表</a>
```
####1.1.2 CourseTableController：
把有关课程表的请求都放进CourseTableController中好管理，所以在CourseTableController中得到请求：
（因为没有参数，所以输入session进去？）
```
@RequestMapping("/coursetable")
public String coursetable(HttpSession session) {
    //得到session里面元素user的username
    String username = ((User)session.getAttribite("user")).getUsername();
    //然后根据用户名查询课程表,返回对象的类是课程表，多个对象就用List
    List<courseTable> courseTables = courseTableService.QueryCourseById(username);
    return "/coursetable";
    }
```
因为这个项目里面service没什么代码，就直接到Dao和mapping部分了
####1.1.3 Service==》Dao和Mapping：

Dao：
```
List<Coursetable> QueryCourseTableById(String studentid);
```
Mapping: 根据学生用户名查询所有的课程
```
 <select id="QueryCourseTableById" parameterType="String" resultType="CMS.Entity.Coursetable">
select * from courseTable where studentid=#{studentid} 
</select>
```
查看课程表流程：**点击我的课表，查询返回成功后，跳转到详细课程表页面。**

####1.1.4 课程表详细页面：
页面上有什么功能？
打开页面就查询===》并不是，而是得到返回的课程表对象
编辑课程表：（更新功能）
**跳转到编辑课程表页面：**
```
<a href="/editcoursetable"><button class="btn btn-inverse">编辑课表</button></a>
```

CourseTablecontroller：
```
@RequestMapping("editcoursetable")
public String editcoursetable(HttpSession session){
    return "/editcoursetable";
}
```
#####1.1.4.1 编辑课程表页面
编辑课程表页面需要注意的：

```
<input type="text">和<textarea>的区别
```
　text标签是单行文本框，不会换行。
　`<textarea>`是多行文本输入框，文本区中可容纳无限数量的文本
　最大的区别就是text是单行文本框，textarea是多行文本框。
　

　显示课程表的表单

    <form action="/submitcoursetable">
　
　从首页查询到的课程表，对象传递到这个页面上，然后再到这个多行文本框上输出，同时也是随时可以更改课程，作为输入对象。
　序号+星期作为文本的名字，是request的参数名，参数数据是文本内容
```
 <tr>
        <td>第<%=(i + 1) * 2 - 1%> - <%=(i + 1) * 2%>节课</td>
        <td><textarea name=<%=(i+1) + "Mon"%> style="resize:none"><%=coursetable.getMon()%></textarea></td>
        <td><textarea name=<%=(i+1) + "Tue"%> style="resize:none"><%=coursetable.getTue()%></textarea></td>
        <td><textarea name=<%=(i+1) + "Wed"%> style="resize:none"><%=coursetable.getWed()%></textarea></td>
        <td><textarea name=<%=(i+1) + "Thu"%> style="resize:none"><%=coursetable.getThu()%></textarea></td>
        <td><textarea name=<%=(i+1) + "Fri"%> style="resize:none"><%=coursetable.getFri()%></textarea></td>
        <td><textarea name=<%=(i+1) + "Sat"%> style="resize:none"><%=coursetable.getSat()%></textarea></td>
        <td><textarea name=<%=(i+1) + "Sun"%> style="resize:none"><%=coursetable.getSun()%></textarea></td>
</tr>　
```
#####1.1.4.2 CourseTableController：
　HTML到标签都是request的参数，所以要从页面上得到session和request。再将session的学生用户名，班别，request的文本内容赋值给新建课程表对象，用这个课程表对象进行更新。
```
@RequestMapping("/submitcoursetable")
    public String submitcoursetable(HttpSession session, HttpServletRequest request) {
    String username = ((User)session.getAttribute("user")).getUserName();
    CourseTable courseTable = null;
    //因为一天又5节课，所以循环5次
    for(int i= 0; i<5;i++){
        courseTable = new CourseTable();
        courseTable.setStudentid(username);
        courseTable.setClassNo(i+1);
        //从request的文本参数得到课程表的文本内容，文本参数名是i+1+"Mon"===》序号+星期 一共是7天，这里偷懒写一天演示
        courseTable.setMon(request.getParameter(i+1+"Mon"));
         //更新，第(i~~i+1)节课7天的课表
    courseService.UpdateCourseTable(courseTable);
    }
   //查询当天课表,然后返回主页
   List<String> TodayTable = courseService.QueryDayTableById(username);
   session.setAttribute("todaytable",TodayTable);
   //重定向到方法上，返回主页（主页面上点击我的课表的那个方法）
   return "redirect:"+ this.coursetable(session);
}
```

#####1.1.4.3 Service====》Dao和Mapping
因为查询当天课表的Service要加入日期，所以这里粘贴上。
为什么？
获取当天日期 要小写String类型的，才可以查询
**Service：**
```
 public List<String> QueryDaytableById(String studentId) {
        log.info("获取" + studentId + "-" + day + "课程表");
        //获取当天日期 要小写String类型的，才可以查询
        SimpleDateFormat sdf = new SimpleDateFormat("E", Locale.ENGLISH);
        Date date = new Date();
        String day = sdf.format(date).toLowerCase();

        return courseDao.QueryDaytableById(day,studentId);
    }
```

**Dao：**
```
    //注意service是什么类，这里也要什么类，集合也要有,mapping里面的参数，在Dao中也要标注到
    List<String> QueryDaytableById(@Param("day") String day,@Param("studentid") String studentid);
    
    void UpdateCourseTable(Coursetable coursetable);
```

**Mapping:**
```
//更新课表,因为是对象，多属性更新用values
replace into courseTable (studentid,classNo,mon,tue,wed,thu,fri,sat,sun) values (#{studentid},#{classNo},#{mon},#{tue},#{wed},#{thu},#{fri},#{sat},#{sun})


//查询当天课表
select ${day} from courseTable where studentid=#{studentid}
```

**Mybatis中的 ${ } 和 #{ }的区别**

参考：https://www.cnblogs.com/dato/p/7027949.html

mybatis 在对 sql 语句进行预编译之前，会对 sql 进行动态解析，解析为一个 BoundSql 对象，也是在此处对动态 SQL 进行处理的。在动态 SQL 解析阶段， #{ } 和 ${ } 会有不同的表现

    select * from user where name = #{name}; 

 #{} 在动态解析的时候， 会解析成一个参数标记符。就是解析之后的语句是：

    select * from user where name = ？; 

那么我们使用 ${}的时候

    select * from user where name = '${name}'; 

${}在动态解析的时候，会将我们传入的参数当做String字符串填充到我们的语句中，就会变成下面的语句

    select * from user where name = "dato"; 

预编译之前的 SQL 语句已经不包含变量了，完全已经是常量数据了。相当于我们普通没有变量的sql了。

综上所得， ${ } 变量的替换阶段是在动态 SQL 解析阶段，而 #{ }变量的替换是在 DBMS 中。

这是 #{} 和 ${} 我们能看到的主要的区别，除此之外，还有以下区别：

 

 1. #方式能够很大程度防止sql注入。
 2. $方式无法防止Sql注入。
 
 3. $方式一般用于传入数据库对象，例如传入表名.

**一般能用#的就别用$**
所以在使用mybatis的时候，尽量的使用#方式！！！这是要注意的地方






  [1]: https://i.loli.net/2018/08/21/5b7b85a6264ad.jpg	2018-08-21 09:59:34
kumika	项目功能4：考试倒计时功能	# 项目功能4：考试倒计时功能

主要功能：
    点击考试时间，进入详细页面
    具有增加 更新，删除功能
    自动检测距离考试剩余时间
    进入页面自动查询
---
# 1 从主页进入详细页面：

查看考试时间安排流程：**点击考试时间安排，查询返回成功后，跳转到详细考试时间安排页面。**
```
  <a href="/examschedule">我的考试倒计时</a>
```

## 1.1 考试有关集中在ExamScheduleController：
ExamScheduleController：
为什么能点击后进入页面自动查询，因为点击发出跳转请求后，在Controller中进行了一次查询。**所有的页面自动查询，好像都是在controller上得到用户信息，然后查询，返回考试安排对象。**

代码：
```
@RequestMapping("examschedule")
public String examschedule(HttpSession sesion){
    String username = ((User)session.getAttribute("user")).getUsername();
    List<ExamSchedule> examschedules = examService.QueryExamscheduleById(username);
    session.setAttribute("examschedule",examschedules);
    //跳转到详细页面
    return "/examschedule";
}
```
## 1.2 Service===》Dao和Mapping：
**service 就不多说了吧，微博集合@带**
```
return examschduleDao.QueryExamscheduleById(studentid);
```
**Dao：**
```
 List<Examschdule> QueryExamscheduleById(String studentid);
```

**Mapping：**
根据学生名用户id查询考试时间安排 ，返回对象是考试安排
```
 <select id="QueryExamscheduleById" parameterType="String" resultType="CMS.Entity.Examschdule">
      SELECT  * from examschedule where studentid=#{studentid}
  </select>
```

查看考试时间安排流程：**点击考试时间安排，查询返回成功后，跳转到详细考试时间安排页面。**


# 2 跳转到考试时间安排的详细页面
页面有什么功能：
点击进入页面自动更新===》主页查询返回的对象传到这里，当然更新了
增加考试时间安排
更新考试时间安排
删除考试时间安排

## 2.1 增加功能：
### 2.1.1 页面上的增加按钮：
```
 <a href="/examedit"><button class="btn btn-inverse"><i class="glyphicon glyphicon-plus"></i>添加考试</button></a>
 
```

### 2.1.2 ExamScheduleController:

**查看request是否存在edit元素，不存在就是增加一个新的考试安排表**
（增加表格，更新表格区分靠这个edit元素，因为edit是在更改考试的提交表单内），跳转到详细页面。

#### 2.1.2.1 Controller里进行跳转：
```
@RequestMapping("examedit")
public String addExam(HttpSession session , HttpServiceRequst request){
    //得到edit，然后判断是否为空，进而得出是更新，还是增加
    String edit = request.getParameter("edit");
    if(edit != null){
        //这部分到更新部分再写
    }
    else{
    //为了保险点，把session域（服务器端）上的更新考试时间安排内容删除，因为这里项目的增加，更新 都在一个form上，容易错乱
        session.removeAttribute("editexam");
    }
    return "examedit";
}
```
#### 2.1.2.2 跳转到的详细页面JSP：

关键的表单：

    <form action="/submitexam?action=<%=action%>" onsubmit="return add()" method="post">
其中的

    onsubmit="return add()"

是检验表格是否填完的js。

表达式：<%=action%> 

是页面上的脚本，判断是增加，还是更新。
**总结：脚本变量名action是作为判断点，判断增加还是更新**
```
    Examschdule examschedule = (Examschdule)session.getAttribute("editexam");
    String action = "edit";
    if(examschedule == null){
        action = "add";
    }
```
#### 2.1.2.3 ExamScheduleController：

增加考试安排，

提交参数确定一定要有的：
HttpSession session
表单里面的4个参数：
     data , examsubject, place, remark

因为/submitexam?action=<%=action%>这里面的<%=action %> 是request的参数，所以也要
HttpServiceRequest request

```
@RequestMapping("submitexam")
public String submitexam(HttpSession session,
                         HttpServiceRequest request,
                         @RequestParam("data") String data,
                         @RequestParam("examsubject") String examsubject,
                         @RequestParam("place") String place,
                         @RequestParam("remark") String remark){
    //从session 上得到学生id 用户名
    String studentid = ((User)session.getAttribute("user")).getUsername();
    //新创建一个 考试安排 对象，然后把request传来的参数放进去
    ExamSchedule examschedule = new ExamSchedule();
    examschedule.setStudentid(studentid);
    examschedule.setExamPlace(place);
    examschedule.setExamSubject(examsubject);
    examschedule.setExamDate(date);
    examschedule.setExamRemark(remark);
    
    //考虑到 data 的形式是yyyy-MM-dd-HH-mm-ss
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss");
    
    //从request得到判断是否增加，更新考试安排的判断点 脚本变量action
    String action = request.getParameter("action");
    //判断是否是增加考试安排
    if(action.equals("add")){
        //创建时间
        Date date2 = new Data();
        examschedule.setCreateTime(sdf.form(date2));
        examService.AddExamSchedule(examschedule);
    }
    else{
        //这部分是更改考试安排的，后面写
    }
    //重定向到方法examschedule(session)上
    return "redirect:" + this.examschedule(session);
}
```

#### 2.1.2.4 Service===》Dao 和Mapping 
Service： 
```
 examschduleDao.addExamSchedule(examschdule);
```

Dao：
```
void addExamSchedule(Examschdule examschdule);
```
Mapping：
插入的是Examschdule类，要在sql里面要全部写完Examschdule类里面的属性

```
<insert id="addExamSchedule" parameterType="XXX.XXX.Examschdule">
insert into examschedule (studentid,examname,````) values (#{studentid},#{examname},`````)
</insert>
```

增加功能：
jsp 传入 request的参数（Ps：@RequestParam("userid")String userid 这注解可在方法内直接使用userid

在controller下 完成  目标类的封装；就是 把request传入的参数全部装入目标类中。然后借用XXXService方法传入Dao和Mapping上
在Mapping写Sql语句



## 2.2 更改功能
页面上的表单循环里面的i 参数，传入后 序号第几，查出来后拿第几个（大概意思，不怎么准确，可能会改）

### 2.2.1 页面上的更改按钮

```
<a href="/examedit?edit=<%=i%>"><button class="btn btn-primary" name="edit" value=<%=i%>>编辑</button></a>
```
这edit=<%=i%> ,是页面显示考试安排的表格里，显示排序的序号i

    for (int i = 0; i < examschedules.size(); i++){


### 2.2.2 ExamScheduleController：
因为
```
<a href="/examedit?edit=<%=i%>">
```
所以在controller中又跳转到了上面增加考试安排的方法上，这里仅仅增加代码是在判断
```
@RequestMapping("examedit")
public String addExam(HttpSession session ,HttpServiceRequest request){
    //获取页面表单上选择的考试安排序号
    String edit = request.getParameter("edit");
    //得到判断点edit，然后进行判断是增加还是更新
    //进入if 就是更新
    if(edit != null){
        String studentid = ((User)session.getAttribute("user")).getUsername();
        //根据用户名 查询该用户所有的考试安排
        List<ExamSchedule> examschedulesss = examscheduleService.QueryExamscheduleById(studentid);
        //获取返回的考试安排，根据页面上选择的序号X，在返回集合中选择一样的序号X
        ExamSchedule examschedule = examschedulesss.get(Integer.parseInt(edit));
        //把更新后的考试安排放进服务器上
        session.setAttribute("examedit",examschedule);
    }
    else{
        //这里是上面增加考试安排的代码,
        session.
    }
    return "redirect:"+ this.examschedule(session);
}
```

把增加 和更新放在一起，有时候会头晕。
需要有一个判断点，判断什么条件下增加，什么条件下更新。
**用循环体里面的i 来作为判断点，要是增加就无法进入循环体，更新则可以进入**，这样的条件判断。

### 2.2.3 Service===》Dao和Mapping：

Dao：
```
List<Examschdule> QueryExamscheduleById(String studentid);
```
Mapping：

```
<select id="QueryExamscheduleById" parameterType="String" resultType="XXX.ExamSchedule">
select * from examschedule where studentid=#{studentid}
</select>
```

## 2.3 删除功能

### 2.3.1 页面上的删除按钮
```
<a href="/examdelete?delete=<%=i%>"><button class="btn btn-danger" name="delete">删除</button></a>
```
delete=<%=i%>   页面显示考试安排的表格里，显示排序的序号i
这次 是要选择删除的了

### 2.3.2 ExamScheduleController:
    删除需要3个参数： 创建时间，用户名，考试科目
```
   @RequestMapping("examdelete") 
   public String examdelete(HttpSession session ,HttpServiceRequest request){
        String studentid = ((User)session.getAttribute("user")).getUsername();
        String deleteNum = request.getParameter("delete");
        
        //从服务器端得到考试安排的集合，然后根据序号选中的删除目标
        Examschdule examschdule = ((List<Examschdule>) session.getAttribute("examschdule")).get(Integer.parseInt(deleteNum));
        
        String createtime = examschedule.getCreateTime();
        String examName = examschedule.getExamName();
        
        examService.deleteById(examName,studentid,createtime);
    
   return "redirect:"+this.examshcedule(session);
   }
``` 
### 2.3.3 Service===》Dao和Mapping:

Dao :
```
 void DeleteExamScheduleByName(String examname, String studentid, String createtime);
```


Mapping: 
```
<delete id="DeleteExamScheduleByName" parameterType="String">
delete  from examschedule where examname =#{0} and studentid=#{1} and createtime=#{2}
</delete>
```





	2018-08-25 09:07:01
kumika	项目功能5 查看我的班级	# 项目功能5 查看我的班级
主要实现功能：
1 自动查找班级社区所有帖子 
2 简单发帖子
3 查看自己的帖子
4 能看到回复
5 删除帖子

---

# 1 点击我的班级进入详细页面：
```
<a href="/myclass">我的班级</a>
```
## 1.1 在ClassController中：
从服务器得到用户信息，根据用户信息查找同班同学， 查找班级社区所有帖子，也查找自己发的帖子
一共3个查找要求
```
@RequestMapping("myclass")
public String myclass(HttpSession session){
    //查找同班同学
    User user = (User)session.getAttribute("user");
    List<User> classmateList = userService.GetUserListByUser(user);
    session.setAttribute("classmember",classmateList);
    
    //查找班级社区所有帖子
    List<Bbs> bbsList = bbsService.getTopicByUser(user);
    session.setAttribute("bbsList",bbsList);
    
    //查找自己发的帖子
    List<Bbs> ownTopicList = bbsService.getTopicByOwn(user.getUserName());
    session.setAttribute("usertopiclist",userTopicList);
    
    return "myclass";
}
```

## 1.2 Service===》Dao 和Mapping：

UserDao：
```
//查询同班同学
List<User> GetUserListByUser(User user);
```

BBsDao：
```
//查找班级社区所有帖子
List<Bbs> getTopicByUser(User user);
//查找自己发的帖子
List<Bbs> getOwnTopic(String studentid);
```
============================mapping===============================
UserMapping：
查询条件： 学校，学科，年级，班级
我个人理解：Mybatis要是 传入的是一个对象，然后可以在Mapping上直接使用对象属性
```
<!--查询同班同学-->
<select id="GetUserListByUser" parameterType="XXX.User" resultType="XXX.User">
select * from user where collage=#{collage} and major=#{major} and grade=#{grade} and classno=#{classno}
</select>
```


**BBsMapping：**
**查找班级社区所有帖子  的思路:**
  根据bbs帖子表单里面的用户名，查询用户的年级，班级，学校，科目
  然后以上面的数据作为条件，选择bbs的所有信息
  **大概就是根据  发过帖的学生的id，查找到年级，班级，学校，科目，然后这些作为条件，再查找班级社区所有帖子==》大概在所有帖子中筛选出有关自己班级的**
```
<!--查找班级社区所有帖子-->
select * from bbs  b where 
(select grade from user where username = b.studentid) =#{grade}
and
(select classno from user where username = b.studentid) =#{classno}
and
(select major from user where username = b.studentid) = #{major}
and
(select collage from user where username = b.studentid) = #{collage}
order by createtime desc


<!--查找自己发的帖子-->
select * from bbs where studentid = #{studentid}
```
查找后对象返回myclass详细页面。


# 2 跳转到myclass.jsp页面上：

按照  我的班级  班级社区  新建主题  我的主题 写
```
<a href="#home" data-toggle="tab">我的班级</a>
<a href="#bbs" data-toggle="tab">班级社区</a>
<a href="#newtopic" data-toggle="tab">新建主题</a>
<a href="#mytopic" data-toggle="tab">我的主题</a>
```
## 2.1.1 从我的班级 展示：
从主页 我的班级 跳转到这里，查询后 传递给 服务器的对象 交给页面脚本（可以说从服务器上得到对象）：
```
<%
List<User> classmenber = (List<User>)session.getAttribute("classmember");
%>
```
显示每一个同学：(页面脚本)
```
 User member = null;
    for (int i = 0; i < classmenber.size(); i++) {
            member = classmenber.get(i);
```

    <a href="/memberdetail?id=<%=member.getUsername()%>" class="list-group-item"><%=member.getUsername() + "   " +  member.getName() + "   " + member.getSex()%></a>
```
}
```
显示同学:

    <a href="/memberdetail?id=<%=member.getUsername()%>"


## 2.1.2 ClassController:
 
 从request得到学生的id 然后进行查询
 
 PS： href=/XXX?id=ZZZZ   request请求里面是带有id这个参数
```
@RequestMapping("memberdetail")
public String memberdetail(HttpSession sesion ,HttpServiceRequest request){
    String studentid = request.getParameter("id");
    User detailmember = userServuce.queryUserById(id);
    session.setAttribute("detailmember",detailmember);
    //跳转到同学详细信息页面
    return "memberdetail";
}
```

## 2.1.3 Service ===》Dao和Mapping

Dao：
```
User QueryUserById(String username);
```

Mapping：
```
select * from user where username=#{username}
```


## 2.2.1 从班级社区 展示： 
功能： 显示 所有有关班级的帖子，和回复

从主页 我的班级 跳转到这里，查询后 传递给 服务器的对象 交给页面脚本（可以说从服务器上得到对象）：
```
List<Bbs> bbsList = (List<Bbs>)session.getAttribute("bbsList");
```
显示有关班级社区的所有帖子：(也显示楼主)
```
<%
    Bbs bbs = null;
        for (int i =  0; i < bbsList.size(); i++) {
            bbs = bbsList.get(i);
%>
```
```
<!--查询帖子条件是需要id 和 创建时间-->
 <a href="/BBSdetail?stu=<%=bbs.getStudentid()%>&time=<%=bbs.getCreatetime()%>" target="_blank"><h4><%=bbs.getTitle()%></h4></a>
 <!-- 显示楼主  -->
 <a href="/memberdetail?id=<%=bbs.getStudentid()%>" target="_blank"><%=bbs.getStudentname()%></a> <%=" 发表于 " + bbs.getCreatetime()%></span>
```
```
<%=(bbs.getDetail().length() > 226) ? bbs.getDetail().substring(0, 225) + "..." : bbs.getDetail()%>

 }
```
显示帖子的循环结构。

## 2.2.2 ClassController：
查询帖子条件是需要id 和 创建时间 （看完href 整句话啊别只看到？就是了，还有& 啊）
```
@ReqeustMapping("BBSdetail")
public String BBSdetail(HttpSession session ,HttpServiceRequest request){
    String studentid = request.getParameter("stu");
    String time = request.getParameter("time");
    Bbs bbsList = bbsSerivce.QueryBBsByIdAndTime(studentid,time);
    //帖子的回复
    List<Comment> CommentList = bbsService.GetReply(studentid,time);
    
    session.setAttribute("commentList",commentList);
    session.setAttribute("bbs",bbs);
    //跳转到帖子的详细页面
    return "BBSdetail";
}
```
## 2.2.3 Service ===》 Dao 和Mapping ：

Dao：
要注意接口的方法里面的参数名称 和类的属性名是否一致，不然在sql是出错的
```
Bbs QueryBBsByIdAndTime(String studentid,String createtime);

List<Comment> GetReply(String topicstudentid,String createtime);
```

Mapping：
```
<select id="QueryBBsByIdAndTime" parameterType="String" resultType="XXX.Bbs">
select * from bbs where studentid=#{0} and createtime=#{1}
</select>

<select id="GetReply" parameterType="String" resultType="XXX.Bbs">
select * from comment where topicstudentid=#{1} and createtime=#{1}
</select>

```

## 2.2.4  返回对象后跳转到帖子里：

### 2.2.4.1 页面上帖子回复：
用了异步调用  
```
<button type="button" onclick="reply()" class="btn btn-info">回复</button>
```
ajax异步调用
```
 $.ajax({
            data:{
                topicstudentid:"<%=bbs.getStudentid()%>",
                reply:$("#reply").val(),
                createtime:"<%=bbs.getCreatetime()%>",
            },
            type:"post",
            url:"/reply",
            dataType:"json",
            error:function (data) {···},
            success:function (response) {
```
### 2.2.4.2 ClassController：

```
@RequestMapping("reply")
@ResponseBody
public String reply(HttpSession session ,@RequestParam("topicstudentid") String topicstudentid), @RequestParam("reply")String reply, @RequestParam("createtime") String createtime ){
    User user = session.getAttribute("user");
    SimpleDateForm sdf = new SimpleDateForm("yyyy-MM-dd-HH-mm-ss");
    
    bbsService.reply(topicstudentid, createtime, reply, user.getUsername(), user.getName(),sdf.format(new Date()));
    return "success";
}
```
### 2.2.4.3 Service===》Dao 和Mapping：

Dao： 
```
void reply(String topicstudentid, String createtime, String reply, String commentstudentid, String studentname, String commenttime);
```

Mapping:
values 里面的编号 是根据Dao接口里reply方法的参数顺序决定的，参数位置改变，mapping里面的编号也改变

```
<insert id="reply" parameterTypr="String">
insert into comment where (topicstudentid,createtime,commentstudentid,commenttime,studentname,comment)
values 
(#{0},#{1},#{3},#{5},#{4},#{2})
```

## 2.3.1 从 新建帖子 展示： 

使用异步调用 ajax ：onclick="return titlecheck()"

```
<input class="form-control" id="topictitle" name="topictitle"  placeholder="标题(不多于50字)" type="text">


 <textarea class="form-control" id="topicdetail" name="topicdetail" placeholder="内容(不多于1500字)"></textarea>
 
 <button onclick="return titlecheck()" class="btn btn-success">提交</button>
```
titlecheck():
```
 $.ajax({
            data:{
                topictitle:$("#topictitle").val(),
                topicdetail:$("#topicdetail").val()
            },
            type:"post",
            url:"/newtopic",
            dataType:"json",
            error:function (data) {````},
            success:function (reponse) {````}
```

## 2.3.2 ClassController：
从服务器端 拿到Session的user信息，
然后创建帖子类的一个新帖子对象，
把前端Ajax传入的参数赋值给帖子的属性，
在放入数据库。

**一定要记得用了Ajax ，在方法上一定要加上@ResponseBody**

```
@RequestMapping("newtopic")
@ResponseBody
public String newtopic(HttpSession session,@RequestParam("topictitle")String topictitle,
@RequsetParam("topicdetail") String topicdetail){
    
    User user = (User) session.getAttribute("user");
    Bbs newbbs = new Bbs();
    
    //帖子需要创建时间，注意时间的形式
    SimpleDateForm sdf = new SimpleDateForm("yyyy-MM-dd-HH-mm-ss");
    
    newbbs.setStudentid(user.getUsername());
    newbbs.setDetail(topicdetail);
    newbbs.setCreatetime(sdf.format(new Date()));
    newbbs.setTitle(topictitle);
    
    bbsService.newTopic(bbs);
    
    return "success";
}
```


## 2.3.3 Service===》Dao 和Mapping ：
难道在Dao 的参数上加 @Param 是因为ajax  吗？
Dao : 
```
void newTopic(Bbs bbs);
```

Mapping:
得到学号id，然后根据学号id来获取学生名字，最后插入学生名字进帖子类

```
insert into bbs (studentid,studentname,title,createtime,detail,good) 
values
(#{studentid},
(SELECT name FROM user WHERE username=#{studentid})
,#{title},#{createtime},#{detail},#{good});
```

## 2.4.1 从 我的主题 展示(删除帖子):

从主页 我的主题 跳转到这里，查询后 传递给 服务器的对象 交给页面脚本（可以说从服务器上得到对象）：

```
List<Bbs> usertopiclist = (List<Bbs>)session.getAttribute("usertopiclist");
```


```
 <%
    Bbs ownbbs = null;
        for (int i = usertopiclist.size() - 1; i >= 0; i--) {
            ownbbs = usertopiclist.get(i);
%>
```
```
<a href="/BBSdetail?stu=<%=ownbbs.getStudentid()%>&time=<%=ownbbs.getCreatetime()%>" target="_blank"><h4><%=ownbbs.getTitle()%></h4></a><span style="text-align: right;"><%="我 发表于 " + ownbbs.getCreatetime()%></span>&nbsp;&nbsp;

<!--删除帖子-->
<a href="/deletetopic?time=<%=ownbbs.getCreatetime()%>">删除该主题</a>
```

## 2.4.2 ClassController:

删除帖子是根据 用户名 和创建时间 作为条件 来删除。

```
@RequestMapping("deletetopic")
public String deletetopic(HttpSession session ,HttpServiceRequest request){
    String createtime = request.getParameter("time");
    User user = (User)session.getAttribute("user");
    
    bbsService.deleteTopic(user.getUsername(),createtime);
    return "redirect:"+ this.myclass(session);
}
```


## 2.4.3 Service===》 Dao 和Mapping :

Dao：
```
void deleteTopic(String topicstudentid, String createtime);
```

Mapping：
其他表也要删除，= =要是联合表怎么办，没有遇见过啊

```
delete from bbs where topicstudentid=#{0} and createtime=#{1}
  DELETE FROM comment WHERE topicstudentid=#{0} AND createtime=#{1};
  DELETE FROM good WHERE topicstudentid=#{0} AND createtime=#{1};
```







	2018-08-27 16:18:32
kumika	功能6 简易留言板	# 功能6 简易留言板

实现功能：

点击进入留言页面后查询所有留言主题
 增加留言
 删除留言
 更新留言


---

# 1 主页进入留言版块

```
<a href="/memo">我的个人备忘录</a>
```

## 1.1 MemoController：


```
 @RequestMapping("memo")
 public String  memo(HttpSession sesion ,HttpServiceRequest reuqest){
    User user = (User) session.getAttribute("user");
    String studentid = user.getUserName();
    //根据用户Id 查询 用户留言
    List<Memo> memoList = memoService.QueryMemoByid(studentid);
    // 根据用户Id 查询 用户首页留言
    List<Memo> homeMemoList = memoService.QueryHomeMemoById(studentid);
    
    session.setAttribute("memolist",memoList);
    session.setAttribute("homememo",homemo);
    return "/memo";
}
```

## 1.2 Service===》dao 和 mapping:

Dao :

```
    List<Memo> QueryHomeMemoById(String studentid);

    List<Memo> QueryMemoById(String studentid);
```

Mapping:

查询首页留言，条件必然有‘首页’这个条件，在memo类里面就是home这个属性了，还有个条件就是用户id了。
**要是遇到不清楚的查询情况，分项出来，就像数学公式，多项组成一个公式。**

```
select * from memo where studentid=#{studentid}

select * from memo where studentid=#{studentid} and home ='1'
```



# 2 进入memo详细页面：

页面实现功能：
增加留言
更新留言
删除留言

## 2.1.1 增加留言：

页面上增加留言使用异步调用

```
<button onclick="add()" class="btn btn-inverse"><i class="glyphicon glyphicon-plus"></i></button>
```
增加留言先确保输入文本框清空：
```
<script type="text/javascript">
    var select = "-1";
    var title = document.getElementById("title");
    var detail = document.getElementById("detail");
    var ishome = document.getElementById("home");
    
    function add() {
        select = "new";
        ishome.checked = false;
        title.value = "";
        detail.value = "";
    }
</script>
```

文本框输入内容：
```
    <input id="title" placeholder="标题" type="text" style="width: 700px;height: 45px"><br><br>
    <textarea id="detail" style="resize:none;height: 325px;width: 700px;"></textarea>
    <!-- 判断是否在首页显示的判断标志 home ，memo类里也要有home属性，
    jsp 传入后台，然后sql的时候进行判断-->
   置顶首页<input id="home" type="checkbox" name="stick"/> 
    <!-- 异步调用 submitcheck() -->
   <button onclick="return submitcheck()" class="btn btn-success" style="width: 110px;" type="button">保存</button>
   
```


异步调用：ajax
```
<script type="text/javascript">

    function submitcheck() {
        var title = $("#title").val();
        var detail = $("#detail").val();
        var ishome = document.getElementById("home");
        <!--select 判断是否是新增 还有执行选择第几个更新的作用-->
        if(select == "-1"){
            $("#msg").text("请选择备忘录再进行编辑" + select);
            return false;
        }
        $.ajax({
            data:{
                title:$("#title").val(),
                detail:$("#detail").val(),
                select:select,
                home:ishome.checked
            },
            type:"post",
            url:"/submitmemo",
            dataType:"json",
            error:function (data) {```},
            success:function (response) {
            
</script>
```
变量：
select： 判断 是否 新增 ，选择哪个更新==》作为序号的作用 ，共2个含义
home： 作为是否作为首页备份 的标志 

### 2.1.2 MemoCortoller：
只先写增加部分，更新部分后面写
因为用了Ajax 所以要用@ResponseBody

思路： 首先进行判断是增加备份还是更新备份，判断标准是Select 是否为字符串"new"
新建一个备份对象，
然后根据session得到的user信息，ajax传来的参数，放进备份对象里，
然后放进数据库中。
```
@RequestMapping（"submitmemo"）
@ResponseBody
public String submitmemo(HttpSession session ,@RequestParam("titile")String titile,@RequestParam("detail")String detail,@RequestParam("home") String home ,@RequestParam("select") String select){
    //当select是字符串new的时候，代表是增加一份新备份
    if(select.equals("new")){
        Memo memo = new Memo();
        User user = (User)sesion.getAttribute("user");
        Sting studentid = user.getUserName();
        //因为备份的属性需要时间,时间的格式也要yyyy-MM-dd-HH-mm-ss
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss");
        
        memo.setDetail(detail);
        memo.setTitle(title);
        memo.setStudentid(studentid);
        memo.setCreatetime(sdf.format(date));
        //设置是否在首页显示 1为是，0为否
        memo.setHome((home.equals("true"))?1:0);
        
        memoService.addMemo(memo);
        return "success";
    }
    else{
        //这部分是更新备份，后面写
    }
}
```

### 2.1.3 Service===》Dao 和Mapping：

Dao：

```
void addMemo(Memo memo);
```
Mapping：

```
insert into memo (studentid,createtime,title,detail,home) values (#{studentid},#{createtime},#{title},#{detail},#{home})
```

## 2.2.1 更新功能

先从上面没有写完的部分开始


### 2.2.2 MemoController:

从session里面得到帖子列表，然后**从帖子集合中拿出选中的帖子，选中依据是 页面显示帖子循体内的变量i ，作为帖子的序号，ajax把 i 作为select 传进来了。** 


得到选中的帖子对象，
把页面文本框里面的内容set进帖子对象去，
然后更新数据库

```
//接上面增加}备份的代码，这里写的是else{ }里面的部分
else{
    //得到选中的帖子对象
    List<Memo> memolist = （List<Memo>）session.getAttribute("memolist");
    Memo memo = memolist.get(Integer.parseInt(select))
    
    //把页面文本框里面的内容set进帖子对象
    memo.setTitle(title);
    memo.setDetail(detail);
    memo.setHome((home.equals("true"))? 1 : 0);
    //更新
    memoService.UpdateMemo(memo);
    
    reurn "success";
}

```

### 2.2.3 Service====》Dao 和 Mapping:

根据 用户名 和时间 作为条件 ，进行更新备忘录

Dao：

```
memoDao.UpdateMemo(memo);
```


Mapping：

根据 用户名 和时间 作为条件 ，进行更新备忘录

```
<update id="UpdateMemo" parameterType="XX.memo">
update memo set title=#{title} ,detail=#{detail},home=#{home}
where studentid=#{studentid} and createtime=#{createtime}
</update>
```

### 2.2.4 页面的显示备份版块更新

```
<%
    Memo memo = null;
    for (int i = 0; i < memoList.size(); i++) {
        memo = memoList.get(i);
%>
 <a onclick="check(<%=i%>)" class="list-group-item"><%=memo.getTitle()%></a>
 
 <%
    }
%>
```

异步调用：

```
<script type="text/javascript">
function check(i) {
        select = i;
        $.ajax({
            data: {
                selectnum:select
            },
            type: "post",
            url: "/getselect",
            dataType: "json",
            error: function (data) {
                alert("系统错误 请重试" + data + select);
                $(that).removeClass("processing");
            },
            success: function (response) {
                data = response.split("/*/");
                title.value = data[0];
                detail.value = data[1];
                if(data[2] == "1")
                    ishome.checked = true;
                else
                    ishome.checked = false;
            }
        });
</script>
```


### 2.2.5 MemoController：

页面上已经显示的备份版块是怎么更新的？
总的来说：
是拿到 session里更新后的备份对象集合，然后根据序号i 拿到选中的备份，然后显示在页面上。

**具体说：**
在前端的ajax中得到序号 select ===》得到选中的备份序号i

在MemoController上：
依据序号，session上的用户信息
得到 session上更新后的备份集合

然后拿到 更新后选中的备份
返回 备份名+/*/ +备份内容+/*/+是否首页显示 这样的字符串

页面上的ajax 根据返回的字符串 依据/*/分组 
data[0] 得到的是备份名 
data[1] 得到的是备份内容  
data[2] 得到的是是否在首页显示的标志 1 或者  0

这3组数据分别赋值给页面上的变量，最后显示。

```
@RequestMapping("getselect")
@ResponseBody
public String getselect(HttpSession session ,HttpServiceRequest request){
    //@RequestParam("xx") String xx 能在方法直接使用xx，而HttpServiceRequest request 还需要getParameter（）一次
    
    String select = request.getParameter("selectnum");
    
    List<Memo> memolist = (List<Memo>)session.getAttribute("memolist");
    Memo memo = memolist.get(Integer.parseInt(select));
    
    return memo.getTitle() + "/*/" + memo.getDetail + "/*/" + memo.getHome();
}
```
返回的字符串内容：

    备份名/*/备份内容 /*/0

## 2.3.1 删除功能：

```
<button onclick="deletememo()" class="btn btn-danger" style="width: 110px;" type="button">删除</button>
```
异步调用：
```
<script type="text/javascript">
    function deletememo() {
        if(select == "-1" || select == "new"){
            $("#msg").text("请选择目标备忘录");
            return false;
        }
        $.ajax({
            data:{
                select:select
            },
            type:"post",
            url:"/deletememo",
            dataType:"json",
            error:function (data) {
                alert("系统错误 请重试" + data + select);
                $(that).removeClass("processing");
            },
            success:function (response) {
                if(response == "success"){
                    alert("操作成功");
                    window.location.href = "/memo";
                }
            }
        });
    }
</script>
```

### 2.3.2 MemoController:

依据拿到的序号I 和session上用户信息 得到要删除的目标备份

删除备份的条件是用户id 和 创建时间（不需要用户知道这些，得到目标备份就可以了）

```
@RequestMapping("deletemome")
@ResponseBody
public String deletememo(HttpSession session , @RequestParam("select") String select ){
    List<Memo> memolist = (List<Memo>)session.getAttribute("memolist");
    Memo memo = memolist.get(Integer.parseInt(select));
    
    memoService.deleteMemo(memo.studentid,memo.getCreatetime());
    return "success";
}
```

### 2.3.3 Service===》Dao 和Mapping :

Dao：
```
void DeleteMemo(@Param("studentid") String studentid, @Param("createtime") String createtime);
```

Mapping：
```
DELETE FROM memo WHERE studentid=#{studentid} AND createtime=#{createtime}
```





	2018-08-28 10:17:23
kumika	疑问，出现的问题	# 疑问，出现的问题



---

#疑问，出现的问题：

#1  return "redirect:" +  XXX？
this.coursetable(session);？为什么这个可以重定向？

因为这个是重定向 返回到这个controller的courseTable方法上。
只是自己没有想到是可以重定向到方法上而已

return "redirect" + this.coursetable(session); 这句是不成功的，缺少了：号

参考：
https://blog.csdn.net/luo4105/article/details/72480997
https://blog.csdn.net/masuwen/article/details/6881738
https://blog.csdn.net/z69183787/article/details/52596995
https://blog.csdn.net/xiaoyu19910321/article/details/52910084
http://www.360doc.com/content/12/0928/15/7471983_238637905.shtml

000000000000000000000000000000000
问题1 解决，redirect： + 方法，这也是重定向，不了解redirect
000000000000000000000000000000000


#2当页面提交表单只有action的时候，controller的参数是什么?
不清楚页面提交与controller直接的参数问题


#3 简单说明session 和request 的区别
首先都是 jsp的内置对象。

session :
是客户端 与 服务器端 之间的连接（会话），然后客户端信息放在服务器端，
    **具体点就是用户登录上淘宝，随意点击任意网页都是在自己账号下浏览网页，不同网页间用户信息是互通的。不会因为一次点击请求就结束会话，真正结束session是退出全部的淘宝网页。**
    
    Attribute是可以在不同页面上使用的，
比如你在aa.jsp中 session.setAttribute("session1","这是保存的内容");
那你在bb.jsp中可以String str=(String)session.getAttrinbute("session1");//那么str就等于"这是保存的内容"


request:
是客户端 对 服务器端的一次请求，当请求得到回应完毕后，就结束它的生命周期。
具体点就是：你点击淘宝上的一个商品，就是一次请求，进入商品详细页面后，请求结束。在详细页面你又点击了什么，那就又发出一次请求。
    
    parameter是一次请求的参数，是从上一个页面中的url,form 获取的参数

参考：
https://zhidao.baidu.com/question/26550839.html
https://www.cnblogs.com/lonelydreamer/p/6169469.html
https://blog.csdn.net/lilinsqq/article/details/78909619
https://blog.csdn.net/hzc543806053/article/details/7416007
https://www.cnblogs.com/xdp-gacl/p/3855702.html

000000000000000000000000000000000
问题3 解决，session 和 request 是
                生命周期： session  》 request
                范围：     session  》 request
                内容：     session  ！=  request
000000000000000000000000000000000

#4 loginout的移除哪些attribute，又在哪里查看的？
   session.removeAttribute("user");
        session.removeAttribute("today");
        session.removeAttribute("Coursetable");
        session.removeAttribute("informlist");
        session.removeAttribute("memolist");
        session.removeAttribute("homememo");
        
        
#5 需要HttpServiceRequest的情况是什么？


#6  Dao和mapping.xml中，什么时候在Dao的方法上加@Param
  比如：
``` java
  void DeleteMemo(@Param("studentid") String studentid, @Param("createtime") String createtime);
```
是mybatis作为参数绑定sql语句的

看前端传来的值是否可以和后端的属性名对应，如果对应，就可以不使用，如果不对应，是需要使用的

参考：
https://ask.csdn.net/questions/384397?sort=id

000000000000000000000000000000000
问题6 解决，看前端传来的值是否可以和后端的属性名对应，如果对应，就可以不使用，如果不对应，是需要使用的
000000000000000000000000000000000

#7 对自己的要求，爬虫爬桂林理工？

#8 复习 每一个功能所需要注重点是什么？

页面的输入，连接

传到controller是怎么接收的

service是在这个项目基本只是传导作用

Dao 和Mapping的需求写法


#9 HTTPS的3次握手






	2018-08-29 10:55:48
kumika	学生管理系统student-manage（简易版）	#学生管理系统student-manage（简易版）

这个项目更多的是想从原作者那里得到他的开发思路，基本功是目前不可能不可比的，人家专业科班，我是半路出家，而且还3天打鱼2天晒网的。漫漫学习路，不能心急躁。

参考：https://www.jianshu.com/p/553fc76bb8eb

基于 Servlet + JSP 实现的简易版的学生管理系统
------------------------------

技术准备
这个项目是自己用于巩固 J2EE 相关知识的练手项目，非常简单，但是相关的功能却非常实用，所以在这里分享一下

为了完成这个项目，需要掌握如下技术：

Java
基础知识
前端：
HTML, CSS, JAVASCRIPT, JQUERY
J2EE：
Tomcat, Servlet, JSP, Filter
数据库：
MySQL


---

#开发流程

##1 需求分析：
-----

保存数据

能对学生信息 进行增删改查，学生的学号，姓名，年龄，性别，出生日期


## 2 表结构设计 

因为是简单模式，只需要 student 表就能够完成功能了。

###创建数据库 ：student
将数据库编码格式设置为Utf-8
```
drop database if exists student;
create database student default character set utf8;
```

###创建学生表格：student

这里犯了个错误，表要有自己的一个主键，用id表示，不能用学生id显示，要是出现学生更改id，表格也要更改，麻烦。
所以增加id，作为表自己的唯一性。

```
create table student(
    id int(11) not null primary key auto_increment,
    student int(255) not null unique,
    studentname varchar(255) not null,
    age int(11) not null,
    sex varchar(255) not null,
    birthday date default null
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


## 3 原型设计:

就是设计界面，在商业项目中，这是很重要的一步，我们可以**解除界面原型，低成本、高效率**的与客户达成**需求的一致性**。

这个项目一共就分为两个页面：

主页面：

学生编辑页面：



## 4 实体类的设计

实体类仅仅是对数据库中表的一一映射，同时也需要兼顾对业务能力的支持。

```
import java.util.Date;

public class student {
    private int id;//数据库里面的id
    private int studentID; // 学号，跟ID区分开为了方便数据库操作
    private String name;
    private int age;
    private String sex;
    private Date birthday;

    //getter 和Setter 因为太长了，不粘贴上来了
}
```

## 5 Dao类的设计

DAO，即 Date Access Object，数据库访问对象，就是对数据库相关操作的封装，让其他地方看不到 JDBC 的代码。

### 5.1 作用于Dao类的工具：

首先我们先创建一个数据库操作的工具类：
创建一个util的包，包下创建DBUtil类

```
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DBUtil {
    //数据库信息
    static String ip = "127.0.0.1";
    static int port = 3306;
    static String database = "student";
    static String encoding = "UTF-8";
    static String loginName = "root";
    static String password = "123";

    static {
        try {
            Class.forName("com.mysql.jdbc.Driver");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    public static Connection getConnection() throws SQLException {

        String url = String.format("jdbc:mysql://%s:%d/%s?characterEncoding=%s", ip, port, database, encoding);
        return DriverManager.getConnection(url, loginName, password);
    }

    public static void main(String[] args) throws SQLException {
        Connection obj = getConnection();
        System.out.println(obj +" 返回的是Connection对象了");
    }
}
```

写工具类的好处：
  便于同一维护，降低维护成本

然后是 DAO 类，除了进行典型的 ORM 支持功能之外，也需要提供各种业务方法。


### 5.2 dao包下创建studentDao类

```
import Util.DBUtil;
import bean.Student;
import com.sun.org.apache.regexp.internal.RE;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class StudentDao {
    public int getTotal() {
        int total = 0;
        String sql = "select count(*) from student";

        try {
            Connection c = DBUtil.getConnection();
            Statement st = c.createStatement();
            ResultSet rs = st.executeQuery(sql);
            while (rs.next()) {
                total = rs.getInt(1);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return total;
    }

    public void add(Student student) {
        String sql = "insert into student values(null,?,?,?,?,?)";
        // 第一个？号是匹配学号 ，第2个？号是匹配姓名····
        //preparedStatement方法里面的编号 是代表sql 语句里面的第几个？号。
        try {
            Connection connection = DBUtil.getConnection();
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            preparedStatement.setInt(1,student.getStudentID());
            preparedStatement.setString(2, student.getName());
            preparedStatement.setString(3, student.getSex());
            preparedStatement.setInt(4, student.getAge());
            preparedStatement.setDate(5, new java.sql.Date(student.getBirthday().getTime()));

            preparedStatement.execute();

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void delete(int id) {
        String sql = "delete from student where id = ?";

        try {
            Connection connection = DBUtil.getConnection();
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            preparedStatement.setInt(1,id);

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void update(Student student) {
        String sql = "update student  set student_id=?, name=?,sex=?,age=?,birthday=? where id=?";

        try {
            Connection connection = DBUtil.getConnection();
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            preparedStatement.setInt(1, student.getStudentID());
            preparedStatement.setString(2, student.getName());
            preparedStatement.setString(3, student.getSex());
            preparedStatement.setInt(4, student.getAge());
            preparedStatement.setDate(5, new java.sql.Date(student.getBirthday().getTime()));
            preparedStatement.setInt(6,student.getId());

            preparedStatement.execute();

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public Student get(int id) {
        Student student = new Student();

        String sql = "select * from student where student_id  = "+id;

        try {
            Connection connection = DBUtil.getConnection();
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(sql);

            if (resultSet.next()) {
                int student_id = resultSet.getInt("student_id");
                String name = resultSet.getString("name");
                int age = resultSet.getInt("age");
                String sex = resultSet.getString("sex");
                Date birthday = resultSet.getDate("birthday");

                student.setStudentID(student_id);
                student.setName(name);
                student.setAge(age);
                student.setBirthday(birthday);
                student.setSex(sex);
                student.setId(id);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return student;
    }

//
//    public List<Student> list() {
//        return list(0, Short.MAX_VALUE);
//    }

    public List<Student> list(int start, int count) {
        List<Student> students = new ArrayList<Student>();

        String sql = "select * from student order by student_id decs limit ?,?";

        try {
            Connection connection = DBUtil.getConnection();
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            preparedStatement.setInt(1, start);
            preparedStatement.setInt(2, count);

            ResultSet resultSet = preparedStatement.executeQuery();

            while (resultSet.next()) {
                Student student = new Student();
                int id = resultSet.getInt("id");
                int student_id = resultSet.getInt("student_id");
                String name = resultSet.getString("name");
                int age = resultSet.getInt("age");
                String sex = resultSet.getString("sex");
                Date birthday = resultSet.getDate("birthday");


                student.setId(id);
                student.setStudentID(student_id);
                student.setName(name);
                student.setAge(age);
                student.setBirthday(birthday);
                student.setSex(sex);

                students.add(student);
            }
            resultSet.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        
        return students;
    }
}

```
该类中，既提供了增删改查这些基本的 CRUD 操作
1.增加：

> public void add(Student student)

2.删除：

> public void delete(int id)

3.修改：

> public void update(Student student)

4.查询所有：

> public List<Student> list()

又提供了一些非 CRUD 方法
1.获取总数：

> public int getTotal()

2.根据 id 获取：

> public Student get(int id)


## 6 业务类介绍

作为 J2EE Web 应用，一般都会按照如图所示的设计流程进行：
Servlet -> Service（业务类） -> DAO -> database

当浏览器提交请求到 Tomcat Web 服务器的时候，对应的 Servlet 的doGet/doPost 方法会被调用，接着在 Servlet 中调用 Service类，然后在 Service 类中调用DAO类，最后在 DAO 中访问数据库获取相应的数据。

![业务类过程图片][1]

单本项目没有使用 Service 这一层，原因是在对 DAO 类进行开发中，已经提供了很好的支持业务的方法，没有必要再包括上一层 Service 业务类。



## 7 功能开发

需要按照模块之间的依赖关系，顺序开发。

首先为项目添加必要的 jar 包：
jstl.jar
mysql-connector-java-5.0.8-bin.jar
servlet-api.jar
standard.jar
这也是 Web 开发中最基本的 4 个包

### 7.1编写Filter
由于项目中设计表单 POST 方式的提交，所以我们先来编写好相关编码的过滤器，好支持中文的存取

#### 7.1.1 在filter包下编写EncodingFilter类

```
import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebFilter("/*")
public class EncodingFilter implements Filter{
    
    public void init(FilterConfig filterConfig) throws ServletException {

    }
    
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        // 设置编码格式为 UTF-8
        request.setCharacterEncoding("UTF-8");
        filterChain.doFilter(request,response);
    }

    public void destroy() {

    }
}
```

### 7.2  编写Servlet

按照传统的方式，我们项目的业务为**增删改查**，所以对应四个路径，也就是需要编写四个 Servlet 才可以


#### 7.2.1 addServlet
```
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

@WebServlet("/addStudent")
public class addServlet extends HttpServlet{
    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException {
        Student student = new Student();

        // 直接从表单中获取数据
        int studentID = Integer.parseInt(request.getParameter("studentid"));
        String name = request.getParameter("name");
        int age = Integer.parseInt(request.getParameter("age"));
        String sex = request.getParameter("radio");
        Date birthday = null;

        // String 类型按照 yyyy-MM-dd 的格式转换为 java.util.Date 类
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

        try {
            birthday = sdf.parse(request.getParameter("birthday"));
        } catch (ParseException e) {
            e.printStackTrace();
        }


        student.setStudentID(studentID);
        student.setName(name);
        student.setSex(sex);
        student.setAge(age);
        student.setBirthday(birthday);

        new StudentDao().add(student);
        response.sendRedirect("/listStudent");// 这里可以理解为刷新，重新请求
    }
}
```

#### 7.2.2 deleteServlet
```
import dao.StudentDao;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/deleteStudent")
public class DeleteServlet extends HttpServlet {
    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException {
        int id = Integer.parseInt(request.getParameter("id"));

        new StudentDao().delete(id);
        response.sendRedirect("/listStudent");
    }
}
```

####  7.2.3 EditServlet

```
import bean.Student;
import dao.StudentDao;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;

@WebServlet("/editStudent")
public class EditServlet extends HttpServlet {
    protected void service(HttpServletRequest request, HttpServletRequest response) {
        int id = Integer.parseInt(request.getParameter("id"));

        Student student = new StudentDao().get(id);

        request.setAttribute("student", student);
        request.getRequestDispatcher("/editStudent.jsp");
    }
}
```


####  7.2.4 ListServlet

```
import Util.Page;
import bean.Student;
import dao.StudentDao;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

@WebServlet("/listStudent")
public class ListServlet extends HttpServlet {
    private StudentDao studentDao = new StudentDao();

    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        // 获取分页参数
        int start = 0;
        int count = 0;

        try {
            start = Integer.parseInt(request.getParameter("page.start"));
            count = Integer.parseInt(request.getParameter("page.count"));
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }

        Page page = new Page(start, count);

        List<Student> students = studentDao.list(page.getStart(), page.getCount());
        int total = studentDao.getTotal();
        page.setTotal(total);


        request.setAttribute("students", students);
        request.setAttribute("page", page);

        request.getRequestDispatcher("/listStudent.jsp").forward(request, response);
    }
}
```


####  7.2.5 UpdateServlet

```
import bean.Student;
import dao.StudentDao;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

@WebServlet("/updateStudent")
public class UpdateServlet extends HttpServlet{
    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException {
        int id = Integer.parseInt(request.getParameter("id"));
        int studentID = Integer.getInteger(request.getParameter("studentId"));
        int age = Integer.parseInt(request.getParameter("age"));
        String name = request.getParameter("name");
        String sex = request.getParameter("sex");
        Date birthday = null;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

        try {
            birthday = sdf.parse(request.getParameter("birthday"));
        } catch (ParseException e) {
            e.printStackTrace();
        }

        Student student = new Student();
        student.setId(id);
        student.setStudentID(studentID);
        student.setName(name);
        student.setAge(age);
        student.setSex(sex);
        student.setBirthday(birthday);

        new StudentDao().update(student);
        response.sendRedirect("/listStudent");
    }
}
```

## 8 编写jsp页面

我们把默认的 index.jsp 修改成如下代码：

      <%
    request.getRequestDispatcher("/listStudent").forward(request, response);
      %>

引入 JQ 和 Bootstrap
为了简化操作，引入了 JQuery 和 Bootstrap
### 8.1 编写 listStudent.jsp
其实主要还是利用 Bootstrap 编写好整个页面，我写的时候也是对照http://www.runoob.com/bootstrap/bootstrap-panels.html写的
```
看他用了什么bootstrap 文件 ？ 是整个文件copy过去，或者copy整段代码，还是香使用jar包那样要引用？
解答：
    是整段copy过去。bootstrap文件也要像jar包那样放在web包下
```

**首先整个页面分为3个区域  2个是div  1个是nav  都是html的区域标签
然后HTML标签里面才是bootstrap功能标签**

第1个区域是 显示学生列表
第2个区域是  分页区域 ，显示前后页，第几页
第3个区域是 增加学生信息 的表单

#### **8.1.1 第1个区域是 显示学生列表**

草稿版本，后面会增加脚本的
```
<!--
    //div 标签定义 HTML 文档中的一个分隔区块或者一个区域部分。
    //div 标签支持 HTML 的全局属性, class是规定元素的类名
-->
<div class="listDIV">
    <table class="table table-striped table-bordered table-hover table-condensed">
        <caption>学生列表 - 共XX页</caption>
        <thead>
            <tr class="success">
                <th>学号</th>
                <th>姓名</th>
                <th>年龄</th>
                <th>性别</th>
                <th>出生日期</th>
    
                <th>编辑</th>
                <th>删除</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>学生id</td>
                <td>名字</td>
                <td>年龄</td>
                <td>性别</td>
                <td>出生日期</td>
                <td>编辑</td>
                <td>删除</td>
            </tr>
        </tbody>
    </table>
</div>
```


#### **8.1.2 第2个区域是 分页区域**

草稿版本
```
<%--
<nav> 标签定义导航链接的部分。
--%>
<nav class="pageDIV">
    <ul class="pagination">
        <li><a href="#">«</a></li>
        <li><a href="#">1</a></li>
        <li><a href="#">2</a></li>
        <li><a href="#">3</a></li>
        <li><a href="#">4</a></li>
        <li><a href="#">5</a></li>
        <li><a href="#">6</a></li>
        <li><a href="#">»</a></li>
    </ul>
</nav>
```




#### **8.1.3 第3个区域是 增加学生信息 的表单**
一个输入表单标签 ，一个表格标签，2个功能标签合在一起形成输入表单
```
//输入表单标签
 <form action="demo-form.php" method="get"> 
 //表格标签
 <table class="addTable">
```
都是在上面的那个菜鸟网页上直接copy模版然后合成

**合在一起形成输入表单:**

```
<%--
        <form> 标签用于创建供用户输入的 HTML 表单
        此表单包含两个单选框和一个提交按钮
         role 本质上是增强语义性,辅助工具就可以认出这实际上是个form
        --%>
<form action="demo-form.php" method="post" role="form">
    <table class="addTable">
                <tr>
                    <td>学号：</td>
                    <%--
                    placeholder 属性规定可描述输入字段预期值的简短的提示信息
                    适用于下面的 input 类型：text、search、url、tel、email 和 password
                    其实就是输入框里面的提示语句，你输入的时候会消失
                    --%>
                    <td><input type="text" name="studentid" value="studentid" placeholder="请在这里输入学号"></td>
                </tr>

                <tr>
                    <td>姓名：</td>
                    <td><input type="text" name="name" value="name" placeholder="请在这里输入名字"></td>
                </tr>

                <tr>
                    <td>年龄：</td>
                    <td><input type="text" name="age" value="age" placeholder="请在这里输入年龄"></td>
                </tr>
                <tr>
                    <td>出生日期：</td>
                    <td><input type="date" name="birthday" value="birthday" placeholder="请在这里输入日期"></td>
                </tr>
                <tr>
                    <td>性别：</td>
                    <td>
                        <input type="radio" name="radio" value="男"> 男<br>
                        <input type="radio" name="radio" value="女" checked="checked"> 女<br>
                    </td>
                </tr>
                <tr class="submitTR">
                    <td>
                        <button class="btn btn-default" type="submit">按钮</button>
                    </td>
                </tr>

            </table>
          </form>
```
这是原始表单，然后要更改action
**注意表单的action是否正确啊**



**修改草稿JSP上，分页在第1，第2区域都要有，另外现在的分页功能应该是最基础的，没有使用任何高级工具。**
所以先实现分页功能
### 8.2 分页功能的实现

#### 8.2.1 在util包下创建page工具类
```
public class Page {
    int start;  // 开始数据
    int count;  // 每一页的数量
    int total;  // 总共的数据量

    public Page(int start, int count) {
        super();
        this.start = start;
        this.count = count;
    }
    //setter 和 getter 这里就不粘贴上来类
}
```
#### 8.2.2 更改第1 区域语句

```
<div class="listDIV">
    <table class="table table-striped table-bordered table-hover table-condensed">
        <%--
        ${page.pageSize}表示从page范围内查找
        ${pageSize}的话会依次从page,request,session,application中查找
        ${}是el表达式
        --%>
        <caption>学生列表 - 共${page.total}人</caption>
        <thead>
            <tr class="success">
                <th>学号</th>
                <th>姓名</th>
                <th>年龄</th>
                <th>性别</th>
                <th>出生日期</th>

                <th>编辑</th>
                <th>删除</th>
            </tr>
        </thead>
        <tbody>
        <%--
        varStatus=“status”事实上定义了一个status名的对象作为varStatus的绑定值。
        该绑定值也就是status封装了当前遍历的状态，比如，可以从该对象上查看是遍历到了第几个元素：${status.count}

        students对象在listservlet里面，也在page，毕竟是request搬运的
--%>
        <c:forEach items="${students}" var="s" varStatus="status">
            <tr>
                <td>${s.studentID}</td>
                <td>${s.name}</td>
                <td>${s.age}</td>
                <td>${s.sex}</td>
                <td>${s.birthday}</td>


                <%--
                 2个都是bootstrap的标签
                    glyphicon glyphicon-edit   编辑图标
                    glyphicon glyphicon-trash  垃圾桶图标
                --%>
                <td><a href="/editStudent?id=${s.id}"><span class="glyphicon glyphicon-edit"></span> </a> </td>
                <td><a href="/deleteStudent?id=${s.id}"><span class="glyphicon glyphicon-trash"></span></a> </td>
            </tr>
        </c:forEach>
        </tbody>
    </table>
</div>
```
#### 8.2.3 **更改第2 区域语句 分页功能实现**

##### 8.2.3.1 使用 `<c:if>`标签来增加边界判断，如果没有前面的页码了则设置为disable状态

1 前一页《 按钮 

```
<li <c:if test="${!page.hasPreviouse}">  class="disabled" </c:if>>
            <a href="?page.start=0">
                <span>«</span>
            </a>
        </li>
        <li <c:if test="${!page.hasPreviouse}">  class="disabled" </c:if>>
            <a href="?page.start=${page.start-page.count}">
                <span>‹</span>
            </a>
        </li>
```

2 后一页  》 按钮 
```
<li <c:if test="${!page.hasNext}"> class="disabled"</c:if>>
            <a href="?page.start=${page.start+page.count}">
               <span> › </span>
            </a>
        </li>
        <li <c:if test="${!page.hasNext}"> class="disabled"</c:if>>
            <a href="?page.start=${page.last}">
                <span> » </span>
            </a>
        </li>
```

3 在page类上添加上面的 hasNext() , hasPreviouse() 方法
```
    public boolean isHasPreiouse() {
        if (start == 0) {
            return false;
        }
        return true;
    }

    public boolean isHasNext() {
        if (start == getLast()) {
            return false;
        }
        return true;
    }

    public int getLast() {
        int last;

        if (0 == total % count) {
        // 假设总数是50，是能够被5整除的，那么最后一页的开始就是40
            last = total - count;
        } 
        else {
         // 假设总数是51，不能够被5整除的，那么最后一页的开始就是50
            last = total - total % count;    
        }

        last = last < 0 ? 0 : last;
        return last;
    }
```


##### 8.2.3.2 再通过 JavaScrip 代码来完成禁用功能：
```
<script>
    $(function () {
        $("ul.pagination li.disabled a").click(function () {
            return false;
        });
    });
</script>
```

##### 8.2.3.3 完成中间码页的编写

从 0 循环到page.totalPage - 1  ,  varStatus 相当于是循环变量

status.count 是从1 开始遍历
status.index 是从0 开始遍历

要求：  显示当前页码的前2个和后2个就可，例如当前页码为 3 的时候，就显示1 2 3（当前页）4 5 的页码

-10  《= 当前页 * 每一页显示的数目 - 当前页开始显示的数据编号 《=30


![页数][2]

这种分页算法 只是看重点在显示哪个区间的数据上。
思路过程：
        就是每一页显示10个，所以第一页十个，编号从数据库的0号开始；
        到了第二页，编号就从10号开始了，10+10 = 20 ，所以第三页是从编号20号开始的。向后依次类推。第100页，显示最顶头编号从90号开始·····
        **页数是无所谓的，重点是显示，只需要判断显示编号在哪个区间，知道区间后就知道页数了。**
```        
           <%-- 中间码页的页数 --%>
        <c:forEach begin="0" end="${page.totalPage - 1}" varStatus="status">
            <%-- 假设 当前页是在第1页 与 第3页之间 --%>
            <c:if test="${status.count * page.count - page.start <= 30 && status.count * page.count - page.start >= 10}">
                <%-- 假设 循环体的开始编号 * 每页的数量 == 页的开头编号 就是 1 * 1 = 1--%>
                <li <c:if test="${status.index * page.count == page.start}"> class="disabled" </c:if>>
                        <a href="?page.start=${status.index * page.count}"
                        <%--  循环的开始编号 * 每页数量 == 页的开头编号  --%>
                        <c:if test="${status.index * page.count == page.start}"> class="current" </c:if>>
                            <span>${status.count}</span>
                        </a>
                    </li>
            </c:if>
        </c:forEach>     
```


因为需要知道总页数，所以在page类增加getTotalPage()
```
    public int getTotalPage() {
        int totalPage;
        // 假设总数是50，是能够被5整除的，那么就有10页
        if (0 == total % count) {
            totalPage = total / count;
        }
        // 假设总数是51，不能够被5整除的，那么就有11页
        else {
            totalPage = total / count + 1;
        }

        if (0 == totalPage) {
            totalPage = 1;
        }
        return totalPage;
    }
```






#疑问：
#1 Dao传递到数据库，不用connection类了，那 SSH  SSM 到底省略的是哪一个部分呢？



#2 servlet和session 是什么关系?servlet是什么内容？cookie和session是什么关系，而且cookie是怎么产生的，包括什么内容，客户端又是怎么获取的？


servlet 是怎么产生的？
  一个基于Java技术的Web组件，运行在服务器端，它由Servlet容器所管理，用于生成动态的内容。
  
  Servlet是平台独立的Java类，编写一个Servlet，实际上就是按照Servlet规范编写一个Java类。


Servlet被编译为平台独立的字节码，可以被动态地加载到支持Java技术的Web服务器中运行。


3句话，一句是说明servlet是服务器端的web组件，一个用于动态产生内容；一句是进一步阐述servlet是在服务器上但是独立于服务器的java类；最后一句是说明可以在服务器上运行，
  
   简单说说 servlet 是包括什么内容？
1.创建并放回一个包含基于请求的动态内容的JSP页面
2.创建可嵌入到现有HTML页面和JSP页面中的部分代码，与其他服务器资源进行通信
3.处理多个客户端连接，接收多个客户端输入，并将结果发送到多个客户机上。



#3 web.xml里面的welcome-file-list标签有什么作用？
web.xml在整个web中要有什么作用？
出现的问题：
当web.xml文件上有
```
<welcome-file-list>
    <welcome-file>/listStudent.jsp</welcome-file>
</welcome-file-list>
```
的时候 就会出现错误javax.servlet.ServletException: javax.servlet.jsp.JspTagException: 'end' < 0

但是删除了这段代码 就可以正常访问。

#4 还有为什么启动Tomcat成功后访问3次过滤器啊

tomcat 启动的时候 请求访问了index.jsp 

index.jsp 又进行请求转发 访问ListStudent.jsp

在ListServlet上  返回JSP页面时候也用了请求转发

所以3次请求，显示进入3次过滤器，请求转发是request的参数不变的，所以难怪后面2次请求的page都是Null，毕竟启动第一次请求的时候，page还没有得到值


#总结：（与后面学习的框架比较，封装了哪个部分）

## 1 JDBC使用的是 数据库本身的sql，没有框架封装。

像自己的就是使用mysql。

与数据库的交换数据中，对重复使用的语句进行了封装，封装成工具类BDUtil

传统JDBC方法连接数据库的过程中，需要 Connection类 ，DriverManager类，com.mysql.jdbc.Driver类

先说下流程：
    1 加载驱动类，使用的是反射技术，知道完整类名，然后进行创建类对象和加载
    2 数据库的ip=127.0.0.1 ，port=3306(mysql的专用) ，dataBase（要用的数据库名） , username , password 这5个参数中 ip , port , dataBase组成一句String语句， 作为Url。
    3 驱动管理类DriverManager使用方法GetConnection(url,username,password),得到connection类对象，也就是得到通向数据库的一条隧道。

作为工具类完成了，接下来就是进行查询


1   String类型的sql查询语句
2   得到DBUtil类对象返回一个Connection对象
3   根据connection对象的创造语句方法CreateStatement() 拿到Statement对象
4   根据语句对象statement的执行查询方法executeQuery（String sql）参数是上面的sql查询语句 返回类型ResultSet类
5   一个while循环，判断条件是ResultSet类是否还有下个元素，next（）方法， 循环体是你想要的内容对象，参数从ResultSet对象拿到。



进行增加，删除 ，更新的操作

1  String类型的sql执行增加 OR 删除 OR 更新 语句
2  根据得到的DBUtil对象返回一个Connection对象
3  根据Connection对象的准备语句方法preparedStatement(String  sql )得到PreparedStatement对象 
4  根据准备语句对象preparedstatement和参数sql的 ？号的排序，进行对preparedstatement对象赋值，就是说preparedstatement对象的值是你想要数据库改变的字段，字段是什么类型的，preparedstatement对象就Set什么类型的，比如我想改变日期Data ，preparedstatement对象就SetData(sql的？号排序，你要改变的日期值)
5  最后准备语句对象preparedstatement的执行方法execute（）



总的来说 无论是 查询  还是增删改 都有类似语句而且 重点都是赋值阶段
只是类型不同，
查询是返回RESULTSET对象，然后拿到自己想要数据的属性，参数是sql里面的字段， 最后得到想要的数据。
增删改是对  发送给数据库语句对象PreparedStatement 进行赋值，数据库得到数据。

虽然载体不同，但是发挥的是同一个作用，就是承担与数据库交接作用，类似是一部公交车，名字是ResultSet和PreparedStatement，里面的乘客是各种各样的类型的参数。
也有区别，ResultSet在数据库上乘客，然后再Connection车站的CreateStatement站台下乘客，
PreparedStatement在Connection车站的preparedStatement站台上乘客，然后在数据库下乘客。



## 2 出现的疑问：

参考：http://dustin.iteye.com/blog/44291
       https://www.cnblogs.com/gaojing/archive/2012/03/23/2413638.html

最开始使用的时候，不明白为什么首先要加载一个驱动类，之后就可以取得了Connection了，很好奇DriverManager是怎么获得那个驱动类的信息，后来看了下com.mysql.jdbc.Driver这个类的源代码。原来在com.mysql.jdbc.Driver类中有这么一段静态初始化代码：
```
package com.mysql.jdbc;

import java.sql.DriverManager;
import java.sql.SQLException;

public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    public Driver() throws SQLException {
    }

    static {
        try {
            DriverManager.registerDriver(new Driver());
        } catch (SQLException var1) {
            throw new RuntimeException("Can't register driver!");
        }
    }
}
```
也就是，**在Class.forName加载完驱动类，开始执行静态初始化代码时，会自动新建一个Driver的对象，并调用DriverManager.registerDriver把自己注册到DriverManager中去。
调用DriverManager的getConnection方法之前，保证相应的Driver类已经被加载到jvm中，并且完成了类的初始化工作就可以了**。


当然反射语句
```
Class.forName(com.mysql.jdbc.Driver);
```
可以成
```
com.mysql.jdbc.Driver driver = new com.mysql.jdbc.Driver();   
```


注意了，如果我们进行如下操作，程序是不能正常运行的，因为这样仅仅使Driver类被装载到jvm中，却没有进行相应的初始化工作。

```
com.mysql.jdbc.Driver driver = null;   
//or：   
ClassLoader cl = new ClassLoader();   
cl.loadClass("com.mysql.jdbc.Driver");  
```
JDBC是使用Bridge模式进行设计的，DriverManager就是其中的Abstraction，java.sql.Driver是Implementor，com.mysql.jdbc.Driver是Implementor的一个具体实现（请参考GOF的Bridge模式的描述）。
注意了，前一个Driver是一个接口，后者却是一个类，它实现了前面的Driver接口。
     
    Bridge模式中，Abstraction（DriverManager）是要拥有一个Implementor（Driver）的引用的，但是我们在使用过程中，并没有将Driver对象注册到DriverManager中去啊，这是怎么回事呢？
     jdk文档对Driver的描述中有这么一句：
     When a Driver class is loaded, it should create an instance of itself and register it with the DriverManager 
哦，原来是com.mysql.jdbc.Driver在装载完后自动帮我们完成了这一步骤, 其实就是下面这句
```
DriverManager.registerDriver(new Driver());
```
##ps1:
Class.forName(String) 与ClassLoader.loadClass(String)的区别
Class.forName(String): 加载类，并且执行类初始化；可以通过Class.forName(String, boolean, ClassLoader)第二个参数来仅仅加载类不执行初始化；
ClassLoader.loadClass(String): 仅仅加载类，不执行类初始化；

##ps2: 
有时会看到这种用法：
Class.forName(“com.mysql.jdbc.Driver”).newInstance();
这是没有必要的，正如前述，静态初始化已经new了一个Driver的对象，注册到DriverManager中去，在此再建立一个Driver对象则是完全没有必要的，浪费空间。

##ps3: 
结合ps1，Class.forName(“com.mysql.jdbc.Driver”);相当于：
ClassLoader loader = Thread.currentThread().getContextClassLoader();
Class cls = loader.loadClass(“com.mysql.jdbc.Driver”);
cls.newInstance();
这种方法的问题同ps2, 浪费了一个Driver对象；

##ps4:
在java 6中，引入了service provider的概念，即可以在配置文件中配置service（可能是一个interface或者abstract class）的provider（即service的实现类）。配置路径是：/META-INF/services/下面。详细信息见：http://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider
而java.sql.DriverManager也添加了对此的支持，因此，在JDK6中，DriverManager的查找Driver的范围为：
1）system property “jdbc.drivers” 中配置的Driver值；
2）用户调用Class.forName()注册的Driver
3）service provider配置文件java.sql.Driver中配置的Driver值。
因此，在jdk6中，其实是可以不用调用Class.forName来加载mysql驱动的，因为mysql的驱动程序jar包中已经包含了java.sql.Driver配置文件，并在文件中添加了com.mysql.jdbc.Driver.但在JDK6之前版本，还是要调用这个方法。

参考文档：
1）http://docs.oracle.com/javase/1.5.0/docs/api/java/sql/DriverManager.html
2）http://docs.oracle.com/javase/6/docs/api/index.html?java/sql/DriverManager.html
3）http://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider

#参考：
    https://www.jianshu.com/p/553fc76bb8eb




最快的学习方法：
按照它们的逻辑顺序流程撸一遍，不要先为什么，因为这时候我还什么都不懂，一个个弄懂它要说明的地方是不可能的，这时候只需要怎么用就可以了，轮子不是我这层次的人做的。

记住这是个工具，有时候是很容易玩成问为什么工具是这个样子的？ 因为别人这样规定的啊，就想你问为什么数学公式这个样子的，别人是这样发现的。

网上更多的解释是在解释工具为什么这样子，或者说它适用的环境，就像十字螺丝刀，适用十字螺丝。



  [1]: https://i.loli.net/2018/08/30/5b87d133bf85f.png
  [2]: https://i.loli.net/2018/09/01/5b8a4c1698f7f.jpg	2018-08-29 21:48:11
kumika	学生管理SSM版	# 学生管理SSM版

##  1 创建数据库：
```
drop database if exists student2
create database student2 default character set utf8
```

## 2 创建学生表格
 学生的属性：
            学号 studentid
            姓名 name
            年龄 age
            性别 sex
            出生日期 birthday
            表格id id
如果学生学号同时作为学生对象，数据库表格，这2个对象主键，实际操作会是否繁琐，所以在数据库表格上增加一个id，作为主键，这样学生学号更改，表格也不需要大的改变。

```
create table student(
    id  int(11) not null auto_increment primary key,
    studentid  int(11) not null  unique,
    name varchar(255) not null,
    age int(11) not null,
    sex varchar(255) not null,
    birthday date default null
)
```

# SSM环境搭建
在真正开始编写代码之前，我们首先需要先来搭建好我们的 SSM 环境

## 1 创建Maven weapp
首先新建工程，选择Maven标签，然后勾选上{create from archetype}

选择webapp:
![图1选择WEBAPP][1]

点击下一步，填写上【GroupId】和【ArtifactId】：
![TU2.jpg](https://i.loli.net/2018/09/08/5b92a3e35d249.jpg)

GroupId：项目组织唯一的标识符，实际对应 JAVA 的包的结构，也就是 main 目录下 java 的目录结构（包）
AritifactId：项目的唯一标识符，实际对应项目的名称，就是项目根目录的名称


然后是确认项目路径，这一步你可以看到 Maven 配置中的参数，不需要做改动，直接下一步就可以（图中的路径是我配置的本地 Maven 仓库的地址）：
![TU3.jpg](https://i.loli.net/2018/09/08/5b92a3e8cb257.jpg)



确认项目名称和路径，点击【Finish】即可：

![tu4.jpg](https://i.loli.net/2018/09/08/5b92a41baa5aa.jpg)

等待一会儿，控制台就会有创建成功的提示信息，我们把【Enable Auto-Import】点上，这个提示会在每次 pom.xml 有改动时出现，自动导入，省掉麻烦：

![tu5.jpg](https://i.loli.net/2018/09/08/5b92a41bad079.jpg)


## 2 搭建项目目录结构

下面就是 Maven 风格的 webapp 的默认目录结构：

![tu6.jpg](https://i.loli.net/2018/09/08/5b92a41b9fb8b.jpg)

注意： webapp 是默认没有 java 源文件也没有 test 目录的。
遵循 Maven 的统一项目结构，我们搭建出项目的完整目录结构如下图：

![tu7.jpg](https://i.loli.net/2018/09/08/5b92a45e9eb9f.jpg)


我们并没有使用 Log4j 来输出日志，而是使用 logback



## 3 配置文件内容

###在【pom.xml】文件中声明依赖的 jar 包 ：
--------------------------

(全部copy，别想自己一个个打进去，SB)

项目完成再粘贴上来
```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <packaging>war</packaging>

  <name>SM23</name>
  <groupId>SSM-StudentManage</groupId>
  <artifactId>SM23</artifactId>
  <version>1.0-SNAPSHOT</version>

  <build>
    <plugins>
      <plugin>
        <groupId>org.mortbay.jetty</groupId>
        <artifactId>maven-jetty-plugin</artifactId>
        <version>6.1.7</version>
        <configuration>
          <connectors>
            <connector implementation="org.mortbay.jetty.nio.SelectChannelConnector">
              <port>8888</port>
              <maxIdleTime>30000</maxIdleTime>
            </connector>
          </connectors>
          <webAppSourceDirectory>${project.build.directory}/${pom.artifactId}-${pom.version}</webAppSourceDirectory>
          <contextPath>/</contextPath>
        </configuration>
      </plugin>
    </plugins>
  </build>


  <properties>
    <!-- 设置项目编码编码 -->
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    <!-- spring版本号 -->
    <spring.version>4.3.5.RELEASE</spring.version>
    <!-- mybatis版本号 -->
    <mybatis.version>3.4.1</mybatis.version>
  </properties>

  <dependencies>
    <!--dependency>
      <groupId>SSM-StudentManage</groupId>
      <artifactId>[the artifact id of the block to be mounted]</artifactId>
      <version>1.0-SNAPSHOT</version>
    </dependency-->

    <!-- jstl标签 -->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>jstl</artifactId>
      <version>1.2</version>
    </dependency>
    <dependency>
      <groupId>org.apache.taglibs</groupId>
      <artifactId>taglibs-standard-impl</artifactId>
      <version>1.2.5</version>
    </dependency>


    <!-- java ee -->
    <dependency>
      <groupId>javax</groupId>
      <artifactId>javaee-api</artifactId>
      <version>7.0</version>
    </dependency>

    <!-- 单元测试 -->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
    </dependency>

    <!-- 实现slf4j接口并整合 -->
    <dependency>
      <groupId>ch.qos.logback</groupId>
      <artifactId>logback-classic</artifactId>
      <version>1.2.2</version>
    </dependency>

    <!-- JSON -->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.8.7</version>
    </dependency>


    <!-- 数据库 -->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.41</version>
      <scope>runtime</scope>
    </dependency>

    <!-- 数据库连接池 -->
    <dependency>
      <groupId>com.mchange</groupId>
      <artifactId>c3p0</artifactId>
      <version>0.9.5.2</version>
    </dependency>

    <!-- MyBatis -->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>${mybatis.version}</version>
    </dependency>

    <!-- mybatis/spring整合包 -->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis-spring</artifactId>
      <version>1.3.1</version>
    </dependency>

    <!-- Spring -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-core</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-beans</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jdbc</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-tx</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-web</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-test</artifactId>
      <version>${spring.version}</version>
    </dependency>
  </dependencies>
</project>

```

`<build>` 标签是默认生成的
我们在 `<properties>` 中声明了编码格式以及使用的 spring 和 mybatis 的版本号，然后在 `<dependencies>` 中声明了具体的 jar 包

###在【web.xml】中声明编码过滤器并配置 DispatcherServlet ：
-----------------------------------------
```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">

  <!-- 编码过滤器 -->
  <filter>
    <filter-name>encodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
      <param-name>encoding</param-name>
      <param-value>UTF-8</param-value>
    </init-param>
  </filter>

  <filter-mapping>
    <filter-name>encodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>

  <!-- 配置DispatcherServlet -->
  <servlet>
    <servlet-name>SpringMVC</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!-- 配置springMVC需要加载的配置文件-->
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:spring-*.xml</param-value>
    </init-param>
    <!--
     1   load-on-startup 元素标记容器是否应该在web应用程序启动的时候就加载这个servlet，(实例化并调用其init()方法)。
     2   它的值必须是一个整数，表示servlet被加载的先后顺序。
     3   如果该元素的值为负数或者没有设置，则容器会当Servlet被请求时再加载。
     4    如果值为正整数或者0时，表示容器在应用启动时就加载并初始化这个servlet，值越小，
         Servlet的优先级越高，就越先被加载。值相同时，容器就会自己选择顺序来加载。
    -->
    <load-on-startup>1</load-on-startup>
    <async-supported>true</async-supported>
  </servlet>

  <servlet-mapping>
    <servlet-name>SpringMVC</servlet-name>
    <!-- 匹配所有请求 -->
    <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>
```

###在【spring-mybatis.xml】中完成 spring 和 mybatis 的配置：
----------------------------------------------
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">

    <!-- 扫描service包下所有使用注解的类型 -->
    <context:component-scan base-package="sm23.service"/>

    <!-- 配置数据库相关参数properties的属性：${url} -->
    <context:property-placeholder location="classpath:jdbc.properties"/>

    <!-- 数据库连接池 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driver}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
        <property name="user" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
        <property name="maxPoolSize" value="${c3p0.maxPoolSize}"/>
        <property name="minPoolSize" value="${c3p0.minPoolSize}"/>
        <property name="autoCommitOnClose" value="${c3p0.autoCommitOnClose}"/>
        <property name="checkoutTimeout" value="${c3p0.checkoutTimeout}"/>
        <property name="acquireRetryAttempts" value="${c3p0.acquireRetryAttempts}"/>
    </bean>

    <!-- 配置SqlSessionFactory对象 -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <!-- 注入数据库连接池 -->
        <property name="dataSource" ref="dataSource"/>
        <!-- 扫描entity包 使用别名 -->
        <property name="typeAliasesPackage" value="sm23.entity"/>
        <!-- 扫描sql配置文件:mapper需要的xml文件 -->
        <property name="mapperLocations" value="classpath:mapper/*.xml"/>
    </bean>

    <!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 -->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <!-- 注入sqlSessionFactory -->
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
        <!-- 给出需要扫描Dao接口包 -->
        <property name="basePackage" value="sm23.dao"/>
    </bean>

    <!-- 配置事务管理器 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!-- 注入数据库连接池 -->
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- 配置基于注解的声明式事务 -->
    <tx:annotation-driven transaction-manager="transactionManager"/>
    
</beans>
```


###在【spring-mvc.xml】中完成 Spring MVC 的相关配置：
--------------------------------------
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd">

    <!-- 扫描web相关的bean -->
    <context:component-scan base-package="sm23.controller"/>


    <!-- 开启SpringMVC注解模式 -->
    <mvc:annotation-driven/>

    <!-- 静态资源默认servlet配置 -->
    <mvc:default-servlet-handler/>


    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
        <property name="suffix" value=".jsp"/>
        <property name="prefix" value="/WEB-INF/views/"/>
    </bean>
    
</beans>
```

### 在【jdbc.properties】中配置 c3p0 数据库连接池：
----------------------------------
```
#驱动包
jdbc.driver=com.mysql.jdbc.Driver
#数据库地址
jdbc.url=jdbc:mysql://localhost:3306/student2?userUnicode=true&characterEncoding=utf8
#用户名
jdbc.username=root
#密码
jdbc.password=123
#最大连接数
c3p0.maxPoolSize=30
#最小连接数
c3p0.minPoolSize=10
#关闭连接后不自动commit
c3p0.autoCommitOnClose=false
#获取连接超时时间
c3p0.checkoutTimeout=10000
#当获取连接失败重试次数
c3p0.acquireRetryAttempts=2
```


###在【logback.xml】中完成日志输出的相关配置：
---------------------------
```
<?xml version="1.0" encoding="UTF-8" ?>
<configuration debug="true">
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
    </appender>

    <root>
        <appender-ref ref="STDOUT"/>
    </root>
</configuration>
```


以上就完成了 SSM 框架的基本配置：

添加进了 SSM 项目所需要的 jar 包
配置好了 spring/mybatis/spring MVC 的相关配置信息（自动扫描 SM23 包下的带有注解的类）
通过 xml 配置的方式配置好了日志和数据库



## 4 实体类设计

实体类仅仅是对数据库中表的一一映射（表中字段名应该和实体类中的名称一一对应），同时可能还需要兼顾对业务能力的支持。


###在entiry包下创建Student类
-------------------
```
import java.util.Date;

public class Student {
    private int id;
    private int studentid;
    private String name;
    private int age;
    private String sex;
    private Date birthday;
 
     /* getter and setter */
}
```


## 5 Dao类的设计


DAO，即 Date Access Object，数据库访问对象，就是对数据库相关操作的封装，让其他地方看不到 JDBC 的代码。

###在Dao包下创建【StudentDao】接口：
-----------------------
```
import org.springframework.stereotype.Repository;
import sm23.entity.Student;
import java.util.List;
@Repository
public interface StudentDao {
    int getTotal();

    void addStudent(Student student);

    void deleteStudent(int id);

    void updateStudent(Student student);

    Student getStudent(int id);

    List<Student> list(int start, int count);

}
```

###然后在【resources/mapper】下创建好对应的映射文件【StudengDao.xml】
------------------------------------------------

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
        
<!-- 将namespace的值设置为DAO类对应的路径 -->
<mapper namespace="sm23.dao.StudentDao">
    <resultMap id="studentMap" type="sm23.entity.Student">
        <id column="id" property="id"/>
        <result column="studentid" property="studentid"/>
        <result column="name" property="name"/>
        <result column="age" property="age"/>
        <result column="sex" property="sex"/>
        <result column="birthday" property="birthday" javaType="java.sql.Date"/>
    </resultMap>

    <!-- 查询数据条目 -->
    <select id="getTotal" resultType="int">
        select count(*) from student
    </select>

    <!-- 增加一条数据 -->
    <insert id="addStudent" parameterType="int">
      insert into student VALUES (null,#{studentid},#{name},#{age},#{sex},#{birthday})
    </insert>

    <!-- 删除一条数据 -->
    <delete id="deleteStudent" parameterType="int">
        delete from student where id=#{id}
    </delete>

    <!-- 更新一条数据 -->
    <update id="updateStudent" parameterType="sm23.entity.Student">
        update student set studentid=#{studentid},id=#{id},name=#{name},age=#{age},sex=#{sex},birthday=#{birthday}
        where id=#{id}
    </update>

    <!-- 查询一条数据 -->
    <select id="getStudent" resultMap="studentMap" parameterType="int">
        SELECT  * from student where id=#{id}
    </select>

    <!-- 查询从start位置开始的count条数据-->
    <select id="list" resultMap="studentMap">
        SELECT * from  student ORDER BY  studentid desc limit #{param1},#{param2}
    </select>
</mapper>
```


## 6 业务类设计

问题： 为什么不直接使用 Dao 类而是还要在上面封装一层 Service 层呢？
回答：
基于责任分离的原则，Dao 层就应该专注于对数据库的操作，而在 Service 层我们可以增加一些非 CRUD 的方法去更好的完成本身抽离出来的 service 服务（业务处理）。

###在【sm23.service】包下创建【StudentService】接口：
--------------------------------------
```
import sm23.entity.Student;
import java.util.List;

public interface StudentService {
    int getTotal();

    void addStudent(Student student);

    void deleteStudent(int id);

    void updateStudent(Student student);

    Student getStudent(int id);

    List<Student> list(int start, int count);
}
```


###并在相同包名下创建实现类【StudentServiceImpl】：
---------------------------------
```
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import sm23.dao.StudentDao;
import sm23.entity.Student;
import java.util.List;
@Service
public class StudentServiceImpl implements StudentService {

    @Autowired
    StudentDao studentDao;

    public int getTotal() {
        return studentDao.getTotal();
    }

    public void addStudent(Student student) {
        studentDao.addStudent(student);
    }

    public void deleteStudent(int id) {
        studentDao.deleteStudent(id);
    }

    public void updateStudent(Student student) {
        studentDao.updateStudent(student);
    }

    public Student getStudent(int id) {
        return studentDao.getStudent(id);
    }

    public List<Student> list(int start, int count) {
        return studentDao.list(start,count);
    }
}
```



## 7 功能开发

在【sm23.controller】包下创建【StudentController】控制器，代码基本上都是复制黏贴之前在 Servlet 中的代码：

```
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
import sm23.Util.Page;
import sm23.entity.Student;
import sm23.service.StudentService;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
@Controller
public class StudentController {
    @Autowired
    StudentService studentService;

    @RequestMapping("/addStudent")
    public String addStudent(HttpServletRequest request, HttpServletResponse response) {

        Student student = new Student();
        int studentID = Integer.parseInt(request.getParameter("studentID"));
        String name = request.getParameter("name");
        int age = Integer.parseInt(request.getParameter("age"));
        String sex = request.getParameter("sex");

        Date birthday = null;

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        try {
            birthday = sdf.parse(request.getParameter("birthday"));
        } catch (ParseException e) {
            e.printStackTrace();
        }

        student.setStudentid(studentID);
        student.setName(name);
        student.setAge(age);
        student.setSex(sex);
        student.setBirthday(birthday);

        studentService.addStudent(student);

        return "redirect:listStudent";
    }

    @RequestMapping("/deleteStudent")
    public String deleteStudent(int id) {
        studentService.deleteStudent(id);
        return "redirect:listStudent";
    }

    @RequestMapping("/editStudent")
    public ModelAndView editStudent(int id) {
        ModelAndView mav = new ModelAndView("editStudent");
        Student student = studentService.getStudent(id);
        mav.addObject("student", student);
        return mav;
    }

    @RequestMapping("/updateStudent")
    public String updateStudent(HttpServletRequest request, HttpServletResponse response) {
        Student student = new Student();

        int id = Integer.parseInt(request.getParameter("id"));
        int studentid = Integer.parseInt(request.getParameter("studentID"));
        int age = Integer.parseInt(request.getParameter("age"));
        String name = request.getParameter("name");
        String sex = request.getParameter("sex");
        Date birthday = null;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        try {
            birthday = sdf.parse(request.getParameter("birthday"));
        } catch (ParseException e) {
            e.printStackTrace();
        }

        student.setId(id);
        student.setStudentid(studentid);
        student.setName(name);
        student.setSex(sex);
        student.setBirthday(birthday);

        studentService.updateStudent(student);
        return "redirect:listStudent";
    }

    @RequestMapping("/listStudent")
    public String listStudent(HttpServletRequest request,HttpServletResponse response) {
        int start = 0;
        int count = 10;

        try {
            start = Integer.parseInt(request.getParameter("page.start"));
            count = Integer.parseInt(request.getParameter("page.count"));
        } catch (Exception e) {

        }

        Page page = new Page(start, count);

        List<Student> students = studentService.list(page.getStart(), page.getCount());
        int total = studentService.getTotal();
        page.setTotal(total);

        request.setAttribute("students", students);
        request.setAttribute("page", page);

        return "listStudent";
    }
}
```


##  8 JSP 文件也直接黏之前的就好了

###listStudent:
```
<!DOCTYPE html>
<%@ page contentType="text/html;charset=UTF-8" language="java"
         pageEncoding="UTF-8" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

<html>
<head>

    <%-- 引入JQ和Bootstrap --%>
    <script src="../../js/jquery/2.0.0/jquery.min.js"></script>
    <link href="../../css/bootstrap/3.3.7/bootstrap.min.css" rel="stylesheet">
    <script src="../../js/bootstrap/3.3.7/bootstrap.min.js"></script>
    <link href="../../css/style.css" rel="stylesheet">

    <title>学生管理页面 - 首页</title>

    <script>
        $(function () {
            $("ul.pagination li.disabled a").click(function () {
                return false;
            });

            $("#addForm").submit(function () {
                if (!checkEmpty("studentID", "学号"))
                    return false;
                if (!checkEmpty("name", "姓名"))
                    return false;
                if (!checkEmpty("age", "年龄"))
                    return false;
                return true;
            })
        });

        function del() {
            var msg = "您真的确定要删除吗？\n\n请确认！";
            if (confirm(msg) == true) {
                return true;
            } else {
                return false;
            }
        }

        function checkEmpty(id, name) {
            var value = $("#" + id).val();
            if (value.length == 0) {
                alert(name + "不能为空");
                $("#" + id).focus();
                return false;
            }
            return true;
        }
    </script>
</head>

<body>

<div class="listDIV">
    <table class="table table-striped table-bordered table-hover table-condensed">

        <caption>学生列表 - 共${page.total}人</caption>
        <thead>
        <tr class="success">
            <th>学号</th>
            <th>姓名</th>
            <th>年龄</th>
            <th>性别</th>
            <th>出生日期</th>

            <th>编辑</th>
            <th>删除</th>
        </tr>
        </thead>
        
        <tbody>
        <c:forEach items="${students}" var="s" varStatus="status">
            <tr>
                <td>${s.studentid}</td>
                <td>${s.name}</td>
                <td>${s.age}</td>
                <td>${s.sex}</td>
                <td>${s.birthday}</td>

                <td><a href="/editStudent?id=${s.id}"><span class="glyphicon glyphicon-edit"></span> </a></td>
                <td><a href="/deleteStudent?id=${s.id}" onclick="javascript:return del();"><span
                        class="glyphicon glyphicon-trash"></span> </a></td>
            </tr>
        </c:forEach>
        </tbody>
    </table>
</div>

<nav class="pageDIV">
    <ul class="pagination">
        <li <c:if test="${!page.HasPreviouse()}">class="disabled"</c:if>>
            <a href="?page.start=0">
                <span>«</span>
            </a>
        </li>

        <li <c:if test="${!page.HasPreviouse()}">class="disabled"</c:if>>
            <a href="?page.start=${page.start-page.count}">
                <span>‹</span>
            </a>
        </li>

        <c:forEach begin="0" end="${page.totalPage-1}" varStatus="status">

            <c:if test="${status.count*page.count-page.start<=30 && status.count*page.count-page.start>=-10}">
                <li <c:if test="${status.index*page.count==page.start}">class="disabled"</c:if>>
                    <a
                            href="?page.start=${status.index*page.count}"
                            <c:if test="${status.index*page.count==page.start}">class="current"</c:if>
                    >${status.count}</a>
                </li>
            </c:if>
        </c:forEach>

        <li <c:if test="${!page.HasNext()}">class="disabled"</c:if>>
            <a href="?page.start=${page.start+page.count}">
                <span>›</span>
            </a>
        </li>
        <li <c:if test="${!page.HasNext()}">class="disabled"</c:if>>
            <a href="?page.start=${page.last}">
                <span>»</span>
            </a>
        </li>
    </ul>
</nav>

<div class="addDIV">
    <div class="panel panel-success">
        <div class="panel-heading">
            <h3 class="panel-title">增加学生</h3>
        </div>
        <div class="panel-body">

            <form method="post" id="addForm" action="/addStudent" role="form">
                <table class="addTable">
                    <tr>
                        <td>学号：</td>
                        <td><input type="text" name="studentID" id="studentID" placeholder="请在这里输入学号"></td>
                    </tr>
                    <tr>
                        <td>姓名：</td>
                        <td><input type="text" name="name" id="name" placeholder="请在这里输入名字"></td>
                    </tr>
                    <tr>
                        <td>年龄：</td>
                        <td><input type="text" name="age" id="age" placeholder="请在这里输入年龄"></td>
                    </tr>
                    <tr>
                        <td>性别：</td>
                        <td><input type="radio" checked class="radio radio-inline" name="radio" value="男"> 男
                            <input type="radio" class="radio radio-inline" name="radio" value="女"> 女
                        </td>
                    </tr>
                    <tr>
                        <td>出生日期：</td>
                        <td><input type="date" name="birthday" id="birthday" placeholder="请在这里输入出生日期"></td>
                    </tr>
                    <tr class="submitTR">
                        <td colspan="2" align="center">
                            <button type="submit" class="btn btn-success">提 交</button>
                        </td>
                    </tr>
                </table>
            </form>
        </div>
    </div>
</div>
</body>
</html>
```

### editStudent:

```
<!DOCTYPE html>
<%@ page contentType="text/html;charset=UTF-8" language="java"
         pageEncoding="UTF-8" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<head>
    <%-- 引入JQ和Bootstrap --%>
    <script src="js/jquery/2.0.0/jquery-2.0.0.min.js"></script>
    <link href="../../css/bootstrap/3.3.7/bootstrap.min.css" rel="stylesheet">
    <script src="../../js/bootstrap/3.3.7/bootstrap.min.js"></script>
    <link href="../../css/style.css" rel="stylesheet">
    <title>学生管理页面-编辑页面</title>
</head>
<body>
<div class="editDIV">
    <div class="panel panel-success">
        <div class="panel-heading">
            <h3 class="panel-title">编辑学生</h3>
        </div>
        <div class="panel-body">
                  <form action="/updateStudent"  method="post" role="form">
                          <table class="editTable">
                                <tr>
                                    <td>学号：</td>
                                    <%--
                                    placeholder 属性规定可描述输入字段预期值的简短的提示信息
                                    适用于下面的 input 类型：text、search、url、tel、email 和 password
                                    其实就是输入框里面的提示语句，你输入的时候会消失
                                    --%>
                                    <td><input type="text" id="studentID" name="studentID" value="${student.studentid}" placeholder="请在这里输入学号"></td>
                                </tr>

                                <tr>
                                    <td>姓名：</td>
                                    <td><input type="text" id="name" name="name" value="${student.name}" placeholder="请在这里输入名字"></td>
                                </tr>

                                <tr>
                                    <td>年龄：</td>
                                    <td><input type="text" id="age" name="age" value="${student.age}" placeholder="请在这里输入年龄"></td>
                                </tr>
                                <tr>
                                    <td>出生日期：</td>
                                    <td><input type="date" id="birthday" name="birthday" value="${student.birthday}"
                                               placeholder="请在这里输入日期"></td>
                                </tr>
                                <tr>
                                    <td>性别：</td>
                                    <td>
                                        <input type="radio" <c:if test="${student.sex == '男'}">checked</c:if> class="radio radio-inline" name="radio" value="男"> 男
                                        <input type="radio" <c:if test="${student.sex == '女'}">checked</c:if> class="radio radio-inline" name="radio" value="女"> 女

                                       <%--
                                        两种写法都可以，区别在于 下面这种是从request上得到的性别，上面的相当于重新选择
                                       <input type="radio" <c:if test="${student.sex == '男'}">checked</c:if>
                                               name="radio" value="男"> 男<br>
                                        <input type="radio" <c:if test="${student.sex == '女'}">checked</c:if>
                                               name="radio" value="女" > 女<br>--%>
                                    </td>
                                </tr>
                                <tr class="submitTR">
                                    <td colspan="2" align="center">
                                        <input type="hidden" name="id"  value="${student.id}">
                                        <button class="btn btn-success" type="submit">提交按钮</button>
                                    </td>
                                </tr>
                      </table>
                  </form>
             </div>
         </div>
    </div>
</div>
</body>
</html>
```

### style.css 文件：

```
body {
    padding-top: 60px;
}

div.listDIV {
    width: 600px;
    margin: 0 auto;
}

div.editDIV {
    width: 400px;
    margin: 0 auto;
}

nav.pageDIV {
    text-align: center;
}

div.addDIV {
    width: 300px;
    margin: 0 auto;
}

table.addTable {
    width: 100%;
    padding: 5px;
}

table.addTable td {
    padding: 5px;
}

table.editTable {
    width: 100%;
    padding: 5px;
}

table.editTable td {
    padding: 5px;
}
```


## 项目整体结构：
=======

![tujiegou.jpg](https://i.loli.net/2018/09/08/5b92a45e9f6e1.jpg)
===============================fenge============================
![tujiegou2.jpg](https://i.loli.net/2018/09/08/5b92a45e95f14.jpg)

#项目总结：

##spring--mybatis.xml
是 数据库和服务器之间连接的配置文件

注解扫描包：service类

连接数据库信息bean ：dataSource，driver,url````

sql的工厂bean： 
         需要连接数据库信息bean
       
         扫描mapping的xml文件的位置

扫描Dao的接口包：（动态实现接口）
        需要sql工厂bean
        
        需要扫描Dao的接口包


连接数据库的事务管理器bean:
        需要连接的数据库信息，dataSource


基于注解的声明式事务管理
        需要连接数据库的事务管理器


##spring-MVC.xml:
    是 服务器 和 用户请求，网页前端响应的配置文件

扫描web相关的bean：
    需要Controller类位置
    
MVC开启注解模式：声明驱动

NVC的servlet静态资源配置 default-servlet-handler

配置内部视图解析器：internalResourceViewResolver==>内部资源视图解析器
    需要JstlView类
    需要前缀解析：/web-inf/jsp/
    需要后缀解析：.jsp


#疑问

1 idea部署了项目，然后自动访问Index.jsp，但是我没有放index.jsp，在web.xml里面增加了welcome-file标签，结果没有访问标签里面的网址，为什么？？？
------------------------------------------------------------------------


#参考：
https://www.jianshu.com/p/6a594fbea51d


  [1]: https://i.loli.net/2018/09/08/5b92a3ad30bcd.jpg	2018-09-05 14:47:07
kumika	模仿天猫实战SSM--项目起步	# 模仿天猫实战SSM--项目起步

#逆向工程和数据库表结构

---

# 1 需求分析

首先要确定实现哪些功能，需要对需求进行完整的分析，才能在编写项目的时候有条不紊，**我们的目的很明确：就是模仿天猫前端+ 自己实现后端。**并且尽最大努力去降低这个项目的复杂度（毕竟高深的东西不懂）


## 1 前端需求分析

**规定：全天猫没有店铺，就只有唯一一家叫做 Tmall 的商家，卖所有的东西。**



    1 数据的显示：

**首页数据显示分析：**
首先是搜索栏下方的九个商品，需要从数据库中取出销量最高的几个产品，关于标红的关键字，是要满足一定条件的，比如：这一个星期内销量超过多少...

图1

接着是分类导航栏，首先是商品分类右边固定的2个连接{天猫超市}和{天猫国际}，还有紧跟着的8个链接，这个可以设计成一个表单，存储它显示的文字和链接过去的地址，然后是具体的16个分类以及轮播：

图2

下面的具体产品展示比较复杂，我们可以自己做一下简化，比如就展示几个产品比较多的固定的几个分类就好了，其他的就直接舍弃：

**总结：总之就是需要显示各种数据库的数据**

    2 登录/注册页


需要有一个登录/注册页，能够完成用户的登录和注册功能，并能提供基础的例如判断空值等功能。



    3 产品搜索页


图3

左上角的图标我们可以统一简化成 Tmall 的图片，商品图片，我们可以整个大分类使用一张图，主要就是实现排序功能还有搜索功能


    4 产品展示页


天猫原生的产品展示页有些复杂，我们可以自己简化一下，就不要选这么多东西，都是一口价，

图4

另外下面规格参数和评价都不能省略

图5


    5购物车/购买页面


## 2 表结构设计

根据对于前端的分析，数据库有了一些眉目，为了简化项目的难度，所以我们需要自己想点办法，先来构思一下大概需要一些什么样的表：

图6

大概就想出来需要用到这些表，一个一个来创建它们：

### 2.1 分类表

首先我们需要一个表来存储我们的分类信息，也就是【女装/内衣】、【男装/运动户外】在内的 16 个分类，为了高度一致，这 16 个分类不能多也不能少。

图7


为了简化任务，可以观察出，【热门手机】、【特色手机】分栏下的东西都是【手机/数码/电脑办公】类别里的东西，所以我们直接砍掉，右边的一些图片超链也给直接砍掉，我们规定每一行显示的产品数目就可以了，这样就简单多了。

```
create table category(
    id int(11) not null auto_increment primary key comment'唯一索引',
    name varchar(255) not null comment'分类的名字'
)

```

### 2.2 商品分类右边的超链表

即在【天猫国际】右边的 8 个超链，我们单独新建一个表来存储超链显示的文字和链接的地址，这样就可以任意的修改其内容：

图8

百度翻译【推荐链接】翻译为【Referral links】，那我们也这么给我们的表命名好了：

```
create table referal_link(
    id int(11) not null auto_increment primary key comment'唯一索引id',
    text varchar(255) not null comment'超链显示的文字',
    link varchar(255) not null comment'超链的地址'
)
```
### 2.3 产品表

每个分类下都要一定的产品，这些产品还有自己的一些属性，所以另外需要属性表，这个表另外创建，我们先来观察一下一个产品表需要一些什么东西：


图9

用于展示的 5 张**图片**
**产品名称**
**小标题**（即名称下面一排标红的小字）
**价格**（就一口价，没别的）
**销量**（别月销量了，能简化就简化一下）
**累计评价**（还需要设计一个评价表）
**库存**
**属性**（需要关联另外的属性表）


```
create table product(
    id int(11) not null auto_increment primary key comment'唯一索引id',
    name varchar(255) not null comment'产品名称',
    sub_title varchar(255) default null comment'产品的小标题',
    price float default null comment'产品的价格',
    sale int(11) default null comment'产品的销量',
    stock int(11) default null comment'库存',
    
    category_id int(11) default null comment'对应的分类Id',
--    //上面的category_id是作为外键， 要与分类表的id字段链接
    constraint fk_product_category foreign key (category_id) references category(id)
   
)
```
**注意：** 其中产品图片，累计评价，属性都作为单独的表存在并让当前表的 id 作为外键



###  2.4 属性表

图10

去掉详细的规格参数划分，其实属性也就是一个名字而已（简化简化简化）。


```
create table property(
    id int(11) not null auto_increment primary key comment'唯一索引id',
    name varchar(255) default null comment'属性名称',
    //属性的外键
    product_id int(11) not null comment'对应的产品id',
    constraint fk_property_product foreign key (product_id) references   product(id)
)
```

    突然想到的问题：
    每一个产品的属性其实是很多的，如果每一个产品都对应很多属性的话，对于天猫这样的数据量来说，应该会让数据库爆炸的吧...
    改进方法：
    将属性表关联到 category 表上，因为其实每一个分类下的产品的属性差不多！


**修改数据库**
根据以上问题，修改一下数据库表之间的关系

图11

并将属性表的外键修改为 category 的主键：

```
create table property(
    id int(11) not null auto_increment primary key comment'唯一索引id',
    name varchar(255) default null comment'属性名称',
--    //外键
    category_id int(11) not null comment'对应分类的id',
    constraint fk_property_category foreign key(category_id) references category(id)
)
```
### 2.5 属性值表

其中就是保存了对应属性的值，并且应该有两个外键，一个指向 Property 表，而另一个则指向 Product 表


```
create table property_value(
    id int(11) not null auto_increment primary key comment'唯一索引id',
    value varchar(255) default null comment'具体的属性值',
        //2个外键，一个指向产品表，一个指向属性表
    product_id int(11) not null comment'对应产品id',
    property_id int(11) not null comment'对应属性id',
    
    constraint fk_property_value_product foreign key(product_id) references product(id),
    constraint fk_property_value_property foreign key (property_id) references property(id)
)
```

### 2.6 产品图片表
这个表名义上是保存了产品的图片，其实只是保存了产品图片的位置即图片名称，我们可以规定所有的产品图片都放在一个统一的文件夹下面，然后**通过 id 来获取对应名称的图片：**


```
create table product_image(
    id int(11) not null auto_increment primary key comment'唯一索引id',
    //外键
    product_id int(11) not null comment'对应产品id',
    
    constraint fk_product_image_product foreign key (product_id) references product(id)
)

```

**注意：** 我们通过把产品图片的文件命名为 id.jpg ，然后通过相对路径来获取到产品图片



### 2.7 用户表

用户表很简单，也没有权限之类的东西

```
create table user(
    id int(11) not null auto_increment primary key comment'唯一索引id',
    name varchar(255) not null comment'用户名称',
    password varchar(255) not null comment'用户密码'
)
```

我们或许会在之后把密码弄成 “*********” 这种形式的，但是现在一切为了简单！



### 2.8 评价表

图12

评价表对应了用户和产品两个表，也比较简单，我们为了简单，把上面红色的部分全部砍掉，因为没有商家，所以也不需要回复用户的评价，都砍掉砍掉！

```
create table review (
    id int(11) not null auto_increment primary key comment'唯一索引id',
    content varchar(4000) default null comment'评价内容',
    createDate datetime default null comment'评价时间',
    //外键
    user_id int(11) not null comment'对应用户Id',
    product_id int(11) not null comment'对应产品id',
    
    constraint fk_review_user foreign key (user_id) references user(id),
    constraint fk_review_product foreign key (product_id) references product(id)
)
```

### 2.9 订单表

由于 Order 是 MySql 的一个关键字，所以我们在订单表的最后添加一个下划线：

```
create table order_(
    id int(11) not null auto_increment primary key COMMENT '唯一索引id',
    order_code varchar(255) not null COMMENT '订单号',
    address varchar(255) not null COMMENT '收货地址',
    post varchar(255) not null COMMENT '邮编',
    receiver varchar(255) not null COMMENT '收货人姓名', 
    mobile varchar(255) not null COMMENT '手机号码',
    user_message varchar(255) not null COMMENT '用户备注的信息',
    create_date datetime default null COMMENT '订单创建时间',
    pay_date datetime default null COMMENT '订单支付时间',
    delivery_date datetime default null COMMENT '发货日期',
    confirm_date datetime default null COMMENT '确认收货日期',
    status varchar(255) not null COMMENT '订单状态',
    //外键
    user_id int(11) default null COMMENT '对应的用户id',
    
    constraint fk_order_user foreign key (user_id) references user(id)
)
```

### 2.10 订单表

一个订单里面可能有多个订单项，一个产品也可能对应多个订单项，所以这个表应该有两个外键：

```
create table order_item(
    id int(11) not null auto_increment primary key  COMMENT '唯一索引id'comment'邮编',
    number int(11) not null COMMENT '对应产品购买的数量',
  --  //外键
    product_id int(11) not null COMMENT '对应产品id',
    order_id int(11) not null COMMENT '对应订单id',
    
    constraint fk_order_item_product foreign key (product_id) references product(id),
    constraint fk_order_item_order foreign key (order_id) references
    order_(id)
)
```

##汇总：
我们在创建表之前，应该创建一个新的数据库，并命名为【tmall_ssm】

```
drop database if exists tmall_ssm
create databse tmall_ssm default character set utf8
```

总的10 个表格进行合起来
```
DROP DATABASE IF EXISTS tmall_ssm;
CREATE DATABASE tmall_ssm DEFAULT CHARACTER SET utf8;

use tmall_ssm;

CREATE TABLE category (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT '唯一索引id',
  name varchar(255) NOT NULL COMMENT '分类的名字',
  PRIMARY KEY (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE referal_link (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT '唯一索引id',
  text varchar(255) NOT NULL COMMENT '超链显示的文字',
  link varchar(255) NOT NULL COMMENT '超链的地址',
  PRIMARY KEY (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE product (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT '唯一索引id',
  name varchar(255) NOT NULL COMMENT '产品的名称',
  sub_title varchar(255) DEFAULT NULL COMMENT '小标题',
  price float DEFAULT NULL COMMENT '价格',
  sale int(11) DEFAULT NULL COMMENT '销量',
  stock int(11) DEFAULT NULL COMMENT '库存',
  category_id int(11) DEFAULT NULL COMMENT '对应的分类id',
  PRIMARY KEY (id),
  CONSTRAINT fk_product_category FOREIGN KEY (category_id) REFERENCES category (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE property (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT '唯一索引id',
  name varchar(255) DEFAULT NULL COMMENT '属性名称',
  category_id int(11) NOT NULL COMMENT '对应的分类id',
  PRIMARY KEY (id),
  CONSTRAINT fk_property_category FOREIGN KEY (category_id) REFERENCES category(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE property_value (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT '唯一索引id',
  product_id int(11) NOT NULL COMMENT '对应产品id',
  properti_id int(11) NOT NULL COMMENT '对应属性id',
  value varchar(255) DEFAULT NULL COMMENT '具体的属性值',
  PRIMARY KEY (id),
  CONSTRAINT fk_property_value_property FOREIGN KEY (properti_id) REFERENCES property (id),
  CONSTRAINT fk_property_value_product FOREIGN KEY (product_id) REFERENCES product (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE product_image (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT '唯一索引id',
  product_id int(11) DEFAULT NULL COMMENT '对应的产品id',
  PRIMARY KEY (id),
  CONSTRAINT fk_product_image_product FOREIGN KEY (product_id) REFERENCES product (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE user (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT '唯一索引id',
  name varchar(255) NOT NULL COMMENT '用户名称',
  password varchar(255) NOT NULL COMMENT '用户密码',
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE review (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT '唯一索引id',
  content varchar(4000) DEFAULT NULL COMMENT '评价内容',
  user_id int(11) NOT NULL COMMENT '对应的用户id',
  product_id int(11) NOT NULL COMMENT '对应的产品id',
  createDate datetime DEFAULT NULL COMMENT '评价时间',
  PRIMARY KEY (id),
  CONSTRAINT fk_review_product FOREIGN KEY (product_id) REFERENCES product (id),
  CONSTRAINT fk_review_user FOREIGN KEY (user_id) REFERENCES user (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE order_ (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT '唯一索引id',
  order_code varchar(255) NOT NULL COMMENT '订单号',
  address varchar(255) NOT NULL COMMENT '收货地址',
  post varchar(255) NOT NULL COMMENT '邮编',
  receiver varchar(255) NOT NULL COMMENT '收货人姓名',
  mobile varchar(255) NOT NULL COMMENT '手机号码',
  user_message varchar(255) NOT NULL COMMENT '用户备注的信息',
  create_date datetime NOT NULL COMMENT '订单创建时间',
  pay_date datetime DEFAULT NULL COMMENT '订单支付时间',
  delivery_date datetime DEFAULT NULL COMMENT '发货日期',
  confirm_date datetime DEFAULT NULL COMMENT '确认收货日期',
  user_id int(11) DEFAULT NULL COMMENT '对应的用户id',
  status varchar(255) NOT NULL COMMENT '订单状态',
  PRIMARY KEY (id),
  CONSTRAINT fk_order_user FOREIGN KEY (user_id) REFERENCES user (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE order_item (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT '唯一索引id',
  product_id int(11) NOT NULL COMMENT '对应产品id',
  order_id int(11) NOT NULL COMMENT '对应订单id',
  number int(11) DEFAULT NULL COMMENT '对应产品购买的数量',
  PRIMARY KEY (id) COMMENT '邮编',
  CONSTRAINT fk_order_item_product FOREIGN KEY (product_id) REFERENCES product (id),
  CONSTRAINT fk_order_item_order FOREIGN KEY (order_id) REFERENCES order_ (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;
```

#逆向工程（就是一键生成）


##第一步：添加必要的Jar包

我们使用逆向工程，需要先导入 Mybatis Generator 的官方包，由于我们使用的是 Maven 搭建的 SSM 项目，所有我们可以去 Maven 的官网去查询需要的相关包：

    http://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core/1.3.7

戳进去点击最新的包：


图13

就可以在下方找到 Maven 依赖添加的语句：

图14


直接粘进 pom.xml 就可以了



## 第二步 ：generatorConfig.xml

【resources】下创建 generatorConfig.xml 配置文件，该配置文件说明了一些逆向工程的细节：

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>
    <context id="DB2Tables" targetRuntime="MyBatis3">
        <!--是否去除自动生成的代码中的注释 true：是 false：否-->
        <commentGenerator>
            <property name="supperssDate" value="true"/>
            <property name="supperssAllComments" value="true"/>
        </commentGenerator>

        <!-- 数据库连接信息：驱动类、连接地址、用户名、密码 -->
        <jdbcConnection driverClass="com.mysql.jdbc.Driver"
                        connectionURL="jdbc:mysql://localhost/tmall_ssm"
                        userId="root"
                        password="123"/>


        <!-- 默认 false，把 JDBC DECIMAL 和 NUMERIC 类型解析为 Integer
             为 true 时解析为 java.math.BigDecimal -->
        <javaTypeResolver>
            <property name="forceBigDecimals" value="false"/>
        </javaTypeResolver>

        <!-- targetProject：生成 POJO 类的位置 -->
        <javaModelGenerator targetPackage="Tmall.pojo" targetProject="src/main/java">
            <!-- enableSubPackages：是否让 schema 作为包的后缀-->
            <property name="enableSubPackages" value="false"/>
            <!-- trimStrings：从数据库返回的值被清理前后的空格 -->
            <property name="trimStrings" value="true"/>
        </javaModelGenerator>

        <!-- targetProject：生成xml映射文件存放位置 -->
        <sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources">
            <!-- enableSubPackages：是否让 schema 作为包的后缀-->
            <property name="enableSubPackages" value="true"/>
        </sqlMapGenerator>

        <!-- targetProject：生成mapper类存放位置 -->
        <javaClientGenerator type="XMLMAPPER" targetPackage="Tmall.mapper" targetProject="src/main/java">
            <!-- enableSubPackages：是否让 schema 作为包的后缀-->
            <property name="enableSubPackages" value="true"/>
        </javaClientGenerator>

        <!--生成对应表及类名
            tableName:要生成的表名
            domainObjectName:生成后的实例名
            enableCountByExample:Count语句中加入where条件查询，默认为true开启
            enableUpdateByExample:Update语句中加入where条件查询，默认为true开启
            enableDeleteByExample:Delete语句中加入where条件查询，默认为true开启
            enableSelectByExample:Select多条语句中加入where条件查询，默认为true开启
            selectByExampleQueryId:Select单个对象语句中加入where条件查询，默认为true开启
        -->
        <table tableName="category" domainObjectName="Category" enableCountByExample="false"
        enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="true"
        selectByExampleQueryId="false">
            <!-- 使用数据库中实际的字段名作为生成的实体类的属性 -->
            <property name="useActualColumnNames" value="true"/>
            <!-- 使用自增长键 -->
            <property name="my.isgen.usekeys" value="true"/>
            <generatedKey column="id" sqlStatement="JDBC"/>
        </table>


        <table tableName="property" domainObjectName="Property" enableCountByExample="false"
               enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="true"
               selectByExampleQueryId="false">
            <!-- 使用数据库中实际的字段名作为生成的实体类的属性 -->
            <property name="useActualColumnNames" value="true"/>
            <!-- 使用自增长键 -->
            <property name="my.isgen.usekeys" value="true"/>
            <generatedKey column="id" sqlStatement="JDBC"/>
        </table>

        <table tableName="product" domainObjectName="Product" enableCountByExample="false"
               enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="true"
               selectByExampleQueryId="false">
            <!-- 使用数据库中实际的字段名作为生成的实体类的属性 -->
            <property name="useActualColumnNames" value="true"/>
            <!-- 使用自增长键 -->
            <property name="my.isgen.usekeys" value="true"/>
            <generatedKey column="id" sqlStatement="JDBC"/>
        </table>

        <table tableName="product_image" domainObjectName="ProductImage" enableCountByExample="false"
               enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="true"
               selectByExampleQueryId="false">
            <!-- 使用数据库中实际的字段名作为生成的实体类的属性 -->
            <property name="useActualColumnNames" value="true"/>
            <!-- 使用自增长键 -->
            <property name="my.isgen.usekeys" value="true"/>
            <generatedKey column="id" sqlStatement="JDBC"/>
        </table>


        <table tableName="order_" domainObjectName="Order" enableCountByExample="false"
               enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="true"
               selectByExampleQueryId="false">
            <!-- 使用数据库中实际的字段名作为生成的实体类的属性 -->
            <property name="useActualColumnNames" value="true"/>
            <!-- 使用自增长键 -->
            <property name="my.isgen.usekeys" value="true"/>
            <generatedKey column="id" sqlStatement="JDBC"/>
        </table>

        <table tableName="property_value" domainObjectName="PropertyValue" enableCountByExample="false"
               enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="true"
               selectByExampleQueryId="false">
            <!-- 使用数据库中实际的字段名作为生成的实体类的属性 -->
            <property name="useActualColumnNames" value="true"/>
            <!-- 使用自增长键 -->
            <property name="my.isgen.usekeys" value="true"/>
            <generatedKey column="id" sqlStatement="JDBC"/>
        </table>


        <table tableName="review" domainObjectName="Review" enableCountByExample="false"
               enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="true"
               selectByExampleQueryId="false">
            <!-- 使用数据库中实际的字段名作为生成的实体类的属性 -->
            <property name="useActualColumnNames" value="true"/>
            <!-- 使用自增长键 -->
            <property name="my.isgen.usekeys" value="true"/>
            <generatedKey column="id" sqlStatement="JDBC"/>
        </table>


        <table tableName="user" domainObjectName="User" enableCountByExample="false"
               enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="true"
               selectByExampleQueryId="false">
            <!-- 使用数据库中实际的字段名作为生成的实体类的属性 -->
            <property name="useActualColumnNames" value="true"/>
            <!-- 使用自增长键 -->
            <property name="my.isgen.usekeys" value="true"/>
            <generatedKey column="id" sqlStatement="JDBC"/>
        </table>

        <table tableName="order_item" domainObjectName="OrderItem" enableCountByExample="false"
               enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="true"
               selectByExampleQueryId="false">
            <!-- 使用数据库中实际的字段名作为生成的实体类的属性 -->
            <property name="useActualColumnNames" value="true"/>
            <!-- 使用自增长键 -->
            <property name="my.isgen.usekeys" value="true"/>
            <generatedKey column="id" sqlStatement="JDBC"/>
        </table>


        <table tableName="referal_link" domainObjectName="ReferalLink" enableCountByExample="false"
               enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="true"
               selectByExampleQueryId="false">
            <!-- 使用数据库中实际的字段名作为生成的实体类的属性 -->
            <property name="useActualColumnNames" value="true"/>
            <!-- 使用自增长键 -->
            <property name="my.isgen.usekeys" value="true"/>
            <generatedKey column="id" sqlStatement="JDBC"/>
        </table>
    </context>
</generatorConfiguration>
```
这样配置文件也就编写好了

## 第三步 ： 逆向数据文件生成类

在编写完配置文件只有，就需要加载该配置文件，利用逆向工程的机制来对数据库的各个表进行一系列文件的生成，我们在【test/java】包下创建【TestMyBatisGenerator】类：

```
import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.api.ShellCallback;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class TestMyBatisGenerator {
    public static void main(String[] args) throws Exception {
        // warnings 为用于放置生成过程中警告信息的集合对象
        List<String> warnings = new ArrayList<String>();
        // 指定是否覆盖重名文件
        boolean overwrite = true;
        // 加载配置文件
        File configFile = new File(MyBatisGenerator.class.getClassLoader().getResource("generatorConfig.xml").toURI());
        // 配置解析类
        ConfigurationParser cp = new ConfigurationParser(warnings);
        // 配置解析类解析配置文件并生成 Configuration 配置对象
        Configuration config = cp.parseConfiguration(configFile);
        // ShellCallback 负责如何处理重复文件
        ShellCallback callback = new DefaultShellCallback(overwrite);
        // 逆向工程对象
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);
        // 执行逆向文件生成操作
        myBatisGenerator.generate(null);
        // 打印提示信息
        System.out.println("MyBatis 逆向工程执行成功，刷新项目查看文件！");
    }
}
```

执行该测试类，就能看见自动生成的文件：

图14

xxxExample
----------
MybatisGenerator会生成一个类叫做XXXXExample的。，它的作用是进行排序，条件查询的时候使用。

这里有详细的说明，了解一下就好了：
[这里][1]




##  测试：

这里仅仅就用 CategoryMapper 映射类来进行简单测试了：






#参考复制：

    https://www.jianshu.com/p/5e44ee046b43





  [1]: https://blog.csdn.net/biandous/article/details/65630783	2018-09-08 12:19:00
kumika	模仿天猫实战SSM--前端开发 1	# 模仿天猫实战SSM--前端开发 1

# 前端需求分析：

页面分类：
  

        公共页面,
        首页,
        分类页面,
        产品页面,
        购物车页面,
        结算页面,
        其他页面 

我就一个一个页面开始学习，前端我就一遍过，了解HTML标签是怎么样的，是怎么实现的，哪些是与服务器交互的就可以了，主要是为后面的后台页面做铺垫。



#公共页面

所谓的公共页面，即每个页面都有内容。 比如页头，页脚还有搜索框。

这样的页面，又叫做include文件。在真正开发网站的时候(不仅仅使用html和css，比如采用JSP技术)，会单独设计这样的网页，然后在不同的主体网页，比如首页，产品页，搜索查询结果页去包含这些网页。
那么这些网页就只需要做一遍就行了，其他页面重复使用这些网页，就可以达到节约开发时间，降低开发和维护成本的效果。

##那么都有哪些公共页面呢？
============

以首页为例，它是由3个公共文件和1个内容文件组成。
这3个公共文件分别是 最上面的置顶导航和搜索栏，以及最下面的页脚。
最后才是页面的真正内容。

每个页面都有这样的页脚，那么就可以把这个页脚单独拿出来做到一个文件里。 然后其他的页面引用这个文件即可。
![页脚.jpg](https://i.loli.net/2018/09/10/5b95c9307a6b9.jpg)

因为每个页面都会包含这些公共页面，所以我们会先把这些公共页面单独拿出来学习和消化。 

![公共页面.jpg](https://i.loli.net/2018/09/10/5b95c8c709686.jpg)

#下面开始编写
在webapp包下创建view包，在view包下创建include包作为公共页面包，作为包括置顶导航.jsp ， search.jsp ，页脚.jsp

## 1 公共页面的置顶导航

创建top.jsp作为置顶导航
### 1.1 置顶导航布局
最外面是nav元素，nav元素和div元素一样都是用来进行布局的。 不同之处在于，nav可以更加明确的告诉搜索引擎，这部分内容，是用于导航的，帮助搜索引擎理解你的网页。

然后是连续摆放的超链和span，因为超链和span是内联元素，不会自动换行，所以这些会自动出现左侧，并且水平摆放。

然后是在右侧放了一个span， 这个span本身是飘在右侧的。 
span里放了超链和span，自动进行水平摆放

###1.2纯HTML
-----

这是html的内容没有使用CSS的效果。
1 为了使用图标，引入了Bootstrap和Jquery

```
 <script src="js/jquery/2.0.0/jquery.min.js"></script>
    <%--<link href="css/bootstrap/3.3.6/bootstrap.min.css" rel="stylesheet">--%>
   <%-- <link href="css/bootstrap/3.3.6/bootstrap.css" rel="stylesheet">--%>
    <link href="assets/css/bootstrap.css" rel="stylesheet">
    <script src="js/bootstrap/3.3.6/bootstrap.min.js"></script>
    <link href="css/fore/style.css" rel="stylesheet">
```
2. 使用了Bootstrap之后，超链会发生变化
超链会变成浅蓝色，但是并不是天猫的颜色风格

3. 没有背景色和边框

4. 向右飘逸定位使用Bootstrap的pull-right样式，其实这个样式很简单，就是使用的float:right. !important;表示高优先级
```
.pull-right {
  float: right !important;
}
```

使用Bootstrap主要是为了使用其中的字体图标，以及轮播和模态窗口效果。 可以看到Bootstrap自带的超链风格并不是天猫的样式风格，并不能直接拿来使用。 所以接下来，还是会让大家掌握如何使用最基本的CSS去实现天猫的效果，这样才能锻炼硬功夫
```
    <nav class="top">
        <a href="#nowhere">
            <span class="glyphicon glyphicon-home redColor"></span>
            天猫首页
        </a>
        <span>喵，欢迎来天猫</span>
            <a href="#nowhere">请登录</a>
            <a href="#nowhere">免费注册</a>
        <%--向右飘逸定位使用Bootstrap的pull-right样式，
        其实这个样式很简单，就是使用的float:right. !important;表示高优先级--%>
        <span class="pull-right"></span>
            <a href="#nowhere">我的订阅</a>
            <a href="#nowhere">
                <span class="glyphicon glyphicon-shopping-cart redColor"></span>
                购物车<strong>0</strong>
            </a>
    </nav>
```
### 1.2 样式CSS

我个人理解：
   就是在style标签里定义HTML标签表现形式--NAV标签什么的用color

```
<style>
    body{
        <%--把所有文字的大小调成12px,这是天猫默认的文字大小--%>
        font-size:12px;
        <%--字库使用Arial--%>
        font-family:Arial;
    }
    a{
        /*所有的超链，都以灰色#999 形式表现出来*/
        color: #999;
    }
    .redColor{
        /*天猫整个网站使用的天猫红都是#C40000,
        在这个例子里首页和购物车图标使用了本样式
            其实就是鼠标移动上图标后，图标变成红色
        */
        color: #C40000 !important;
    }
    nav.top{
        /*置顶导航nav*/

        background-color: #f2f2f2;
        /*背景色#f2f2f2;*/
        padding-top: 5px;
        /*上内边距是5px*/
        padding-bottom: 5px;
        /*下内边距是5px*/
        border-bottom:1px solid #e7e7e7;
        /*下边缘有1个像素的实线边框，颜色是比背景色#f2f2f2略深的#e7e7e7*/
    }
    nav.top span, nav.top a{/*置顶导航里的span和超链*/
        color: #999;
       /* 颜色#999*/
        margin: 0px 10px 0px 10px;
        /*并且有左右外边距10px，但是没有上下外边距*/
    }
    nav.top a:hover{/*超链悬停*/
        color: #C40000;
        /*当鼠标移动到超链上的时候，颜色变为天猫红 #C40000*/
        text-decoration:none;
        /*去掉下划线*/
    }
</style>
```


## 2 搜索栏

创建search.jsp

### 2.1搜索栏布局
搜索栏所在的div是一个居中的div

这个居中的div，包含一个子div，其中是 平衡车 | 扫地机器人 | 原汁机 | 冰箱 等信息

左侧的图片使用绝对定位的方式，这样就可以很方便的做到图片和搜索栏div水平放置的效果

![search.jpg](https://i.loli.net/2018/09/10/5b95dfe2b9085.jpg)


### 2.2 纯html

```
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <%-- 引入JQ和Bootstrap--%>
    <script src="js/jquery/2.0.0/jquery.min.js"></script>
    <link href="css/bootstrap/3.3.6/bootstrap.min.css" rel="stylesheet">
    <script src="js/bootstrap/3.3.6/bootstrap.min.js"></script>
    <link href="css/fore/style.css" rel="stylesheet">
</head>

<div>
    <a href="#nowhere">
        <img class="logo" id="logo" src="img/site/logo.gif">
    </a>

    <div class="searchDiv">
        <input type="text" placeholder="时尚男鞋  太阳镜 " name="keyword">
        <button class="searchButton" type="submit">搜索</button>
        <div class="searchBelow">
            <span>
                <a href="#nowhere">平衡车</a> <span> | </span>
            </span>
            <span>
                <a href="#nowhere">扫地机器人</a> <span> | </span>
            </span>
            <span>
                <a href="#nowhere">原汁机</a> <span> | </span>
            </span>
            <span>
                <a href="#nowhere">冰箱</a> <span> | </span>
            </span>
        </div>
    </div>
<div style="height: 50px"></div>
</div>
```



### 2.3 CSS 样式

HTML标签里的class是CSS的id

     <div class="searchDiv"> ==> div.searchDiv{/*搜索栏*/
        <input>   ========> div.searchDiv input{/*搜索栏中的输入框*/
        <button class="searchButton"> =====>div.searchDiv button{/*搜索栏中的按钮*/
    
    <div class="searchBelow"> =======>div.searchBelow{/*搜索栏下方的关键字*/
        <span> =======> div.searchBelow span{/*关键字之间的竖棒*/
        <a>  ========>  div.searchBelow a{/*关键字超链*/
        
    <img class="logo">======>img.logo{/*logo图片*/

HTML的class和CSS是互通的

完整的CSS：
```
<style>
    div.searchDiv{/*搜索栏*/
        background-color: #C40000;
        /*搜索框div背景色是天猫红#C40000;*/
        width: 400px;
        /*宽度固定400px;*/
        margin: 50px auto;
        /*水平居中，并且有50px的上下外边距*/
        padding: 1px;
        /*有1px的内边距*/
        height: 40px;
        /*高度是40px；*/
        display: block;
        /*以块状元素显示，只有在以块状元素显示的时候,
        水平居中才有效果。 当然div默认也是块状元素显示的*/

        /*
            这里个人修改成：
                            margin ： 150px auto
                            水平居中，并且有150px的上下外边距
        */

    }
    div.searchDiv input{/*搜索栏中的输入框*/
        width: 275px;
        /*宽度275px*/
        border: 1px solid transparent;
        /*边框设置成透明的，否则会有边框阴影*/
        height: 36px;
        /*高度36px*/
        margin: 1px;
        /*外边距设置为1px，看上去输入框和边框之间就有很小的空隙*/
        outline:none;
        /*去掉输入框轮廓，否则获取焦点的时候会发生颜色变化*/
    }
    div.searchDiv button{/*搜索栏中的按钮*/
        width: 110px;
        /*宽度110px,这样加上左边的input的275px的宽度，正好把searchDiv填满*/
        border: 1px solid transparent;
        /*边框设置成透明的，否则会有边框阴影*/
        background-color: #C40000;
        /*背景色设置成天猫红，和searchDiv融为一体*/
        color: white;
        /*字体白色*/
        font-size: 20px;
        /*字体大小20px*/
        font-weight: bold;
        /*字体加粗*/
    }
    div.searchBelow{/*搜索栏下方的关键字*/
        margin-top: 3px;
        /*搜索栏下方的div，有3个像素的上外边距*/
        margin-left: -20px;
        /*-20个像素的左外边距*/
    }
    div.searchBelow span{/*关键字之间的竖棒*/
        color: #999;
        /*把不同的关键字之间的竖棒设置为灰色*/
    }
    div.searchBelow a{/*关键字超链*/
        padding: 0px 20px 0px 20px;
        /*超链之间的水平间隔20px*/
        font-size: 14px;
        /*超链文字大小14px*/
    }
    img.logo{/*logo图片*/
        position: absolute;
        /*logo图片使用绝对定位*/
        left: 0px;
        /*贴在左边*/
        top: 30px;
        /*距离上面30px*/
        z-index:-1;
        /*-1表示放在下面，免得图片挡住了输入框*/
        /*
        个人修改成： position： auto
                    top 20px
        */

    }
    body{/*整个body*/
        font-size:12px;
        /*把所有文字的大小调成12px,这是天猫默认的文字大小*/
        font-family:Arial;
/*        字库使用Arial*/
    }
    a{/*所有超链*/
        color:#999;
        /*所有的超链，都默认以灰色#999 形式表现出来*/
    }
    a:hover{/*鼠标悬停*/
        text-decoration:none;
        /*超链鼠标悬停的时候,没有下划线*/
        color:#C40000;
        /*超链鼠标悬停的时候,使用天猫红显示*/
    }
</style>
```

## 3 简单搜索栏

在include包下创建mini-search.jsp

### 3.1简单搜索栏布局

输入框所在的div 向右漂浮

这个向右漂浮的div，包含一个子div，其中是 冰箱 | 空调 | 女表 | 男装 等信息

左侧的图片使用绝对定位的方式，这样就可以很方便的做到图片和搜索栏div水平放置的效果

![简单搜索布局.jpg](https://i.loli.net/2018/09/10/5b95efc05fa3f.jpg)



### 3.2 纯HTML


```
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <%-- 引入JQ和Bootstrap--%>
    <script src="js/jquery/2.0.0/jquery.min.js"></script>
    <link href="css/bootstrap/3.3.6/bootstrap.min.css" rel="stylesheet">
    <script src="js/bootstrap/3.3.6/bootstrap.min.js"></script>
    <link href="css/fore/style.css" rel="stylesheet">
</head>
<div>
    <a href="#nowhere">
        <img class="simpleLogo" id="simpleLogo"  src="img/site/simpleLogo.png">
    </a>
    <div class="simpleSearchDiv pull-right">
        <input type="text" name="keyword" placeholder="平衡车 原汁机">
        <button type="button" class="searchButton">搜天猫</button>
        <div class="searchBelow">
            <span>
                <a href="#nowhere">
                    冰箱
                </a>
                <span> | </span>
            </span>
            <span>
                <a href="#nowhere">
                    空调
                </a>
                <span> | </span>
            </span>
            <span>
                <a href="#nowhere">
                    女手表
                </a>
                <span> | </span>
            </span>
            <span>
                <a href="#nowhere">
                    男手表
                </a>
                <span> | </span>
            </span>
        </div>
    </div>
    <div style="clear: both"></div>
</div>
```


### 3.3 CSS样式


```
<style>
    div.simpleSearchDiv{/*简单搜索栏*/
        background-color: #C40000;
        /*背景色天猫红*/
        width: 300px;
        /*宽度300px*/
        margin: 10px 20px 40px;
        /*外边距*/
        padding: 1px;
        /*内边距1px*/
        height: 40px;
        /*高度40px*/
        display: block;
        /*用块状显示，只有使用块状显示的时候，上下外边距才会生效*/
    }
    div.simpleSearchDiv input{/*输入框*/
        width: 225px;
        /*按钮宽度225px*/
        border: 1px solid transparent;
        /*边框透明不然会有阴影，看上去就不是嵌进去的*/
        height: 34px;
        /*高度34px*/
        margin: 2px;
        /*外边距2px，显得和外面的div有一定的距离*/
        outline:none;
        /*去掉输入框轮廓，否则获取焦点的时候会发生颜色变化*/
    }
    div.simpleSearchDiv button{/*搜天猫按钮*/
        width: 60px;
        /*按钮宽度60px*/
        border: 1px solid transparent;
        /*边框透明不然会有阴影，看上去就不是嵌进去的*/
        background-color: #C40000;
        /*背景色天猫红，和div的背景色一样，按钮轮廓就会消失*/
        color: white;
        /*文字颜色白色*/
        font-size: 14px;
        /*文字大小*/
            /* font-weight:bold */;
     /*   首页的搜索框字体是粗体，这里没有使用*/
    }
    div.searchBelow{/*关键字所在div*/
        margin-top: 3px;
        /*下方关键字所在的div，上外边距*/
        margin-left: -20px;
     /*   左边距，结合超链的内边距，正好使得超链出现在开始的位置*/
    }
    div.searchBelow span{/*关键字之间的 | */
        color: #999;
        /*设置为灰色*/
    }
    div.searchBelow a{/*关键字超链*/
        padding: 0px 20px 0px 20px;
        /*超链的左右内编剧*/
        font-size: 14px;
     /*   超链文字大小*/
    }
    img.simpleLogo{/*logo图片*/
        position: absolute;
        /*logo图片使用绝对定位*/
        left: 10px;
        /*左边距离*/
        top: 50px;
        /*上方距离*/
        width: 140px;
     /*   宽度*/
    }
    body{/*整个body*/
        font-size: 12px;
       /* 把所有文字的大小调成12px,这是天猫默认的文字大小*/
        font-family: Arial;
        /*字库使用Arial*/
    }
    a{
        color:#999;
       /* 所有的超链，都默认以灰色#999 形式表现出来*/
    }
    a:hover{/*鼠标悬停*/
        text-decoration:none;
        /*超链鼠标悬停的时候,没有下划线*/
        color: #C40000;
        /*超链鼠标悬停的时候,使用天猫红显示*/
    }
</style>
```

## 4 页脚上 （分上，下2部分）

在include包下创建foot1.jsp

先看完整效果：

![天猫.jpg](https://i.loli.net/2018/09/10/5b9637bda1ed9.jpg)

上下分界就是 黑白分割 ，白的部分是上，黑的部分是下


### 4.1 白色部分效果和布局情况

![白的.jpg](https://i.loli.net/2018/09/10/5b96386acde25.jpg)

布局情况

![布局.jpg](https://i.loli.net/2018/09/10/5b963872b456e.jpg)


### 4.2 纯HTML

```
//引入bootStrap 和jquery那部分就不粘贴上来了
<div style="display: block;" class="footer" id="footer">
    <div class="footer_ensure" id="footer_ensure">
        <img src="img/site/ensure.png">
    </div>

    <div class="footer_desc" id="footer_desc">
        <div class="descColumn">
            <span class="descColumnTitle">购物指南</span>
            <a href="#nowhere">免费注册</a>
            <a href="#nowhere">开通支付宝</a>
            <a href="#nowhere">支付宝充值</a>
        </div>
        <div class="descColumn">
            <span class="descColumnTitle">天猫保障</span>
            <a href="#nowhere">发票保障</a>
            <a href="#nowhere">售后规则</a>
            <a href="#nowhere">缺货赔付</a>
        </div>
        <div class="descColumn">
            <span class="descColumnTitle">支付方式</span>
            <a href="#nowhere">快捷支付</a>
            <a href="#nowhere">信用卡</a>
            <a href="#nowhere">蚂蚁花呗</a>
            <a href="#nowhere">货到付款</a>
        </div>
        <div class="descColumn">
            <span class="descColumnTitle">商家服务</span>
            <a href="#nowhere">商家入驻</a>
            <a href="#nowhere">商家中心</a>
            <a href="#nowhere">天猫智库</a>
            <a href="#nowhere">天猫规则</a>
            <a href="#nowhere">物流服务</a>
            <a href="#nowhere">喵言喵语</a>
            <a href="#nowhere">运营服务</a>
        </div>
        <div class="descColumn">
            <span>手机天猫</span>
            <a href="#nowhere">
                <img src="img/site/ma.png">
            </a>
        </div>
    </div>
    <div style="clear: both"></div>
</div>
```

### 4.3 CSS样式

html 和css联动有6个标签

```
<style>
    div.footer{/*页脚div*/
        margin: 0px 0px;
        /*无外边距*/
        border-top-style: solid;
        /*上边框实线*/
        border-top-width: 1px;
        /*上边框1个像素*/
        border-top-color: #e7e7e7;
        /*上边框颜色*/
    }
    div.footer_ensure{/*品质保障图片所在div*/
        margin-top: 24px;
        /*上外边距*/
        margin-bottom: 24px;
        /*下外边距*/
        text-align: center;
        /*图片居中*/
    }
    div.footer_desc{/*购物指南等超链所在div*/
        border-top-style: solid;
        /*上边框实线*/
        border-top-width: 1px;
        /*上边框1个像素*/
        border-top-color: #e7e7e7;
        /*上边框颜色*/
        padding-top: 30px;
        /*上内边距*/
        margin: 0px 20px;
        /*左右外边距20px*/
    }
    div.footer_desc div.descColumn{/*购物指南，天猫保障等列*/
        width: 20%;
        /*刚好有5列，所以每列占用20%*/
        float: left;
        /*漂浮起来，使得这些列水平摆放*/
        padding-left: 15px;
        /*左内边距15px*/
    }
    div.footer_desc div.descColumn span.descColumnTitle{/*购物指南等字样*/
        color: #646464;
        /*颜色*/
        font-weight: bold;
        /*粗体*/
        font-size: 16px;
        /*文本大小16px*/
    }
    div.footer_desc a{/*超链*/
        display: block;
        /*超链默认是inline,会水平摆放，改成block出现换行效果*/
        padding-top: 3px;
        /*3px内边距*/
    }
    body{/*整个body*/
        font-size: 12px;
        /*把所有文字的大小调成12px,这是天猫默认的文字大小*/
        font-family: Arial;
        /*字库使用Arial*/
    }
    a{/*所有超链*/
        color:#999;
     /*   所有的超链，都默认以灰色#999 形式表现出来*/
    }
    a:hover{/*鼠标悬停*/
        text-decoration:none;
        /*超链鼠标悬停的时候,没有下划线*/
        color: #C40000;
        /*超链鼠标悬停的时候,使用天猫红显示*/
    }
</style>
```


## 5 页脚下

### 5.1 布局和黑色部分效果

布局：

![黑色布局.jpg](https://i.loli.net/2018/09/10/5b9686267cda2.jpg)

页脚黑色效果：

![黑色部分.jpg](https://i.loli.net/2018/09/10/5b9686267f046.jpg)



### 5.2纯HTML

```
<div class="footer" id="footer">
    <img src="img/site/cateye.png" id="cateye" class="cateye"/>

    <div class="copyright" id="copyright">
        <div class="white_link">
        <a href="#nowhere">关于天猫</a>
        <a href="#nowhere"> 帮助中心</a>
        <a href="#nowhere">开放平台</a>
        <a href="#nowhere">  诚聘英才</a>
        <a href="#nowhere">联系我们</a>
        <a href="#nowhere">网站合作</a>
        <a href="#nowhere">知识产权</a>
        <a href="#nowhere">  廉正举报 </a>
        </div>

        <div class="white_link">
            <a href="#nowhere"> 阿里巴巴集团</a><span class="slash"> | </span>
            <a href="#nowhere"> 淘宝网</a><span class="slash"> | </span>
            <a href="#nowhere">天猫 </a><span class="slash"> | </span>
            <a href="#nowhere">  聚划算</a><span class="slash"> | </span>
            <a href="#nowhere">全球速卖通</a><span class="slash"> | </span>
            <a href="#nowhere">全球速卖通</a><span class="slash"> | </span>
            <a href="#nowhere">阿里巴巴国际交易市场</a><span class="slash"> | </span>
            <a href="#nowhere">1688</a><span class="slash"> | </span>
            <a href="#nowhere">阿里妈妈</a><span class="slash"> | </span>
            <a href="#nowhere">  阿里旅行·去啊  </a><span class="slash"> | </span>
            <a href="#nowhere">  阿里云计算    </a><span class="slash"> | </span>
            <a href="#nowhere">    阿里通信    </a><span class="slash"> | </span>
            <a href="#nowhere">  YunOS    </a><span class="slash"> | </span>
            <a href="#nowhere">  阿里旅行·去啊    </a><span class="slash"> | </span>
            <a href="#nowhere">  万网    </a><span class="slash"> | </span>
            <a href="#nowhere">  高德   </a><span class="slash"> | </span>
            <a href="#nowhere">  优视    </a><span class="slash"> | </span>
            <a href="#nowhere">  友盟    </a><span class="slash"> | </span>
            <a href="#nowhere">  虾米    </a><span class="slash"> | </span>
            <a href="#nowhere">  天天动听    </a><span class="slash"> | </span>
            <a href="#nowhere">  来往    </a><span class="slash"> | </span>
            <a href="#nowhere">  钉钉    </a><span class="slash"> | </span>
            <a href="#nowhere">  支付宝    </a><span class="slash"> | </span>
        </div>
        <div class="license">
            <span>增值电信业务经营许可证： 浙B2-20110446</span>
            <span>网络文化经营许可证：浙网文[2015]0295-065号</span>
            <span>互联网医疗保健信息服务 审核同意书 浙卫网审【2014】6号 </span>
            <span>互联网药品信息服务资质证书编号：浙-（经营性）-2012-0005</span>
            <div class="copyRightYear">© 2003-2016 TMALL.COM 版权所有</div>

            <div>
                <img src="img/site/copyRight1.jpg"/>
                <img src="img/site/copyRight2.jpg"/>
            </div>
        </div>
    </div>
</div>
```


### 5.3 CSS样式

```
<style>
    div.footer{/*页脚*/
        margin: 0px 0px;
        /*无外边距*/
        border-top-style: solid;
        /*上边框实线*/
        border-top-width: 1px;
        /*上边框1个像素*/
        border-top-color: #e7e7e7;
        /*上边框颜色*/
    }
    div.copyright{/*页脚二div*/
        background-color: black;
        /*背景色变为黑色*/
        border-top-style: solid;
        /*上边框实线*/
        border-top-width: 2px;
        /*上边框2个像素*/
        border-top-color: #C40000;
        /*上边框天猫红*/
    }
    div.copyright span.slash{/*竖线 | */
         color: white;
         /*白色*/
     }
    div.footer div.copyright div.white_link a{/*应该变成白色的超链*/
        color: white;
        /*白色*/
        padding: 0px 5px;
        /*水平内边距5px*/
    }
    div.footer div.copyright div.white_link{/*超链之间的间隔*/
        padding: 10px 0px;
        /*上下内边距10px*/
        margin-left: 10px;
        /*左外边距10px*/
    }
    div.license{/*下面关于经营许可证部分的div*/
        margin-left: 10px;
        /*做外边距10px*/
        padding-bottom: 30px;
        /*下内边距30px*/
    }
    div.license span{/*经营许可证部分字体的颜色*/
        color: #A4A4A4;
        /*颜色#A4A4A4;*/
    }
    div.license div.copyRightYear{/*版本信息中的年月*/
        margin: 10px 0px;
        /*上下外边距10px*/
        color: #686868;
        /*颜色#686868;*/
    }
    img.cateye{/*猫耳朵图片*/
        margin-left: 20px;
        /*左外边距20px*/
    }
    body{/*整个body*/
        font-size: 12px;
        /*把所有文字的大小调成12px,这是天猫默认的文字大小*/
        font-family: Arial;
        /*字库使用Arial*/
    }
</style>
```







  [1]: http://www.cssmoban.com/cssthemes/7381.shtml	2018-09-09 17:49:39
kumika	模仿天猫实战SSM--前端首页页面	"# 模仿天猫实战SSM--前端首页页面

#首页

首页的内容是比较丰富的，除了公共页中的置顶导航，搜索栏和页脚之外，还有本身的页面内容。

只对首页特有的内容进行讲解，免去重复学习

## 1 导航和轮播

### 1.1 效果和布局

效果：
![效果.jpg](https://i.loli.net/2018/09/11/5b96a0b7ec093.jpg)

**布局：**
![布局轮播.jpg](https://i.loli.net/2018/09/11/5b96a0b7e3ba5.jpg)



### 1.2纯HTML

```
    <div class="categoryWithCarousel">
        <div class="headar">
            <div class="head">
                <span class="glyphicon glyphicon-th-list" style="margin-left: 10px"></span>
                <span style="margin-left: 10px">商品分类</span>
            </div>

            <div class="rightMenu">
                <span>
                    <a href="#nowhere">
                        <img src="img/site/chaoshi.png">
                    </a>
                </span>
                <span>
                    <a href="#nowhere">
                        <img src="img/site/guoji.png">
                    </a>
                </span>
                <span>
                    <a href="#nowhere">
                        平板电视
                    </a>
                </span>
                <span>
                    <a href="#nowhere">
                        电热水器
                    </a>
                </span>
            </div>
        </div>

        <div data-ride="carousel" class="carousel-of-product carousel slide" id="carousel-of-product">
            <!-- Indicators  轮播（Carousel）指标 -->
            <ol class="carousel-indicators">
                <li class="active" data-slide-to="0" data-target="#carousel-of-product"></li>
                <li data-slide-to="1" data-target="#carousel-of-product" class=""></li>
                <li data-slide-to="2" data-target="#carousel-of-product" class=""></li>
                <li data-slide-to="3" data-target="#carousel-of-product" class=""></li>
            </ol>
            <!-- Wrapper for slides 轮播（Carousel）项目 -->
            <div role="listbox" class="carousel-inner">
                <div class="item active">
                    <img src="img/lunbo/1.jpg" class="carousel carouselImage"/>
                </div>
                <div class="item">
                    <img src="img/lunbo/2.jpg" class="carouselImage"/>
                </div>
                <div class="item" >
                    <img src="img/lunbo/3.jpg" class="carouselImage"/>
                </div>
                <div class="item">
                    <img src="img/lunbo/4.jpg" class="carouselImage"/>
                </div>
            </div>
        </div>
        <div class="carouselBackgroundDiv"></div>
    </div>

```


### 1.3 CSS样式


```
<style>
    div.categoryWithCarousel { /*分类和轮播总体div*/
        width: 100%;
        /*宽度100%*/
        position: relative;
        /*把这个div设计为相对定位，是因为在后面的carouselBackgroundDiv是居于这个div进行绝对定位的。*/
    }
    div.categoryWithCarousel div.headbar{/*导航条*/
        background-color: #DD2727;
        /*背景色比天猫红淡一点*/
    }
    div.categoryWithCarousel div.head{/*导航条中的商品分类字样*/
        width: 200px;
        /*宽度200px*/
        background-color: #C60A0A;
        /*背景色比导航条深一点*/
        height: 36px;
        /*高度36px*/
        line-height: 36px;
        /*行高36px,这样文字可以垂直居中*/
        font-size: 16px;
        /*字体大小16px*/
        font-weight: bold;
        /*粗体*/
        color: white;
        /*文字白色*/
        margin-left: 20px;
        /*左边距20px*/
        display: inline-block;
        /*设置为内联块，即可以做到不换行水平摆放，也可以设置大小*/
    }
    div.categoryWithCarousel div.rightMenu{/*导航条右侧子菜单*/
        display: inline-block;
        /*右侧子菜单设置为内联块，即可以做到不换行水平摆放，也可以设置大小*/
    }
    div.categoryWithCarousel div.rightMenu a{/*导航中的超链*/
        font-size: 16px;
        /*文字大小16px*/
        color: white;
        /*文字颜色白色*/
        text-decoration:none;
        /*没有下划线*/
    }
    div.categoryWithCarousel div.rightMenu span{/*导航中的span*/
        margin: 0px 20px 0px 20px;
     /*   文字之间的距离20px*/
    }
    div.categoryWithCarousel div.rightMenu img{/*天猫超市和天猫国际图片*/
        height: 30px;
     /*   高度30px，把图片变小*/
    }
    div.carousel-of-product{/*轮播div*/
        height: 510px;
        /*高度510px*/
        width:1024px;
        /*宽度1024px,设置宽度是为了配合下面的margin实现居中效果*/
        margin:0px auto;
        /*元素居中*/
    }
    img.carouselImage{/*轮播中的图片*/
        height: 510px !important;
        /*图片的高度设置为和轮播div的高度一样*/
    }
    div.carouselBackgroundDiv{/*和图片一样颜色的背景div (当高分辨率，比如1920px的时候会看见，不然会被轮播遮挡)*/
        width:100%;
        /*宽度100%*/
        height:510px;
        /*高度510px*/
        background-color:#E8E8E8;
        /*背景色和图片的背景色一致*/
        position:absolute;
        /*绝对定位*/
        top:36px;
        /*向下移动36px*/
        z-index:-1;
        /*表示在轮播图片的下方*/
    }
</style>
```

### 2.1 效果

### 2.2 布局

### 2.3 纯HTML

### 2.4 CSS样式

## 2 分类和推荐产品

### 2.1 效果

分类菜单和产品列表效果。
产品列表平时是隐藏起来的，只有鼠标放上来的时候，才会显示出来。
为了讲解产品列表中的样式，在这里是默认把产品列表显示出来的。


![效果.jpg](https://i.loli.net/2018/09/11/5b972bab5281b.jpg)


### 2.2 布局

左侧菜单和右侧产品列表是水平摆放的，本来可以使用inline-block来处理这个问题，但是要和上一个知识点中的导航和轮播重叠在一起，所以使用绝对定位来处理，更加方便。

![布局.jpg](https://i.loli.net/2018/09/11/5b972bab51353.jpg)


### 2.3 纯HTML

因为分类菜单和产品列表都会和下面的轮播重叠在一起，所以会采用绝对定位的方式。 而绝对定位又是**基于已经定位了的父容器**，所以在他们之上，会做一个

    <div style="position: relative;left: 0;top: 0;">

专门用于在当前位置进行绝对定位，否则就会基于整个窗体进行绝对定位。

![运行效果.jpg](https://i.loli.net/2018/09/11/5b972c5a0a47f.jpg)

```

```

### 2.4 CSS样式

```
<style>
    div.categoryMenu{/*分类菜单div*/
        width: 200px;
        /*宽度200px*/
        background-color: #e2e2e3;
        /*背景色*/
        margin-left: 20px;
        /*左外边距*/
        position: absolute;
        /*绝对定位*/
        left: 0;
        /*紧靠左边*/
        top: 0;
        /*紧靠上面*/
        z-index: 1;
        /*因为这个菜单会和上个知识点讲解的轮播重叠在一起，为了使得这个菜单变得可以点击，需要使用z-index,把它放在"上面"*/
    }
    div.categoryMenu a{/*菜单中的连接*/
        color: #000;
        /*颜色黑色*/
    }
    div.categoryMenu a:hover{/*菜单中的连接悬停状态*/
        color: lightskyblue;
        /*悬停时候变成天蓝色*/
        text-decoration: none;
        /*去掉下划线*/
    }
    div.productsAsideCategorys{/*分类对应的推荐商品列表*/
        width: 800px;
        /*宽度800*/
        height: 510px;
        /*高度510,510这个高度，刚好和轮播的高度一样，所以当显示的时候，就恰好把轮播遮挡起来*/
        background-color: white;
        /*背景白色*/
        margin-left: 220px;
        /*左外边距220刚好接着左边的菜单*/
        position: absolute;
        /*绝对定位*/
        left: 0;
    /*贴在左边(左外边距在此基础上起作用)*/
        top: 0;
        /*贴在上面*/
        z-index: 1;
        /*因为这个产品列表div会和上个知识点讲解的轮播重叠在一起，为了使得这个菜单变得可以点击，需要使用z-index,把它放在"上面"*/
    }
    div.productsAsideCategorys div.row{/*商品列表中的每一行*/
        margin: 20px 80px 0px 80px;
        /*左右外边距80px,上外边距20px*/
    }
    div.productsAsideCategorys div.row div.seperator{/*每一行的分隔符*/
        margin-top: 20px;
       /* 上外边距20px*/
        border-bottom-style: dashed;
        /*下边框虚线*/
        border-bottom-width: 1px;
        /*下边框1个像素*/
        border-bottom-color: #e7e7e7;
       /* 下边框颜色*/
    }
    div.productsAsideCategorys a{/*商品连接*/
        color: #999;
        /*商品连接颜色灰色*/
        font-size: 14px;
        /*大小14px*/
        margin: 8px;
        /*外边距8px*/
    }
    div.productsAsideCategorys a:hover{/*商品连接悬停状态*/
        color: #C40000;
        /*悬停呈现天猫红*/
        text-decoration: none;
        /*没有下划线*/
    }
    div.eachCategory{/*每个分类*/
        line-height: 30px;
        /*文字垂直居中*/
        padding-left: 10px;
        /*左内边距10px*/
        font-size: 14px;
        /*大小14px*/
    }
    div.eachCategory span{/*每个分类前面的小图标*/
        margin-right: 10px;
        /*图标和文字之间有10px距离*/
    }
    div.eachCategory:hover{/*分类div悬停状态*/
        background-color: white;
        /*背景色改成白色，感觉就和右边的产品列表连在一起了*/
    }
</style>
```

## 3 产品列表

### 3.1 效果
完整的首页产品列表是在 模仿天猫首页 中，每个分类有5种首页推荐产品，一共17种分类。 为了讲解的便利性，只选取了其中的2个分类来分析样式。

如果屏幕分辨率比较小的话，会看到5个产品换行了，这是因为为了演示实际效果，放在了步骤栏里，压缩了宽度。 相同的代码，放在整个页面就不会换行了

![安全椅子.jpg](https://i.loli.net/2018/09/11/5b973646995f8.jpg)
![太阳镜.jpg](https://i.loli.net/2018/09/11/5b9736469c75d.jpg)

### 3.2 布局

![3204.png](https://i.loli.net/2018/09/11/5b97371496be0.png)


### 3.3 纯HTML


```
<div class="homepageCategoryProducts">
    <div class="eachHomepageCategoryProducts">
        <div class="left-mark"></div>
        <span class="categoryTitle">太阳镜</span>
        <br>
                <div class="productItem">
                    <a href="#nowhere">
                        <img width="100px" src="img/productSingle_middle/9543.jpg"/>
                    </a>
                    <a href="#nowhere" class="productItemDescLink">
                        <span class="productItemDesc">[热销]
                            好先生同款墨镜孙红雷偏光男士太阳镜韩明星
                        </span>
                    </a>
                    <span class="productPrice">97.50</span>
                </div>
                <div class="productItem">
                    <a href="#nowhere">
                        <img width="100px" src="img/productSingle_middle/9532.jpg"/>
                    </a>
                    <a href="#nowhere" class="productItemDescLink">
                                <span class="productItemDesc">[热销]
                                    陌森太阳眼镜男女2016偏光定制驾驶近视
                                </span>
                    </a>
                    <span class="productPrice"> 518.70</span>
                </div>
                <div class="productItem">
                    <a href="#nowhere">
                        <img width="100px" src="img/productSingle_middle/9521.jpg"/>
                    </a>
                    <a href="#nowhere" class="productItemDescLink">
                                        <span class="productItemDesc">[热销]
                                            帕莎Prsr太阳镜女偏光镜潮范冰冰同款女
                                        </span>
                    </a>
                    <span class="productPrice">624.00</span>
                </div>
                <div class="productItem">
                    <a href="#nowhere">
                        <img width="100px" src="img/productSingle_middle/9510.jpg"/>
                    </a>
                    <a href="#nowhere" class="productItemDescLink">
                                                <span class="productItemDesc">[热销]
                                                    变色眼镜男女款半框太阳镜大框潮流防辐射防
                                                </span>
                    </a>
                    <span class="productPrice">170.00</span>
                </div>
                <div class="productItem">
                    <a href="#nowhere">
                        <img width="100px" src="img/productSingle_middle/9499.jpg"/>
                    </a>
                    <a href="#nowhere" class="productItemDescLink">
                                                        <span class="productItemDesc">[热销]
                                                            新款男士偏光太阳镜日夜两用墨镜潮运动开车
                                                        </span>
                    </a>
                    <span class="productPrice">551.00</span>
                </div>
        <div style="clear: both;"></div>
    </div>

    <div class="eachHomepageCategoryProducts">
        <div class="left-mark"></div>
        <span class="categoryTitle">安全座椅</span>
        <br>
        <div class="productItem">
            <a href="#nowhere">
                <img width="100px" src="img/productSingle_middle/10192.jpg"/>
            </a>
            <a href="#nowhere" class="productItemDescLink">
                        <span class="productItemDesc">[热销]
                            新生儿婴儿提篮式安全座椅汽车用车载儿童安
                        </span>
            </a>
            <span class="productPrice">882.00</span>
        </div>
        <div class="productItem">
            <a href="#nowhere">
                <img width="100px" src="img/productSingle_middle/10181.jpg"/>
            </a>
            <a href="#nowhere" class="productItemDescLink">
                                <span class="productItemDesc">[热销]
                                    REEBABY汽车儿童安全座椅ISOFI
                                </span>
            </a>
            <span class="productPrice"> 1,344.00</span>
        </div>
        <div class="productItem">
            <a href="#nowhere">
                <img width="100px" src="img/productSingle_middle/10170.jpg"/>
            </a>
            <a href="#nowhere" class="productItemDescLink">
                                        <span class="productItemDesc">[热销]
                                            REEBABY儿童安全座椅9个月-12岁
                                        </span>
            </a>
            <span class="productPrice">1,216.00</span>
        </div>
        <div class="productItem">
            <a href="#nowhere">
                <img width="100px" src="img/productSingle_middle/9510.jpg"/>
            </a>
            <a href="#nowhere" class="productItemDescLink">
                                                <span class="productItemDesc">[热销]
                                                    好孩子汽车儿童安全座椅goodbaby9
                                                </span>
            </a>
            <span class="productPrice">1,199.40</span>
        </div>
        <div class="productItem">
            <a href="#nowhere">
                <img width="100px" src="img/productSingle_middle/10148.jpg"/>
            </a>
            <a href="#nowhere" class="productItemDescLink">
                                                        <span class="productItemDesc">[热销]
                                                            惠尔顿儿童安全座椅isofix硬接口汽车
                                                        </span>
            </a>
            <span class="productPrice">1,993.60</span>
        </div>
        <div style="clear: both;"></div>
    </div>
    <img src="img/site/end.png" class="endpng" id="endpng"/>
</div>
```




### 3.4 CSS样式

```
<style>
    div.homepageCategoryProducts{/*整体的产品列表div*/
        background-color: #F5F5F5;
        /*背景色*/
        padding: 50px 10px 50px 10px;
        /*内边距上下50px，左右10px*/
        margin: 10px auto;
        /*居中*/
        max-width: 1013px;
        /*最大宽度1013px，如果用户的分辨率比较大，那么就会使产品列表整体宽度最大1013，并且居中，这样看上去好一点，而不是铺满整个屏幕*/
    }
    div.productItem{/*产品项*/
        width: 189px;
        /*宽度*/
        height: 285px;
        /*高度*/
        border: 1px solid white;
        /*边框*/
        background-color: white;
        /*背景色*/
        margin: 8px 4px;
        /*外边距*/
        float: left;
        /*向左漂浮，这样使得所有的产品项可以水平摆放*/
        cursor: pointer;
        /*鼠标指正变成点击状态*/
    }
    div.productItem span.productItemDesc{/*产品描述信息*/
        font-size: 12px;
        /*字体*/
        color: #666666;
        /*颜色*/
        display: block;
        /*以块状显示，自动换行*/
        padding: 16px;
        /*内边距*/
    }
    div.productItem span.productPrice{/*产品价格*/
        font-size: 16px;
        /*字体大小*/
        color: #FF003A;
        /*颜色*/
        display: block;
        /*以块状显示，自动换行*/
        padding-left: 16px;
        /*左内边距*/
        margin-top: -10px;
        /*上外边距*/
    }
    div.productItem img{/*图片*/
        width: 187px;
        /*宽度*/
        height: 190px;
        /*高度*/
    }
    div.productItem img:hover{/*产品图片鼠标悬停状态*/
        opacity: 0.7;
        /*变亮*/
        filter: alpha(opacity = 70);
        /*火狐浏览器下的变亮*/
    }
    div.eachHomepageCategoryProducts{/*一个分类下5个产品为一个div*/
        margin: 0px 0px 40px 0px;
        /*下外边距40px*/
    }
    a.productItemDescLink{/*产品超链*/
        display: inline-block;
        /*显示为内联*/
        height: 66px;
        /*高度66px*/
        text-decoration:none;
        /*无下划线*/
    }
    span.categoryTitle{/*分类名称*/
        font-size: 16px;
        /*字体大小*/
        margin-left: 30px;
        /*左外边距30px*/
        color: #646464;
        /*颜色*/
        font-weight: bold;
        /*粗体*/
    }
    div.left-mark{/*竖状条---分类*/
        display: inline-block;
        /*显示为内联元素*/
        height: 20px;
        /*高度20px*/
        vertical-align: top;
        /*垂直居顶*/
        width: 5px;
        /*宽度5px*/
        background-color: #19C8A9;
        /*背景色*/
    }
    img.endpng{/*最下方"END"字样图片*/
        display: block;
        /*显示为块级，为了居中效果*/
        width: 82px;
        /*宽度*/
        margin: 0 auto;
        /*居中*/
    }
</style>
```

## 4 交互效果
首页的互动效果主要是猫耳朵的出现，以及在轮播部分显示和隐藏产品列表。
### 4.1 猫耳朵效果
首页的互动效果主要是猫耳朵的出现，以及在轮播部分显示和隐藏产品列表。

![猫耳朵.jpg](https://i.loli.net/2018/09/11/5b97772d6a868.jpg)
![交互.jpg](https://i.loli.net/2018/09/11/5b97772d6c1c5.jpg)

### 4.2 猫耳朵讲解

```
img.catear {
    position: absolute;
    height: 15px;
    display: none;
}
```

首先加上一段新的css, 这是用来使得猫耳朵图片隐藏并且是绝对定位状态

```
$("div.rightMenu span").mouseenter(function(){
	var left = $(this).position().left;
	var top = $(this).position().top;
	var width = $(this).css("width");
	var destLeft = parseInt(left) + parseInt(width)/2;
	$("img#catear").css("left",destLeft);
	$("img#catear").css("top",top-20);
	$("img#catear").fadeIn(500);
});
```
监听菜单鼠标移入事件mouseenter，当鼠标移入的时候，获取当前span的左，上和宽度信息，根据这些信息，计算出猫耳朵应该出现的位置，然后通过css设置猫耳朵的left和top数据， 最后使用fadeIn(500)，在半秒内淡入猫耳朵图片。

```
$("div.rightMenu span").mouseleave(function(){
	$("img#catear").hide();
});
```
当鼠标移出的时候，隐藏猫耳朵

```
<script>
$(function(){
    $("div.rightMenu span").mouseenter(function(){
        var left = $(this).position().left;
        var top = $(this).position().top;
        var width = $(this).css("width");
        var destLeft = parseInt(left) + parseInt(width)/2;
        $("img#catear").css("left",destLeft);
        $("img#catear").css("top",top-20);
        $("img#catear").fadeIn(500);
    });
    $("div.rightMenu span").mouseleave(function(){
        $("img#catear").hide();
    });
});
</script>
```


### 4.3 轮播部分显示和隐藏列表

### 4.4 轮播部分显示和隐藏列表讲解

```
<div class="eachCategory" cid="83">
```
左侧的菜单项div的class是eachCategory


```
<div class="productsAsideCategorys" cid="83" style="display: none;">
```

右侧的产品列表div是productsAsideCategorys

首先每个菜单项eachCategory都有一个cid属性，取的是该分类的id值
然后这个菜单项对应的产品列表，也有一个一样的cid属性。

整体思路是：
1. 把所有的产品列表都隐藏
2. 当鼠标移动到菜单项上的时候，取出对应的cid
3. 根据cid，找到对应的产品列表
4. 显示该产品列表
5. 当鼠标移开的时候，隐藏对应的产品列表

```
显示产品列表函数
function showProductsAsideCategorys(cid){
	$("div.eachCategory[cid="+cid+"]").css("background-color","white");
	$("div.eachCategory[cid="+cid+"] a").css("color","#87CEFA");
	$("div.productsAsideCategorys[cid="+cid+"]").show();
}
```

```
隐藏产品列表函数
function hideProductsAsideCategorys(cid){
	$("div.eachCategory[cid="+cid+"]").css("background-color","#e2e2e3");
	$("div.eachCategory[cid="+cid+"] a").css("color","#000");
	$("div.productsAsideCategorys[cid="+cid+"]").hide();
}

```

```
$("div.eachCategory").mouseenter(function(){
	var cid = $(this).attr("cid");
        showProductsAsideCategorys(cid);
});
```
当鼠标移入菜单项的时候，显示对应的产品列表

```
$("div.eachCategory").mouseleave(function(){
	var cid = $(this).attr("cid");
        hideProductsAsideCategorys(cid);
});
```
当鼠标移出菜单项的时候，隐藏对应的产品列表

```
$("div.productsAsideCategorys").mouseenter(function(){
    	var cid = $(this).attr("cid");
    	showProductsAsideCategorys(cid);
});
```
当鼠标移入产品列表的时候，显示对应的产品列表

```
$("div.productsAsideCategorys").mouseleave(function(){
    	var cid = $(this).attr("cid");
    	hideProductsAsideCategorys(cid);
});
```
当鼠标移出产品列表的时候，隐藏对应的产品列表

```
function showProductsAsideCategorys(cid){
    $("div.eachCategory[cid="+cid+"]").css("background-color","white");
    $("div.eachCategory[cid="+cid+"] a").css("color","#87CEFA");
    $("div.productsAsideCategorys[cid="+cid+"]").show();
}
 
function hideProductsAsideCategorys(cid){
    $("div.eachCategory[cid="+cid+"]").css("background-color","#e2e2e3");
    $("div.eachCategory[cid="+cid+"] a").css("color","#000");
    $("div.productsAsideCategorys[cid="+cid+"]").hide();
}
 
$(function(){
    $("div.eachCategory").mouseenter(function(){
        var cid = $(this).attr("cid");
        showProductsAsideCategorys(cid);
    });
    $("div.eachCategory").mouseleave(function(){
        var cid = $(this).attr("cid");
        hideProductsAsideCategorys(cid);
    });
    $("div.productsAsideCategorys").mouseenter(function(){
        var cid = $(this).attr("cid");
        showProductsAsideCategorys(cid);
    });
    $("div.productsAsideCategorys").mouseleave(function(){
        var cid = $(this).attr("cid");
        hideProductsAsideCategorys(cid);
    });
});
```

"	2018-09-10 23:38:47
kumika	模仿天猫实战SSM--前端分类页面	# 模仿天猫实战SSM--前端分类页面

#分类页面

    ### 1.1 效果
    
    ### 1.2 布局
    
    ### 1.3 纯HTML
    
    ### 1.4 样式CSS

## 1 排序和价格

### 1.1 效果

![效果.jpg](https://i.loli.net/2018/09/11/5b977b4279919.jpg)

### 1.2 布局

因为分类图片的宽度就是分类div的宽度，直接摆放，不存在布局，所以布局这样一块主要讲几个排序按钮和价格区间

![布局.jpg](https://i.loli.net/2018/09/11/5b977b425c02f.jpg)


### 1.3 纯HTML

```
<div class="categoryPageDiv">
    <img src="img/category/72.jpg">
    <div class="categorySortBar">
        <table class="categorySortBarTable categorySortTable">
            <tbody>
                <tr>
                    <td class="grayColumn"><a href="#nowhere">综合<span class="glyphicon plyphicon-arrow-down"></span> </a> </td>
                    <td><a href="#nowhere">人气<span class="glyphicon glyphicon-arrow-down"></span> </a> </td>
                    <td><a href="#nowhere">新品<span class="glyphicon glyphicon-arrow-down"></span> </a> </td>
                    <td><a href="#nowhere">销量<span class="glyphicon glyphicon-arrow-down"></span> </a> </td>
                    <td><a href="#nowhere">价格<span class="glyphicon glyphicon-resize-vertical"></span> </a> </td>
                </tr>
            </tbody>
        </table>
        <table class="categorySortBarTable">
            <tbody>
            <tr>
                <td>
                    <input type="text" placeholder="请输入" class="sortBarPrice beginPrice">
                </td>
                 <td class="grayColumn priceMiddleColumn">-</td>
                <td>
                    <input type="text" placeholder="请输入" class="sortBarPrice endPrice">
                </td>
            </tr>
            </tbody>
        </table>
    </div>
</div>
```


### 1.4 样式CSS

```
<style>
    div.categoryPageDiv{/*整个分类div*/
        max-width: 1013px;
        /*最大宽度1013px，如果用户的分辨率比较大，
        那么就会使产品列表整体宽度最大1013，并且居中，
        这样看上去好一点，而不是铺满整个屏幕*/
        margin: 10px auto;
        /*居中显示*/
    }
    div.categorySortBar{/*排序按钮栏*/
        background-color: #FAF9F9;
       /* 背景色: #FAF9F9*/
        margin: 40px 20px 20px 20px;
        /*外边距*/
        padding: 4px;
        /*内边距 4px*/
    }
    table.categorySortBarTable{/*排序栏中的两个表格*/
        border-collapse: collapse;
        /*单元格之间没有空隙*/
        display:inline-block;
     /*   显示为内联，既可以设置大小，又能够不换行*/
    }
    table.categorySortBarTable span.glyphicon{/*排序表格中的Bootstrap图标*/
        font-size: 10px;
        /*字体大小: 10px*/
    }
    table.categorySortBarTable td{/*排序表格中的单元格*/
        height:17px;
        /*高度:17px*/
        font-size:12px;
        /*字体大小:12px*/
        border:1px solid #CCCCCC;
        /*边框*/
        padding:3px;
        /*内边距 3px*/
    }
    table.categorySortBarTable td.grayColumn{/*默认选中的那个单元格*/
        background-color: #F1EDEC;
     /*   背景色: #F1EDEC*/
    }
    table.categorySortBarTable td a{/*超链*/
        color: #806F66;
     /*   字体颜色: #806F66*/
    }
    table.categorySortBarTable td a:hover{/*超链鼠标悬浮状态*/
        color: #C40000;
     /*   字体颜色: #C40000*/
    }
    table.categorySortBarTable input{/*价格区间输入框*/
        border-width: 0px;
        /*隐藏边框*/
        height: 15px;
        /*高度: 15px*/
        width: 50px;
     /*   宽度: 50px*/
    }
    table.categorySortBarTable td.priceMiddleColumn{/*}价格区间中间的棒棒*/
        width: 5px;
        /*宽度: 5px*/
        vertical-align: middle;
        /*垂直居中*/
        color: #CCCCCC;
     /*   字体颜色: #CCCCCC*/
    }
    table.categorySortTable td:hover{/*几个排序按钮所在td鼠标悬停状态*/
        background-color: #F1EDEC;
     /*   背景色: #F1EDEC*/
    }
    body{/*整个body*/
        font-size: 12px ;
     /*   把所有文字的大小调成12px,这是天猫默认的文字大小*/
        font-family: Arial;
        /*字库使用Arial*/
    }
</style>
```


## 2 产品列表


### 2.1 效果
    
![效果.jpg](https://i.loli.net/2018/09/11/5b9780de38f0a.jpg)
    
### 2.2 布局
    
![布局.jpg](https://i.loli.net/2018/09/11/5b9780de31599.jpg)
    
### 2.3 纯HTML
    
```
<div class="categoryPageDiv">
    <div class="categoryProducts">
        <div price="799.2" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="img/productSingle_middle/7058.jpg" class="productImage"/>
                </a>
                <span class="productPrice">￥799.20</span>
                <a href="#nowhere" class="productLink">
                    MAXFEEL休闲男士手包真皮手拿包大容量信封包手抓包夹包软韩版潮
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal">月成交<span class="productDealNumber">16笔</span> </span>
                    <span class="productReview">评价<span class="productReviewNumber">16</span> </span>
                    <span class="wangwang">
                        <a href="#nowhere" class="wangwanglink">
                            <img src="img/site/wangwang.png"/>
                        </a>
                    </span>
                </div>
            </div>
        </div>

        <div price="511.2" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="img/productSingle_middle/7047.jpg" class="productImage"/>
                </a>
                <span class="productPrice">￥511.20</span>
                <a href="#nowhere" class="productLink">
                    宾度 男士手包真皮大容量手拿包牛皮个性潮男包手抓包软皮信封包
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal">月成交<span class="productDealNumber">49笔</span> </span>
                    <span class="productReview">评价<span class="productReviewNumber">17</span> </span>
                    <span class="wangwang">
                        <a href="#nowhere" class="wangwanglink">
                            <img src="img/site/wangwang.png"/>
                        </a>
                    </span>
                </div>
            </div>
        </div>

        <div price="448.2" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="img/productSingle_middle/7036.jpg" class="productImage"/>
                </a>
                <span class="productPrice">￥448.20</span>
                <a href="#nowhere" class="productLink">
                    唯美诺新款男士手包男包真皮大容量小羊皮手拿包信封包软皮夹包潮
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal">月成交<span class="productDealNumber">49笔</span> </span>
                    <span class="productReview">评价<span class="productReviewNumber">17</span> </span>
                    <span class="wangwang">
                        <a href="#nowhere" class="wangwanglink">
                            <img src="img/site/wangwang.png"/>
                        </a>
                    </span>
                </div>
            </div>
        </div>

        <div price="448.2" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="img/productSingle_middle/7036.jpg" class="productImage"/>
                </a>
                <span class="productPrice">￥448.20</span>
                <a href="#nowhere" class="productLink">
                    唯美诺新款男士手包男包真皮大容量小羊皮手拿包信封包软皮夹包潮
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal">月成交<span class="productDealNumber">49笔</span> </span>
                    <span class="productReview">评价<span class="productReviewNumber">17</span> </span>
                    <span class="wangwang">
                        <a href="#nowhere" class="wangwanglink">
                            <img src="img/site/wangwang.png"/>
                        </a>
                    </span>
                </div>
            </div>
        </div>
        <div price="411.6" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="http://how2j.cn/tmall/img/productSingle_middle/7025.jpg" class="productImage">
                </a>
                <span class="productPrice">¥411.60</span>
                <a href="#nowhere" class="productLink">
                    英伦邦纹男士手包牛皮大容量真皮手拿包手抓包双拉链商务正品软皮
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal ">月成交 <span class="productDealNumber">25笔</span></span>
                    <span class="productReview">评价<span class="productReviewNumber">19</span></span>
                    <span class="wangwang">
                    <a href="#nowhere" class="wangwanglink">
                        <img src="http://how2j.cn/tmall/img/site/wangwang.png">
                    </a>
                    </span>
                </div>
            </div>
        </div>
        <div price="157.25" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="http://how2j.cn/tmall/img/productSingle_middle/7014.jpg" class="productImage">
                </a>
                <span class="productPrice">¥157.25</span>
                <a href="#nowhere" class="productLink">
                    劳迪莱斯男士手包休闲手拿包牛皮大容量钱包男包软面小包包手抓包
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal ">月成交 <span class="productDealNumber">17笔</span></span>
                    <span class="productReview">评价<span class="productReviewNumber">16</span></span>
                    <span class="wangwang">
                    <a href="#nowhere" class="wangwanglink">
                        <img src="http://how2j.cn/tmall/img/site/wangwang.png">
                    </a>
                    </span>
                </div>
            </div>
        </div>
        <div price="268.2" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="http://how2j.cn/tmall/img/productSingle_middle/7003.jpg" class="productImage">
                </a>
                <span class="productPrice">¥268.20</span>
                <a href="#nowhere" class="productLink">
                    帕朗尼男士手拿包真皮手包商务休闲头层牛皮软牛皮大容量休闲钱包
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal ">月成交 <span class="productDealNumber">5笔</span></span>
                    <span class="productReview">评价<span class="productReviewNumber">19</span></span>
                    <span class="wangwang">
                    <a href="#nowhere" class="wangwanglink">
                        <img src="http://how2j.cn/tmall/img/site/wangwang.png">
                    </a>
                    </span>
                </div>
            </div>
        </div>
        <div price="233.4" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="http://how2j.cn/tmall/img/productSingle_middle/6992.jpg" class="productImage">
                </a>
                <span class="productPrice">¥233.40</span>
                <a href="#nowhere" class="productLink">
                    编织手包手拿包男信封大容量手抓包真皮韩版潮商务休闲牛皮男包
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal ">月成交 <span class="productDealNumber">8笔</span></span>
                    <span class="productReview">评价<span class="productReviewNumber">19</span></span>
                    <span class="wangwang">
                    <a href="#nowhere" class="wangwanglink">
                        <img src="http://how2j.cn/tmall/img/site/wangwang.png">
                    </a>
                    </span>
                </div>
            </div>
        </div>
        <div price="952.0" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="http://how2j.cn/tmall/img/productSingle_middle/6981.jpg" class="productImage">
                </a>
                <span class="productPrice">¥952.00</span>
                <a href="#nowhere" class="productLink">
                    犟牛男士手包真皮手拿包头层牛皮商务大容量手抓包软皮夹包信封包
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal ">月成交 <span class="productDealNumber">20笔</span></span>
                    <span class="productReview">评价<span class="productReviewNumber">16</span></span>
                    <span class="wangwang">
                    <a href="#nowhere" class="wangwanglink">
                        <img src="http://how2j.cn/tmall/img/site/wangwang.png">
                    </a>
                    </span>
                </div>
            </div>
        </div>

        <div style="clear: both"></div>
    </div>
</div>
``` 
### 2.4 样式CSS

```
<style>
    /*整个body*/
    body{
        font-size: 12px;
      /*  把所有文字的大小调成12px,这是天猫默认的文字大小*/
        font-family: Arial;
        /*字库使用Arial*/
    }
    /*整个分类div*/
    div.categoryPageDiv{
        max-width: 1013px;
      /*  最大宽度1013px，如果用户的分辨率比较大，那么就会使产品列表整体宽度最大1013，并且居中，这样看上去好一点，而不是铺满整个屏幕*/
        margin: 10px auto;
        /*居中显示*/
    }
/*    产品列表div*/
    div.categoryProducts{
        padding: 0px 20px 40px 20px;
        /*内边距*/
    }
/*    产品项*/
    div.productUnit{
        width: 225px;
        /*宽度: 225px*/
        height: 338px;
        /*高度: 338px*/
        border: 3px solid #fff;
       /* 边框3个像素，但是是白色的，只有当鼠标移动上来的时候，才会变成天猫红*/
        background-color: white;
        /*背景色: white*/
        margin: 12px 5px;
        /*外边距*/
        float: left;
        /*向左漂浮，这样可以水平摆放*/
    }
/*    产品项的鼠标悬浮状态*/
    div.productUnit:hover{
        border:3px solid #C40000;
        /*边框变成天猫红*/
    }
    /*产品项的边框*/
    div.productUnitFrame{
        border:1px solid #eee;
        /*这个是又一个边框，在鼠标没有悬停的时候，显示为灰色*/
        height:100%;
        /*高度100%*/
    }
/*    产品项的边框鼠标悬停状态*/
    div.productUnitFrame:hover{
        border:1px solid #C40000;
        /*颜色变为天猫红，和外层3个像素的div融为一体，一共表现为厚实的4个像素*/
    }
    /*产品图片*/
    div.productUnit img.productImage{
        width: 100%;
/*        宽度: 100%*/
        height: 190px;
        /*高度: 190px*/
    }
/*    产品价格*/
    div.productUnit span.productPrice{
        font-size: 20px;
        /*字体大小: 20px*/
        color: #CC0000;
        /*字体颜色: #CC0000*/
        display: block;
        /*以块状显示，自动换行*/
        padding-left: 4px;
        /*左内边距: 4px*/
    }
    /*产品链接*/
    div.productUnit a.productLink{
        margin: 10px 0px;
/*        上下外边距10px*/
        color: #333333;
        /*字体颜色: #333333*/
        display: block;
        /*以块状显示，自动换行*/
        height:34px;
        /*高度34px*/
    }
/*    产品链接鼠标悬停状态*/
    div.productUnit a.productLink:hover{
        text-decoration: underline;
        /*有下划线*/
        color: #C40000;
        /*字体颜色: #C40000*/
    }
    /*天猫专卖链接*/
    div.productUnit a.tmallLink{
        margin: 10px 0px;
        /*上下外边距10px*/
        color: #999999;
        /*字体颜色: #999999*/
        display:block;
/*        以块状显示，自动换行*/
        text-decoration: underline;
        /*有下划线*/
    }
/*    天猫专卖链接鼠标悬停状态*/
    div.productUnit a.tmallLink:hover{
        text-decoration: underline;
        /*有下划线*/
        color: #C40000;
        /*字体颜色: #C40000*/
    }
  /*  成交，评价，旺旺所在的div*/
    div.productUnit div.productInfo{
        border-top-width: 1px;
        /*上边框宽度1px*/
        border-top-style: solid;
        /*上边框宽度实线*/
        border-top-color: #EEEEEE;
        /*上边框颜色*/
        color:#999999;
        /*文字颜色#999999*/
    }
/*    月成交数量*/
    div.productUnit span.productDealNumber{
        font-weight: bold;
        /*粗体*/
        color: #B57C5B;
        /*字体颜色: #B57C5B*/
    }
/*    评价所在span*/
    div.productUnit span.productReview{
        border-left-width: 1px;
        /*左边框宽度1px*/
        border-left-style: solid;
        /*左边框实线*/
        border-left-color: #EEEEEE;
        /*左边框颜色#EEEEEE*/
        border-right-width: 1px;
        /*右边框宽度1px*/
        border-right-style: solid;
        /*右边框实线*/
        border-right-color: #EEEEEE;
        /*右边框颜色#EEEEEE*/
    }
    /*评价数量*/
    div.productUnit span.productReviewNumber{
        font-weight: bold;
      /*  粗体*/
        color: #3388BB;
        /*字体颜色: #3388BB*/
    }
    /*月成交和评价所在span*/
    div.productUnit span.monthDeal, div.productUnit span.productReview{
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
        width: 90px;
        /*宽度: 90px*/
        height:29px;
        /*高度: 29px*/
        padding-top: 5px;
/*        上内边距: 5px*/
        padding-left: 5px;
        /*左内边距: 5px*/
    }
    /*旺旺所在span*/
    div.productUnit span.wangwang{
        padding-left: 3px;
        /*左内边距: 3px*/
    }
</style>
```











	2018-09-11 16:16:18
kumika	模仿天猫实战SSM--前端产品页面	# 模仿天猫实战SSM--前端产品页面

#产品页面

    ### 1.1 效果
    
    ### 1.2 布局
    
    ### 1.3 纯HTML
    
    ### 1.4 样式CSS

## 1 产品图片

### 1.1 效果
    
    
 ![效果.jpg](https://i.loli.net/2018/09/11/5b97b4ae6bbff.jpg)   
    
    
### 1.2 布局
    
    
![3230.png](https://i.loli.net/2018/09/11/5b97b4ae90b3b.png)
    
    
    
    
### 1.3 纯HTML
    
``` 
 <div class="imgAndInfo">
    <div class="imgInimgAndInfo">
        <img width="100px" class="bigImg" src="img/productSingle/8619.jpg"/>
        <div class="smallImageDiv">
            <img width="56px" class="smallImage" src="img/productSingle/8620.jpg"/>
            <img width="56px" class="smallImage" src="img/productSingle/8619.jpg"/>
            <img width="56px" class="smallImage" src="img/productSingle/8618.jpg"/>
            <img width="56px" class="smallImage" src="img/productSingle/8617.jpg"/>
            <img width="56px" class="smallImage" src="img/productSingle/8616.jpg"/>
        </div>
    </div>
    <div style="clear: both"></div>
</div>
``` 
    
### 1.4 样式CSS


```
<style>
    div.imgAndInfo{/*图片和基本信息所在的div*/
        margin: 40px 20px;
        /*外边距*/
    }
    div.imgInimgAndInfo{/*图片所在的div*/
        width: 400px;
        /*宽度: 400px*/
        float: left;
        /*向左漂浮，这样可以水平摆放，为的是和右边的基本信息保持水平摆放关系.
        在本知识点，暂时看不到右边的基本信息*/
    }
    div.imgAndInfo img.bigImg{/*大图片*/
        width: 400px;
        /*宽度: 400px*/
        height: 400px;
        /*高度: 400px*/
        padding: 20px;
        /*内边距*/
        border: 1px solid #F2F2F2;
        /*边框*/
    }
    div.imgAndInfo div.smallImageDiv{/*小图片所在的div*/
        width: 80%;
        /*宽度: 80%*/
        margin: 20px auto;
        /*居中显示*/
    }
    div.imgAndInfo img.smallImage{/*小图片*/
        width: 60px;
        /*宽度: 60px*/
        height: 60px;
        /*高度: 60px*/
        border: 2px solid white;
        /*边框设置为2个像素白色，鼠标悬浮的时候就会设置为黑色*/
    }
    div.imgAndInfo img.smallImage:hover{/*小图片鼠标悬浮效果*/
        border: 2px solid black;
        /*边框设置为2个像素黑色*/
    }
</style>
```



## 2 产品的基本信息

### 2.1 效果
    
  因为需要讲解基本信息和左侧图片的水平关系，所以依然要使用左侧的图片。
但是又因为屏幕大小关系，不能使用左侧完整图片，否则右侧会被压缩，导致样式变形，不利于学习，所以把左侧的图片简化，并缩小尺寸。  


![效果.jpg](https://i.loli.net/2018/09/11/5b97ca049a7b0.jpg)
     
    
    
    
    
    
### 2.2 布局
    
  这里不仅仅是水平摆放，还需要做到右侧的div占用剩下所有的宽度。
使用的布局手段是： 左侧固定，右边自动占满  
   
   左侧固定，右边自动占满 实现代码：
```
   <style>
 .left{
   width:200px;
   float:left;
   background-color:pink
  }
  .right{
    overflow:hidden;
    background-color:lightskyblue;
  }
</style>
 
<div class="left">左边固定宽度</div>
 
<div class="right">右边自动填满</div> 
```
 
**所以需要3个小布局 组成大布局**

布局1
![3236.png](https://i.loli.net/2018/09/11/5b97ca0498e04.png)
布局2
![3254.png](https://i.loli.net/2018/09/11/5b97ca0494ad2.png) 
布局3
![3255.png](https://i.loli.net/2018/09/11/5b97ca0466af5.png)

### 2.3 纯HTML

```  
<div class="imgAndInfo">
    <div class="imgInimgAndInfo">
        <img width="100px" src="img/productSingle/8619.jpg"/>
    </div>
    <div class="infoInimgAndInfo">
        <div class="productTitle">
            名媛2016新款女装夏两件套裤韩版雪纺七分裤阔腿裤休闲时尚套装女
        </div>
        <div class="productSubTitle">
            高端定制 高档棉麻 现货即发 加购物车 领优惠卷
        </div>
        <div class="productPrice">
            <div class="juhuasuan">
                <span class="juhuasuanBig">聚划算</span>
                <span>此商品即将参加聚划算，<span class="juhuasuanTime">1天19小时</span>
                后开始，</span>
            </div>
            <div class="productPriceDiv">
                <div class="gouwujuanDiv">
                    <img height="16px" src="img/site/gouwujuan.png"/>
                    <span> 全天猫实物商品通用</span>
                </div>
                <div class="originalDiv">
                    <span class="originalPriceDesc">价格</span>
                    <span class="originalPriceYuan">￥</span>
                    <span class="originalPrice">399.00</span>
                </div>
                <div class="promotionDiv">
                    <span class="promotionPriceDesc">促销价</span>
                    <span class="promotionPriceYuan">￥</span>
                    <span class="promotionPrice">375.00</span>
                </div>
            </div>
        </div>

        <div class="productSaleAndReviewNumber">
            <div>销量<span class="redColor boldWord">50</span></div>
            <div>累计评价<span class="redColor boldWord">19</span></div>
        </div>

        <div class="productNumber">
            <span>数量</span>
            <span>
                <span class="productNumberSettingSpan">
                    <input type="text" value="1" class="productNumberSetting"/>
                </span>
                <span class="arrow">
                    <a class="increaseNumber" href="#nowhere">
                        <span class="updown">
                            <img src="img/site/increase.png"/>
                        </span>
                    </a>
                    <span class="updownMiddle"></span>
                    <a class="decreaseNumber" href="#nowhere">
                        <span class="updown">
                            <img src="img/site/decrease.png"/>
                        </span>
                    </a>
                </span>
            件</span>
            <span>库存88件</span>
        </div>


        <div class="serviceCommitment">
            <span class="serviceCommitmentDesc">服务承诺</span>
            <span class="serviceCommitmentLink">
                <a href="#nowhere">正品保证</a>
                <a href="#nowhere">极速退款</a>
                <a href="#nowhere">赠运费险</a>
                <a href="#nowhere">七天无理由退换</a>
            </span>
        </div>

        <div class="buyDiv">
            <a href="#nowhere" class="buyLink"><button class="buyButton">立即购买</button> </a>
            <a href="#nowhere" class="addCarLink"><button class="buyButton">加入购物车</button> </a>
        </div>
    </div>
    <div style="clear:both"></div>
</div>    
``` 
    
### 2.4 样式CSS

```
<style>
/*    整个body*/
    body{
        font-size: 12px;
        /*把所有文字的大小调成12px,这是天猫默认的文字大小*/
        font-family: Arial;
        /*字库使用Arial*/
    }
/*    包括图片和基本信息的div*/
    div.imgAndInfo{
        margin: 40px 20px;
        /*左右外边距40px 上下20px*/
    }
/*    图片div，这里为了强调右边的基本信息，左侧只放了一个图片。*/
    div.imgInimgAndInfo{
        width: 100px;
        /*宽度: 100px*/
        float: left;
        /*向左漂浮，这样就可以和右边的基本信息内容水平摆放*/
    }
/*    基本信息div*/
    div.infoInimgAndInfo{
        padding: 0px 20px;
        /*左右内边距20px*/
        overflow: hidden;
        /*隐藏溢出部分。 结合图片div的float:left,就可以做到基本信息div和图片div水平摆放，并且基本信息div自动占用剩下所有的宽度*/
    }
    产品标题
    div.infoInimgAndInfo div.productTitle{
        color: black;
        /*字体颜色: black*/
        font-size: 16px;
        /*字体大小: 16px*/
        font-weight: bold;
        /*粗体*/
        margin: 0px 10px;
        /*水平外边距10px*/
    }
/*    产品小标题*/
    div.infoInimgAndInfo div.productSubTitle{
        color: #DD2727;
        /*字体颜色: #DD2727*/
        font-size: 12px;
        /*字体大小: 12px*/
        margin: 0px 10px;
        /*水平外边距10px*/
    }
/*    聚划算div*/
    div.infoInimgAndInfo div.juhuasuan{
        background-color: #2DA77A;
        /*背景色: #2DA77A*/
        color: white;
        /*字体颜色: white*/
        text-align: center;
        /*文本水平居中*/
        line-height: 40px;
        /*文本垂直居中*/
        margin-top: 10px;
        /*上外边距: 10px*/
    }
/*    聚划算几个大字*/
    div.infoInimgAndInfo span.juhuasuanBig{
        font-size: 18px;
        /*字体大小: 18px*/
        font-weight: bold;
        /*粗体*/
        font-family: 黑体;
        /*字体黑体*/
    }
    /*聚划算日期*/
    div.infoInimgAndInfo span.juhuasuanTime{
        color: #FFC057;
        /*字体颜色: #FFC057*/
        font-weight: bold;
        /*粗体*/
    }
/*    产品价格信息*/
    div.infoInimgAndInfo div.productPriceDiv{
        background-image:url(http://how2j.cn/tmall/img/site/priceBackground.png);
        /*背景图片*/
        height: 102px;
        /*高度: 102px*/
        padding: 10px;
        /*内边距10px*/
        color: #666666;
        /*字体颜色: #666666*/
    }
/*    购物卷div*/
    div.infoInimgAndInfo div.gouwujuanDiv{
        margin-top: 5px;
        /*上外边距: 5px*/
    }
/*    原始价格所在div*/
    div.infoInimgAndInfo div.originalDiv{
        margin-top: 5px;
        /*上外边距: 5px*/
    }
/*    原始价格文字*/
    div.infoInimgAndInfo span.originalPriceDesc{
        color: #999999;
        /*字体颜色: #999999*/
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
        width: 68px;
        /*宽度: 68px*/
    }
/*    原始价格-价格数字*/
    div.infoInimgAndInfo span.originalPrice{
        font-family: Arial;
        /*字体Arial*/
        font-size: 12px;
        /*字体大小: 12px*/
        color: #333333;
        /*字体颜色: #333333*/
        text-decoration: line-through;
        /*删除线*/
    }
/*    促销价格 人民币标示*/
    div.infoInimgAndInfo span.promotionPriceYuan{
        font-family: Arial;
        /*字体Arial*/
        font-size: 18px;
        /*字体大小: 18px*/
        color: #C40000;
        /*字体颜色: #C40000*/
    }
/*    促销价格-价格数字*/
    div.infoInimgAndInfo span.promotionPrice{
        color: #c40000;
        /*字体颜色: #c40000*/
        font-family: Arial;
        /*字体Arial*/
        font-size: 30px;
        /*字体大小: 30px*/
        font-weight: bold;
        /*粗体*/
    }
/*    促销价格文字*/
    div.infoInimgAndInfo span.promotionPriceDesc{
        color: #999999;
        /*字体颜色: #999999*/
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
        width: 68px;
        /*宽度: 68px*/
        position: relative;
        /*相对定位*/
        left: 0px;
        /*水平不动*/
        top: -10px;
        /*垂直向上移动10px*/
    }
/*    销量和累计评价共同的div*/
    div.infoInimgAndInfo div.productSaleAndReviewNumber{
        margin: 20px 0px;
        /*上下外边距20px*/
        border-top-style: dotted;
        /*上边框虚线*/
        border-top-color: #C9C9C9;
        /*上边框颜色*/
        border-top-width: 1px;
        /*上边框宽度1px*/
        border-bottom-style: dotted;
        /*下边框虚线*/
        border-bottom-color: #C9C9C9;
        /*下边框颜色*/
        border-bottom-width: 1px;
        /*下边框宽度1px*/
        padding: 10px;
        /*内边距10px*/
    }
/*    销量和累计评价分别的div*/
    div.infoInimgAndInfo div.productSaleAndReviewNumber div{
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
        width: 49%;
        /*宽度: 49%*/
        text-align: center;
        /*文本居中*/
        color: #999999;
        /*字体颜色: #999999*/
        font-size: 12px;
      /*  字体大小: 12px*/
    }
    /*销量所处的div*/
    div.infoInimgAndInfo div.productSaleAndReviewNumber div:first-child{
        border-right-width: 1px;
        /*右边框宽度1px*/
        border-right-style: solid;
        /*右边框实线*/
        border-right-color: #E5DFDA;
      /*  右边框颜色*/
    }
    /*产品数量和库存所在div*/
    div.infoInimgAndInfo div.productNumber{
        color: #999999;
        /*字体颜色: #999999*/
    }
/*    输入数字的input所在的span*/
    div.infoInimgAndInfo span.productNumberSettingSpan{
        border: 1px solid #999;
        /*边框*/
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
        width: 43px;
        /*宽度: 43px*/
        height: 32px;
        /*高度: 32px*/
        padding-top:7px;
        /*上内边距 7px，把input顶下去*/
    }
/*    输入数字的input*/
    div.infoInimgAndInfo input.productNumberSetting{
        border: 0px;
        /*无边框*/
        height: 80%;
        /*高度: 80%*/
        width: 80%;
        /*宽度: 80%*/
    }
/*    上下箭头所使用的图片*/
    div.productNumber span.updown img{
        display:inline-block;
        /*设置成内联块，可以调整其垂直向上对齐*/
        vertical-align:top;
        /*确保垂直向上对齐，因为在不同的浏览器下，img元素可能表现出不贴在上面的现象。 贴在上面之后，再借助其所在span的内边距的padding-top就可以很方便的调整其位置*/
    }
/*    上下箭头所在的两个span*/
    div.productNumber span.updown{
        border: 1px solid #999;
        /*边框*/
        display: block;
        /*以块状显示，自动换行*/
        width: 20px;
        /*宽度: 20px*/
        height: 14px;
        /*高度: 14px*/
        text-align: center;
        /*水平居中*/
        padding-top:4px;
        /*上内边距 4px*/
    }
/*    上下箭头中间的span*/
    div.productNumber span.updownMiddle{
        height: 4px;
        /*高度: 4px*/
        display: block;
        /*以块状显示，自动换行*/
    }
/*    上下箭头图标所在的span的父span*/
    div.productNumber span.arrow{
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
        width: 22px;
        /*宽度: 22px*/
        height: 32px;
        /*高度: 32px*/
        vertical-align:top;
        /*垂直贴在上面*/
    }
/*    服务承诺信息所在div*/
    div.serviceCommitment{
        margin: 20px 0px;
        /*上下外边距20px*/
    }
/*    服务承诺四个字所在span*/
    div.infoInimgAndInfo span.serviceCommitmentDesc{
        color: #999999;
        /*字体颜色: #999999*/
    }
    /*服务承诺右侧四个连接所在span*/
    div.infoInimgAndInfo span.serviceCommitmentLink a{
        color: #666666;
        /*字体颜色: #666666*/
    }
    /*立即购买和加入购物车所在div*/
    div.buyDiv{
        margin: 20px auto;
        /*div本身居中显示*/
        text-align: center;
        /*内容水平居中显示*/
    }
/*    立即购买和加入购物车按钮*/
    div.buyDiv button{
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
        margin: 0px 10px;
        /*左右外边距10px*/
        width: 180px;
        /*宽度: 180px*/
        height: 40px;
        /*高度: 40px*/
    }
/*    立即购买按钮*/
    button.buyButton{
        border: 1px solid #C40000;
        /*边框*/
        background-color: #FFEDED;
        /*背景色: #FFEDED*/
        text-align: center;
        /*内容水平居中*/
        line-height: 40px;
        /*内容垂直居中*/
        font-size: 16px;
        /*字体大小: 16px*/
        color: #C40000;
        /*字体颜色: #C40000*/
        font-family: arial;
        /*字体arial*/
    }
/*    加入购物车按钮*/
    button.addCartButton{
        border: 1px solid #C40000;
        /*外边框*/
        background-color: #C40000;
        /*背景色: #C40000，和外边框一个颜色*/
        text-align: center;
        /*内容水平居中*/
        line-height: 40px;
        /*内容垂直居中*/
        font-size: 16px;
        /*字体大小: 16px*/
        color: white;
        /*字体颜色: white*/
        font-family: arial;
      /*  字体arial*/
    }
    /*加入购物车前的图标*/
    button.addCartButton span.glyphicon{
        font-size: 12px;
/*        字体大小: 12px*/
        margin-right: 8px;
        /*右外边距8px*/
    }
/*    超链鼠标悬停*/
    a:hover{
        text-decoration:none;
        /*超链鼠标悬停的时候,没有下划线*/
    }
/*    销量和累计评价后的数字*/
    .redColor{
        color: #C40000;
        /*字体颜色: #C40000*/
    }
    /*销量和累计评价后的数字*/
    .boldWord{
        font-weight: bold;
       /* 粗体*/
    }
</style>
```



## 3 产品详细信息


### 3.1 效果
  每种商品都有5个详细图片，而且这些图片都比较大。 为了加快显示的速度，讲解的时候，只使用一个图片。  

![效果.jpg](https://i.loli.net/2018/09/11/5b97d9753a24c.jpg)  
    
### 3.2 布局

![3242.png](https://i.loli.net/2018/09/11/5b97d9756ea6f.png)
   

### 3.3 纯HTML


```
<div class="productDetailDiv" style="display:block">
    <div class="productDetailTopPart">
        <a class="productDetailTopPartSelectedLink selected" href="#nowhere">商品详情</a>
        <a class="productDetailTopReviewLink" href="#nowhere">
                累积评价
                <span class="productDetailTopReviewLinkNumber">19</span>
        </a>
    </div>

    <div class="productParamterPart">
        <div class="productParamter">产品参数：</div>
        <div class="productParamterList">
            <span>材质成分:  聚酯纤维100% </span>
            <span>品牌:  Emyche/艾米秋 </span>
            <span>货号:  129668 </span>
            <span>尺码:  L M S XL X </span>
            <span>上市年份季节:  2016年夏季 </span>
            <span>颜色分类:  白色 黑色 浅蓝 </span>
            <span>适用年龄:  18-25周岁 </span>
        </div>
        <div style="clear:both"></div>
    </div>

    <div class="productDetailImagesPart">
        <img src="img/productDetail/8626.jpg"/>
    </div>
</div>
```

    
### 3.4 样式CSS

```
<style>
/*    产品详情div*/
    div.productDetailDiv{
        width: 790px;
        /*宽度: 790px*/
        margin: 40px auto;
        /*居中显示*/
    }
/*    顶部div*/
    div.productDetailTopPart{
        border: 1px solid #DFDFDF;
        /*边框*/
        border-left-width: 0px;
        /*左边框去掉，因为“商品详情”四个字接下来会用红色边框显示*/
    }
/*    被选中的超链*/
    a.selected{
        border-left: 1px solid #cfbfb1;
        /*左边框*/
        border-right: 1px solid #cfbfb1;
        /*右边框*/
        color: #b10000;
        /*字体颜色: #b10000*/
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
        font-weight: bold;
        /*粗体*/
        line-height: 46px;
        /*文字垂直居中*/
        width: 90px;
        /*宽度: 90px*/
        text-align: center;
        /*文字水平居中*/
        position: relative;
        /*相对定位，为的是下一步使用:before新增加的元素做绝对定位。 因为绝对定位是基于定位了的父元素*/
    }
/*    使用:before为超链上方加一个天猫色的横条*/
    a.selected:before{
        content:"";
        /*内容为空*/
        display: block;
        /*以块状显示，便于修改宽度*/
        border-width: 1px;
        /*边框宽度*/
        border-color: #b00000;
        /*边框颜色*/
        border-style: solid;
        /*边框实线*/
        width: 90px;
        /*宽度: 90px，刚好和其父元素超链宽度一样*/
        height: 0;
        /*高度: 0，无高度仅仅显示边框*/
        position: absolute;
        /*绝对定位，其父元素超链是相当定位的，所以这绝对定位就会基于父元素*/
        top: -1px;
        /*向上移动一个像素*/
        margin-left: -1px;
        /*左外边距: -1px，向左边移动一个像素，导致和左边的边框重合*/
    }
    /*使用:after 为超链上方加一个天猫色的美人尖*/
    a.selected:after{
        content: "";
        /*内容为空*/
        display: block;
        /*以块状显示，便于修改宽度*/
        border-color: #b00000 transparent transparent;
        /*美人尖的原理是只有上边框，其他边框是透明色，#b00000 transparent transparent; 这种写法既表示只有上边框有颜色，其他都是透明色*/
        border-style: solid;
        /*边框实线*/
        border-width: 5px;
        /*边框宽度*/
        width: 0;
        /*宽度: 0*/
        height: 0;
        /*高度: 0*/
        position: absolute;
        /*绝对定位*/
        top: -1px;
        /*向上移动1个像素*/
        left: 50%;
        /*居中*/
        margin-left: -5px;
        /*向左边移动-5px*/
    }
/*    累计评论超链*/
    a.productDetailTopReviewLink{
        padding: 0px 20px;
        /*左右内边距20px*/
        border-right: 1px dotted #D2D2D2;
        /*右侧边框呈点状*/
        color: #333333;
        /*字体颜色: #333333*/
    }
/*    评论数量*/
    span.productDetailTopReviewLinkNumber{
        color: #3355B9;
        /*字体颜色: #3355B9*/
    }
/*    参数列表div*/
    div.productParamterPart{
        border: 1px solid #DFDFDF;
        /*边框实线*/
        padding: 40px;
        /*内边距40px*/
    }
/*    产品参数四个字*/
    div.productParamter{
        color: #999999;
        /*字体颜色: #999999*/
        font-weight: bold;
        /*粗体*/
        margin-bottom: 20px;
        /*下外边距20px*/
    }
/*    产品参数项*/
    div.productParamterList span{
        display: block;
        /*以块状显示，自动换行*/
        width: 220px;
        /*宽度: 220px*/
        float: left;
        /*向左漂浮，这样可以水平摆放*/
        padding: 8px 0px;
        /*上下内边距8px*/
        color: #666666;
        /*字体颜色: #666666*/
    }
/*    详情图片*/
    div.productDetailImagesPart img{
        display: block;
        /*显示为块级元素，自动换行*/
        width: 790px;
        /*宽度: 790px，详情图片都是这样的宽度的大图片*/
        margin:20px 0px;
        /*上下外边距*/
    }
/*    整个body*/
    body{
        font-size: 12px;
        /*把所有文字的大小调成12px,这是天猫默认的文字大小*/
        font-family: Arial;
        /*字库使用Arial*/
    }
/*    鼠标悬停*/
    a:hover{
        text-decoration:none;
        /*超链鼠标悬停的时候,没有下划线*/
        color: #C40000;
        /*超链鼠标悬停的时候,使用天猫红显示*/
    }
</style>
```



## 4 累计评价



### 4.1 效果

![效果.jpg](https://i.loli.net/2018/09/11/5b97df68a7dbf.jpg) 
    
    
### 4.2 布局
    
![3248.png](https://i.loli.net/2018/09/11/5b97df68b5161.png)
    
### 4.3 纯HTML
    
```
<div class="productPageDiv">
    <div class="productReviewDiv" style="display: block">
        <div class="productReviewTopPart">
            <a class="productReviewTopPartSelectedLInk" href="#nowhere">商品详情</a>
            <a class="selected" href="#nowhere">
                累积评价
                <span class="productReviewTopReviewLinkNumber">19</span>
            </a>
        </div>
        <div class="productReviewContentPart">
            <div class="productReviewItem">
                <div class="productReviewItemDesc">
                    <div class="productReviewItemContent">
                        不错的购物，包装很精细，布料也不错舒服，
                        因为之前一直购买品牌装，很好的一次网购，
                        生完宝宝刚刚一个多月我一百五十斤穿2XL不错
                    </div>
                    <div class="productReviewItemDate">2016-08-10</div>
                </div>
                <div class="producReviewItemUserInfo">
                    哀****莉<span class="userInfoGrayPart">（匿名）</span>
                </div>
                <div style="clear: both;"></div>
            </div>

            <div class="productReviewItem">
                <div class="productReviewItemDesc">
                    <div class="productReviewItemContent">
                        面料很好，大小也刚刚好，本来买之前还担心，犹豫，
                        等货到了，比我心中想象的好很多，
                        大家放心购买，很满意的购物，以后还会来??
                    </div>
                    <div class="productReviewItemDate">2016-08-10</div>
                </div>
                <div class="producReviewItemUserInfo">
                    贤*闲<span class="userInfoGrayPart">（匿名）</span>
                </div>
                <div style="clear: both;"></div>
            </div>

            <div class="productReviewItem">
                <div class="productReviewItemDesc">
                    <div class="productReviewItemContent">
                        <span>商品：</span>宝贝料子和手感都不错，是值这价，
                        卖家很贴心的送了内衣带，5分好评是必须的。喜欢的可以 下手了
                    </div>
                    <div class="productReviewItemDate">2016-08-10</div>
                </div>
                <div class="producReviewItemUserInfo">
                    孤*****爱<span class="userInfoGrayPart">（匿名）</span>
                </div>
                <div style="clear: both;"></div>
            </div>

        </div>
    </div>
</div>
```
    
### 4.4 样式CSS

```
<style>
    body{/*整个body*/
        font-size: 12px;
       /* 把所有文字的大小调成12px,这是天猫默认的文字大小*/
        font-family: Arial;
        /*字库使用Arial*/
    }
    div.productReviewDiv{/*评价div*/
        width: 790px;
        /*宽度: 790px*/
        margin: 40px auto;
     /*   居中显示*/
    }
    div.productReviewTopPart{/*标题div*/
        border: 1px solid #DFDFDF;
        /*边框*/
    }
    a.productReviewTopPartSelectedLink{/*商品详情超链*/
        padding: 0px 20px;
        /*左右内边距*/
        color: #333333;
        /*字体颜色: #333333*/
    }
    a.selected{/*累计评价超链*/
        border-left: 1px solid #cfbfb1;
        /*左侧边框*/
        border-right: 1px solid #cfbfb1;
        /*右侧边框*/
        color: #b10000;
        /*字体颜色: #b10000*/
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
        font-weight: bold;
        /*粗体*/
        line-height: 46px;
        /*文本垂直居中*/
        width: 90px;
        /*宽度: 90px*/
        text-align: center;
        /*文本水平居中*/
        position: relative;
     /*   相对定位，为的是下一步使用:before新增加的元素做绝对定位。 因为绝对定位是基于定位了的父元素*/
    }
    a.selected:before{/*使用:before为超链上方加一个天猫色的横条*/
        content: "";
        /*内容为空*/
        display: block;
        /*以块状显示，便于修改宽度*/
        border-width: 1px;
        /*边框宽度*/
        border-style: solid;
        /*边框实线*/
        border-color: #b00000;
        /*边框颜色*/
        width: 90px;
        /*宽度: 90px，刚好和其父元素超链宽度一样*/
        height: 0;
        /*高度: 0，无高度仅仅显示边框*/
        position: absolute;
        /*绝对定位，其父元素超链是相当定位的，所以这绝对定位就会基于父元素*/
        top: -1px;
        /*向上移动一个像素*/
        margin-left: -1px;
        /*左外边距: -1px，向左边移动一个像素，导致和左边的边框重合*/
    }
    a.selected:after{/*使用:after 为超链上方加一个天猫色的美人尖*/
        content: "";
        /*内容为空*/
        display: block;
        /*以块状显示，便于修改宽度*/
        border-color: #b00000 transparent transparent;
        /*美人尖的原理是只有上边框，其他边框是透明色，#b00000 transparent transparent; 这种写法既表示只有上边框有颜色，其他都是透明色*/
    border-style: solid;
        /*边框实线*/
        border-width: 5px;
        /*边框宽度*/
        width: 0;
        /*宽度: 0*/
        height: 0;
        /*高度: 0*/
        position: absolute;
        /*绝对定位*/
        top: -1px;
        /*向上移动1个像素*/
        left: 50%;
        /*居中*/
        margin-left: -5px;
        /*向左边移动-5px*/
    }
    div.productReviewContentPart{/*评价内容div*/
        padding-top: 50px;
     /*   上内边距: 50px*/
    }
    div.productReviewItem{/*评价条目*/
        border-bottom: 1px solid #E3E3E3;
        /*下边框*/
        margin: 10px 0px;
     /*   上下外边距10px*/
    }
    div.productReviewItem div.productReviewItemDesc{/*评价描述*/
        width: 80%;
        /*宽度: 80%*/
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
        color: #333333;
        /*字体颜色: #333333*/
        margin: 5px 20px;
        /*外边距*/
        float: left;
        /*向左漂浮，这样可以水平摆放*/
    }
    div.productReviewItemDate{/*评价日期*/
        margin: 15px 0px 0px 0px;
        /*上边距15px*/
        color: #CCCCCC;
        /*字体颜色: #CCCCCC*/
    }
    div.productReviewItem div.productReviewItemUserInfo{/*用户信息*/
        color: #404040;
        /*字体颜色: #404040*/
        margin: 5px 20px;
        /*外边距*/
        padding: 20px 0;
        /*上下内边距*/
    }
    span.userInfoGrayPart{/*用户匿名括弧*/
        color: #999999;
     /*   字体颜色: #999999*/
    }
    a:hover{/*超链鼠标悬停*/
        color:#C40000;
        /*天猫红*/
        text-decoration:none;
        /*超链鼠标悬停的时候,没有下划线*/
    }
</style>
```

	2018-09-11 20:24:01
kumika	模仿天猫实战SSM--购物车页面	# 模仿天猫实战SSM--购物车页面



# 购物车页面：

有2个部分组成，结算按钮 和订单项内容


## 1 结算按钮

### 1.1效果

因为购物车里面的订单项部分比较复杂，所以先把结算按钮这部分简单的拿出来单独讲解。 后面就可以专注在订单项部分的讲解了
![效果.jpg](https://i.loli.net/2018/09/12/5b987c214e02d.jpg)

### 1.2 布局

![3263.png](https://i.loli.net/2018/09/12/5b987beec666d.png)


### 1.3 纯HTML

```
<div class="cartDiv">
    <div class="cartTitle pull-right">
        <span>已选商品（不含运费）</span>
        <span class="cartTitlePrice">￥0.00</span>
        <button class="createOrderButton" style="background-color: rgb(170,170,170);" disabled="disabled">结算</button>
    </div>
    <div style="text-align: center;color:grey;line-height: 100px;">
        订单项内容，在下个知识点讲解
    </div>
    <div class="cartFoot">
        <img src="img/site/cartNotSelected.png" class="selectAllItem" selectit="false"/>
        <span>全选</span>
        <div class="pull-right">
            <span>已选商品<span class="cartSumNumber">0</span> 件</span>
            <span>合计（不含运费）：</span>
            <span class="cartSumPrice">￥0.00</span>
            <button class="createOrderButton" style="background-color: rgb(170,170,170)" disabled="disabled">结  算</button>
        </div>
    </div>
</div>
```

### 1.4 样式CSS

```
<style>
    span.cartSumPrice{/*下面的价格*/
        color: #C40000;
        /*字体颜色: #C40000*/
        font-weight: bold;
        /*粗体*/
        font-size: 20px;
        /*字体大小: 20px*/
    }
    span.cartSumNumber{
        color: #C40000;
        /*字体颜色: #C40000*/
        font-weight: bold;
        /*粗体*/
        font-size: 16px;
        /*字体大小: 16px*/
    }
    img.cartProductItemIfSelected, img.selectAllItem{/*选择框是一个图片，当鼠标放上去呈现点击状*/
        cursor: pointer;
       /* 鼠标呈现点击状*/
    }
    div.cartFoot button{/*下面的结算按钮*/
        background-color: #AAAAAA;
     /*   背景色: #AAAAAA*/
        border: 0px solid #AAAAAA;
        /*去掉边框*/
        color: white;
        /*字体颜色: white*/
        width: 120px;
        /*宽度: 120px*/
        height: 50px;
        /*高度: 50px*/
        font-size: 20px;
        /*字体大小: 20px*/
        text-align: center;
        /*文本水平居中*/
    }
    div.cartFoot{/*购物车的页脚*/
        background-color: #E5E5E5;
        /*背景色: #E5E5E5*/
        line-height: 50px;
        /*文本垂直居中*/
        margin: 20px 0px;
        /*上下外边距20px*/
        color: black;
        /*字体颜色: black*/
        padding-left: 20px;
        /*左内边距: 20px*/
    }
    span.cartTitlePrice{/*上面的价格信息*/
        color: #C40000;
        /*字体颜色: #C40000*/
        font-size: 14px;
        /*字体大小: 14px*/
        font-weight: bold;
        /*粗体*/
        margin-left: 5px;
        /*左外边距: 5px*/
        margin-right: 3px;
        /*右边距3px*/
    }
    div.cartTitle button{/*上面的结算按钮*/
        background-color: #AAAAAA;
        /*背景色: #AAAAAA*/
        border: 1px solid #AAAAAA;
        /*边框和背景色一个颜色*/
        color: white;
        /*字体颜色: white*/
        width: 53px;
        /*宽度: 53px*/
        height: 25px;
        /*高度: 25px*/
        border-radius: 2px;
        /*圆角*/
    }
    div.cartDiv{/*整个购物车div*/
        max-width: 1013px;
     /*   最大宽度1013，有时候用户的分辨率很高，比如1600x1200,使用1013可以使购物车这一块仅仅显示在中间，而不是平铺满整个屏幕，那样不好看*/
        margin: 10px auto;
        /*本元素居中显示*/
        color: black;
        /*字体颜色: black*/
    }
    body{
        font-size: 12px;
        /*把所有文字的大小调成12px,这是天猫默认的文字大小*/
        font-family: Arial;
        /*字库使用Arial*/
    }
</style>
```




## 2 订单项内容



### 2.1效果

![效果.jpg](https://i.loli.net/2018/09/12/5b988233aefae.jpg)


### 2.2 布局

![3275.png](https://i.loli.net/2018/09/12/5b988233adc2b.png)

    
### 2.3 纯HTML

```
<div class="cartDiv">
    <div class="cartProductList">
        <table class="cartProductTable">
            <thead>
                <tr>
                    <th class="selectAndImage">
                        <img src="img/site/cartNotSelected.png" class="selectAllItem" selecttit="false"/>
                        全选
                    </th>
                    <th>商品信息</th>
                    <th>单价</th>
                    <th>数量</th>
                    <th width="120px">金额</th>
                    <th class="operation">操作</th>
                </tr>
            </thead>
            <tbody>
                <tr class="cartProductItemTR" oiid="936">
                    <td>
                        <img src="img/site/cartNotSelected.png" class="cartProductItemIfSelected" oiid="936"
                             selectit="false"/>
                        <a href="#nowhere" style="display: none">
                            <img src="img/site/cartSelected.png">
                            <img width="40px" src="img/productSingle_middle/3665.jpg" class="cartProductImg">
                        </a>
                    </td>
                    <td>
                        <div class="cartProductLinkOutDiv">
                            <a class="cartProductLink" href="#nowhere">
                                美国iRobot扫地机器人吸尘器全自动家用智能扫地机650 天猫电器城
                            </a>
                            <div class="cartProductLinkInnerDiv">
                                <img title="支持信用卡支付" src="img/site/creditcard.png">
                                <img title="消费者保障服务,承诺7天退货" src="img/site/7day.png">
                                <img title="消费者保障服务,承诺如实描述" src="img/site/promise.png">
                            </div>
                        </div>
                    </td>
                    <td>
                        <span class="cartProductItemOringalPrice">￥7580.0</span>
                        <span class="cartProductItemPromotionPrice">￥5306.0</span>
                    </td>
                    <td>
                        <div class="cartProductChangeNumberDiv">
                            <span pid="365" class="hidden orderItemStock">75</span>
                            <span pid="365" class="hidden orderItemPromotionPrice">5306</span>
                            <a href="#nowhere" class="numberMinus" pid="365">-</a>
                            <input value="4" autocomplete="off" class="orderItemNumberSetting" oiid="936" pid="365">
                            <a href="#nowhere" class="numberPlus" pid="365" stock="75">+</a>
                        </div>
                    </td>
                    <td>
                        <span pid="365" oiid="936" class="cartProductItemSmallSumPrice">￥5306</span>
                    </td>
                    <td>
                        <a href="#nowhere" oiid="936" class="deleteOrderItem">删除</a>
                    </td>
                </tr>

                <tr class="cartProductItemTR" oiid="935">
                    <td>
                        <img src="img/site/cartNotSelected.png" class="cartProductItemIfSelected" oiid="935"
                             selectit="false"/>
                        <a href="#nowhere" style="display: none">
                            <img src="img/site/cartSelected.png">
                            <img width="40px" src="img/productSingle_middle/8510.jpg" class="cartProductImg">
                        </a>
                    </td>
                    <td>
                        <div class="cartProductLinkOutDiv">
                            <a class="cartProductLink" href="#nowhere">
                                阔腿裤三件套装女夏装2016新款大码雪纺时尚休闲气质棉麻九分裤潮
                            </a>
                            <div class="cartProductLinkInnerDiv">
                                <img title="支持信用卡支付" src="img/site/creditcard.png">
                                <img title="消费者保障服务,承诺7天退货" src="img/site/7day.png">
                                <img title="消费者保障服务,承诺如实描述" src="img/site/promise.png">
                            </div>
                        </div>
                    </td>
                    <td>
                        <span class="cartProductItemOringalPrice">￥235.0</span>
                        <span class="cartProductItemPromotionPrice">￥152.75</span>
                    </td>
                    <td>
                        <div class="cartProductChangeNumberDiv">
                            <span pid="809" class="hidden orderItemStock">17</span>
                            <span pid="809" class="hidden orderItemPromotionPrice">152.75</span>
                            <a href="#nowhere" class="numberMinus" pid="809">-</a>
                            <input value="1" autocomplete="off" class="orderItemNumberSetting" oiid="935" pid="809">
                            <a href="#nowhere" class="numberPlus" pid="809" stock="17">+</a>
                        </div>
                    </td>
                    <td>
                        <span pid="809" oiid="935" class="cartProductItemSmallSumPrice">￥152.75</span>
                    </td>
                    <td>
                        <a href="#nowhere" oiid="935" class="deleteOrderItem">删除</a>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>
```
 
### 2.4 样式CSS

```
<style>
/*    购物车div*/
    div.cartDiv{
        max-width: 1013px;
        /*最大宽度1013，有时候用户的分辨率很高，比如1600x1200,使用1013可以使购物车这一块仅仅显示在中间，而不是平铺满整个屏幕，那样不好看*/
        margin: 10px auto;
        /*本元素居中显示*/
        color: black;
        字体颜色: black
    }
/*    商品table*/
    table.cartProductTable{
        width: 100%;
        /*宽度: 100%*/
        font-size:12px;
        /*字体大小:12px*/
    }
/*    商品所在的每一行*/
    tr.cartProductItemTR{
        border: 1px solid #CCCCCC;
        /*边框*/
    }
/*    商品所在的每一列*/
    tr.cartProductItemTR td{
        padding: 20px 20px;
        /*内边距*/
    }
/*    表头信息的每一列*/
    table.cartProductTable th{
        font-weight: normal;
        /*正常字体粗细*/
        color: #3C3C3C;
        /*字体颜色: #3C3C3C*/
        padding: 20px 20px;
        /*内边距*/
    }
/*    商品图片*/
    img.cartProductImg{
        padding: 1px;
        /*内边距*/
        border: 1px solid #EEEEEE;
        /*边框*/
        width: 80px;
        /*宽度: 80px*/
        height: 80px;
        /*高度: 80px*/
    }
/*    图片所在列*/
    table.cartProductTable th.selectAndImage{
        width:100px;
        /*宽度:10px*/
    }
/*    最后一列*/
    table.cartProductTable th.operation{
        width:30px;
        /*宽度:30px*/
    }
/*    产品连接所在div*/
    div.cartProductLinkOutDiv{
        position: relative;
        /*相对定位，之所以要使用相对定位，是这个div里有用来放3个图标的另一个div:cartProductLinkInnerDiv,而cartProductLinkInnerDiv需要使用据对定位*/
        height: 80px;
        /*高度: 80px*/
    }
/*    产品连接*/
    a.cartProductLink{
        color: #3C3C3C;
        /*字体颜色: #3C3C3C*/
    }
/*    产品连接悬停状态*/
    a.cartProductLink:hover{
        color: #C40000;
        /*字体颜色: #C40000*/
        text-decoration: underline;
        /*有下划线*/
    }
/*    产品连接下面的三个图标所在div*/
    div.cartProductLinkInnerDiv{
        position: absolute;
        /*绝对定位*/
        bottom: 0;
        /*贴在下面*/
        height: 20px;
        /*高度: 20px*/
    }
/*    原始价格*/
    span.cartProductItemOringalPrice{
        text-decoration: line-through;
        /*删除线*/
        color: #9C9C9C;
        /*字体颜色: #9C9C9C*/
        display: block;
        /*以块状显示，自动换行, 并且可以修改宽度*/
        font-weight: bold;
        /*粗体*/
        font-size: 14px;
        /*字体大小: 14px*/
    }
/*    促销价格*/
    span.cartProductItemPromotionPrice{
        font-family: Arial;
        /*使用Arial字体的目的是为了把￥正常显示出来*/
        font-size: 14px;
        /*字体大小: 14px*/
        font-weight: bold;
        /*粗体*/
        color: #C40000;
        /*字体颜色: #C40000*/
    }
/*    调整数量div*/
    div.cartProductChangeNumberDiv{
        border: solid 1px #E5E5E5;
        /*边框*/
        width: 80px;
        /*宽度: 80px*/
    }
/*    增加和减少*/
    div.cartProductChangeNumberDiv a{
        width: 14px;
        /*宽度: 14px*/
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
        text-align: center;
        /*文本水平居中*/
        color: black;
        /*字体颜色: black*/
        text-decoration: none;
        /*无下划线*/
    }
/*    数量输入框*/
    div.cartProductChangeNumberDiv input{
        border: solid 1px #AAAAAA;
        /*边框*/
        width: 42px;
        /*宽度: 42px*/
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
    }
/*    小计金额*/
    span.cartProductItemSmallSumPrice{
        font-family: Arial;
        /*使用Arial字体的目的是为了把￥正常显示出来*/
        font-size: 14px;
        /*字体大小: 14px*/
        font-weight: bold;
        /*粗体*/
        color: #C40000;
        /*字体颜色: #C40000*/
    }
/*    最前方的是否选中图片*/
    img.cartProductItemIfSelected, img.selectAllItem{
        cursor: pointer;
       /* 鼠标呈点击状*/
    }
</style>
```


	2018-09-12 10:34:50
kumika	模仿天猫实战SSM--我的订单页面	#模仿天猫实战SSM--我的订单页面

#我的订单页面：


我的订单页面和购物车一样，需要登录后，购买并付款，才能在我的订单页面查看到相关数据。 

没有账号可以先在注册页面新注册一个账号，登录后，随便选中某一个商品直接购买，并付款，即可在我的订单查看到相关数据。 

购物车的页面分析，分为简单的标题部分，较为复杂的产品列表部分以及交互 三部分构成

交互部分，我现在阶段还不适合深入，知道有这个方法就可以了，了解而已

## 1 标题部分

### 1.1 效果

![效果.jpg](https://i.loli.net/2018/09/12/5b98b91024b14.jpg)

### 1.2 布局

![3289.png](https://i.loli.net/2018/09/12/5b98b9101cffe.png)

### 1.3 纯HTML

```
<div class="boughtDiv">
    <div class="orderType">
        <div class="selectedOrderType">
            <a href="#nowhere" orderstatus="all">所有订单</a>
        </div>
        <div>
            <a href="#nowhere" orderstatus="waitPay">待付款</a>
            <a href="#nowhere" orderstatus="waitDelivery">待发货</a>
            <a href="#nowhere" orderstatus="waitConfirm">待收货</a>
            <a href="#nowhere" orderstatus="waitReview" class="noRightborder">待收货</a>
            <div class="orderTypeLastOne">
            </div>
        </div>
        <div style="clear:both"></div>
        <div class="orderListTitle">
            <table class="orderListTitleTable">
                <tbody>
                    <tr>
                        <td>宝贝</td>
                        <td width="100px">单价</td>
                        <td width="100px">数量</td>
                        <td width="100px">实际付款</td>
                        <td width="100px">交易操作</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</div>
```


### 1.4 样式CSS

```
<style>
    div.boughtDiv{/*订单页面*/
        max-width: 1013px;
        /*最大宽度1013，有时候用户的分辨率很高，比如1600x1200,使用1013可以使订单页面这一块仅仅显示在中间，而不是平铺满整个屏幕，那样不好看*/
        margin: 10px auto;
        /*本元素居中显示*/
    }
/*    各种订单类型*/
    div.orderType div{
        border-bottom: 2px solid #E8E8E8;
        /*下边框*/
        float: left;
        /*向左漂浮，这样可以水平摆放*/
    }
/*    订单类型超链*/
    div.orderType a{
        border-right: 1px solid #E8E8E8;
        /*右边框*/
        display:inline-block;
        /*显示为内联块，这样下外边距才能生效*/
        font-size: 16px;
        /*字体大小: 16px*/
        font-weight: bold;
        /*粗体*/
        color: black;
        /*字体颜色: black*/
        margin-bottom: 10px;
        /*下外边距*/
        padding: 0px 20px;
        /*左右内边距*/
        text-decoration: none;
        /*无下划线*/
    }
/*    订单类型超链鼠标悬浮*/
    div.orderType a:hover{
        color: #C40000;
        /*字体颜色: #C40000*/
        text-decoration: none;
        /*无下划线*/
    }
/*    选中的订单类型div*/
    div.orderType div.selectedOrderType{
        border-bottom: 2px solid #C40000;
        /*下边框*/
    }
/*    选中的订单类型超链*/
    div.orderType div.selectedOrderType a{
        color: #C40000;
        /*字体颜色: #C40000*/
    }
/*    右边的空的div*/
    div.orderTypeLastOne{
        overflow: hidden;
        /*隐藏滚动条*/
        float: none !important;
        /*取消浮动，就会自动出现在右边，并且把剩下的占满*/
        border-bottom: 2px solid #E8E8E8;
        /*下边框*/
        height:35px;
        /*高度:35px*/
    }
/*    待评估超链*/
    a.noRightborder{
        border-right-width:0px !important;
        /*去掉右边框*/
    }
/*    订单列表标题所在表格*/
    table.orderListTitleTable{
        border: 1px solid #E8E8E8;
        /*边框*/
        width: 100%;
        /*宽度: 100%*/
        margin: 20px 0px;
        /*上下外边距*/
        background-color: #F5F5F5;
        /*背景色: #F5F5F5*/
        text-align: center;
        /*文本水平居中*/
        font-size:12px;
        /*字体大小12px*/
    }
/*    订单列表标题*/
    table.orderListTitleTable td{
        padding: 12px 0px;
        /*垂直内边距*/
    }
</style>
```



## 2 产品列表部分

### 2.1 效果

![效果.jpg](https://i.loli.net/2018/09/12/5b98ba2a4aaf1.jpg)

### 2.2 布局

![3295.png](https://i.loli.net/2018/09/12/5b98ba2a2ee69.png)


### 2.3 纯HTML

```
<div class="boughtDiv">
    <div class="orderListItem">
        <table oid="946" orderstatus="waitReview" class="orderListItemTable">
            <tbody>
                <tr class="orderListItemFirstTR">
                    <td colspan="2">
                        <b>2016-09-12 17:00:41</b>
                        <span>订单号: 20160912170041674794</span>
                    </td>
                    <td colspan="2">
                        <img src="img/site/orderItemTmall.png">天猫商城
                    </td>
                    <td colspan="1">
                        <a href="#nowhere" class="wangwanglink">
                            <div class="orderItemWangWangGif"></div>
                        </a>
                    </td>
                    <td class="orderItemDeleteTD">
                        <a href="#nowhere" oid="946" class="deleteOrderLink">
                            <span class="orderListItemDelete glyphicon glyphoneicon-trash"></span>
                        </a>
                    </td>
                </tr>

                <tr class="orderItemProductInfoPartTR">
                    <td class="orderItemProductInfoPartTD">
                        <img width="80" height="80" src="img/productSingle_middle/3796.jpg">
                    </td>
                    <td class="orderItemProducInfoPartTD">
                        <div class="orderListItemProductLinkOutDiv">
                            <a href="#nowhere">
                                公众智能扫地机器人家用全自动电动清洁地毯擦拖地一体机吸尘器
                            </a>
                            <div class="orderListItemProductLinkInnerDiv">
                                <img title="支持信用卡支付" src="img/site/creditcard.png"/>
                                <img title="消费者保障服务,承诺7天退货" src="img/site/7day.png"/>
                                <img title="消费者保障服务,承诺如实描述" src="img/site/promise.png"/>
                            </div>
                        </div>
                    </td>
                    <td width="100px" class="orderItemProductInfoPartTD">
                        <div class="orderListITemProductOriginalPrice">
                            ￥2,499.00
                        </div>
                        <div class="orderListItemProductPrice">
                            ￥2,124.15
                        </div>
                    </td>
                    <td width="100px" valign="top" class="orderListItemNumberTD orderItemOrderInfoPartTD" rowspan="1">
                        <span class="orderListItemNumber">1</span>
                    </td>
                    <td width="120px" valign="top" class="orderListItemProductRealPriceTD orderItemOrderInfoPartTD"  rowspan="1">
                          <div class="orderListItemProductRealPrice">
                             ￥2,124.15
                          </div>
                          <div class="orderListItemPriceWithTransport">
                             (含运费：￥0.00)
                          </div>
                    </td>

                    <td width="100px" valign="top" class="orderListItemButtonTD orderItemOrderInfoPartTD" rowspan="1">
                        <a href="#nowhere">
                            <button class="orderListItemReview">评价</button>
                        </a>
                    </td>
                </tr>
            </tbody>
        </table>

        <table oid="945" orderstatus="waitConfirm" class="orderListItemTable">
            <tbody>
            <tr class="orderListItemFirstTR">
                <td colspan="2">
                    <b>2018-09-12 17:00:33</b>
                    <span>订单号: 201609121700333128784</span>
                </td>
                <td colspan="2">
                    <img src="img/site/orderItemTmall.png">天猫商城
                </td>
                <td colspan="1">
                    <a href="#nowhere" class="wangwanglink">
                        <div class="orderItemWangWangGif"></div>
                    </a>
                </td>
                <td class="orderItemDeleteTD">
                    <a href="#nowhere" oid="946" class="deleteOrderLink">
                        <span class="orderListItemDelete glyphicon glyphoneicon-trash"></span>
                    </a>
                </td>
            </tr>

            <tr class="orderItemProductInfoPartTR">
                <td class="orderItemProductInfoPartTD">
                    <img width="80" height="80" src="img/productSingle_middle/3796.jpg">
                </td>
                <td class="orderItemProducInfoPartTD">
                    <div class="orderListProductLinkOutDiv">
                        <a href="#nowhere">
                            ULIFE原创信封包男个性真皮手包男士手拿包休闲男包手抓包拉链潮
                        </a>
                        <div class="orderListItemProductLinkInnerDiv">
                            <img title="支持信用卡支付" src="img/site/creditcard.png"/>
                            <img title="消费者保障服务,承诺7天退货" src="img/site/7day.png"/>
                            <img title="消费者保障服务,承诺如实描述" src="img/site/promise.png"/>
                        </div>
                    </div>
                </td>
                <td width="100px" class="orderItemProductInfoPartTD">
                    <div class="orderListItemProductOriginalPrice">
                        ￥1,188.00
                    </div>
                    <div class="orderListItemProductPrice">
                        ￥1,128.60
                    </div>
                </td>
                <td width="100px" valign="top" class="orderListItemNumberTD orderItemOrderInfoPartTD" rowspan="1">
                    <span class="orderListItemNumber">1</span>
                </td>
                <td width="120px" valign="top" class="orderListItemProductRealPriceTD orderItemOrderInfoPartTD"  rowspan="1">
                    <div class="orderListItemProductRealPrice">
                        ￥1,128.60
                    </div>
                    <div class="orderListItemPriceWithTransport">
                        (含运费：￥0.00)
                    </div>
                </td>

                <td width="100px" valign="top" class="orderListItemButtonTD orderItemOrderInfoPartTD" rowspan="1">
                    <a href="#nowhere">
                        <button class="orderListItemConfirm">确认收货</button>
                    </a>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
</div>
```


### 2.4样式CSS

```
<style>
    div.boughtDiv{/*订单页面div*/
        max-width: 1013px;
        /*最大宽度1013，有时候用户的分辨率很高，
        比如1600x1200,使用1013可以使订单页面这一块仅仅显示在中间，
        而不是平铺满整个屏幕，那样不好看*/
        margin: 10px auto;
        /*本元素居中显示*/
    }
    table.orderListItemTable{/*订单项目所在表格*/
        border: 2px solid #ECECEC;
        width: 100%;
        margin: 20px 0px;
        font-size:12px;
    }
    table.orderListItemTable:hover {/*表格悬停状态*/

        border: 2px solid #aaa !important;
    }
    table.orderListItemTable td{/*单元格*/
        padding: 8px 10px;/*内边距*/
    }
    tr.orderListItemFirstTR{/*标题行*/
        background-color: #F1F1F1;
    }
    div.orderItemWangWangGif{/*旺旺图标*/
        display: inline-block;/*显示为内联，既可以设置大小，又能够不换行*/
        width: 67px;
        height: 22px;
        /*//不知道用什么连接，是要上传到服务器上的，还是文件夹里面的*/
        background-image:url(http://how2j.cn/tmall/img/site/wangwang.gif);/*背景图片*/
        background-repeat: no-repeat;/*不重复*/
        background-color: transparent;/*背景色: transparent*/
        background-attachment: scroll;/*滚动背景图片*/
        background-position: -0px -0px;/*取背景图片左上角*/
        position: relative;
        top: 0px;
        left: 2px;
    }
    td.orderItemDeleteTD{/*删除列*/
        text-align: right;/*文本居右*/
    }
    span.orderListItemDelete{/*删除按钮*/
        display: inline-block;/*显示为内联，既可以设置大小，又能够不换行*/
        margin: 0px 10px;
        color: #999999;
        font-size: 16px;
    }
    div.orderListItemProductLinkOutDiv{/*产品连接外部div*/
        position: relative;
        height: 80px;
    }
    div.orderListItemProductLinkInnerDiv{/*三个图标所在div*/
        position: absolute;
        bottom: 0px;
    }
    div.orderListItemProductOriginalPrice{/*原始价格*/
        color: #999999;
        font-size: 14px;
    }
    div.orderListItemProductPrice{/*促销价格*/
        color: #3C3C3C;
        font-size: 14px;
    }
    td.orderListItemNumberTD{/*数量所在td*/
        text-align: center;
    }
    td.orderItemOrderInfoPartTD{/*订单项所在td*/
        border: solid 1px #ECECEC;
    }
    span.orderListItemNumber{/*数量颜色*/
        color: #3C3C3C;
    }
    td.orderListItemProductRealPriceTD{/*价格td*/
        text-align: center;
    }
    div.orderListItemProductRealPrice{/*价格信息*/
        color: #3C3C3C;
        font-size: 14px;
        font-weight: bold;
    }
    div.orderListItemPriceWithTransport{/*运费*/
        color: #6C6C6C;
        font-size: 12px;
    }
    td.orderListItemButtonTD{/*按钮所在td*/
        text-align: center;
    }
    button.orderListItemReview{/*评价按钮*/
        border: 1px solid #DCDCDC;
        background-color: #fff;
        border-radius: 2px;
        color: #3C3C3C;
        font-size: 12px;
        font-weight: bold;
        padding: 6px 12px;
    }
    button.orderListItemReview:hover{/*评价按钮鼠标悬浮状态*/
        border-color: #C40000;
        color: #C40000;
    }
    button.orderListItemConfirm{/*确认收货按钮
*/
        background-color: #66B6FF;
        border-radius: 2px;
        color: white;
        font-size: 12px;
        font-weight: bold;
        border-width: 0px;
        padding: 6px 12px;
    }
    button.orderListItemConfirm:hover{/*确认收货按钮鼠标悬浮状态*/
        background-color: #118ADB;
    }
    a{/*所有超链*/
        color:#999;
    }
    a:hover{/*超链鼠标悬停*/
        text-decoration:none;
        color: #C40000;
    }
</style>
```











	2018-09-12 14:43:34
kumika	模仿天猫SSM--结算页面	#模仿天猫SSM--结算页面

结算页面和购物车一样，需要登录后，直购买商品，或者在购物车中点击结算按钮才能够访问 

没有账号可以先在注册页面新注册一个账号，登录后，随便选中某一个商品直接购买，进入结算页面。 

购物车的页面分析，分为简单的头部和收货地址，较为复杂的确认订单信息以及交互 三部分构成

## 1 头部和收货地址


### 1.1 效果：

![效果.jpg](https://i.loli.net/2018/09/12/5b98c83bdea6f.jpg)





### 1.2 布局

![3310.png](https://i.loli.net/2018/09/12/5b98c83bca6c1.png)






### 1.3 纯HTML

```
<div class="buyPageDiv">
    <div class="productList">
        <div class="productListTip">确认订单信息</div>
        <table class="productListTable">
            <thead>
                <tr>
                    <th class="productListTableFirstColumn" colspan="2">
                        <img src="img/site/tmallbuy.png" class="tmallbuy"/>
                        <a href="#nowhere" class="marketLink">店铺：天猫店铺</a>
                        <a href="#nowhere" class="wangwanglink">
                            <span class="wangwangGif"></span>
                        </a>
                    </th>
                    <th>单价</th>
                    <th>数量</th>
                    <th>小计</th>
                    <th>配送方式</th>
                </tr>
                <tr class="rowborder">
                    <td colspan="2"></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </thead>
            <tbody class="productListTableTbody">
                <tr class="orderItemTR">
                    <td class="orderItemFirstTD">
                        <img src="img/productSingle_middle/4206.jpg" width="20px" class="orderItemImg">
                    </td>
                    <td class="orderItemProductInfo">
                        <a href="#nowhere" class="orderItemProductLink">
                            Philips/飞利浦 HR1897/30破壁微榨原汁机 多功能家用果汁榨汁机
                        </a>
                        <img title="支持信用卡支付" src="img/site/creditcard.png">
                        <img title="消费者保障服务,承诺7天退货" src="img/site/7day.png">
                        <img title="消费者保障服务,承诺如实描述" src="img/site/promise.png">
                    </td>
                    <td>
                        <span class="orderItemProductPrice">￥3,514.05</span>
                        <span class="orderItemProductNumber">2</span>
                    </td>
                    <td>
                        <span class="orderItemUnitSum">￥7,028.10</span>
                    </td>
                    <td class="orderItemLastTD" rowspan="5">
                        <label class="orderItemDeliveryLabel">
                            <input type="radio" checked="checked" value="">
                            普通配送
                        </label>
                        <select class="orderItemDeliverySelect">
                            <option>快递 免邮费</option>
                        </select>
                    </td>
                </tr>

                <tr class="orderItemTR">
                    <td class="orderItemFirstTD">
                        <img src="img/productSingle_middle/3796.jpg" width="20px" class="orderItemImg">
                    </td>
                    <td class="orderItemProductInfo">
                        <a href="#nowhere" class="orderItemProductLink">
                            公众智能扫地机器人家用全自动电动清洁地毯擦拖地一体机吸尘器
                        </a>
                        <img title="支持信用卡支付" src="img/site/creditcard.png">
                        <img title="消费者保障服务,承诺7天退货" src="img/site/7day.png">
                        <img title="消费者保障服务,承诺如实描述" src="img/site/promise.png">
                    </td>
                    <td>
                        <span class="orderItemProductPrice">￥2,124.15</span>
                        <span class="orderItemProductNumber">1</span>
                    </td>
                    <td>
                        <span class="orderItemUnitSum">￥2,124.15</span>
                    </td>
                    <td class="orderItemLastTD" rowspan="5">
                        <label class="orderItemDeliveryLabel">
                            <input type="radio" checked="checked" value="">
                            普通配送
                        </label>
                        <select class="orderItemDeliverySelect">
                            <option>快递 免邮费</option>
                        </select>
                    </td>
                </tr>
            </tbody>
        </table>

        <div class="orderItemSumDiv">
            <div class="pull-right">
                <span class="leaveMessageText">给卖家留言:
                    <img src="img/site/leaveMessage.png" class="leaveMessageImg">
                </span>
                <span class="leaveMessageTextareaSpan" style="display: none;">
                    <textarea class="leaveMessageTextarea" name="userMessage"></textarea>
                    <div>
                        <span>还可以输入200个字符</span>
                    </div>
                </span>
            </div>
            <span class="pull-right">店铺合计(含运费): ￥9,152.25</span>
        </div>
    </div>
    <div class="orderItemTotalSumDiv">
        <div class="pull-right">
            <span>实付款：</span>
            <span class="orderItemTotalSumSpan">￥9,152.25</span>
        </div>
    </div>
    <div class="submitOrderDiv">
        <button class="submitOrderButton" type="button">提交订单</button>
    </div>
</div>
```



### 1.4 样式CSS


```
<style>
    div.buyPageDiv{/*结算页面div*/
        margin: 20px auto;
        max-width: 1013px;
    }
    div.addressTip, div.productListTip{/*确认订单信息几个字*/
        color: #333333;
        font-size: 16px;
        font-weight: bold;
        text-align: left;
        margin-bottom: 30px;
    }
    table.productListTable{/*产品列表所在table*/
        width: 100%;
        border-collapse: separate;
        font-size:12px;
    }
    table.productListTable th{/*标题栏的每个单元格*/
        color: #999999;
        font-family: 宋体;
        font-weight: normal;
        font-size: 12px;
        text-align: center;
        padding-bottom: 5px;
    }
    table.productListTable tr.rowborder td{/*标题栏下的下划线*/
        background-color: #b2d1ff;
        border-right: 2px solid #fff;
        height: 3px;
    }
    th.productListTableFirstColumn{/*标题栏第一列*/
        text-align: left !important;
    }
    img.tmallbuy{/*天猫图片*/
        width: 15px;
    }
    a.marketLink{/*天猫店铺超链*/
        color: black;
        font-size: 12px;
        font-family: 宋体;
        font-weight: normal;
    }
    a.marketLink:hover{/*天猫店铺超链悬停状态*/
        color: black;
        font-size: 12px;
        text-decoration: underline;
        font-family: 宋体;
        font-weight: normal;
    }
    span.wangwangGif{/*旺旺图标*/
        display: inline-block;
        width: 25px;
        height: 25px;
        background-image:url(http://how2j.cn/tmall/img/site/wangwang.gif);
        background-repeat: no-repeat;
        background-color: transparent;
        background-attachment: scroll;
        background-position: -83px -0px;
        position: relative;
        top: 8px;
        left: 2px;
    }
    tbody.productListTableTbody td{/*产品列表单元格*/
        text-align: center;
    }
    tbody.productListTableTbody td.orderItemFirstTD{/*产品列表第一列*/
        text-align: left;
    }
    tr.orderItemTR td{/*产品信息单元格*/
        border-bottom: 1px solid #E5E5E5;
    }
    tr.orderItemTR td{/*订单项单元格*/
        padding: 10px 0px;
    }
    img.orderItemImg{/*产品图片*/
        width: 50px;
        height: 50px;
        border: 1px solid #E9E9E9;
    }
    td.orderItemProductInfo{/*产品信息*/
        text-align:left !important;
    }
    td.orderItemProductInfo img{/*3个图标*/
        height: 16px;
    }
    a.orderItemProductLink{/*3个图标*/
        color: #666666;
        display: block;
    }
    a.orderItemProductLink:hover{/*产品超链悬停状态*/
        color: #666666;
        text-decoration: underline;
    }
    span.orderItemProductPrice, span.orderItemProductNumber{/*产品价格和产品数量*/
        color: #000000;
    }
    span.orderItemUnitSum{/*小计*/
        color: #CC0000;
        font-weight: bold;
    }
    td.orderItemFirstTD, td.orderItemLastTD{/*第一列和最后一列*/
        border-bottom: 0px solid black !important;
    }
    label.orderItemDeliveryLabel{/*普通配送字样*/
        color: #666666;
        font-family: 宋体;
        font-size: 12px;
        font-weight: normal;
    }
    select.orderItemDeliverySelect{/*配送方式下拉*/
        width: 100px;
        height: 23px;
    }
    div.orderItemSumDiv{/*v配送方式下拉*/
        padding: 20px;
        border-top: 2px solid #B4D0FF;
        background-color: #F2F6FF;
        height: 50px;
    }
    div.orderItemSumDiv span{/*v合计div下所有的span*/
        color: #999999;
    }
    span.leaveMessageText{/*v给卖家留言*/
        display: inline-block;
        margin-right: 10px;
        float: left;
    }
    div.orderItemTotalSumDiv{/*实付款所在div*/
        margin: 40px;
        height: 40px;
    }
    div.submitOrderDiv{/*提交订单按钮所在div*/
        height: 40px;
        margin: 20px 0px;
    }
    div.orderItemTotalSumDiv span{/*实付款字样*/
        color: #999999;
    }
    span.orderItemTotalSumSpan{/*实付款金额*/
        color: #C40000 !important;
        font-size: 22px;
        font-weight: bold;
        border-bottom: 1px dotted #F2F6FF;
    }
    button.submitOrderButton{/*提交订单按钮*/
        border: 1px solid #C40000;
        background-color: #C40000;
        text-align: center;
        line-height: 40px;
        font-size: 14px;
        font-weight: 700;
        color: white;
        float: right;
        display:inline-block;
        margin:0px 10px;
        width:180px;
        height: 40px;
    }
    body{/*整个body*/
        font-size: 12px;
        font-family: Arial;
    }
</style>
```



	2018-09-12 16:16:08
kumika	模仿天猫实战SSM--查询结果页面	#模仿天猫实战SSM--查询结果页面

因为没有直接的页面例子，只能按照参考的提示来写。

参考提示：

    从效果上来看，查询结果页面和分类页面是一样的，并且还要简单一些—— 没有了排序和价格区间。
    因为样式和布局都是一模一样的

### 1.1 纯HTML

```
<div class="categoryPageDiv">
    <div class="categoryProducts">
        <div price="799.2" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="img/productSingle_middle/7058.jpg" class="productImage"/>
                </a>
                <span class="productPrice">￥799.20</span>
                <a href="#nowhere" class="productLink">
                    MAXFEEL休闲男士手包真皮手拿包大容量信封包手抓包夹包软韩版潮
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal">月成交<span class="productDealNumber">16笔</span> </span>
                    <span class="productReview">评价<span class="productReviewNumber">16</span> </span>
                    <span class="wangwang">
                        <a href="#nowhere" class="wangwanglink">
                            <img src="img/site/wangwang.png"/>
                        </a>
                    </span>
                </div>
            </div>
        </div>

        <div price="511.2" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="img/productSingle_middle/7047.jpg" class="productImage"/>
                </a>
                <span class="productPrice">￥511.20</span>
                <a href="#nowhere" class="productLink">
                    宾度 男士手包真皮大容量手拿包牛皮个性潮男包手抓包软皮信封包
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal">月成交<span class="productDealNumber">49笔</span> </span>
                    <span class="productReview">评价<span class="productReviewNumber">17</span> </span>
                    <span class="wangwang">
                        <a href="#nowhere" class="wangwanglink">
                            <img src="img/site/wangwang.png"/>
                        </a>
                    </span>
                </div>
            </div>
        </div>

        <div price="448.2" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="img/productSingle_middle/7036.jpg" class="productImage"/>
                </a>
                <span class="productPrice">￥448.20</span>
                <a href="#nowhere" class="productLink">
                    唯美诺新款男士手包男包真皮大容量小羊皮手拿包信封包软皮夹包潮
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal">月成交<span class="productDealNumber">49笔</span> </span>
                    <span class="productReview">评价<span class="productReviewNumber">17</span> </span>
                    <span class="wangwang">
                        <a href="#nowhere" class="wangwanglink">
                            <img src="img/site/wangwang.png"/>
                        </a>
                    </span>
                </div>
            </div>
        </div>

        <div price="448.2" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="img/productSingle_middle/7036.jpg" class="productImage"/>
                </a>
                <span class="productPrice">￥448.20</span>
                <a href="#nowhere" class="productLink">
                    唯美诺新款男士手包男包真皮大容量小羊皮手拿包信封包软皮夹包潮
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal">月成交<span class="productDealNumber">49笔</span> </span>
                    <span class="productReview">评价<span class="productReviewNumber">17</span> </span>
                    <span class="wangwang">
                        <a href="#nowhere" class="wangwanglink">
                            <img src="img/site/wangwang.png"/>
                        </a>
                    </span>
                </div>
            </div>
        </div>
        <div price="411.6" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="http://how2j.cn/tmall/img/productSingle_middle/7025.jpg" class="productImage">
                </a>
                <span class="productPrice">¥411.60</span>
                <a href="#nowhere" class="productLink">
                    英伦邦纹男士手包牛皮大容量真皮手拿包手抓包双拉链商务正品软皮
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal ">月成交 <span class="productDealNumber">25笔</span></span>
                    <span class="productReview">评价<span class="productReviewNumber">19</span></span>
                    <span class="wangwang">
                    <a href="#nowhere" class="wangwanglink">
                        <img src="http://how2j.cn/tmall/img/site/wangwang.png">
                    </a>
                    </span>
                </div>
            </div>
        </div>
        <div price="157.25" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="http://how2j.cn/tmall/img/productSingle_middle/7014.jpg" class="productImage">
                </a>
                <span class="productPrice">¥157.25</span>
                <a href="#nowhere" class="productLink">
                    劳迪莱斯男士手包休闲手拿包牛皮大容量钱包男包软面小包包手抓包
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal ">月成交 <span class="productDealNumber">17笔</span></span>
                    <span class="productReview">评价<span class="productReviewNumber">16</span></span>
                    <span class="wangwang">
                    <a href="#nowhere" class="wangwanglink">
                        <img src="http://how2j.cn/tmall/img/site/wangwang.png">
                    </a>
                    </span>
                </div>
            </div>
        </div>
        <div price="268.2" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="http://how2j.cn/tmall/img/productSingle_middle/7003.jpg" class="productImage">
                </a>
                <span class="productPrice">¥268.20</span>
                <a href="#nowhere" class="productLink">
                    帕朗尼男士手拿包真皮手包商务休闲头层牛皮软牛皮大容量休闲钱包
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal ">月成交 <span class="productDealNumber">5笔</span></span>
                    <span class="productReview">评价<span class="productReviewNumber">19</span></span>
                    <span class="wangwang">
                    <a href="#nowhere" class="wangwanglink">
                        <img src="http://how2j.cn/tmall/img/site/wangwang.png">
                    </a>
                    </span>
                </div>
            </div>
        </div>
        <div price="233.4" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="http://how2j.cn/tmall/img/productSingle_middle/6992.jpg" class="productImage">
                </a>
                <span class="productPrice">¥233.40</span>
                <a href="#nowhere" class="productLink">
                    编织手包手拿包男信封大容量手抓包真皮韩版潮商务休闲牛皮男包
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal ">月成交 <span class="productDealNumber">8笔</span></span>
                    <span class="productReview">评价<span class="productReviewNumber">19</span></span>
                    <span class="wangwang">
                    <a href="#nowhere" class="wangwanglink">
                        <img src="http://how2j.cn/tmall/img/site/wangwang.png">
                    </a>
                    </span>
                </div>
            </div>
        </div>
        <div price="952.0" class="productUnit">
            <div class="productUnitFrame">
                <a href="#nowhere">
                    <img width="100px" src="http://how2j.cn/tmall/img/productSingle_middle/6981.jpg" class="productImage">
                </a>
                <span class="productPrice">¥952.00</span>
                <a href="#nowhere" class="productLink">
                    犟牛男士手包真皮手拿包头层牛皮商务大容量手抓包软皮夹包信封包
                </a>
                <a href="#nowhere" class="tmallLink">天猫专卖</a>
                <div class="show1 productInfo">
                    <span class="monthDeal ">月成交 <span class="productDealNumber">20笔</span></span>
                    <span class="productReview">评价<span class="productReviewNumber">16</span></span>
                    <span class="wangwang">
                    <a href="#nowhere" class="wangwanglink">
                        <img src="http://how2j.cn/tmall/img/site/wangwang.png">
                    </a>
                    </span>
                </div>
            </div>
        </div>

        <div style="clear: both"></div>
    </div>
</div>
```


### 1.2 样式CSS

```
<style>
    /*整个body*/
    body{
        font-size: 12px;
      /*  把所有文字的大小调成12px,这是天猫默认的文字大小*/
        font-family: Arial;
        /*字库使用Arial*/
    }
    /*整个分类div*/
    div.categoryPageDiv{
        max-width: 1013px;
      /*  最大宽度1013px，如果用户的分辨率比较大，那么就会使产品列表整体宽度最大1013，并且居中，这样看上去好一点，而不是铺满整个屏幕*/
        margin: 10px auto;
        /*居中显示*/
    }
/*    产品列表div*/
    div.categoryProducts{
        padding: 0px 20px 40px 20px;
        /*内边距*/
    }
/*    产品项*/
    div.productUnit{
        width: 225px;
        /*宽度: 225px*/
        height: 338px;
        /*高度: 338px*/
        border: 3px solid #fff;
       /* 边框3个像素，但是是白色的，只有当鼠标移动上来的时候，才会变成天猫红*/
        background-color: white;
        /*背景色: white*/
        margin: 12px 5px;
        /*外边距*/
        float: left;
        /*向左漂浮，这样可以水平摆放*/
    }
/*    产品项的鼠标悬浮状态*/
    div.productUnit:hover{
        border:3px solid #C40000;
        /*边框变成天猫红*/
    }
    /*产品项的边框*/
    div.productUnitFrame{
        border:1px solid #eee;
        /*这个是又一个边框，在鼠标没有悬停的时候，显示为灰色*/
        height:100%;
        /*高度100%*/
    }
/*    产品项的边框鼠标悬停状态*/
    div.productUnitFrame:hover{
        border:1px solid #C40000;
        /*颜色变为天猫红，和外层3个像素的div融为一体，一共表现为厚实的4个像素*/
    }
    /*产品图片*/
    div.productUnit img.productImage{
        width: 100%;
/*        宽度: 100%*/
        height: 190px;
        /*高度: 190px*/
    }
/*    产品价格*/
    div.productUnit span.productPrice{
        font-size: 20px;
        /*字体大小: 20px*/
        color: #CC0000;
        /*字体颜色: #CC0000*/
        display: block;
        /*以块状显示，自动换行*/
        padding-left: 4px;
        /*左内边距: 4px*/
    }
    /*产品链接*/
    div.productUnit a.productLink{
        margin: 10px 0px;
/*        上下外边距10px*/
        color: #333333;
        /*字体颜色: #333333*/
        display: block;
        /*以块状显示，自动换行*/
        height:34px;
        /*高度34px*/
    }
/*    产品链接鼠标悬停状态*/
    div.productUnit a.productLink:hover{
        text-decoration: underline;
        /*有下划线*/
        color: #C40000;
        /*字体颜色: #C40000*/
    }
    /*天猫专卖链接*/
    div.productUnit a.tmallLink{
        margin: 10px 0px;
        /*上下外边距10px*/
        color: #999999;
        /*字体颜色: #999999*/
        display:block;
/*        以块状显示，自动换行*/
        text-decoration: underline;
        /*有下划线*/
    }
/*    天猫专卖链接鼠标悬停状态*/
    div.productUnit a.tmallLink:hover{
        text-decoration: underline;
        /*有下划线*/
        color: #C40000;
        /*字体颜色: #C40000*/
    }
  /*  成交，评价，旺旺所在的div*/
    div.productUnit div.productInfo{
        border-top-width: 1px;
        /*上边框宽度1px*/
        border-top-style: solid;
        /*上边框宽度实线*/
        border-top-color: #EEEEEE;
        /*上边框颜色*/
        color:#999999;
        /*文字颜色#999999*/
    }
/*    月成交数量*/
    div.productUnit span.productDealNumber{
        font-weight: bold;
        /*粗体*/
        color: #B57C5B;
        /*字体颜色: #B57C5B*/
    }
/*    评价所在span*/
    div.productUnit span.productReview{
        border-left-width: 1px;
        /*左边框宽度1px*/
        border-left-style: solid;
        /*左边框实线*/
        border-left-color: #EEEEEE;
        /*左边框颜色#EEEEEE*/
        border-right-width: 1px;
        /*右边框宽度1px*/
        border-right-style: solid;
        /*右边框实线*/
        border-right-color: #EEEEEE;
        /*右边框颜色#EEEEEE*/
    }
    /*评价数量*/
    div.productUnit span.productReviewNumber{
        font-weight: bold;
      /*  粗体*/
        color: #3388BB;
        /*字体颜色: #3388BB*/
    }
    /*月成交和评价所在span*/
    div.productUnit span.monthDeal, div.productUnit span.productReview{
        display: inline-block;
        /*显示为内联，既可以设置大小，又能够不换行*/
        width: 90px;
        /*宽度: 90px*/
        height:29px;
        /*高度: 29px*/
        padding-top: 5px;
/*        上内边距: 5px*/
        padding-left: 5px;
        /*左内边距: 5px*/
    }
    /*旺旺所在span*/
    div.productUnit span.wangwang{
        padding-left: 3px;
        /*左内边距: 3px*/
    }
</style>
```










	2018-09-12 22:35:29
kumika	模仿天猫实战SSM--支付页面	# 模仿天猫实战SSM--支付页面



## 1 效果

![效果.jpg](https://i.loli.net/2018/09/12/5b992bc088900.jpg)


## 2 布局

![3324.png](https://i.loli.net/2018/09/12/5b992bc09950f.png)


## 3 纯HTML

```
<div class="aliPayPageDiv">
    <div class="aliPayPageLogo">
        <img src="img/site/simpleLogo.png" class="pull-left"/>
        <div style="clear:both"></div>
    </div>
    <div>
        <span class="confirmMoneyText">扫一扫付款（元）</span>
        <span class="confirmMoney">￥1,359.20</span>
    </div>
    <div>
        <img src="img/site/MyAlipay.png" class="aliPayImg">
    </div>
    <div>
        <a href="#nowhere">
            <button class="confirmPay">确认支付</button>
        </a>
    </div>
</div>
```


## 4 样式CSS

```
<style>
    body{/*整个body*/
        font-size: 12px;
        font-family: Arial;
    }
    div.aliPayPageDiv{/*支付页面div*/
        text-align: center;
        padding-bottom: 40px;
        max-width: 1013px;
        margin: 10px auto;
    }
    div.aliPayPageLogo{/*支付图片所在div*/
        margin: 20px;
    }
    span.confirmMoneyText{/*扫一扫付款*/
        color: #4D4D4D;
    }
    span.confirmMoney{/*金额*/
        display: block;
        color: #FF6600;
        font-weight: bold;
        font-size: 20px;
        margin: 10px;
    }
    button.confirmPay{/*确认支付按钮*/
        background-color: #00AAEE;
        border: 1px solid #00AAEE;
        text-align: center;
        line-height: 31px;
        font-size: 14px;
        font-weight: 700;
        color: white;
        width: 107px;
        margin-top: 20px;
    }
</style>
```


















	2018-09-12 22:46:00
kumika	模仿天猫实战SSM--支付成功页面	#模仿天猫实战SSM--支付成功页面




## 1 效果

![效果.jpg](https://i.loli.net/2018/09/12/5b992e3544154.jpg)

## 2 布局

![3354.png](https://i.loli.net/2018/09/12/5b992e354265d.png)


## 3 纯HTML

```
<div class="payedDiv">
    <div class="payedTextDiv">
        <img src="img/site/paySuccess.png"/>
        <span>您已成功付款</span>
    </div>
    <div class="payedAddressInfo">
        <ul>
            <li>收货地址： 北京市 朝阳区 天安门 3栋 2单元 402室 </li>
            <li>实际付款：
                <span class="payedInfoPrice">
                    ￥2,124.15
                </span>
            </li>
            <li>预计08月08日送达    </li>
        </ul>
        <div class="paedCheckLinkDiv">
            您可以
            <a href="#nowhere" class="payedCheckLink">查看已买到的宝贝</a>
            <a href="#nowhere" class="payedCheckLink">查看交易详情</a>
        </div>
    </div>
    <div class="payedSeperateLine"></div>
    <div class="warningDiv">
        <img src="img/site/warning.png">
        <b>安全提醒：</b>下单后，<span class="redColor boldWord">用QQ给您发送链接办理退款的都是骗子！</span>
        天猫不存在系统升级，订单异常等问题，谨防假冒客服电话诈骗！
    </div>
</div>
```


## 4 样式CSS


```
<style>
    div.payedDiv{/*支付成功页面*/
        border: 1px solid #D4D4D4;
        max-width: 1013px;
        margin: 10px auto 20px auto;
    }
    div.payedTextDiv{/*您已成功付款字样所在div*/
        height: 61px;
        background-color: #ECFFDC;
        padding: 17px 0px 0px 25px;
    }
    div.payedTextDiv span{/*您已成功付款*/
        font-weight: bold;
        font-size: 14px;
        margin-left: 10px;
    }
    div.payedAddressInfo{/*地址信息所在div*/
        padding: 26px 35px;
    }
    div.payedAddressInfo li{/*地址信息列表*/
        background-image:url(http://how2j.cn/tmall/img/site/li_dot.png);/*背景图片*/
        background-repeat: no-repeat;
        background-color: transparent;
        background-attachment: scroll;
        background-position: 0px 13px;
        list-style-type: none;
        color: #333333;
        padding-left: 15px;
        padding-top: 5px;
    }
    span.payedInfoPrice{/*实付款*/
        color: #B10000;
        font-weight: bold;
        font-size: 14px;
        font-family: arial;
    }
    div.paedCheckLinkDiv{/*查看已买到的宝贝所在div*/
        margin-left: 38px;
    }
    a.payedCheckLink{/*两个查看连接*/
        color: #2D8CBA;
    }
    a.payedCheckLink:hover{/*两个查看连接鼠标悬停状态*/
        color: #2D8CBA;
        text-decoration: underline;
    }
    div.payedSeperateLine{/*分割线*/
        border-top: 1px dotted #D4D4D4;
        margin: 0px 31px;
    }
    div.warningDiv{/*警告div*/
        margin: 23px 45px;
        color:black;
    }
    body{/*整个body*/
        font-size: 12px;
        font-family: Arial;
    }
    .boldWord{/*文字粗体*/
        font-weight: bold;
    }
    .redColor{/*天猫红*/
        color: #C40000;
    }
</style>
```


	2018-09-12 23:10:18
kumika	模仿天猫实战SSM--确认收货页面上	#模仿天猫实战SSM--确认收货页面上

## 1 效果

![效果.jpg](https://i.loli.net/2018/09/12/5b9936fb504d7.jpg)

## 2 布局

![3330.png](https://i.loli.net/2018/09/12/5b9936fb3a8b6.png)

## 3 纯HTML

```
<div class="confirmPayPageDiv">
    <div class="confirmPayImageDiv">
        <img src="img/site/confirmPayFlow.png"/>
        <div class="confirmPayTime1">
            2016-09-14 11:14:45
        </div>
        <div class="confirmPayTime2">
            2016-09-14 11:14:47
        </div>
        <div class="confirmPayTime3">
            yyyy-MM-dd HH:mm:ss
        </div>
    </div>

    <div class="confirmPayOrderInfoDiv">
        <div class="confirmPayOrderInfoText">我已收到货，同意支付宝付款</div>
    </div>
    <div class="confirmPayOrderItemDiv">
        <div class="confirmPayOrderItemText">
            订单信息
        </div>
        <table class="confirmPayOrderItemTable">
            <thead>
            <tr>
                <th colspan="2">宝贝</th>
                <th width="120px">单价</th>
                <th width="120px">数量</th>
                <th width="120px">商品总价</th>
                <th width="120px">运费</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><img src="img/productSingle_middle/5848.jpg" width="50px"></td>
                <td class="confirmPayOrderItemProductLink">
                    <a href="#nowhere">罗宾 钢带女表 女士腕表 水钻夜光防水石英表 潮流时尚复古手表女</a>
                </td>
                <td>￥990.00</td>
                <td>1</td>
                <td><span class="conformPayProductPrice">￥792.00</span> </td>
                <td><span>快递 ： 0.00 </span> </td>
            </tr>
            <tr>
                <td><img src="img/productSingle_middle/3676.jpg" width="50px"></td>
                <td class="confirmPayOrderItemProductLink">
                    <a href="#nowhere">科沃斯地宝凌云扫地机器人WiFi智能家用吸尘器超薄全自动洗擦地机</a>
                </td>
                <td>￥5,680.00</td>
                <td>1</td>
                <td><span class="conformPayProductPrice">￥3,692.00</span> </td>
                <td><span>快递 ： 0.00 </span> </td>
            </tr>
            </tbody>
        </table>
        <div class="confirmPayOrderItemText pull-right">
            实付款：<span class="confirmPayOrderItemSumPrice">￥4,484.00</span>
        </div>
    </div>
</div>
```

## 4 样式CSS

```
<style>
    body,table{/*body以及表格*/
        font-size: 12px;
        font-family: Arial;
    }
    div.confirmPayPageDiv{/*确认支付div*/
        max-width: 1013px;
        margin: 10px auto;
    }
    div.confirmPayImageDiv{/*确认支付图片所在div*/
        margin:5px auto 80px auto;
        width: 900px;
        position: relative;
    }
    div.confirmPayImageDiv div{/*时间信息所在div*/
        color: #999999;
    }
    div.confirmPayTime3{/*卖家发货时间*/
        position: absolute;
        top: 100px;
        left: 400px;
    }
    div.confirmPayTime2{/*付款到支付宝时间*/
        position: absolute;
        top: 100px;
        left: 190px;
    }
    div.confirmPayTime1{/*拍下商品时间*/
        position: absolute;
        top: 100px;
        left: -20px;
    }
    div.confirmPayOrderInfoText{/*同意付款字样*/
        margin: 10px 10px 0px 10px;
        font-size: 16px;
        font-weight: bold;
        color: black;
        padding-bottom: 15px;
        border-bottom: 1px solid #ADC8E6;
    }
    div.confirmPayOrderItemDiv{/*订单项列表div*/
        margin: 0px 20px;
    }
    div.confirmPayOrderItemText{/*v订单信息字样*/
        margin: 20px 10px;
        font-size: 14px;
        font-weight:normal;
        color: black;
    }
    table.confirmPayOrderItemTable{/*订单项列表所在表格*/
        border: 1px solid #DDDDDD;
        width: 100%;
    }
    table.confirmPayOrderItemTable thead{/*v表格的标题部分*/
        background-color: #E8F2FF;
        height: 33px;
    }
    table.confirmPayOrderItemTable tr{/*表格的每一行*/
        border: 1px solid #DDDDDD;
    }
    table.confirmPayOrderItemTable th, table.confirmPayOrderItemTable td{/*v单元格*/
        text-align: center;
    }
    table.confirmPayOrderItemTable td{/*订单项列表单元格*/
        padding: 20px;
    }
    td.confirmPayOrderItemProductLink{/*产品连接*/
        text-align: left !important;
    }
    span.conformPayProductPrice{/*产品单价*/
        font-size: 18px;
        font-weight: bold;
        color: #666666;
    }
    span.confirmPayOrderItemSumPrice{/*产品总价*/
        color: #C40000;
    }
    a{/*所有超链*/
        color:#999;
    }
    a:hover{/*鼠标悬停*/
        text-decoration:none;
        color: #C40000;
    }
</style>
```
	2018-09-12 23:52:15
kumika	模仿天猫实战SSM--确认收货页面下	#模仿天猫实战SSM--确认收货页面下

## 1 效果
![效果.jpg](https://i.loli.net/2018/09/13/5b993dc83d23a.jpg)

## 2 布局

![3360.png](https://i.loli.net/2018/09/13/5b993dc8454b0.png)

## 3 纯HTML

```
<div class="confirmPayPageDiv">
    <div class="confirmPayOrderDetailDiv">
        <table class="confirmPayOrderDetailTable">
            <tbody>
            <tr>
                <td>订单编号：</td>
                <td>201609141114454899001 <img width="23px" src="img/site/confirmOrderTmall.png"></td>
            </tr>
            <tr>
                <td>卖家昵称：</td>
                <td>天猫商铺 <span class="confirmPayOrderDetailWangWangGif"> </span></td>
            </tr>
            <tr>
                <td>收货信息： </td>
                <td>北京市 朝阳区 天安门 4栋二单元 490，朝阳群众， 15800000000，10000 </td>
            </tr>
            <tr>
                <td>成交时间：</td>
                <td>2016-09-14 11:14:45</td>
            </tr>
            </tbody>
        </table>
    </div>
    <div class="confirmPayButtonDiv">
        <div class="confirmPayWarning">请收到货后，再确认收货！否则您可能钱货两空！</div>
        <a href="#nowhere">
            <button class="confirmPayButton">确认支付</button></a>
    </div>
</div>
```

## 4 样式CSS

```
<style>
    div.confirmPayPageDiv{/*确认收货div*/
        max-width: 1013px;
        margin: 10px auto;
    }
    div.confirmPayOrderDetailDiv{/*订单详情div*/
        margin: 40px;
    }
    table.confirmPayOrderDetailTable{/*订单详情table*/
        width: 100%;
        border-top: 1px solid #DDDDDD;
    }
    table.confirmPayOrderDetailTable td{/*单元格*/
        padding: 8px;
        color: black;
        font-size: 14px;
    }
    span.confirmPayOrderDetailWangWangGif{/*旺旺图标*/
        display: inline-block;
        width: 67px;
        height: 22px;
        background-image:url(http://how2j.cn/tmall/img/site/wangwang.gif);
        background-repeat: no-repeat;
        background-color: transparent;
        position: relative;
        left: 2px;
    }
    div.confirmPayButtonDiv{/*确认按钮div*/
        border: 1px solid #F58B0F;
        margin: 20px;
    }
    div.confirmPayWarning{/*支付警告*/
        margin: 20px 80px;
        font-size: 18px;
        color: red;
        font-weight: bold;
    }
    button.confirmPayButton{/*确认按钮*/
        margin: 20px 80px;
        width:67px;
        height: 30px;
        border: 1px solid #E67C00;
        background-color: #F4A21D;
        border-radius: 4px;
        color: white;
        font-size:12px;
    }
    button.confirmPayButton:hover{/*确认按钮悬停状态*/
        background-color: #F6AE30;
    }
</style>
```
	2018-09-13 00:23:40
kumika	模仿天猫实战SSM--收货成功页面	#模仿天猫实战SSM--收货成功页面

## 1 效果
![效果.jpg](https://i.loli.net/2018/09/13/5b99423de4165.jpg)

## 2 布局

![3336.png](https://i.loli.net/2018/09/13/5b99423de5864.png)
## 3 纯HTML

```
<div class="orderFinishDiv">
    <div class="orderFinishTextDiv">
        <img src="img/site/orderFinish.png">
        <span>交易已经成功，卖家将收到您的货款。</span>
    </div>
</div>
```

## 4 样式CSS

```
<style>
    div.orderFinishDiv{/*收货成功div*/
        border: 1px solid #E5E5E5;
        padding: 40px;
        max-width: 1013px;
        margin: 10px auto;
    }
    div.orderFinishDiv span{/*收货成功文字*/
        font-size: 14px;
        color: black;
        font-weight: bold;
        margin-left: 20px;
        padding-top: 20px;
    }
</style>
```	2018-09-13 00:38:33
kumika	模仿天猫实战SSM--评价页面上	#模仿天猫实战SSM--评价页面上

## 1 效果

![效果.jpg](https://i.loli.net/2018/09/13/5b9942e60eb1f.jpg)

## 2 布局

![3342.png](https://i.loli.net/2018/09/13/5b9942e6378ec.png)

## 3 纯HTML

```
<div class="reviewDiv">
    <div class="reviewProductInfoDiv">
        <div class="reviewProductInfoImg">
            <img class="reviewProductImg" src="img/productSingle/8697.jpg" width="100px" height="100px">
        </div>
        <div class="reviewProductInfoRightDiv">
            <div class="reviewProductInfoRightText">
                2016夏季新款女装雪纺衫短裤两件套 韩版时尚名媛休闲套装女夏装
            </div>
            <table class="reviewProductInfoTable">
                <tbody>
                <tr>
                    <td width="75px">价格：</td>
                    <td><span class="reviewProductInfoTablePrice">￥263.00</span> 元  </td>
                </tr>
                <tr>
                    <td>配送</td>
                    <td>快递:  0.00</td>
                </tr>
                <tr>
                    <td>月销量:</td>
                    <td><span class="reviewProductInfoTableSellNumber"> 50</span> 件 </td>
                </tr>
                </tbody>
            </table>
            <div class="reviewProductInfoRightBelowDiv">
                <span class="reviewProductInfoRightBelowImg">
                    <img src="img/site/reviewLight.png"/>
                </span>
                <span class="reviewProductInfoRightBelowText">
                    现在查看的是 您所购买商品的信息于2016年09月12下单购买了此商品
                </span>
            </div>
        </div>
        <div style="clear: both;"></div>
    </div>
</div>
```

## 4 样式CSS

```
<style>
    div.reviewDiv{/*评价div*/
        max-width: 1013px;
        margin: 10px auto;
    }
    div.reviewProductInfoImg{/*图片所在div*/
        border: 1px solid #E7E7E7;
        width: 464px;
        text-align: center;
        float: left;
    }
    div.reviewProductInfoRightDiv{/*右侧div*/
        overflow: hidden;
        border-top: 1px solid #E7E7E7;
        padding: 30px 20px;
    }
    div.reviewProductInfoRightText{/*产品标题*/
        color: black;
        font-size: 16px;
        font-weight: bold;
    }
    table.reviewProductInfoTable{/*产品信息表格*/
        margin: 20px 10px;
        font-size:12px;
    }
    table.reviewProductInfoTable td{/*单元格*/
        padding-bottom: 5px;
        color: #999999;
    }
    span.reviewProductInfoTablePrice{/*产品价格*/
        color: #C40000;
        font-size: 20px;
        font-weight: bold;
    }
    span.reviewProductInfoTableSellNumber{/*月销量*/
        color: #C40000;
        font-size: 14px;
        font-weight: bold;
    }
    div.reviewProductInfoRightBelowDiv{/*购买日期信息所在div*/
        border: 1px solid #F6F5F3;
        background-color: #FDFBFA;
        height: 166px;
        padding:16px 0px 16px 81px;
    }
    span.reviewProductInfoRightBelowImg{/*小图片*/
        background-color: white;
        border: 1px solid #E1E1E1;
        display: inline-block;
        width: 23px;
        height: 42px;
        background-image:url(http://how2j.cn/tmall/img/site/reviewLight.png);
        background-repeat: no-repeat;
        padding: 0px;
    }
    span.reviewProductInfoRightBelowText{/*购买日期信息*/
        border: 1px solid #EFEFEF;
        display: inline-block;
        width: 200px;
        height: 42px;
        padding: 4px;
        position: relative;
        left: -4px;
        top: -7px;
        color: #666666;
        font-size:12px;
    }
    img.reviewProductImg{/*产品图片*/
        width:400px;
        height:400px;
    }
</style>
```

	2018-09-13 00:44:41
kumika	模仿天猫实战SSM--评论页面下	#模仿天猫实战SSM--评论页面下

## 1 效果

![效果.jpg](https://i.loli.net/2018/09/13/5b9946d1b3afc.jpg)



## 2 布局
布局1
![3366.png](https://i.loli.net/2018/09/13/5b9946d196c0d.png)

布局2
![3371.png](https://i.loli.net/2018/09/13/5b9946d1c620d.png)


## 3 纯HTML


```
<div class="reviewDiv">
    <div class="reviewStasticsDiv">
        <div class="reviewStasticsLeft">
            <div class="reviewStasticsLeftTop"></div>
            <div class="reviewStasticsLeftContent">
                累计评价 <span class="reviewStasticsNumber"> 13</span>
            </div>
            <div class="reviewStasticsLeftFoot"></div>
        </div>

        <div class="reviewStasticsRight">
            <div class="reviewStasticsRightEmpty"></div>
            <div class="reviewStasticsFoot"></div>
        </div>
    </div>

    <div class="makeReviewDiv">
        <form method="post">
            <div class="makeReviewText">
                其他买家，需要你的建议哦！
            </div>
            <table class="makeReviewTable">
                <tbody>
                <tr>
                    <td class="makeReviewTableFirstTD">评价商品</td>
                    <td><textarea name="content"> </textarea></td>
                </tr>
                </tbody>
            </table>
            <div class="makeReviewButtonDiv">
                <input type="hidden" value="952" name="oid">
                <input type="hidden" value="256" name="pid">
                <button type="button">提交评价</button>
            </div>
        </form>
    </div>
</div>
```



## 4 样式CSS

```
<style>
    div.reviewDiv{/*评价div*/
        max-width: 1013px;
        margin: 10px auto;
    }
    div.reviewStasticsDiv{/*累计评价div*/
        margin-top: 20px;
    }
    div.reviewStasticsLeft{/*累计评价左侧div*/
        width: 180px;
        float: left;
    }
    div.reviewStasticsLeftTop{/*累计评价左上div*/
        background-color: #C40000;
        height: 6px;
    }
    div.reviewStasticsLeftContent{/*累计评价左边内容*/
        line-height: 29px;
        border-left: 1px solid #D5D4D4;
        border-right: 1px solid #D5D4D4;
        background-color: #F6F5F1;
        text-align: center;
        font-size: 14px;
        color: #363535;
        font-weight: bold;
    }
    div.reviewStasticsLeftFoot{/*累计评价左下div*/
        height: 6px;
        border-left: 1px solid #D5D4D4;
        border-bottom: 1px solid #D5D4D4;
        background-color: #F6F5F1;
    }
    span.reviewStasticsNumber{/*累计评价数字*/
        color: #284CA5;
    }
    div.reviewStasticsRight{/*累计评价右侧div*/
        overflow: hidden;
    }
    div.reviewStasticsRightEmpty{/*累计评价右侧空白div*/
        height: 35px;
    }
    div.reviewStasticsFoot{/*累计评价右下div*/
        background-color: #F6F5F1;
        border: 1px solid #D5D4D4;
        border-left-width: 0px;
        height: 6px;
    }
    div.makeReviewDiv{/*进行评价div*/
        border: 1px solid #D1CCC8;
        margin: 20px 0px;
        background-color: #EFEFEF;
    }
    div.makeReviewText{/*其他买家，需要你的建议哦！*/
        font-size: 16px;
        color: #333333;
        font-weight: bold;
        margin: 20px 40px;
    }
    table.makeReviewTable{/*v评价商品表格*/
        margin: 20px 40px;
        font-size: 12px;
    }
    table.makeReviewTable td{/*单元格*/
        border: 1px solid #E7E7E7;
        padding: 10px;
        background-color: white;
    }
    table.makeReviewTable textarea{/*文本域*/
        border-width: 0px;
        resize: none;
        width: 420px;
        height: 120px;
    }
    td.makeReviewTableFirstTD{/*第一列*/
        background-color: #F6F6F6;
    }
    div.makeReviewButtonDiv{/*提交评价按钮所在div*/
        background-color: white;
        text-align: center;
        padding: 15px;
    }
    div.makeReviewButtonDiv button{/*提交评价按钮*/
        width: 72px;
        height: 26px;
        border-radius: 2px;
        background-color: #C40000;
        color: white;
        border-width: 0px;
        font-weight: bold;
    }
</style>
```


	2018-09-13 01:01:00
kumika	模仿天猫实战SSM--登陆页面	#模仿天猫实战SSM--登陆页面

## 1 效果

![效果.jpg](https://i.loli.net/2018/09/13/5b99d8ec5b622.jpg)

## 2 布局

![3348.png](https://i.loli.net/2018/09/13/5b99d8ec75bdf.png)

## 3 纯HTML

```
<div id="loginDiv">
    <div class="simpleLogo">
        <img src="img/site/simpleLogo.png"/>
    </div>
    <img src="img/site/loginBackground.png" id="loginBackgroundImg" class="loginBackgroundImg">
    <div class="loginSmallDiv" id="loginSmallDiv">
        <div class="login_acount_text">账户登录</div>
        <div class="loginInput">
            <span class="loginInputIcon">
                <span class="glyphicon glyphicon-user"></span>
            </span>
            <input type="text" placeholder="手机/会员名/邮箱" name="name" id="name">
        </div>
        <div class="loginInput">
            <span class="loginInputIcon">
                <span class="glyphicon glyphicon-lock"></span>
            </span>
            <input type="password" name="password" id="password" placeholder="密码">
        </div>
        <div>
            <a href="#nowhere" class="notImplementLink">忘记登陆密码</a>
            <a href="#nowhere" class="pull-right">免费注册</a>
        </div>
        <div style="margin-top: 20px">
            <button type="button" class="btn btn-block redButton">登录</button>
        </div>
    </div>
</div>
```

## 4 样式CSS


```
<style>
    div.simpleLogo{/*天猫图标logo所在div*/
        padding: 32px 0px;
    }
    img.loginBackgroundImg{/*背景图片*/
        display: block;
        margin: 0px auto;
    }
    div.loginSmallDiv{/*登录框div*/
        background-color: white;
        position: absolute;
        right: 80px;
        top: 180px;
        width: 350px;
        height: 400px;
        padding: 60px 25px 80px 25px;
    }
    div.login_acount_text{/*账号登录字样*/
        color: #3C3C3C;
        font-size: 16px;
        font-weight: bold;
    }
    div.loginInput{/*输入框所在div*/
        border: 1px solid #CBCBCB;
        margin: 20px 0px;
    }
    div.loginInput span.loginInputIcon{/*左侧放置图标的span*/
        margin: 0px;
        background-color: #CBCBCB;
        width: 40px;
        height: 40px;
        display:inline-block;
    }
    span.loginInputIcon span.glyphicon{/*用户和密码图标*/
        font-size: 22px;
        position: relative;
        left: 9px;
        top: 9px;
        color: #606060;
    }
    div.loginInput input{/*输入框*/
        display: inline-block;
        border: 0px solid transparent;
        width: 244px;
        height: 30px;
        position: relative;
        left: 6px;
        top: 6px;
    }
    body{/*整个body*/
        font-size: 12px;
        font-family: Arial;
    }
    a{/*所有超链*/
        color:#999;
    }
    a:hover{/*鼠标悬停*/
        text-decoration:none;
        color: #C40000;
    }
    button.redButton{/*登录按钮*/
        color: white;
        background-color: #C40000;
        font-size: 14px;
        font-weight: bold;
    }
</style>
```

	2018-09-13 10:33:23
kumika	模仿天猫实战SSM--注册页面	#模仿天猫实战SSM--注册页面

## 1 效果

![效果.jpg](https://i.loli.net/2018/09/13/5b99dc83df32c.jpg)

## 2 布局

![3373.png](https://i.loli.net/2018/09/13/5b99dc83d54c9.png)

## 3 纯HTML

```
<div class="registerDiv">
    <table align="center" class="registerTable">
        <tbody>
        <tr>
            <td class="registerTip registerTableLeftTD">设置会员名</td>
            <td></td>
        </tr>
        <tr>
            <td class="registerTableLeftTD">登录名</td>
            <td class="registerTableRightTD">
                <input placeholder="会员名一旦设置成功，无法修改" name="name" id="name">
            </td>
        </tr>
        <tr>
            <td  class="registerTip registerTableLeftTD">设置登陆密码</td>
            <td class="registerTableRightTD">登陆时验证，保护账号信息</td>
        </tr>
        <tr>
            <td class="registerTableLeftTD">登陆密码</td>
            <td class="registerTableRightTD">
                <input type="password" placeholder="设置你的登陆密码" name="password" id="password">
            </td>
        </tr>
        <tr>
            <td class="registerTableLeftTD">登陆确认</td>
            <td class="registerTableRightTD">
                <input type="password" placeholder="请再次输入你的密码"  id="repeatpassword">
            </td>
        </tr>
        <tr>
            <td class="registerButtonTD" colspan="2">
                <a href="#nowhere">
                    <button>提  交</button>
                </a>
            </td>
        </tr>
        </tbody>
    </table>
</div>
```

## 4 样式CSS

```
<style>
    div.registerDiv{/*注册页面div*/
        margin: 10px 20px;
        text-align: center;
    }
    table.registerTable{/*注册表格*/
        color: #3C3C3C;
        font-size: 16px;
        table-layout: fixed;
        margin-top: 50px;
    }
    table.registerTable td{/*单元格*/
        padding: 10px 30px;
    }
    table.registerTable input{/*输入框*/
        border: 1px solid #DEDEDE;
        width: 213px;
        height: 36px;
        font-size: 14px;
    }
    table.registerTable button{/*提交按钮*/
        width: 170px;
        height: 36px;
        border-radius: 2px;
        color: white;
        background-color: #C40000;
        border-width: 0px;
    }
    td.registerTip{/*提示文字*/
        font-weight: bold;
    }
    td.registerTableLeftTD{/*左侧单元格*/
        width: 300px;
        text-align: right;
    }
    td.registerTableRightTD{/*v右侧单元格*/
        width: 300px;
        text-align: left;
    }
    td.registerButtonTD{/*注册按钮*/
        text-align: center;
    }
</style>
```
	2018-09-13 11:40:18
kumika	天猫实战SSM--前后台需求	#天猫实战SSM--前后台需求

# 1 前端页面需求列表清单

显示有 ** XX ** 的表示与服务器有交互需求，没有显示 **的就是一般展示需求。

## 1.1首页
    在横向导航栏上提供4个分类连接
    在纵向导航栏上提供全部17个分类连接
    当鼠标移动到某一个纵向分类连接的时候，显示这个分类下的推荐商品
    按照每种分类，显示5个商品的方式显示所有17种分类
## 1.2产品页
    显示分辨率为950x100的当前商品对应的分类图片
    显示本商品的5个单独图片
    商品的基本信息，如标题，小标题，加6个，销量，评价数量，库存等
    商品详情
    评价信息
    5张商品详细图片
    **立即购买**
    **加入购物车**
## 1.3分类页
    显示分辨率为950x100的当前分类图片
    显示本分类下的所有产品
    **分类页排序**
## 1.4 搜索结果页
    显示满足查询条件的商品
## 1.5购物车查看页
    在购物车中显示订单项
    **调整订单项数量**
    **删除订单项**
## 1.6结算页
    在结算页面显示被选中的订单项
    **生成订单**
## 1.7确认支付页
    确认支付页面显示本次订单的金额总数
    **确认付款**
## 1.8支付成功页
    付款成功时，显示本次付款金额
## 1.9我的订单页
    显示所有订单，以及对应的订单项
## 1.10确认收货页
    显示订单项内容
    显示订单信息，收货人地址等
    **确认收货**
## 1.11评价页
    显示要评价的商品信息，商品当前的总评价数
    评价成功后，显示当前商品所有的评价信息
    **提交评价信息**
## 1.12页头信息展示
    未登录状态
    已登录状态
    **登录**
    **注册**
    **退出**
## 1.13所有页面
    **搜索**



# 2 后台需求分析


## 2.1 分类管理

    分页查询
    新增分类
    编辑修改
    删除


## 2.2 属性管理

    属性概念
    分页查询
    新增属性
    编辑修改
    删除

属性概念
----

这里的属性，指的是产品属性。 
比如`太阳镜`这种产品，有镜片材质，适合脸型，眼镜配件类型等属性。
而`平板电视`这种产品，有操作系统，能效等级，网络连接方式等属性。

不同的产品，有不同的属性，以及对应的属性值。

按照传统的数据库的设计方式，就会在产品表里设置不同的字段，而天猫的产品五花八门，有成百上千种不同的属性，难道给一张产品表设置成百上千的字段吗？ 

这样做出来的系统，肯定是不具备维护性的。

为了解决这个问题，引入了产品属性这个概念，假定同一类产品，都有相同的属性。
比如所有的`女装`，都有 材质成分，尺码，上市年份季节等等属性。 具体到某一件女装，其区别只是在于属性值不一样。

这样在一个分类下，就可以维护一系列的产品属性，针对于不同的产品，再设置不同的值，即可达到保存和维护大量产品属性值的效果。



## 2.3 产品管理

    分页查询
    新增产品
    编辑修改
    删除



## 2.4 产品图片管理

    产品图片概念
    产品图片管理

产品图片概念
------
一件产品，对应多条 **单个图片**
一件产品，对应多条 **详情图片**

所以这部分单独做一个页面进行管理

![6033.png](https://i.loli.net/2018/09/15/5b9cd3960b10b.png)



## 2.5 产品属性设置

根据属性管理中的讲解，一种产品所具备的属性，在其对应的分类中进行了维护。

那么，要修改产品的这些属性值，就在本页面进行。

这里采用异步提交方式，编辑即修改,修改成功用绿色边框表示


![6034.png](https://i.loli.net/2018/09/15/5b9cd4044299a.png)



## 2.6 用户管理

分页查询
用户管理就提供了一个分页查询，做的比较简约，几个原因：
1. 用户是不能删除的
2. 用户信息的修改，应该交由前端由客户自己修改，比如密码，基本信息等
3. 用户的增加，是前端注册导致的，后台不负责用户的增加

所以，增，删，改功能在后台就不提供了，仅仅提供一个分页查询

![6035.png](https://i.loli.net/2018/09/15/5b9cd55510f2b.png)



## 2.7 订单管理

    订单分页查询
    查看详情
    发货


![6036.png](https://i.loli.net/2018/09/15/5b9cd5b75c257.png)






































	2018-09-15 09:44:06
kumika	天猫实战SSM--表结构设计	"#天猫实战SSM--表结构设计

在需求分析结束之后，接下来要做的不是马上开发功能，而是进行表结构的设计。 
只有把表结构设计正确了，才能支撑软件后续的功能开发，这一步是非常重要的。 
为了便于理解表结构设计的过程，把设计过程分解成了 

    1. 数据库的创建 
    2. 表与表关系 
    3. 建表SQL语句 
    4. 表与页面 



# 1 数据库的创建

创建数据库:tmall_ssm3
并且将数据库的编码设置为utf8，便于存放中文

```
drop database if exists tmall_ssm3;
create database tmall_ssm3 default character set utf8;
```


# 2 表与表的关系

![表格.jpg](https://i.loli.net/2018/09/15/5b9cdb96da3d0.jpg)




| 表名 |  中文含义  |    介绍   | 
| ----- | ----- | ----- |
| Category| 分类表  | 存放分类信息，如女装，平板电视，沙发等 |
| Property | 属性表  |存放属性信息，如颜色，重量，品牌，厂商，型号等|
| PropertyValue | 属性值表   |存放属性值信息，如重量是900g,颜色是粉红色|
| Product| 3.7M |存放产品信息，如LED40EC平板电视机，海尔EC6005热水器|
| ProductImage | 3.7M |存放产品图片信息，如产品页显示的5个图片|
| Review | 3.7M |存放评论信息，如买回来的蜡烛很好用，么么哒|
| User | 3.7M |存放用户信息，如斩手狗，千手小粉红|
| Order | 3.7M |存放订单信息，包括邮寄地址，电话号码等信息|
| OrderItem | 3.7M |存放订单项信息，包括购买产品种类，数量等|


# 3 正确的分析表与表之间的关系的方法


表与表之间的关系，基本上是3种
**一对一**
**一对多**
**多对一**
那么怎么判断关系到底是什么呢？
以分类和产品为例子，分类表里有多条数据，产品表里也有多条数据，那么他们的关系是多对多吗？ 从经验上讲，我们知道这个结果是不正确的。

正确的分析表与表之间的关系的方法是这样：
**一个**分类对应 **多个** 产品
**一个**产品对应 **一个** 分类

所以分类和产品之间的关系是**一对多**


# 4 表关系

从最上面的表关系图中可以看到，有关系的表之间，都是一对多关系(反过来就是多对一关系)，并没有一对一关系，和多对多关系。

所以本表列出了所有的一对多关系

注：产品和用户之间其实是多对多关系，即一个用户可以购买多种产品，一种产品可以被多个用户购买。 但是他们的多对多关系是间接的建立在订单项表(OrderItem)上的。


| 1 | 多 |
| ----- | ----- |
|Category-分类 |Product-产品  |
|Category-分类 |Property-属性  |
|Property-属性 |PropertyValue-属性值  |
|Product-产品  |PropertyValue-属性值  |
|Product-产品  | ProductImage-产品图片 |
|Product-产品  | ProductImage-产品图片 |
|Product-产品  | Review-评价 |
|User-用户  | Order-订单 |
|Product-产品  | OrderItem-订单项 |
|User-用户  | OrderItem-订单项 |
|Order-订单	  |OrderItem-订单项 |
|User-用户  | Review-评价 |
"	2018-09-15 17:52:48
kumika	天猫实战SSM--建立表格SQL语句	#天猫实战SSM--建立表格SQL语句

#1 建立表格顺序

在建表过程中，会设置外键约束，所以表和表之间有依赖关系。 因此会**先建立被外键指向的表**，比如User,Category，然后再是其他表

**这里没有在表后面加级联，默认是restrict，
要是想要级联，就在后面加on delete cascade on update cascade**

这里的项目默认restrict，后面的几个删除会受到限制，因为还没有设置用户权限。

这我为了贪图方便，就创建表的时候加入了级联，这样可以实现几个删除操作。**注意，级联要慎重使用，因为会波及到别的表，复杂点的项目级联出错，多少数据没了，自己要慎重考虑下。**

# 2 用户表

```
create table User (
    id int(11) not null auto_increment primary key,
    name varchar(255) default null,
    password varchar(255) default null
)
```

# 3 分类表

```
create table Category(
    id int(11) not null auto_increment primary key,
    name varchar(255) default null
)
```

# 4 属性表

从这个表开始， 就有外键约束了。
本表的外键cid，指向分类表的id字段

```
create table Property(
    id int(11) not null auto_increment primary key,
    cid int(11) default null,
    name varchar(255) default null,
    constraint fk_Property_Category foreigh key (cid) reference Category (id) 
)
```

# 5 产品表

产品表字段稍多,标注下
name: 产品名称
subTitle: 小标题
originalPrice: 原始价格
promotePrice: 优惠价格
stock: 库存
createDate: 创建日期

本表的外键cid，指向分类表的id字段


```
ceate table Product(
    id int(11) not null auto_increment primary key,
    name varchar(255) default null,
    subTitle varchar(255) default null,
    originalPrice float default null,
    promotePrice float default null,
    stock int(11) default null,
    createDate  datetime default null,
    
    cid int(11) default null,
    constraint fk_Product_Category foreigt key (cid) reference Category (id)
)
```

# 6 属性值表


本表有两个外键
外键ptid，指向属性表的id字段
外键pid，指向产品表的id字段

```
ceate table PropertyValue(
    id int(11) not null auto_increment primary key,
    value varchar(255) default null,
    
    pid int(11) default null,
    ptid int(11) default null,
    constraint fk_PropertyValue_Property foreigh key (pid) reference Property(id),
    constraint fk_PropertyValue_Product foreigh key (ptid) reference Product(id)
)
```


# 7 产品图片表

type表示类型，产品图片分单个图片和详情图片两种

本表的外键pid，指向产品表的id字段


```
create table ProductImage(
    id int(11) not null auto_increment primary key,
    type varchar(255) default null,
    
    pid int(11) default null,
    constraint fk_ProductImage_Product foreigh key (pid) reference Product(id)
)

```

# 8 评价表

外键pid,指向产品表的id字段
外键uid,指向用户表的Id字段

```
create table Review (
    id int(11) not null auto_increment primary key,
    content varchar(4000) default null,
    createDate datetime default null,
    
    uid int(11) default null,
    pid int(11) default null,
    constraint fk_Review_User foreigh key (uid) reference User(id),
    constraint fk_Review_Product foreigh key (pid) reference Product(id)
)

```

# 9 订单表

订单表的字段也比较多，讲解一下：
orderCode： 订单号
address:收货地址
post: 邮编
receiver: 收货人信息
mobile: 手机号码
userMessage: 用户备注信息
createDate: 订单创建日期
payDate: 支付日期
deliveryDate: 发货日期
confirmDate：确认收货日期
status: 订单状态
外键uid，指向用户表id字段

```
create table Order_(
    id int(11) not null auto_increment primary key,
    orderCode varchar(255) default null,
    address varchar(255) default null,
    post int(11) default null,
    mobile int(11) default null,
    receiver varchar(255) default null,
    userMessage varchar(255) default null,
    createDate datetime default null,
    payDate datetime default null,
    deliveryDate datetime default null,
    confirmDate datetime default null,
    status varchar(255) default null,
    
    uid int(11) default null,
    constraint fk_Order_User foreiht key (uid) reference User(id)
)
```



# 10 订单项

这个表是外键最多的一个表
外键pid，指向产品表id字段
外键oid，指向订单表id字段
外键uid，指向用户表id字段
number字段表示购买数量

```
create table OrderItem(
    id int(11) not null auto_increment primary key,
    number int(11) default null,
    
    pid int(11) default null,
    uid int(11) default null,
    oid int(11) default null,
    
    constraint fk_OrderItem_Order foreigh key (oid) reference Order_(id),
    constraint fk_OrderItem_User foreigh key (uid) reference Order_(id),
    constraint fk_OrderItem_Product foreigh key(pid) reference Order_(id)
)
```


	2018-09-15 21:39:16
kumika	天猫实战SSM--前台前端实现与服务器交互	#天猫实战SSM--前台前端实现与服务器交互





# 置顶导航页面top.jsp

置顶导航页面
这里会根据用户是否登录，决定是否显示退出按钮，或者登录注册按钮，以及购物车中的商品数量

![6220.png](https://i.loli.net/2018/09/16/5b9e76ea121de.png)

原版静态的前端
-------

```
<nav class="top">
        <a href="#nowhere">
            <span class="glyphicon glyphicon-home redColor"></span>
            天猫首页
        </a>
        <span>喵，欢迎来天猫</span>
            <a href="#nowhere">请登录</a>
            <a href="#nowhere">免费注册</a>
        <%--向右飘逸定位使用Bootstrap的pull-right样式，
        其实这个样式很简单，就是使用的float:right. !important;表示高优先级--%>
        <span class="pull-right"></span>
            <a href="#nowhere">我的订阅</a>
            <a href="#nowhere">
                <span class="glyphicon glyphicon-shopping-cart redColor"></span>
                购物车<strong>0</strong>
            </a>
    </nav>
```

交互的前端
-----

```
<nav class="top ">
    <a href="${contextPath}">
        <span style="color:#C40000;margin:0px" class=" glyphicon glyphicon-home redColor"></span>
        天猫首页
    </a>
 
    <span>喵，欢迎来天猫</span>

 <%-- 如果用户成功登录，则显示如下： --%>
    <c:if test="${!empty user}">
        <a href="loginPage">${user.name}</a>
        <a href="forelogout">退出</a>
    </c:if>
 <%--如果取不到用户信息则显示如下： --%>
    <c:if test="${empty user}">
        <a href="loginPage">请登录</a>
        <a href="registerPage">免费注册</a>
    </c:if>
 <%--向右飘逸定位使用Bootstrap的pull-right样式，
        其实这个样式很简单，就是使用的float:right. !important;表示高优先级--%>
    <span class="pull-right">
            <a href="forebought">我的订单</a>
            <a href="forecart">
            <span style="color:#C40000;margin:0px" class=" glyphicon glyphicon-shopping-cart redColor"></span>
            购物车<strong>${cartTotalItemNumber}</strong>件</a>
        </span>
 
</nav>
```


# 搜索 search.jsp


这里会从request的属性"cs" 中获取到分类集合，并取第5个到第8个，一共4个来显示。

![6221.png](https://i.loli.net/2018/09/16/5b9e76ea13c1a.png)


静态的前端：
------
```
<a href="#nowhere">
        <img class="logo" id="logo" src="img/site/logo.gif">
    </a>

    <div class="searchDiv">
        <input  type="text" placeholder="时尚男鞋  太阳镜 " name="keyword">
        <button class="searchButton" type="submit">搜索</button>
        <div class="searchBelow">
            <span>
                <a href="#nowhere">平衡车</a> <span> | </span>
            </span>
            <span>
                <a href="#nowhere">扫地机器人</a> <span> | </span>
            </span>
            <span>
                <a href="#nowhere">原汁机</a> <span> | </span>
            </span>
            <span>
                <a href="#nowhere">冰箱</a> <span> | </span>
            </span>
        </div>
    </div>
```


交互服务器的前端
--------

网页上的：
```
<a href="${contextPath}">
        <img class="logo" id="logo" src="img/site/logo.gif">
    </a>
    <form action="foresearch" method="post">
        <div class="searchDiv">
            <input  type="text" placeholder="时尚男鞋  太阳镜 " name="keyword">
            <button class="searchButton" type="submit">搜索</button>
            <div class="searchBelow">
                <c:forEach items="${cs}" var="c" varStatus="st">
                    <c:if test="${st.count >= 5 and st.count <=8}">
                        <span>
                            <a href="forecategory?cid=${c.id}">${c.name}</a>
                            <c:if test="${st.count!=8}">
                                <span> | </span>
                            </c:if>
                        </span>
                    </c:if>
                </c:forEach>
            </div>
        </div>
    </form>
```










































	2018-09-16 10:05:08
kumika	分页	# 分页


分页的实现分为真分页和假分页两种，也就是物理分页和逻辑分页


##1 真分页（物理分页）
-----------


**实现原理**： `SELECT * FROM xxx [WHERE...] LIMIT #{param1}, #{param2}`
第一个参数是开始数据的索引位置
第二个参数是要查询多少条数据
**优点：** 不会造成内存溢出
**缺点：** 翻页的速度比较慢


##2 假分页（逻辑分页）
-----------
实现原理： 
**一次性将所有的数据查询出来放在内存之中**，每次需要查询的时候就直接从内存之中去取出相应索引区间的数据

**优点：** 分页的速度比较快
**缺点：** 可能造成内存溢出


#传统的分页方式

对于假分页的实现方式很简单，只需要准备一个集合保存从数据库中取出的所有数据，然后根据当前页面的码数，取出对应范围的数据显示就好了，我们这里基于物理分页来实现。

#参考：
https://www.jianshu.com/p/d108d0cd9acf


























	2018-09-18 11:22:19
kumika	增删改查功能	#增删改查功能





## 1 增加

 增加分类同时有上传图片功能

### 开发流程
1. add方法映射路径admin_category_add的访问
     1.1 参数 Category c接受页面提交的分类名称
     1.2 参数 session 用于在后续获取当前应用的路径
     1.3 UploadedImageFile 用于接受上传的图片
     
2. 通过categoryService保存c对象
     
3. 通过session获取ControllerContext,再通过getRealPath定位存放分类图片的路径。
     如果严格按照本教程的做法，使用idea中的tomcat部署的话，那么图片就会存放在:E:\project\tmall_ssm\target\tmall_ssm\img\category 这里
     
4. 根据分类id创建文件名
     
5. 如果/img/category目录不存在，则创建该目录，否则后续保存浏览器传过来图片，会提示无法保存
    
6. 通过UploadedImageFile 把浏览器传递过来的图片保存在上述指定的位置
     
7. 通过ImageUtil.change2jpg(file); 确保图片格式一定是jpg，而不仅仅是后缀名是jpg.
     
8. 客户端跳转到admin_category_list








## 2 删除

###增加删除方法
1. 映射路径admin_category_delete
2. 提供参数接受id注入
3. 提供session参数，用于后续定位文件位置
3. 通过categoryService删除数据
4. 通过session获取ControllerContext然后获取分类图片位置，接着删除分类图片
5. 客户端跳转到 admin_category_list



## 3 编辑

###增加edit方法
--------

1. 映射admin_category_edit路径的访问
2. 参数id用来接受注入
3. 通过categoryService.get获取Category对象
4. 把对象放在“c"上
5. 返回editCategory.jsp











## 4 修改

###新增update方法
----------

1. update 方法映射路径admin_category_update的访问
1.1 参数 Category c接受页面提交的分类名称
1.2 参数 session 用于在后续获取当前应用的路径
1.3 UploadedImageFile 用于接受上传的图片
2. 通过categoryService更新c对象
3. 首先判断是否有上传图片，如果有上传，那么通过session获取ControllerContext,再通过getRealPath定位存放分类图片的路径。
如果严格按照本教程的做法，使用idea中的tomcat部署的话，那么图片就会存放在:E:\project\tmall_ssm\target\tmall_ssm\img\category 这里
4. 根据分类id创建文件名
5. 通过UploadedImageFile 把浏览器传递过来的图片保存在上述指定的位置
6. 通过ImageUtil.change2jpg(file); 确保图片格式一定是jpg，而不仅仅是后缀名是jpg.
7. 客户端跳转到admin_category_list




复习IO流
-----

没有用到IO流，因为传输进入服务器完成保存的是这句

uploadImageFile是pojo类，file是服务器的文件
```
 MultipartFile image = uploadImageFile.getImage();
image.transferTo(file);
```



传输图片的过程，还有图片格式代码
----------------

1 jsp网页上传图片文件

2 jsp表单上的标签`<input name="imageFile">`要与pojo类属性名一致才能传进来，MVC中的M（model模型类）

3 在Controller中得到pojo类，并且作为add方法的参数

4 在add方法里，分2部分，
    第一部分==》图片的分类名，id,增加到数据库中
    第二部分===》图片文件数据，在服务器中创建文件IMAGE，然后把图片文件传输到IMGAE上，完成保存，同时也完成了上传功能。


查看以前上传功能代码
----------

都是图片，就找重复需要的语句把

在JSP上： 
表单需要写上**enctype="multipart/form-data"**
```
<form enctype="multipart/form-data">
```
在后台上：
都是  根据项目路径，创建在服务器上目录XXX/XXX的文件，然后把上传的文件传输数据给服务器的文件，这样就是上传完成了
都用的一样的想法：
PS：getServletContext() 获取的是Servlet容器对象,相当于tomcat容器了
```
//创建服务器上的文件
File fileFolder = new File(session.getServletContext().getRealPath("XXX/XXX"));
//文件根据分类重命名,category是产品分类的类
File file = new File(fileFolder,category.getId()+".jpg");
//假如目录没有，就创建
if(! file.exists()){
    file.mkdirs();
}
//把上传的文件传输到服务器上的文件，POJO类是MultipartFile类，UploadImageFile是JSP上接收来的上传文件
UploadImageFile.transferTo(file);


//也有用剪切进行传输同时也重命名的方法，注意：POJO类是File类
String fileNewName = "XX";
UploadFile.renameTo(new File(file,fileNewName));

```


理解增加类型上传图片整个流程
--------------

注意： 名字称号，文件本身数据是分别存放的，名称存放在数据库上，文件数据存放在服务器上。

增加就是一般的增加数据库的数据

上传：
从JSP接收上传文件uploadFile，===》根据项目的根目录或者自己创建新的目录，创建服务器上的文件（你可以随便命名这个文件，此时是0KB的空文件）===》把uploadFile传输到服务器的文件上，完成上传。

在判断文件格式，或者修改文件格式上才需要到IO流，这只是上传，没有改格式，所以没有用到IO流。

开发 和部署 是不一样的吗
-------------




#疑问：

1 为什么查询用转发而添加就用重定向呢？
------------------

因为查询出来后，要传数据到页面，只能用服务端跳转。
而增加之后，不需要传数据。 所以客户端跳转到查询去。


2 现在图片上传到的是TomCat服务器，还是项目开发环境上？
-------------------------------

看你开发的时候idea用的是什么模式：
war模式：将WEB工程以包的形式上传到服务器 ；
war exploded模式：将WEB工程以当前文件夹的位置关系上传到服务器；



3 springMVC是怎么接收JSP表单发来的数据的？
----------------------------

spring把表单上的属性**全部自动包装成Model**，然后传进后台去，**自动包装**====》用的是ModelDriver还是ModelAndView？里面的内容就是spring的底层实现了，目前没有实力去理解。



	2018-09-19 00:43:48
kumika	重构	# 重构

    <!--keyProperty="id"  useGeneratedKeys="true" 意思：调用增加之后，实体类才会有id,如果没有这个，实体类的id 是0-->


提交表单上隐藏外键cid，值是category的id，这就意味着提交表单后，product对象里面是有cid外键的，它的值是category的id，这样就把分类category 和product的外键联系起来了。增加了product到数据库同时也把外键增加到数据库了，在product表里。













	2018-09-21 15:32:42
kumika	天猫SSM实战--后台实现功能 1	#天猫SSM实战--后台实现功能 1


#分3个大的功能管理--分类管理--用户管理--订单管理

因为先实现的是后台功能，前台的功能还没有做，所以是未完成版的，以后代码会有改动。

# 1 分类管理

目标效果：

[![分类项目.jpg](https://i.loli.net/2018/09/26/5bab4ccd49952.jpg)](https://i.loli.net/2018/09/26/5bab4ccd49952.jpg)

[![增加分类.jpg](https://i.loli.net/2018/09/26/5bab4ccd12113.jpg)](https://i.loli.net/2018/09/26/5bab4ccd12113.jpg)

主要功能:

[![分类管理.jpg](https://i.loli.net/2018/09/26/5bab4b8da5db8.jpg)](https://i.loli.net/2018/09/26/5bab4b8da5db8.jpg)



## 1 分类管理（管理分类）



### 1.1 查询所有分类功能

#### 1.1.1 查询所有分类功能jsp:
----

 查询所有的分类

```
 <a class="navbar-brand" href="admin_category_list">分类管理</a>
```


#### 1.1.2 CategoryController：
-------------------

因为分页功能是分开的，所以要是有分页功能的都要有page参数

```
    @RequestMapping("admin_category_list")
    public String list(Model model, Page page) {

        //通过分页插件指定分页参数, 开始编号，每页显示多少个
        PageHelper.offsetPage(page.getStart(), page.getCount());
        /*调用list() 获取对应分页的数据*/
        List<Category> categories = categoryService.list();
        /*通过PageInfo获取总数*/
        int total = (int)new PageInfo(categories).getTotal();
        page.setTotal(total);

        model.addAttribute("categories", categories);
        model.addAttribute("page", page);
        return "admin/listCategory";
    }
```


#### 1.1.3 CategoryServiceIMP
------------------

生成的Mapper和Dao 都是使用mybatis的逆向工程，查询，增加，更新，修改都是使用自动生成的方法，未有改动。所以也不粘贴上来了

```
    public List<Category> list() {
        CategoryExample categoryExample = new CategoryExample();
        categoryExample.setOrderByClause("id desc");

        return categoryMapper.selectByExample(categoryExample);
    }
```



### 1.2 增加分类(包括上传图片)

#### 1.2.1 增加分类功能jsp:

 1. method="post" 用于保证中文的正确提交
 2. 必须有enctype="multipart/form-data"，这样才能上传文件
 3. accept="image/*" 这样把上传的文件类型限制在了图片

**关键点在于要有enctype="mutipart/form-date"这个属性和 name="image"**  

个人理解：在controller的方法上，无论jsp的提交表单是什么类型，只要pojo类上能对应上name的，这个Pojo类就可作为参数注入到方法上（要是pojo类的属性与表单name对应不全，那pojo类的属性就有null值）

```
<form method="post" id="addForm" action="admin_category_add" enctype="multipart/form-data">
                <table class="addTable">
                    <tr>
                        <td>分类名称</td>
                        <td><input  id="name" name="name" type="text" class="form-control"></td>
                    </tr>
                    <tr>
                        <td>分类圖片</td>
                        <td>
                            <input id="categoryPic" accept="image/*" type="file" name="image" />
                        </td>
                    </tr>
                    <tr class="submitTR">
                        <td colspan="2" align="center">
                            <button type="submit" class="btn btn-success">提 交</button>
                        </td>
                    </tr>
                </table>
            </form>
```


#### 1.2.2 CategoryController:

图片类 uploadImageFile  是接收表单上传图片的pojo类

**MultipartFile 类型的属性，用于接受上传文件的注入
jsp上的enctype="multipart/form-data"**


```
public class UploadimageFile {
//MultipartFile 类型的属性，用于接受上传文件的注入
//jsp上的enctype="multipart/form-data"
  MultipartFile image;

<!-- setter 和 getter -->
}
```

[![上传图片.jpg](https://i.loli.net/2018/10/30/5bd812a03397c.jpg)](https://i.loli.net/2018/10/30/5bd812a03397c.jpg)

思路：（分2部分保存，一个保存表单对象，一个保存上传图片文件）
1 方法参数1 ： pojo类 category
2 方法参数2 ： 图片类 uploadImageFile  
3 方法参数3 ： HttpSession session

4 对category对象增加到数据库中
**============完成category对象保存，下面是对图片文件保存=======**
5 创建新的文件
5.1 根据session.getServletContext().getRealPath("img/category"),获得存放文件目录,然后创建新文件 File file = new File(目录路径)

5.2 根据自己需要的文件名创建新的文件File file = new File(文件，文件名)

5.3 确保目录真实存在file.getParentFile().mkdirs()

6 把上传的文件传输到新的文件中,其中使用MultipartFile 类的方法transferTo()。进行

uploadImageFile.getImage().transferTo(file)


7 返回页面重新查询，重定向admin_category_list

```
    @RequestMapping("admin_category_add")
    public String add(Category category, HttpSession session, UploadimageFile uploadimageFile) throws IOException {
        /*通过categoryService保存category对象*/
        categoryService.add(category);
        /*通过session获取ControllerContext,再通过getRealPath定位存放分类图片的路径。
        *
        request.getSession().getServletContext() 获取的是Servlet容器对象,相当于tomcat容器了.
        getRealPath(“/”) 获取实际路径,
        “/”指代项目根目录,所以代码返回的是项目在容器中的实际发布运行的根路径。
        session.getServletContext().getRealPath("img/category")这个路径就是“根路径/img/category”

        1. 先用可运行项目跑起来，是可以实现上传功能的
        2. session.getServletContext.getRealPath("") 拿到的是运行时环境，而在idea里部署的话，
            运行环境不会是源代码webapp/img目录呢
        3. maven项目里src目录下的java,webapp和resource目录都不会参与部署，如果是通过idea部署的话，
            部署的位置是/target/tmall_ssm目录下呢
        4. 从你的截图来看，你应该采用的是tomcat独立部署方式吧。 这就对了呀，独立部署，
            那么获取到的路径肯定是tomcat那里的目录嘛。
            想想真实环境，开发是在windows上做的，部署是在linux上做的，那么获取到的img路径，难道不应该是在linux上吗？ 对嘛

        */
        File imageFolder = new File(session.getServletContext().getRealPath("img/category"));
        System.out.println("根路径：  " + session.getServletContext());
        System.out.println("实际路径：  " + session.getServletContext().getRealPath("/"));

        /*根据分类id创建文件名*/
        File file = new File(imageFolder, category.getId() + ".jpg");
       /*如果/img/category目录不存在，则创建该目录，否则后续保存浏览器传过来图片，会提示无法保存*/
        if (!file.getParentFile().exists()) {
            /*如果父文件夹不存在并且最后一级子文件夹不存在，它就自动新建所有路经里写的文件夹；
            如果父文件夹存在，它就直接在已经存在的父文件夹下新建子文件夹*/
            file.getParentFile().mkdirs();
        }
        /*通过UploadedImageFile 把浏览器传递过来的图片保存在上述指定的位置
        * transfer是把浏览器上传的文件保存在服务器
        * */
        uploadimageFile.getImage().transferTo(file);
        /*通过ImageUtil.change2jpg(file); 确保图片格式一定是jpg，而不仅仅是后缀名是jpg.*/
        BufferedImage bufferedImage = ImageUtil.change2jpg(file);
        /*确保图片格式一定是jpg*/
        ImageIO.write(bufferedImage, "jgp", file);

        return "redirect:/admin_category_list";
    }
```


#### 1.2.3 CategoryServiceIMP


```
  public void add(Category category) {
        categoryMapper.insert(category);
    }
```



### 1.3 删除分类功能

删除分类，因为这有分类图片，所以要删除2次 ，一次是删除分类，一次删除图片。
毕竟保存多少次，就删除多少次嘛

**删除文件需要文件是空的**

file 的删除api解释：Deletes the file or directory denoted by this abstract pathname.（通过抽象路径名进行文件OR指定路径）

#### 1.3.1 删除功能Jsp：

那个《span》标签内容是删除图标trash
```
<td><a href="admin_category_delete?id=${category.id}" deleteLink="true"><span class="glyphicon glyphicon-trash"></span></a> </td>
```


#### 1.3.2 CategoryController：

删除思路：

1 删除category对象

CategoryService.delete(id)

2 删除服务器上保存的图片

[![删除上传图片.jpg](https://i.loli.net/2018/10/30/5bd812a01ad09.jpg)](https://i.loli.net/2018/10/30/5bd812a01ad09.jpg)
2.1 创建一个一样路径,一样名字的文件，覆盖图片文件
2.2 这样空的文件就可以删除了

```
    @RequestMapping("admin_category_delete")
    public String delete(HttpSession session, int id) {

        categoryService.delete(id);

        File imgeFolder = new File(session.getServletContext().getRealPath("img/category"));
        File file = new File(imgeFolder, id + ".jpg");
        file.delete();

        return "redirect:/admin_category_list";
    }

```

#### 1.3.3 CategoryServiceIMP：

```
  public void delete(int id) {
        categoryMapper.deleteByPrimaryKey(id);
    }
```




### 1.4 修改分类功能（修改上传图片）

其实所谓修改上传图片，就是新的图片整个覆盖旧的图片

修改2个内容 
1 分类名称
2 修改图片

================================
想更正自己的一个惯性思维，老是觉得修改是一步到位的，但是其实是分2个部分的。

第1部分是**拿到需要修改的分类**  category

第2部分 是根据上传表单的内容更新拿到的分类，进行修改更新


#### 1.4.1 第 1 部分 拿到分类

Jsp：
```
<td><a href="admin_category_edit?id=${category.id}"><span class="glyphicon glyphicon-edit"></span></a> </td>
```

Controller:
拿到需要更新的分类，然后进行跳转到展示需要更新分类的页面，更新表单在那里。
```
    @RequestMapping("admin_category_edit")
    public String edit(int id, Model model) {
        Category category = categoryService.get(id);
        model.addAttribute("category", category);
        return "admin/editCategory";
    }
```

ServiceIMP:

```
   public Category get(int id) {
        return categoryMapper.selectByPrimaryKey(id);
    }
```


#### 1.4.2 第 2 部分 更新分类

这里更新2样，分类名称，图片，所以不要忘记**enctype="mutipart-data"**

JSP的表单：

```
 <form method="post" id="editForm" action="admin_category_update" enctype="multipart/form-data">
                <table class="editTable">
                    <tr>
                        <td>分类名称</td>
                        <td><input  id="name" name="name" value="${category.name}" type="text" class="form-control"></td>
                    </tr>
                    <tr>
                        <td>分类圖片</td>
                        <td>
                            <input id="categoryPic" accept="image/*" type="file" name="image" />
                        </td>
                    </tr>
                    <tr class="submitTR">
                        <td colspan="2" align="center">
                            <input  type="hidden" name="id" value="${category.id}">
                            <button type="submit" class="btn btn-success">提 交</button>
                        </td>
                    </tr>
                </table>
            </form>
```


Controller：

几乎是与增加分类与图片是一样的，区别在于这要判断上传图片是否为空
```
MultipartFile image = uploadImageFile.getImage();
        if (null != image && !image.isEmpty()) {
```
更新也是分2部分更新，更新分类  和  更新 图片

思路：
3个参数 上传图片，分类对象，HttpSession

1 对分类对象进行更新CategoryService.update(catogory)

2 根据Session.getServletContext().getRealPath(目录路径)，得到目录路径，然后创建新的文件File file = new File(目录路径) ，接着根据一样的文件名创建文件 File  NewFile = new File(file,一样的文件名)

3 上传的文件image,传输到这个新的文件 image.transferTo(NewFile)

```
    @RequestMapping("admin_category_update")
    public String update(HttpSession session, Category category, UploadimageFile uploadImageFile) throws IOException {
        categoryService.update(category);
        //判断上传文件是否为空
        MultipartFile image = uploadImageFile.getImage();
        if (null != image && !image.isEmpty()) {
            File imageFolder = new File(session.getServletContext().getRealPath("img/category"));
            File file = new File(imageFolder, category.getId() + ".jpg");
            image.transferTo(file);
            //下面的都是确保图片是jpg格式
            BufferedImage bufferedImage = ImageUtil.change2jpg(file);
            ImageIO.write(bufferedImage, "jpg", file);
        }
        return "redirect:/admin_category_list";
    }
```


CategoryServiceIMP：

```
 public void update(Category category) {
        categoryMapper.updateByPrimaryKey(category);
    }
```




















	2018-09-26 16:36:49
kumika	天猫SSM实战--后台实现功能 2	#天猫SSM实战--后台实现功能 2


# 1 显示分类图片


JSP：

```
  <td><img height="40px" src="img/category/${category.id}.jpg"/></td>
```


# 2 属性管理


## 1 显示属性

在分类的listCategory.JSP：

```
<td><a href="admin_property_list?cid=${category.id}"><span class="glyphicon glyphicon-th-list"></span></a> </td>
```


PropertyController:

```
    @RequestMapping("admin_property_list")
    public String list(int cid, Model model, Page page) {

        PageHelper.offsetPage(page.getStart(), page.getCount());

        Category category = categoryService.get(cid);

        List<Property> propertyList = propertyService.list(cid);

        int total = (int) new PageInfo(propertyList).getTotal();
        page.setTotal(total);
        page.setParam("&cid=" + category.getId());

        model.addAttribute("propertyList", propertyList);
        model.addAttribute("category", category);
        model.addAttribute("page", page);
        return "admin/listProperty";
    }
```


PropertyServiceIMP:

```
    public List<Property> list(int cid) {
        PropertyExample propertyExample = new PropertyExample();
        propertyExample.createCriteria().andCidEqualTo(cid);
        propertyExample.setOrderByClause("id desc");
        return propertyMapper.selectByExample(propertyExample);
    }
```



##  2 增加属性

在listProperty.JSP：
注意：
```
 <input type="hidden" name="cid" value="${category.id}">
```
在增加属性的同时把Cid这个外键添加到属性对象中，让属性与当前分类产生关联
```
<form method="post" id="addForm" action="admin_property_add" enctype="multipart/form-data">
                <table class="addTable">
                    <tr>
                        <td>属性名称</td>
                        <td><input  id="name" name="name" type="text" class="form-control"></td>
                    </tr>
                    <tr class="submitTR">
                        <td colspan="2" align="center">
                            <input type="hidden" name="cid" value="${category.id}">
                            <button type="submit" class="btn btn-success">提 交</button>
                        </td>
                    </tr>
                </table>
            </form>
```


PropertyController:

```
 @RequestMapping("admin_property_add")
    public String add(Property property) {
        propertyService.add(property);
        return "redirect:admin_property_list?cid=" + property.getCid();
    }
```

PropertyServiceIMP:

```
  public void add(Property property) {
        propertyMapper.insert(property);
    }
```



## 3 修改属性名称

修改是需要2部分组成，第1 拿到修改对象，第2 更新对象


### 3.1 得到更新的对象
JSP ：
```
<td><a href="admin_property_edit?id=${propertyList.id}"><span class="glyphicon glyphicon-edit"></span></a> </td>
```

PropertyController:

```
    @RequestMapping("admin_property_edit")
    public String edit(int id, Model model) {
        Property property = propertyService.get(id);
        Category category = categoryService.get(property.getCid());
        property.setCategory(category);

        model.addAttribute("property", property);
        return "admin/editProperty";
    }
```

PropertyServiceIMP:

```
   @Override
    public Property get(int id) {
        return propertyMapper.selectByPrimaryKey(id);
    }
```


### 3.2 更新部分

JSP：

关键点：
    将当前属性与外键Cid和 当前分类联系在一起
```
<input  type="hidden" name="id" value="${property.id}">
                            <input  type="hidden" name="cid" value="${property.category.id}">
```

完整的表单：

```
<form method="post" id="editForm" action="admin_property_update" enctype="multipart/form-data">
                <table class="editTable">
                    <tr>
                        <td>属性名称</td>
                        <td><input  id="name" name="name" value="${property.name}" type="text" class="form-control"></td>
                    </tr>

                    <tr class="submitTR">
                        <td colspan="2" align="center">
                            <input  type="hidden" name="id" value="${property.id}">
                            <input  type="hidden" name="cid" value="${property.category.id}">
                            <button type="submit" class="btn btn-success">提 交</button>
                        </td>
                    </tr>
                </table>
            </form>
```


PropertyController：

```
@RequestMapping("admin_property_update")
    public String update(Property property) {
        propertyService.update(property);
        return "redirect:admin_property_list?cid=" + property.getCid();
    }
```

PropertyServiceIMP:

```
    public void update(Property property) {
        propertyMapper.updateByPrimaryKeySelective(property);
    }
```



	2018-09-26 20:05:35
kumika	天猫实战SSM---后台实现功能3	#天猫实战SSM---后台实现功能3

#1 产品管理

首先明白产品表与表之间的外键关连，才更好理解数据之间传输的关系
[![表与表之间外键的联系.jpg](https://i.loli.net/2018/09/27/5bac58ba84f7e.jpg)](https://i.loli.net/2018/09/27/5bac58ba84f7e.jpg)


## 3.1 增加产品

这里的增加产品只是增加产品的基本信息，比如产品名称，小标题，价格，优惠价格·····

JSP：

注意： 这个cid是增加产品product的外键，关联分类的，**关键**

    <input type="hidden" name="cid" value="${category.id}">

表单代码：

```
<form method="post" id="addForm" action="admin_product_add" enctype="multipart/form-data">
                <table class="addTable">
                    <tr>
                        <td>产品名称</td>
                        <td><input  id="name" name="name" type="text" class="form-control"></td>
                    </tr>
                    <tr>
                        <td>产品小标题</td>
                        <td><input  id="subTitle" name="subTitle" type="text" class="form-control"></td>
                    </tr>
                    <tr>
                        <td>原价格</td>
                        <td><input  id="originalPrice" name="originalPrice" value="99.98" type="text" class="form-control"></td>
                    </tr>
                    <tr>
                        <td>优惠价格</td>
                        <td><input  id="promotePrice" name="promotePrice" value="19.98" type="text" class="form-control"></td>
                    </tr>
                    <tr>
                        <td>库存</td>
                        <td><input  id="stock" name="stock" value="199" type="text" class="form-control"></td>
                    </tr>
                    <tr class="submitTR">
                        <td colspan="2" align="center">
                            <input type="hidden" name="cid" value="${category.id}">
                            <button type="submit" class="btn btn-success">提 交</button>
                        </td>
                    </tr>
                </table>
            </form>
```

ProductController:

```
    @RequestMapping("admin_product_add")
    public String add(Product product) {
        product.setCreateDate(new Date());

        productService.add(product);
        return "redirect:admin_product_list?cid=" + product.getCid();
    }
```

ProductServiceIMP:

```
    @Override
    public void add(Product product) {
        productMapper.insert(product);
    }
```

## 3.2 展示产品和产品图片管理

### 3.2.1 展示产品
效果是： 从展示分类页面上点击产品管理，进入展示产品页面
[![QQ截图20180927122323.jpg](https://i.loli.net/2018/09/27/5bac5b515e091.jpg)](https://i.loli.net/2018/09/27/5bac5b515e091.jpg)

产品图片和产品属性信息是分开存储的，而且此时产品还没有图片属性，所以我们自己增加图片属性和分类属性。
在查询的时候也要注意查询完成后产品是没有图片内容和分类内容的，它们的值都是Null。
产品类上增加图片属性，分类属性。
```
    private ProductImage firstProductImage;

    private List<ProductImage> productSingleImages;

    private List<ProductImage> productDetailImages;

    private Category category;
    //setter和getter就不写了
```

#### 3.2.1.1产品图片类

```
public class ProductImage {
    private Integer id;

    private Integer pid;

    private String type;
    
    //setter 和 getter
}
```
#### 3.2.1.2 查询产品

在ListCategory.jsp上：
```
<td><a href="admin_product_list?cid=${category.id}"><span class="glyphicon glyphicon-shopping-cart"></span></a> </td>
```

ProductController:


```
    @RequestMapping("admin_product_list")
    public String list(int cid, Model model, Page page) {
        Category category = categoryService.get(cid);

        PageHelper.offsetPage(page.getStart(), page.getCount());
        List<Product> productList = productService.list(cid);

        int total = (int) new PageInfo().getTotal();

        page.setTotal(total);
        /*
        拼接字符串"&cid="+c.getId()，设置给page对象的Param值。
        因为产品分页都是基于当前分类下的分页，所以分页的时候需要传递这个cid
        */
        page.setParam("&cid=" + category.getId());

        model.addAttribute("productList", productList);
        model.addAttribute("category", category);
        model.addAttribute("page", page);

        return "admin/listProduct";
    }
```

ProductServiceIMP：

在业务层完成图片和产品的合并。
就是**完成产品的图片属性赋值，分类属性赋值。**
产品与分类的关联是外键cid，----》意思是知道产品的cid，就依据id查询知道category的id，从而得到category

    产品与产品图片的关联是外键Pid，----》意思是知道产品图片的pid，就依据id查询知道产品的id,从而得到产品图片
  
    反过来也是可以的，知道分类的id ，可以依据cid查询得到产品，
    知道产品的id ，可以依据pid查询得到产品图片。



```
    @Override
    public List<Product> list(int cid) {
        ProductExample productExample = new ProductExample();
        productExample.createCriteria().andCidEqualTo(cid);
        productExample.setOrderByClause("id desc");
        List<Product> productList =  productMapper.selectByExample(productExample);
        setFirstProductImage(productList);
        setCategory(productList);

        return productList;
    }
    
    public void setCategory(List<Product> productList) {
        for (Product pro : productList) {
            setCategory(pro);
        }
    }

    public void setCategory(Product product) {
        int cid = product.getCid();
        Category category = categoryService.get(cid);
        product.setCategory(category);
    }    
 
     //根据产品的id ,图片的类型进行查询返回图片，然后产品setImage
    @Override
    public void setFirstProductImage(Product product) {
        List<ProductImage> productImageList = productImageService.list(product.getId(), ProductImageService.type_single);
        if (!productImageList.isEmpty()) {
            ProductImage productImage = productImageList.get(0);
            product.setFirstProductImage(productImage);
        }
    }


    public void setFirstProductImage(List<Product> productlist) {
        for (Product pro : productlist) {
            setFirstProductImage(pro);
        }
    }
    
```


**下面说明产品图片业务和分类业务：**

产品图片思路：
在给产品图片赋值，是需要**产品业务层**使用
查询单一图片方法`setFirstProductImage(product)`，或者列表查询图片方法`setFirstProductImage(List<Product> productlist)`。

然后方法体里使用**产品图片业务层**`ProductImageService`查询方法`list(产品id,图片类型)`。同时，图片是存在2种类型的，单一，中等大小类型。

查询方法得到图片列表，最后拿第一个元素赋值给产品。

========================================================

####在产品图片业务层创建ProductImageServiceIMP：
---------------------------------

注意： 查询的是pid，type这两个参数

    andPidEqualTo(pid).andTypeEqualTo(type);

查询
```
    @Override
    public List<ProductImage> list(int pid, String type) {
        ProductImageExample productImageExample = new ProductImageExample();
        productImageExample.createCriteria()
                .andPidEqualTo(pid)
                .andTypeEqualTo(type);
        productImageExample.setOrderByClause("id desc");

        return productImageMapper.selectByExample(productImageExample);
    }
```


**疑问： 为什么返回的图片是列表呢？业务层上需要拿图片列表对象的第一个元素？**


####赋值分类属性也是一样：
-----------
产品分类思路：
在产品业务层创建SetCategory（product）方法；

然后方法体里使用分类的业务层查询方法得到分类，

最后赋值给产品

单个分类赋值
```
    public void setCategory(Product product) {
        int cid = product.getCid();
        Category category = categoryService.get(cid);
        product.setCategory(category);
    } 
```
批量分类赋值（在单个基础上，增加for循环）
```
    public void setCategory(List<Product> productList) {
        for (Product pro : productList) {
            setCategory(pro);
        }
    }
```


拿个图显示下关系
[![2.jpg](https://i.loli.net/2018/09/27/5bacd37caa470.jpg)](https://i.loli.net/2018/09/27/5bacd37caa470.jpg)


### 3.2.2 产品图片修改（增加）

图片增加和修改完成效果都是一样的。都是新建文件然后覆盖。

jsp:
注意---外键和图片类型都是隐藏的
```
 <input type="hidden" name="type" value="type_single" />
 <input type="hidden" name="pid" value="${product.id}" />
```
表单代码：
```
 <form method="post" class="addFormSingle" action="admin_productImage_add"
                                  enctype="multipart/form-data">
                                <table class="addTable">
                                    <tr>
                                        <td>请选择本地图片 尺寸400X400 为佳</td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <input id="filepathSingle" type="file" name="image" />
                                        </td>
                                    </tr>
                                    <tr class="submitTR">
                                        <td align="center">
                                            <input type="hidden" name="type" value="type_single" />
                                            <input type="hidden" name="pid" value="${product.id}" />
                                            <button type="submit" class="btn btn-success">提 交</button>
                                        </td>
                                    </tr>
                                </table>
                            </form>
```


**ProductImageController：**
增加图片，因为有2种图片类型，所以在前面增加图片的代码上增加判断语句。

整体思路还是不变的：2次保存，一次是保存图片pojo类，一次是保存图片文件。
3个参数： pojo类：ProductImage, HttpSession session , uploadFile

1 根据自己想要的目录路径，根据图片id，新建空文件ImageFile，（图片id是作为文件名的）


2 根据上传的图片的类型属性进行判断，**可以分出不同类型，然后根据不同的类型创建目录路径，保证自己的每一条目录路径保存的都是相同类型图片**
EG：
```
String imageFolder;
String imageFolder_small = null;
String imageFolder_middle = null;
 if (ProductImageService.type_single.equals(productImage.getType())) {
            imageFolder = session.getServletContext().getRealPath("img/ProductImageSingle");
            imageFolder_small = session.getServletContext().getRealPath("img/ProductImage_small");
            imageFolder_middle = session.getServletContext().getRealPath("img/ProductImage_middle");
} else {
            imageFolder = session.getServletContext().getRealPath("img/ProductImageDetail");
        }
```

3 上传图片文件uploadfile传输到ImageFile，完成，此时ImageFile是图片文件了。

 
4 上传图片类型作为判断条件，进入判断体内，
关键点：创建文件

    File XXXfile = new File（XXX目录路径，图片编号）

XXXFile此时是空文件，然后借助别的工具类把ImageFile和XXXFile作为参数放进某个方法里，就可以得到不同大小的图片了。


```
 if (ProductImageService.type_single.equals(productImage.getType())) {
        File file_small = new File(imageFolder_small, fileName);
        File file_middle = new File(imageFolder_middle, fileName);
        ImageUtil.resizeImage(newFile, 56, 56, file_small);
        ImageUtil.resizeImage(newFile, 217, 190, file_middle);
}
```

完整代码：

```
@RequestMapping("admin_productImage_add")
    public String add(ProductImage productImage, HttpSession session, UploadimageFile uploadimageFile) {
        productImageService.add(productImage);

        String fileName = productImage.getId() + ".jpg";
        String imageFolder;
        String imageFolder_small = null;
        String imageFolder_middle = null;

        if (ProductImageService.type_single.equals(productImage.getType())) {
            imageFolder = session.getServletContext().getRealPath("img/ProductImageSingle");
            imageFolder_small = session.getServletContext().getRealPath("img/ProductImage_small");
            imageFolder_middle = session.getServletContext().getRealPath("img/ProductImage_middle");
        } else {
            imageFolder = session.getServletContext().getRealPath("img/ProductImageDetail");
        }

        File newFile = new File(imageFolder, fileName);
        newFile.getParentFile().mkdirs();

        try {
            uploadimageFile.getImage().transferTo(newFile);
            BufferedImage bufferedImage = ImageUtil.change2jpg(newFile);
            ImageIO.write(bufferedImage, "jpg", newFile);

            if (ProductImageService.type_single.equals(productImage.getType())) {
                File file_small = new File(imageFolder_small, fileName);
                File file_middle = new File(imageFolder_middle, fileName);

                ImageUtil.resizeImage(newFile, 56, 56, file_small);
                ImageUtil.resizeImage(newFile, 217, 190, file_middle);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        return "redirect:admin_productImage_list?pid=" + productImage.getPid();
    }
```

ProductImageServiceIMP:
```
    @Override
    public void add(ProductImage productImage) {
        productImageMapper.insert(productImage);
    }
```


### 3.2.3 产品图片删除

删除的思路也是和修改增加一样的，都是创建新文件，然后覆盖。

1 根据方法的参数查询得到图片文件，然后得到图片id 

2 根据图片文件属性判断是什么类型的，然后根据目录和图片id进行创建新文件（图片id是作为文件名的），用空文件覆盖旧文件完成删除数据作用。（一般用图片id作为文件名，这样创建文件同时也是覆盖）

3 对新建的空文件进行删除。

JSP：
```
<td><a href="admin_product_delete?id=${productList.id}" deleteLink="true"><span class="glyphicon glyphicon-trash"></span></a> </td>
```

ProductImageController：
```
@RequestMapping("admin_productImage_delete")
    public String delete(int id, HttpSession session) {
        ProductImage productImage = productImageService.get(id);

        String fileName = productImage.getId() + ".jpg";
        String imageFloder;
        String imageFloder_small = null;
        String imageFloder_middel = null;


        if (ProductImageService.type_single.equals(productImage.getType())) {
            imageFloder = session.getServletContext().getRealPath("img/ProductImageSingle");
            imageFloder_small = session.getServletContext().getRealPath("img/ProductImage_small");
            imageFloder_middel = session.getServletContext().getRealPath("img/ProductImage_middle");

            File imagefile = new File(imageFloder, fileName);
            File imagefile_small = new File(imageFloder_small, fileName);
            File imagefile_middel = new File(imageFloder_middel, fileName);

            imagefile.delete();
            imagefile_small.delete();
            imagefile_middel.delete();
        }
        else {
            imageFloder = session.getServletContext().getRealPath("img/ProductImageDetail");
            File imageFile = new File(imageFloder, fileName);

            imageFile.delete();
        }

        productImageService.delete(id);
        return "redirect:admin_productImage_list?pid=" + productImage.getPid();
    }
```


ProductServiceIMP:
```
    @Override
    public ProductImage get(int id) {
        return productImageMapper.selectByPrimaryKey(id);
    }
    
    @Override
    public void delete(int id) {
        productImageMapper.deleteByPrimaryKey(id);
    }
```


## 3.3 产品属性修改


### 3.3.1 产品属性值的增加

产品属性值： 就是产品属性信息，随便修改的
[![产品属性值.jpg](https://i.loli.net/2018/09/28/5badaa71a94c5.jpg)](https://i.loli.net/2018/09/28/5badaa71a94c5.jpg)

这里需要跳转的过程比较多，因为产品属性值有2个外键。
根据外键来进行业务的来往 ，没有外键关联是无法进行数据相互查询传递的。

关键点在于：
**规则是===》分类管理产品属性**
产品属性值的2个外键， 在初始化的时候，外键是没有值的，需要赋值
而且产品属性值是作为产品的公共类处理的

**思路：**
 1 修改产品属性值需要确认这个值是否关联了**产品和属性，2个类**。此外，第一次点击编辑是没有产品属性值的，**因为此时属性值还没有和2个类进行关联**，所以需要初始化。
 2 需要将产品属性，产品2个类与产品属性值关联在一起，这个关联关键点在于外键。在初始化方法中**，查询得到产品，又根据产品的分类，查询得到同一个分类下的所有产品属性**，（规则是===》分类管理产品属性）
 这样2个类都得到了，然后产品属性值进行与2个外键关联与设置setter
 
3 产品属性值增加到数据库，完成增加OR修改。

4  完成属性值与属性关联后，根据外键，查询得到产品属性对象，然后属性值进行设置产品属性

**外键关联：**

[![表与表之间外键的联系.jpg](https://i.loli.net/2018/09/27/5bac58ba84f7e.jpg)](https://i.loli.net/2018/09/27/5bac58ba84f7e.jpg)

**业务层上方法的调用与外键的关系：**

[![业务层与外键的关联.jpg](https://i.loli.net/2018/09/28/5bada340af17a.jpg)](https://i.loli.net/2018/09/28/5bada340af17a.jpg)

产品属性值是产品基本信息的拓展，可以修改，但是不能删除，为什么？ 
技术上可以用级联实现删除功能，但是怕错误操作，就没有实现。


通过产品管理界面的设置属性，跳到编辑页面
JSP：
```
<td><a href="admin_propertyValue_edit?pid=${productList.id}"><span class="glyphicon glyphicon-list"></span></a> </td>
```

PropertyValueController：
调用PropertyValueController的edit方法：
     1. 根据pid获取product对象，因为面包屑导航里需要显示产品的名称和分类的连接。
     2. 初始化属性值： propertyValueService.init(p)。 因为在第一次访问的时候，这些属性值是不存在的，需要进行初始化。
     3. 根据产品，获取其对应的属性值集合。
     4. 服务端跳转到editPropertyValue.jsp 上
     5. 在editPropertyValue.jsp上，用c:forEach遍历出这些属性值
```
    @RequestMapping("admin_propertyValue_edit")
    public String edit(Model model, int pid) {
        Product product = productService.get(pid);

        /*增加产品属性值*/
        propertyValueService.init(product);
        List<PropertyValue> propertyValues = propertyValueService.list(product.getId());

        model.addAttribute("product", product);
        model.addAttribute("propertyValues", propertyValues);
        return "admin/editPropertyValues";
    }
```


productServiceIMP:
```
    @Override
    public Product get(int id) {
        Product product = productMapper.selectByPrimaryKey(id);
        setCategory(product);
        setFirstProductImage(product);
        return product;
    }
```

**ProertyValueServiceIMP:**
3 init方法
         3.1 这个方法的作用是初始化PropertyValue。 为什么要初始化呢？
     因为对于PropertyValue的管理，没有增加，只有修改。 所以需要通过初始化来进行自动地增加，以便于后面的修改。
         3.2 首先根据产品获取分类，然后获取这个分类下的所有属性集合
         3.3 然后用属性和id产品id去查询，看看这个属性和这个产品，是否已经存在属性值了。
         3.4 如果不存在，那么就创建一个属性值，并设置其属性和产品，接着插入到数据库中。
         这样就完成了属性值的初始化。
```
    @Override
    public void init(Product product) {
        //首先根据产品获取分类，然后获取这个分类下的所有属性集合
        List<Property> properties = propertyService.list(product.getCid());
        for (Property property : properties) {
        //然后用属性和id产品id去查询，看看这个属性和这个产品，是否已经存在属性值了。
            PropertyValue propertyValue = get(property.getId(), product.getId());
            //如果不存在，那么就创建一个属性值，并设置其属性和产品，接着插入到数据库中。
            //这样就完成了属性值的初始化。
            if (null == propertyValue) {
                propertyValue = new PropertyValue();
                propertyValue.setPid(product.getId());
                propertyValue.setPtid(property.getId());
                propertyValueMapper.insert(propertyValue);
            }
        }
    }
    
    //根据属性id和产品id获取PropertyValue对象
    @Override
    public PropertyValue get(int ptid, int pid) {
        PropertyValueExample propertyValueExample = new PropertyValueExample();
        propertyValueExample.createCriteria()
                .andPtidEqualTo(ptid)
                .andPidEqualTo(pid);

        List<PropertyValue> propertyValues = propertyValueMapper.selectByExample(propertyValueExample);
        if (propertyValues.isEmpty()) {
            return null;
        }
        return propertyValues.get(0);
    }
```

propertyServiceIMP:
```
    public List<Property> list(int cid) {
        PropertyExample propertyExample = new PropertyExample();
        propertyExample.createCriteria().andCidEqualTo(cid);
        propertyExample.setOrderByClause("id desc");
        return propertyMapper.selectByExample(propertyExample);
    }
```



### 3.3.2 产品属性值的更新
思路：
修改功能采用的是使用post方式提交ajax的异步调用方式

     1. 监听输入框上的keyup事件
     2. 获取输入框里的值
     3. 获取输入框上的自定义属性pvid，这就是当前PropertyValue对应的id
     4. 把边框的颜色修改为黄色，表示正在修改的意思
     5. 借助JQuery的ajax函数 $.post，把id和值，提交到admin_propertyValue_update
     6. admin_propertyValue_update导致PropertyValueController的update方法被调用
     6.1 参数 PropertyValue 获取浏览器Ajax方式提交的参数
     6.2 通过 propertyValueService.update(propertyValue) 更新到数据库
     6.3 结合方法update上的注解@ResponseBody和return "success" 就会向浏览器返回字符串 "success"
     6.4 propertyValueService调用的是propertValueMapper.updateByPrimaryKeySelective(pv); 这个方法只会更新propertyValue存在的字段，而参数PropertyValue只有id和value有值，所以即便这个PropertyValue对象没有pid和ptid值，修改的时候也不会影响该PropertyValue的pid和ptid。
     7 浏览器判断如果返回值是"success",那么就把边框设置为绿色，表示修改成功，否则设置为红色，表示修改失败

在editPropertyValueJsp:
script:异步调用
```
<script>
    /*对分类名称做了为空判断，当为空的时候，不能提交*/
    $(function () {
        $("input.pvValue").keyup(function(){
            var value = $(this).val();
            var page = "admin_propertyValue_update";
            var pvid = $(this).attr("pvid");
            var parentSpan = $(this).parent("span");
            parentSpan.css("border","1px solid yellow");
            $.post(
                page,
                {"value":value,"id":pvid},
                function(result){
                    if("success"==result)
                        parentSpan.css("border","1px solid green");
                    else
                        parentSpan.css("border","1px solid red");
                }
            );
        });
    });
</script>
```

PropertyValueController:
```
    @RequestMapping("admin_propertyValue_update")
    @ResponseBody
    public String update(PropertyValue propertyValue) {
        propertyValueService.update(propertyValue);
        return "success";
    }
```

PropertyValueServiceIMP：
```
@Override
    public void update(PropertyValue propertyValue) {
        propertyValueMapper.updateByPrimaryKeySelective(propertyValue);
    }
```


## 3.4 产品信息修改

记住 修改是一定要拿修改对象的啊

产品信息修改，这里只是对产品的名称，小标题，价格···进行更新

###获得修改对象：
-------

在listProductjsp：

```
<td><a href="admin_product_edit?id=${productList.id}"><span class="glyphicon glyphicon-list"></span></a> </td>
```

ProductController:
```
    @RequestMapping("admin_product_edit")
    public String edit(int id, Model model) {
        Product product = productService.get(id);

        Category category = categoryService.get(product.getCid());
        product.setCategory(category);

        model.addAttribute("product", product);
        return "admin/editProduct";
    }
```

###正式更新对象
------
editProductjsp:
记得隐藏产品Id 和外键cid

    <input  type="hidden" name="id" value="${product.id}">
<input  type="hidden" name="cid" value="${product.category.id}">


表单代码
```
 <form method="post" id="editForm" action="admin_product_update" enctype="multipart/form-data">
                <table class="editTable">
                    <tr>
                        <td>产品名称</td>
                        <td><input  id="name" name="name" value="${product.name}" type="text" class="form-control"></td>
                    </tr>
                    <tr>
                        <td>产品小标题</td>
                        <td><input  id="subTitle" name="subTitle" value="${product.subTitle}" type="text" class="form-control"></td>
                    </tr>
                    <tr>
                        <td>原价格</td>
                        <td><input  id="originalPrice" name="originalPrice" value="${product.originalPrice}" type="text" class="form-control"></td>
                    </tr>
                    <tr>
                        <td>优惠价格</td>
                        <td><input  id="promotePrice" name="promotePrice" value="${product.promotePrice}" type="text" class="form-control"></td>
                    </tr>
                    <tr>
                        <td>库存</td>
                        <td><input  id="stock" name="stock" value="${product.stock}" type="text" class="form-control"></td>
                    </tr>
                    <tr class="submitTR">
                        <td colspan="2" align="center">
                            <input  type="hidden" name="id" value="${product.id}">
                            <input  type="hidden" name="cid" value="${product.category.id}">
                            <button type="submit" class="btn btn-success">提 交</button>
                        </td>
                    </tr>
                </table>
            </form>
```

ProductController:

```
    @RequestMapping("admin_product_update")
    public String update(Product product) {
        productService.update(product);
        return "redirect:/admin_product_list?cid=" + product.getCid();
    }
```

ProductServiceIMP:

```
@Override
    public void update(Product product) {
        productMapper.updateByPrimaryKeySelective(product);
    }
```

## 3.5 产品删除

是要将 产品图片删除完，才可以删除产品，没有实现级联删除嘛，有外键是不能删除的。


在listProduct.jsp:

```
<td><a href="admin_product_delete?id=${productList.id}" deleteLink="true"><span class="glyphicon glyphicon-trash"></span></a> </td>
```

ProductController:

```
    @RequestMapping("admin_product_delete")
    public String delete(int id) {
        Product product = productService.get(id);

        productService.delete(id);
        return "redirect:/admin_product_list?cid=" + product.getCid();
    }
```
ProductServiceIMP:

```
    @Override
    public void delete(int id) {
        productMapper.deleteByPrimaryKey(id);
    }
```









	2018-09-28 13:35:27
kumika	天猫实战SSM---后台实现功能4	#天猫实战SSM---后台实现功能4


# 1 用户管理

用户只有查看功能而已

在adminNavigatory.jsp上：
```
<a class="navbar-brand" href="admin_user_list">用户管理</a>
```

UserController:
```
    @RequestMapping("admin_user_list")
    public String list(Model model, Page page) {
        List<User> users = userService.list();

        PageHelper.offsetPage(page.getStart(), page.getCount());
        int total = (int) new PageInfo(users).getTotal();
        page.setTotal(total);


        model.addAttribute("users", users);
        model.addAttribute("page", page);

        return "admin/listUser";
    }
}
```


UserServiceIMP:

```
    @Override
    public List<User> list() {
        UserExample userExample = new UserExample();
        userExample.setOrderByClause("id desc");

        return userMapper.selectByExample(userExample);
    }
```


# 2 订单管理

订单管理有2个功能：
![后台订单管理.jpg](https://i.loli.net/2018/09/28/5badbf5ab88ae.jpg)


外键关系：
![表格外键关系.jpg](https://i.loli.net/2018/09/28/5bae0bc138cd7.jpg)


完成后的业务层与外键关系
[![订单项的内容与外键关系.jpg](https://i.loli.net/2018/09/28/5bae0eb4c9bed.jpg)](https://i.loli.net/2018/09/28/5bae0eb4c9bed.jpg)



## 2.1 订单查看
在adminNavigatory.jsp上：
```
<a class="navbar-brand" href="admin_order_list">订单管理</a>
```

OrderController:
fill(Order order) :
     为什么要提供这个方法呢？ 因为在订单管理界面，首先是遍历多个订单，然后遍历这个订单下的多个订单项。
     而由MybatisGenerator逆向工程所创建的一套自动生成代码，是不具备一对多关系的，需要自己去二次开发。
     这里就是做订单与订单项的一对多关系。
```
    @RequestMapping("admin_order_list")
    public String list(Model model, Page page) {
        //1. 获取分页对象
        PageHelper.offsetPage(page.getStart(), page.getCount());
        //2. 查询订单集合
        List<Order> orders = orderService.list();
        //3. 获取订单总数并设置在分页对象上
        int total = (int) new PageInfo().getTotal();

        page.setTotal(total);
        //4. 借助orderItemService.fill()方法为这些订单填充上orderItems信息
        orderItemService.fill(orders);
        //5把订单集合和分页对象设置在model上
        model.addAttribute("orders", orders);
        model.addAttribute("page", page);
        //6. 服务端跳转到admin/listOrder.jsp页面
        //7. 在listOrder.jsp借助c:forEach把订单集合遍历出来
        //8. 遍历订单的时候，再把当前订单的orderItem订单项集合遍历出来
        return "admin/listOrder";
    }
```


OrderServiceIMP:
查询订单集合同时给订单设置用户属性（自己增加的用户属性）
```
    @Override
    public List<Order> list() {
        OrderExample orderExample = new OrderExample();
        orderExample.setOrderByClause("id desc");

        List<Order> orders = orderMapper.selectByExample(orderExample);
        setUser(orders);

        return orders;
    }
    
    public void setUser(List<Order> orders) {
        for (Order order : orders) {
            setUser(order);
        }
    }

    public void setUser(Order order) {
        int uid = order.getUid();
        User user = userService.get(uid);
        order.setUser(user);
    }
```




OrderItemServiceIMP：


 在fill(Order order)中
     1. 根据订单id查询出其对应的所有订单项
     2. 通过setProduct为所有的订单项设置Product属性
     3. 遍历所有的订单项，然后计算出该订单的总金额和总数量
    
    for (OrderItem orderItem : orderItems) {
            total += orderItem.getNumber() * orderItem.getProduct().getPromotePrice();
            totalNumber += orderItem.getNumber();
        }


4 最后再把订单项设置在订单的orderItems属性上。
```
public void fill(Order order) {
        OrderItemExample orderItemExample = new OrderItemExample();
        orderItemExample.createCriteria().andOidEqualTo(order.getId());
        orderItemExample.setOrderByClause("id desc");
        //1. 根据订单id查询出其对应的所有订单项
        List<OrderItem> orderItems = orderItemMapper.selectByExample(orderItemExample);
        //2. 通过setProduct为所有的订单项设置Product属性
        setProduct(orderItems);

        float total = 0;
        int totalNumber = 0;
        //3. 遍历所有的订单项，然后计算出该订单的总金额和总数量
        for (OrderItem orderItem : orderItems) {
            total += orderItem.getNumber() * orderItem.getProduct().getPromotePrice();
            totalNumber += orderItem.getNumber();
        }

        //4. 最后再把订单项设置在订单的orderItems属性上。
        order.setTotal(total);
        order.setTotalNumber(totalNumber);
        order.setOrderItems(orderItems);
    }
    
    public void setProduct(List<OrderItem> orderItems) {
        for (OrderItem orderItem : orderItems) {
            setProduct(orderItem);
        }
    }

    //已知订单项pid，要设置产品，根据pid查找到产品，然后设置产品
    public void setProduct(OrderItem orderItem) {
        Product product = productService.get(orderItem.getPid());
        orderItem.setProduct(product);
    }
```




## 2.2 发货操作

思路：
当订单状态是waitDelivery的时候，就会出现发货按钮
     1. 发货按钮链接跳转到admin_order_delivery
     2. OrderController.delivery()方法被调用
     2.1 注入订单对象
     2.2 修改发货时间，设置发货状态
     2.3 更新到数据库
     2.4 客户端跳转到admin_order_list页面

在ListOrder.jsp上：

```
<c:if test="${orders.status=='waitDelivery'}">
    <a href="admin_order_delivery?id=${orders.id}">
        <button class="btn btn-primary btn-xs">发货</button>
    </a>
</c:if>
```



在Order类上增加一个方法

```
 /*提供了一个getStatusDesc方法，用于把英文表达的Status信息转换为中文：*/

    public String getStatusDesc() {
        String desc = "未知";
        switch (status) {
            case OrderService.waitPay:
                desc = "待付款";
                break;
            case OrderService.waitDelivery:
                desc = "待发货";
                break;
            case OrderService.waitConfirm:
                desc = "待收货";
                break;
            case OrderService.waitReview:
                desc = "待评价";
                break;
            case OrderService.finish:
                desc = "完成";
                break;
            case OrderService.delete:
                desc = "删除";
                break;
            default:
                desc = "未知";
        }
        return desc;
    }
```



OrderController:
```
@RequestMapping("admin_order_delivery")
    //2.1 注入订单对象order,   注入我可以理解为调用参数
    public String delivery(Order order) {
        //2.2 修改发货时间，设置发货状态
        order.setDeliveryDate(new Date());
        order.setStatus(OrderService.waitConfirm);
        //2.3 更新到数据库
        orderService.update(order);
        return "redirect:admin_order_list";
    }
```
waitCongfirm是orderService的属性

```
public interface OrderService {
    String waitPay = "waitPay";
    String waitDelivery = "waitDelivery";
    String waitConfirm = "waitConfirm";
    String waitReview = "waitReview";
    String finish = "finish";
    String delete = "delete";
    }
```


OrderServiceIMP:

```
 @Override
    public void update(Order order) {
        orderMapper.updateByPrimaryKeySelective(order);
    }
```

	2018-09-28 13:36:58
kumika	实战天猫SSM---前端实现功能 1	"#实战天猫SSM---前端实现功能 1 

把前台功能分为两部分 
1. 无需登录 
有一些功能，无需登录也可以使用的，比如登录，注册本身，分类页面，查询，产品页面等 
2. 需要登录 
有一些功能，必须建立在已经登录的基础之上，比如购买，加入购物车，查看购物车，结算页面，订单页面等等。




# 1 无登录部分

游客随意浏览，没有权限限制

#注册：

`registerPage.jsp` 的form提交数据到路径 foreregister,导致`ForeController.register()`方法被调用

registerPage.jsp
```
<form method="post" action="foreRegister" class="registerForm">
```

控制层：
----

[![用户注册.jpg](https://i.loli.net/2018/10/30/5bd81b8b70931.jpg)](https://i.loli.net/2018/10/30/5bd81b8b70931.jpg)

ForeController：
思路：
    **1 注入方法参数，参数就是表单提交上来的用户对象user,里面包含用户名和密码
    2 进行数据库的查询用户名是否存在
        2.1 在service里查询用户名，看返回的集合是否为空
        2.2 集合为空就说明可以注册
    3 不存在的就通过，向数据库增加user
    4 存在的就返回到注册页面**

代码：
```
    @RequestMapping("foreRegister")
    public String register(Model model, User user) {
        String name = user.getName();
        /*
        为什么要用 HtmlUtils.htmlEscape？
        因为有些同学在恶意注册的时候，会使用诸如 <script>alert('papapa')</script> 这样的名称，
        会导致网页打开就弹出一个对话框。 那么在转义之后，就没有这个问题了。
        */
        name = HtmlUtils.htmlEscape(name);

        user.setName(name);
        boolean exist = userService.isExist(name);

        if (exist) {
            String msg = "用户名已经被使用,不能使用";
            model.addAttribute("msg", msg);
            /*
                model.addAttribute("user", null); 这句话的用处是当用户存在，
                服务端跳转到register.jsp的时候不带上参数user,
                否则当注册失败的时候，会在原本是“请登录”的超链位置显示刚才注册的名称
            */
            model.addAttribute("user", null);
            return "fore/register";
        }
        
        // 3 不存在的就通过，向数据库增加user
        userService.add(user);
        return "redirect:registerSuccessPage";
    }
```

业务层：
----

UserServiceIMP:

判断是否存在相同的用户名
思路：
    1 先查询出集合
    2 然后判断集合是否为空

```
    public boolean isExist(String name) {
        UserExample userExample = new UserExample();
        userExample.createCriteria().andNameEqualTo(name);

        List<User> result = userMapper.selectByExample(userExample);

        if (!result.isEmpty())
        return true;

        return false;
    }
    
   public void add(User user) {
        userMapper.insert(user);
    }
```




# 登录

登陆业务页面，用于向服务器提交账号和密码

`loginPage.jsp`的form提交数据到路径 forelogin,导致`ForeController.login()`方法被调用

loginPage.jsp：

```
<form method="post" class="loginForm" action="forelogin">
```


控制层：
----

ForeController:

[![用户登录.jpg](https://i.loli.net/2018/10/30/5bd81b8b82a35.jpg)](https://i.loli.net/2018/10/30/5bd81b8b82a35.jpg)

思路：
    **1 注入表单上提交的用户名和密码
    2 根据账号和密码查询用户User对象
    3 判断用户对象是否为空，空就返回登录页面
    4 不为空就增加model的attribute,然后跳转到首页**

自己用过有一种是参数是user的，这里不用参数user是因为直接用表单上的参数name,password可以减少方法里面的变量。

代码：
```
    @RequestMapping("forelogin")
    public String login(@RequestParam("name") String name, @RequestParam("password") String password,
                        Model model, HttpSession session) {
        name = HtmlUtils.htmlEscape(name, "UTF-8");
        User user = userService.get(name, password);

        if (null == user) {
            model.addAttribute("msg", "账号密码错误");
            return "fore/login";
        }
        session.setAttribute("user", user);
        return "redirect:forehome";
    }
```


业务层：
----

UserServiceIMP：

根据账号和密码进行查询用户对象

思路：
    1 使用myBaits的自带方法进行查询，自带参数判断的。
    2 查询完了，进行是否为空的判断
    3 空的返回Null，不为空就返回对象


代码：
```
    public User get(String name, String password) {
        UserExample userExample = new UserExample();
        userExample.createCriteria()
                .andNameEqualTo(name)
                .andPasswordEqualTo(password);
        List<User> users = userMapper.selectByExample(userExample);

        if (users.isEmpty()) {
            return null;
        }
        return users.get(0);
    }
```



#退出


TOP.jsp

```
<a href="forelogout">退出</a>
```

控制层：
----

ForeController:

[![用户退出.jpg](https://i.loli.net/2018/10/30/5bd81b8b89449.jpg)](https://i.loli.net/2018/10/30/5bd81b8b89449.jpg)

思路：
     直接在session里删除attribute就可以了
     然后返回首页

**重点： session上删除attribute里的User**

```
@RequestMapping("forelogout")
    public String forelogout(HttpSession session) {
        session.removeAttribute("user");
        return "redirect:forehome";
    }
```


# 首页

首页是随意浏览的，只需要查询产品，分类，图片OK了，至于返回的时候需要什么对象，这是要看你的页面需要展示什么了。

现在这个项目的首页需要展示的是产品和分类，作者现在为了方便点，把产品增加作为分类的属性，到时候页面调用产品也方便点。也因为这样，产品的属性赋值会导致业务层的调用方法比较多，留心注意逻辑关系。


首页具体 是分成5个页面组成的
---------------

```
<%@include file="../include/fore/header.jsp"%>
<%@include file="../include/fore/top.jsp"%>
<%@include file="../include/fore/search.jsp"%>
<%@include file="../include/fore/home/homePage.jsp"%>
<%@include file="../include/fore/footTotal.jsp"%>
```

**重点是homePage.jsp**
homePage.jsp是分成2个页面组成`categoryAndcarousel`是页面轮播部分，`homepageCategoryProducts`是展示产品部分

```
	<%@include file="categoryAndcarousel.jsp"%>
	<%@include file="homepageCategoryProducts.jsp"%>	
```

其中`categoryAndcarousel`是分成3个页面组成

```
<div style="position: relative">
	<%@include file="categoryMenu.jsp" %>
</div>

<div style="position: relative;left: 0;top: 0;">
	<%@include file="productsAsideCategorys.jsp" %>
</div>
<%@include file="carousel.jsp" %>
```

那个流程图看看：
[![home首页.jpg](https://i.loli.net/2018/10/06/5bb8151334115.jpg)](https://i.loli.net/2018/10/06/5bb8151334115.jpg)


控制层：
----

开始做项目，是不可能一步到位，做完这么多东西的，所以首页可以方法空着，后面具体用到的时候具体实现。比如产品图片，分类·····

ForeController:

首页是查询所有分类，展示所有产品。
查询分类，产品，产品属性的逻辑关系：
分类 包含 产品
产品 包含 各种属性
各种属性  在业务层 调用  各种方法


思路：
（给分类新增属性--产品集合，给产品新增属性--图片和分类）
1 查询所有分类集合
2 **对分类集合里的分类的产品集合里的产品进行赋值**，产品如果有属性，则也要赋值
2.1  根据分类集合里的分类元素查询产品集合
2.2  查询产品集合方法中查询产品图片，给产品赋值分类属性

[![额瑞.jpg](https://i.loli.net/2018/10/06/5bb848b596183.jpg)](https://i.loli.net/2018/10/06/5bb848b596183.jpg)

3 为这些分类填充推荐产品集合
3.1 分类行里填充产品行（产品8个作为一个集合，分类行是红框，产品集合是蓝框）
[![宝蓝.jpg](https://i.loli.net/2018/10/06/5bb84a3f70bc6.jpg)](https://i.loli.net/2018/10/06/5bb84a3f70bc6.jpg)



4 跳转到Home.jsp


**注意：**
查询返回的分类对象，只有Id 和name有值， ，自己增加的属性productList,和productByRow是null的，因为表的字段只有Id和name，在pojo类增加属性是不能增加到表字段的

下面是解释竖状导航的分类行数问题：
     productsByRow这个属性的类型是`List<List<Product>> productsByRow`。
     即一个分类又对应多个 List<Product>，提供这个属性，是为了在首页竖状导航的分类名称右边显示推荐产品列表。

     具体解释：一个分类会对应多行产品，而一行产品里又有多个产品记录。
     为了实现界面上的这个功能，为Category类设计了
     List<List<Product>> productsByRow
     这样一个集合属性
    

控制层代码：
------

```
    @RequestMapping("forehome")
    public String home(Model model) {
        //1. 查询所有分类，查询返回的分类对象，只有Id 和name有值，
        // 自己增加的属性productList,和productByRow是null的，
        // 因为表的字段只有Id和name，在pojo类增加属性是不能增加到表字段的
        List<Category> categoryList = categoryService.list();
        //2. 为这些分类填充产品集合
        productService.fill(categoryList);
        //3. 为这些分类填充推荐产品集合
        productService.fillByRow(categoryList);

        model.addAttribute("categories", categoryList);
        //4. 服务端跳转到home.jsp
        return "fore/home";
    }
```

业务层：
----
主要是使用mybaits的查询，没有自己写sql语句


CategoryServiceIMP ：
因为这只是单纯的查询分类，不细节了。
```
    public List<Category> list() {
        CategoryExample categoryExample = new CategoryExample();
        categoryExample.setOrderByClause("id desc");

        return categoryMapper.selectByExample(categoryExample);
    }
```


ProductServiceIMP:

主要实现竖状导航，对分类的产品属性进行赋值，然后对分类所在的行进行赋值===》一行装着8个产品的集合

和对产品的图片，分类属性进行查询，然后赋值

**查询返回的分类中自动生成的属性是有值的，而自己新增加的属性是没有值的，因为数据库表上没有新增的字段，所以这里要把自己新增的属性赋值。**


```
    public void fillByRow(List<Category> categoryList) {
        int productNumberEachRow = 8;
        //竖状导航分类，把一行行的产品填充到分类所在的行上，
        // 其实就是把那些产品增加到分类对象上，然后在页面上进行分行
        for (Category category : categoryList) {
            //根据分类查询到的产品进行排列成一行
            List<Product> productList = category.getProductList();
            //productByRow是分类所在的行
            List<List<Product>> productByRow = new ArrayList<>();
            //一行8个产品，现在是直接把8个做为一个整体行
            for (int i = 0; i<productList.size();i+=productNumberEachRow) {
                //确定一行多少个产品
                int size = i + productNumberEachRow;
                size = size > productList.size() ? productList.size() : size;
                //把8个做为一个整体行，超过8个则余下的是作为下个循环进行放入
                List<Product> productsOfEachRow = productList.subList(i, size);
                //拥有8个产品的一个整行放在分类所在的行
                productByRow.add(productsOfEachRow);
            }
            //增加该分类的导航产品行
            category.setProductsByRow(productByRow);
        }
    }
    
    /**
     * 为多个分类填充产品集合
     * @param categoryList
     */
    @Override
    public void fill(List<Category> categoryList) {
        for (Category category : categoryList) {
            fill(category);
        }
    }

    /**
     * 为分类填充产品集合
     * @param category
     */
    public void fill(Category category) {
        List<Product> productList = list(category.getId());
        category.setProductList(productList);
    }
    
    @Override
    public List<Product> list(int cid) {
        ProductExample productExample = new ProductExample();
        productExample.createCriteria().andCidEqualTo(cid);
        productExample.setOrderByClause("id desc");
        List<Product> productList =  productMapper.selectByExample(productExample);
        setFirstProductImage(productList);
        setCategory(productList);

        return productList;
    }

    public void setCategory(List<Product> productList) {
        for (Product pro : productList) {
            setCategory(pro);
        }
    }

    public void setCategory(Product product) {
        int cid = product.getCid();
        Category category = categoryService.get(cid);
        product.setCategory(category);
    }

    public void setFirstProductImage(List<Product> product) {
        for (Product pro : product) {
            setFirstProductImage(pro);
        }
    }
    
//根据产品的id ,图片的类型进行查询返回图片，然后产品setImage
    @Override
    public void setFirstProductImage(Product product) {
        List<ProductImage> productImageList = productImageService.list(product.getId(), ProductImageService.type_single);
        if (!productImageList.isEmpty()) {
            ProductImage productImage = productImageList.get(0);
            product.setFirstProductImage(productImage);
        }
    }
```


图片ProductImageServiceIMP:

```
    @Override
    public List<ProductImage> list(int pid, String type) {
        ProductImageExample productImageExample = new ProductImageExample();
        productImageExample.createCriteria()
                .andPidEqualTo(pid)
                .andTypeEqualTo(type);
        productImageExample.setOrderByClause("id desc");

        return productImageMapper.selectByExample(productImageExample);
    }
```


"	2018-09-28 19:41:27
kumika	实战天猫SSM---前端实现功能 3	#实战天猫SSM---前端实现功能 3 


需要登录的前台功能，这些功能都是和购买支付流程息息相关的，所以我们先把购买的业务流程捋一捋

接着再把购物流程各个环节与表关系搞清楚，这个开发人员必须明白的部分，这个部分稀里糊涂，后面做出来的功能就会越来越乱


#  登录部分

# 1 购买的业务流程

1. 登录
2. 访问产品页
3. 立即购买
4. 进入结算页面
5. 加入购物车
6. 查看购物车
7. 选中购物车中的商品
8. 又到了第4步的结算页面
9. 在结算页面生成订单
10. 付款
11. 确认收货
12. 评价

[![购物过程.jpg](https://i.loli.net/2018/09/30/5bb0419a163ec.jpg)]((https://i.loli.net/2018/09/30/5bb0419a163ec.jpg)



# 2 购物流程环节与表关系


围绕购物流程最重要的两个表是OrderItem 和 Order表

**<h2>OrderItem 订单项=只装一种产品的购物车</h2>**

关于OrderItem的业务行为
1. 立即购买 —— 新增 OrderItem
2. 加入购物车 —— 新增 OrderItem
3. 查看购物车 —— 显示未和Order关联的OrderItem
4. 选中购物车中的商品 —— 选中OrderItem
5. 结算页面 —— 显示选中的OrderItem

6. 生成订单 —— 新增Order
7 .付款 —— 修改Order状态
8. 我的订单 —— 显示Order
9. 确认收货 —— 修改Order状态


[![购物流程环节与表关系.jpg](https://i.loli.net/2018/09/30/5bb04550a2e16.jpg)](https://i.loli.net/2018/09/30/5bb04550a2e16.jpg)



#功能实现：

# 1 立即购买

购物流程：

使用jquery方法，判断页面当前用户状态，是否登录，然后监听点击购物按钮，产品数量。
验证完成后， 拿到产品数量，把数量增加到href后面。
重点是下面这2句：
```
var num = $(".productNumberSetting").val();
location.href= $(".buyLink").attr("href")+"&num="+num;
```

完整的script:
```
$(".buyLink").click(function(){
            var page = "forecheckLogin";
            $.post(
                page,
                function(result){
                    if("success"==result){
                        var num = $(".productNumberSetting").val();
                        location.href= $(".buyLink").attr("href")+"&num="+num;
                    }
                    else{
                        $("#loginModal").modal('show');
                    }
                }
            );
            return false;
        });
```

**购买语句：**
```
<a href="forebuyone?pid=${product.id}" class="buyLink"><button class="buyButton">立即购买</button> </a>
```


点击购买所产生的动作是，OrderItem表里插入一条数据， 
该数据内容：
1. pid =844 购买的商品id
2. oid = null, 这个订单项还没有生成对应的订单，即还在购物车中
3. uid= 3，用户的id是3
4. number=3, 购买了3件产品


控制层：
----

**ForeController：**
思路：

[![立即购买.jpg](https://i.loli.net/2018/10/30/5bd821cde4d6b.jpg)](https://i.loli.net/2018/10/30/5bd821cde4d6b.jpg)

访问的地址 /forebuyone 导致ForeController.buyone()方法被调用
1. 获取参数pid
2. 获取参数num
3. 根据pid获取产品对象p
4. 从session中获取用户对象user

接下来就是新增订单项OrderItem， 新增订单项要考虑**两个情况**

    a. 如果已经存在这个产品对应的OrderItem，并且还没有生成订单，即还在购物车中。 那么就应该在对应的OrderItem基础上，调整数量
    a.1 基于用户对象user，查询没有生成订单的订单项集合
    a.2 遍历这个集合
    a.3 如果产品是一样的话，就进行数量追加
    a.4 获取这个订单项的 id

    b. 如果不存在对应的OrderItem,那么就新增一个订单项OrderItem
    b.1 生成新的订单项
    b.2 设置数量，用户和产品
    b.3 插入到数据库
    b.4 获取这个订单项的 id

最后， 基于这个订单项id客户端跳转到结算页面/forebuy

代码：
```
    @RequestMapping("forebuyone")
    public String buyone(int pid, int num, HttpSession session) {
        //3. 根据pid获取产品对象p
        Product product = productService.get(pid);
        int oiid = 0;
        //4. 从session中获取用户对象user
        User user = (User) session.getAttribute("user");
        //作为判断存在订单项的标准。（常规想法，引入新的变量，来表述一个物体的状态
        boolean found = false;
        //根据user的id查询订单，
        // 这里订单和购物车，我没有理解好。
        // 正确理解是：订单和购物车，订单里面包含多个订单项，
        // 订单项=只装一种产品的购物车，订单项在结算的时候才增加到订单上，单纯的创建订单项=拿到购物车
        // 产品放进购物车就是产品增加到订单项上
        // 在结算的时候有2种情况：
        // 1 要是购买的产品没有存在在购物车上，则需要新建一个订单项对象，增加产品
        // 2 购买的产品存在在购物车上，则订单项上对应产品的数量增加就可以了   **因为订单项 是只装一种产品的购物车**

        //a.1 基于用户对象user，查询没有生成订单的订单项集合（订单项要是有订单外键oid的值，则说明该订单项结算过了
        List<OrderItem> orderItems = orderItemService.listByUser(user.getId());
        //a.2 遍历这个集合
        for (OrderItem orderItem : orderItems) {
            //订单项上产品和购买产品对比，判断购物车是否有相同产品，有的就增加购物车产品总数量
            if (orderItem.getProduct().getId().intValue() == product.getId().intValue()) {
                //增加购物车产品总数量
                orderItem.setNumber(orderItem.getNumber() + num);
                //更新订单项
                orderItemService.update(orderItem);
                found = true;
                //a.4 获取这个订单项的 id
                oiid = orderItem.getId();
                break;
            }
        }
        //b. 如果不存在对应的OrderItem,那么就新增一个订单项OrderItem，
        // 就是说明没有购物车，现在去拿购物车
        if (!found) {
            //b.1 生成新的订单项
            OrderItem orderItem = new OrderItem();
            //b.2 设置数量，用户和产品
            orderItem.setUid(user.getId());
            orderItem.setNumber(num);
            orderItem.setPid(pid);
            //b.3 插入到数据库
            orderItemService.add(orderItem);
            oiid = orderItem.getId();
        }
        //基于这个订单项id客户端跳转到结算页面/forebuy
        //就是拿着这个购物车去柜台
        return "redirect:forebuy?oiid=" + oiid;
    }
```

业务层：
----

 **OrderItemServiceIMP:**


```
    @Override
    public List<OrderItem> listByUser(Integer uid) {
        OrderItemExample orderItemExample = new OrderItemExample();
        //查询没有生成订单的订单项集合, 查询条件：订单字段null, 字段uid
        orderItemExample.createCriteria().andUidEqualTo(uid).andOidIsNull();
        List<OrderItem> result = orderItemMapper.selectByExample(orderItemExample);

        setProduct(result);

        return result;
    }

    @Override
    public void update(OrderItem orderItem) {
        orderItemMapper.updateByPrimaryKeySelective(orderItem);
    }

    @Override
    public void add(OrderItem orderItem) {
        orderItemMapper.insert(orderItem);
    }
```



# 结算商品


因为点击立即购买后，跳转到这里调用`ForeController.buy()`方法


控制层：
----

[![结算方法.jpg](https://i.loli.net/2018/10/30/5bd826043eecb.jpg)](https://i.loli.net/2018/10/30/5bd826043eecb.jpg)

思路：
1. 通过字符串数组获取参数oiid（类似现实中可以拿多个购物车）

    为什么这里要用字符串数组试图获取多个oiid，而不是int类型仅仅获取一个oiid? 因为根据购物流程环节与表关系，结算页面还需要显示在购物车中选中的多条OrderItem数据，所以为了兼容从购物车页面跳转过来的需求，要用字符串数组获取多个oiid
2. 准备一个泛型是OrderItem的集合orderItems，**购物车集合就大概是订单了，只是缺少了用户地址，电话之类的**
3. 根据前面步骤获取的oiids，从数据库中取出OrderItem对象，并放入ois集合中
4. 计算每一个订单项的总价格，累计这些orderItems的价格总数，赋值在total上
5. 把订单项集合放在session的属性 "orderItems" 上
6. 把总价格放在 model的属性 "total" 上
7. 服务端跳转到付钱页面 buy.jsp


代码：
```
    @RequestMapping("forebuy")
    //1. 通过字符串数组获取参数oiid
    public String buy(Model model, String[] oiid, HttpSession session) {
        //2. 准备一个泛型是OrderItem的集合orderItems，这个就是订单了
        List<OrderItem> orderItems = new ArrayList<>();
        //总消费价格
        float total = 0;
        //3. 根据前面步骤获取的oiids，从数据库中取出OrderItem对象，并放入orderItems集合中
        for (String strid : oiid) {
            int id = Integer.parseInt(strid);
           //获得订单项
            OrderItem orderItem = orderItemService.get(id);
            //4. 累计这些orderItems的价格总数，赋值在total上
            //计算每一个订单项的消费价格，然后相加，得到总消费价格
            //产品的价格 X  订单项上的数量（一类产品就是一个订单项就是一个购物车）
            total += orderItem.getProduct().getPromotePrice() * orderItem.getNumber();
            //订单上增加订单项
            orderItems.add(orderItem);
        }
        //5. 把订单项集合放在session的属性 "orderItems" 上
        session.setAttribute("orderItems", orderItems);
        //6. 把总价格放在 model的属性 "total" 上
        model.addAttribute("total", total);
        return "fore/buy";
    }
```


业务层：
----

订单项的属性新增了产品属性，所以查询完后，记得要赋值。

OrderItemServiceIMP：

```
   public OrderItem get(int id) {
        OrderItem result = orderItemMapper.selectByPrimaryKey(id);

        setProduct(result);
        return result;
    }
    
    public void setProduct(List<OrderItem> orderItems) {
        for (OrderItem orderItem : orderItems) {
            setProduct(orderItem);
        }
    }
    
    //已知订单项pid，要设置产品，根据pid查找到产品，然后设置产品
    public void setProduct(OrderItem orderItem) {
        Product product = productService.get(orderItem.getPid());
        orderItem.setProduct(product);
    }
```


# 加入购物车


效果：  点击加入购物车（只能点击一次），这里和立即购买的区别在于返回的是success,立即购买返回的是跳转语句，跳转到结算页面。

使用jquery的异步ajax实现，监听加入购物车按钮
```
$(".addCartLink").click(function(){
            var page = "forecheckLogin";
            $.post(
                page,
                function(result){
                    if("success"==result){
                        var pid = ${product.id};
                        var num= $(".productNumberSetting").val();
                        var addCartpage = "foreaddCart";
                        $.post(
                            addCartpage,
                            {"pid":pid,"num":num},
                            function(result){
                                if("success"==result){
                                    $(".addCartButton").html("已加入购物车");
                                    $(".addCartButton").attr("disabled","disabled");
                                    $(".addCartButton").css("background-color","lightgray")
                                    $(".addCartButton").css("border-color","lightgray")
                                    $(".addCartButton").css("color","black")

                                }
                                else{

                                }
                            }
                        );
                    }
                    else{
                        $("#loginModal").modal('show');
                    }
                }
            );
            return false;
        });
```



控制层：
----

根据jquery异步ajax调用了foreAddCart， 所以在控制层上要增加`@ResponseBody`

[![加入购物车.jpg](https://i.loli.net/2018/10/30/5bd8262b879c4.jpg)](https://i.loli.net/2018/10/30/5bd8262b879c4.jpg)

思路：
1  获得产品id 和产品数量num
    根据产品id查找到产品，用于和订单项进行判断是否单子里面有相同产品
2  根据用户id查找到订单项集合

3  遍历订单项集合，这里订单项会有2种情况
3.1  判断产品和订单项里的产品是否一致，一致就更新订单项产品的总数量。

3.2  产品没有订单项，新建一个订单项，把当前用户id，产品，订单项产品的总数量增加到订单中

4 因为是异步ajax,所以返回success

```
@RequestMapping("foreaddCart")
@ResponseBody
public String addcart(HttpSession session , int pid , int num,Model model){
    boolean found = false;
    Product product = productService.get(pid);
    User user  = (User) session.getAttribute("user");
    List<OrderItem> orderItems = orderItemService.get(user.getId());
    
    for(OrderItem orderItem : orderItems){
        if(product.getId().intValue() == ordetItem.getProduct().getId().intValue()){
            ordetItem.setNum(orderItem.getNum() + num);
            orderItemService.update(orderItem);
            found = true;
            break;
        }
    }
    
    if(!found){
        OrderItem orderItem = new OrderItem();
        orderItem.setUid(user.getId());
        orderItem.setNum(num);
        orderItem.setPid(pid);
        orderItemService.add(orderItem);
    }
    return "success";
}
```


业务层：
----

OrderItemServiceIMP：
```
  public void update(OrderItem orderItem) {
        orderItemMapper.updateByPrimaryKeySelective(orderItem);
    }
    
  public void add(OrderItem orderItem) {
        orderItemMapper.insert(orderItem);
    }
```




# 查看购物车

页面上的跳转语句：

    <a href="forecart"/>



控制层：
----

[![查看购物车.jpg](https://i.loli.net/2018/10/30/5bd82647bc75c.jpg)](https://i.loli.net/2018/10/30/5bd82647bc75c.jpg)

调用了forecart()方法。 
思路：
  1 要检查用户状态，是否登录了，这里要用到后面说的登录状态拦截器
  2 session获取用户
  3 根据用户Id，查询订单项集合 
  4 把订单项集合放入model 中
  5 返回显示购物车页面cart

```
@RequestMapping("forecart")
public String cart(Model model ,HttpSession session){
    User user = (User) session.getAttribute("user");
    List<OrderItem> orderItems  =  orderItemService.listByUser(user.getId());
    model.addAttribute("orderItems",orderItems);
    return "fore/cart";
}
```

业务层：
----

OrderItemServiceIMP:

记得 **订单项 新增属性 ：产品** 

```
@Override
    public List<OrderItem> listByUser(Integer uid) {
        OrderItemExample orderItemExample = new OrderItemExample();
        //查询没有生成订单的订单项集合, 查询条件：订单字段null, 字段uid
        orderItemExample.createCriteria().andUidEqualTo(uid).andOidIsNull();
        List<OrderItem> result = orderItemMapper.selectByExample(orderItemExample);

        setProduct(result);

        return result;
    }
    
    public void setProduct(List<OrderItem> orderItems) {
        for (OrderItem orderItem : orderItems) {
            setProduct(orderItem);
        }
    }

    //已知订单项pid，要设置产品，根据pid查找到产品，然后设置产品
    public void setProduct(OrderItem orderItem) {
        Product product = productService.get(orderItem.getPid());
        orderItem.setProduct(product);
    }
```



# 登录状态拦截器

所以在查看购物车之前，应该进行登录操作，但是又不能确保用户一定会记得登录，那么怎么办呢？ 
准备一个过滤器，当访问那些需要登录才能做的页面的时候，**进行是否登录的判断，如果不通过，那么就跳转到login.jsp页面去，提示用户登录**。

哪些页面需要登录？哪些页面不需要呢？
**a. 不需要登录也可以访问的
如：注册，登录，产品，首页，分类，查询等等**

**b. 需要登录才能够访问的
如：购买行为，加入购物车行为，查看购物车，查看我的订单等等**



LoginInterceptor：
-----------------
**写了拦截器后，要在mvc上注册。**

[![登录拦截器.jpg](https://i.loli.net/2018/10/30/5bd8266ab3a76.jpg)](https://i.loli.net/2018/10/30/5bd8266ab3a76.jpg)


思路：

哪些页面需要登录？哪些页面不需要呢？

    a. 不需要登录也可以访问的
    如：注册，登录，产品，首页，分类，查询等等

    b. 需要登录才能够访问的
    如：购买行为，加入购物车行为，查看购物车，查看我的订单等等


**不需要登录也可以访问的已经确定**了，但是需要登录才能够访问，截止目前为止还不能确定，所以这个**过滤器就判断如果不是注册，登录，产品这些，就进行登录校验**


1 准备字符串数组NoNeedAuthPage，存放哪些不需要登录也能访问的路径
2 获取uri
3 去掉前缀/tmall_ssm
4 如果访问的地址是/fore开头
4.1 取出fore后面的字符串，比如是forecart,那么就取出cart
4.2 判断cart是否是在noNeedAuthPage,如果不在，那么就需要进行是否登录验证
4.3 从session中取出“user”对象
4.4 如果对象不存在，就客户端跳转到login.jsp上
4.5 否则就正常执行。

代码：
```
public class LoginInterceptor extends HandlerInterceptorAdapter {
    @Autowired
    CategoryService categoryService;
    @Autowired
    OrderItemService orderItemService;

    /**
     * 在业务处理器处理请求之前被调用
     * 如果返回false
     *     从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链
     * 如果返回true
     *    执行下一个拦截器,直到所有的拦截器都执行完毕
     *    再执行被拦截的Controller
     *    然后进入拦截器链,
     *    从最后一个拦截器往回执行所有的postHandle()
     *    接着再从最后一个拦截器往回执行所有的afterCompletion()
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException {

        HttpSession session = request.getSession();
        //得到servlet的上下文的路径： 就是项目名tmall_ssm
        String contextPath = session.getServletContext().getContextPath();
        //不需要登录就可以浏览的
        String[] noNeedAuthPage = new String[]{
                "home", "checkLogin", "Register", "loginAjax", "login", "product", "category", "search"
        };
        //返回包含工程名的当前页面全路径，eg:/XXXXX/course/index.jsp===》/course/index.jsp
        //但是这里就只单纯显示/course，没有显示后面的index.jsp，因为action就是/course嘛，没有带jsp
        String uri = request.getRequestURI();
        //3 去掉前缀/tmall_ssm
        uri = StringUtils.remove(uri, contextPath);
        //4 如果访问的地址是/fore开头。 判断uri是否是fore开头
        if (uri.startsWith("/fore")) {
            //4.1 取出fore后面的字符串，比如是forecart,那么就取出cart
            //对uri的开头/fore进行分割
            String method = StringUtils.substringAfterLast(uri, "/fore");
            //4.2 判断cart是否是在noNeedAuthPage,如果不在，那么就需要进行是否登录验证
            //当得到的字符method，不存在在noNeedAuthPage数组里面，则说明需要进行登录验证
            //数组里面都是不需要登录验证的字符。
            if (!Arrays.asList(noNeedAuthPage).contains(method)) {
                //4.3 从session中取出“user”对象
                User user = (User) session.getAttribute("user");
                if (null == user) {
                    //4.4 如果对象不存在，就客户端跳转到login.jsp上
                    response.sendRedirect("loginPage");
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * 在业务处理器处理请求执行完成后,生成视图之前执行的动作
     * 可在modelAndView中加入数据，比如当前时间
     */
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {

    }


    /**
     * 在DispatcherServlet完全处理完请求后被调用,可用于清理资源等
     * <p>
     * 当有拦截器抛出异常时,会从当前拦截器往回执行所有的拦截器的afterCompletion()
     */
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {

    }
}
```


springMVC:
----------
```
    <!--拦截器  对foreXXX进行拦截-->
    <mvc:interceptors>
        <mvc:interceptor>
            <mvc:mapping path="/fore*"/>
            <bean class="CCTV.Tmall.Interceptor.LoginInterceptor"/>
        </mvc:interceptor>


        <mvc:interceptor>
            <mvc:mapping path="/fore*"/>
            <bean class="CCTV.Tmall.Interceptor.OtherInterceptor"/>
        </mvc:interceptor>

    </mvc:interceptors>
```



# 其他拦截器


OtherInterceptor：
-----------------


```
public class OtherInterceptor extends HandlerInterceptorAdapter {

    @Autowired
    CategoryService categoryService;

    @Autowired
    OrderItemService orderItemService;


    /**
     * 在业务处理器处理请求之前被调用
     * 如果返回false
     * 从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链
     * 如果返回true
     * 执行下一个拦截器,直到所有的拦截器都执行完毕
     * 再执行被拦截的Controller
     * 然后进入拦截器链,
     * 从最后一个拦截器往回执行所有的postHandle()
     * 接着再从最后一个拦截器往回执行所有的afterCompletion()
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        return true;
    }

    /**
     * 在业务处理器处理请求执行完成后,生成视图之前执行的动作
     * 可在modelAndView中加入数据，比如当前时间
     */
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {

        /*这里是获取分类集合信息，用于放在搜索栏下面*/
        List<Category> categoryList = categoryService.list();
        request.getSession().setAttribute("categoryList", categoryList);


         /*这里是获取当前的contextPath:tmall_ssm,用与放在左上角那个变形金刚，
         点击之后才能够跳转到首页，否则点击之后也仅仅停留在当前页面*/
        HttpSession session = request.getSession();
        String contextPath = session.getServletContext().getContextPath();
        request.getSession().setAttribute("contextPath", contextPath);

        /*这里是获取购物车中一共有多少数量*/
        User user = (User) session.getAttribute("user");
        int cartTotalItemNumber = 0;
        if (null != user) {
            List<OrderItem> orderItems = orderItemService.listByUser(user.getId());
            for (OrderItem orderItem : orderItems) {
                cartTotalItemNumber += orderItem.getNumber();
            }
        }
        request.getSession().setAttribute("cartTotalItemNumber", cartTotalItemNumber);
    }


    /**
     * 在DispatcherServlet完全处理完请求后被调用,可用于清理资源等
     * <p>
     * 当有拦截器抛出异常时,会从当前拦截器往回执行所有的拦截器的afterCompletion()
     */
    public void afterCompletion(HttpServletResponse response, HttpServletRequest request, Object handler, Exception ex) {

    }
}
```

springMVC:
----------
```
    <!--拦截器  对foreXXX进行拦截-->
    <mvc:interceptors>
        <mvc:interceptor>
            <mvc:mapping path="/fore*"/>
            <bean class="CCTV.Tmall.Interceptor.LoginInterceptor"/>
        </mvc:interceptor>


        <mvc:interceptor>
            <mvc:mapping path="/fore*"/>
            <bean class="CCTV.Tmall.Interceptor.OtherInterceptor"/>
        </mvc:interceptor>

    </mvc:interceptors>
```




# 购物车页面操作

1 增加，减少某种产品的数量

2 删除某种产品

3 选中产品后，提交到结算页面

[![购物车操作.jpg](https://i.loli.net/2018/10/30/5bd8276c1a42b.jpg)](https://i.loli.net/2018/10/30/5bd8276c1a42b.jpg)


## 1 增加，减少某种产品的数量

点击增加或者减少按钮后，根据 cartPage.jsp 中的js代码，会通过Ajax访问/forechangeOrderItem路径，导致ForeController.changeOrderItem()方法被调用

script：
```
var page = "forechangeOrderItem";
        $.post(
            page,
            {"pid":pid,"number":num},
            function(result){
                if("success"!=result){
                    location.href="loginPage";
                }
            }
        );
```

###控制层：
----

思路：
1 判断用户是否登录（就是看User是否为空）
2 获得外键pid 和 产品数量num
3 根据user的id，查询没有加入订单的订单项集合

**4 根据pid 来判断订单项是否有相同的产品，有则更改数量后进行更新**
5 返回success

代码：
```
@RequestMapping("forechangeOrderItem")
@ResponseBody
public String changeNum(Model model, HttpSession session,int pid,int num){
    User user = (User) session.getAttribute("user");
    if(user == null) return "fail";
    
    List<OrderItem> orderItems = orderItemService.listByUser(user.getId());
    for(OrderItem orderItem : orderItems){
        if(pid == orderItem.getProduct.getPid()){
            ordetItem.setNum(num);
            orderItemService.update(orderItem);
            break;
        }
    }
    
    return "success";
}
```

###业务层：
----

OrderItemServiceIMP:
```
    public void update(OrderItem orderItem) {
        orderItemMapper.updateByPrimaryKeySelective(orderItem);
    }
```




## 2 删除订单项

点击删除按钮后，根据 `cartPage.jsp` 中的js代码，会通过Ajax访问`/foredeleteOrderItem`路径，导致`ForeController.deleteOrderItem`方法被调用


script：
```
var deleteOrderItem = false;

$("button.deleteConfirmButton").click(function(){
            deleteOrderItem = true;
            $("#deleteConfirmModal").modal('hide');
        });

if(deleteOrderItem){
                var page="foredeleteOrderItem";
                $.post(
                    page,
                    {"oiid":deleteOrderItemid},
                    function(result){
                        if("success"==result){
                            $("tr.cartProductItemTR[oiid="+deleteOrderItemid+"]").hide();
                        }
                        else{
                            location.href="loginPage";
                        }
                    }
                );
            }
```

jsp:
```
 <a href="#nowhere" oiid="${orderItem.id}" class="deleteOrderItem">删除</a>
```



###控制层：
----

思路：

1 判断用户是否登录（看user是否为空）

2 获取oiid
3 删除oiid对应的orderItem数据
4 返回字符串success

```
@RequestMapping("foredeleteOrderItem")
@ResponseBody
public String deleteOrderItem(HttpSession session,Model model,int oiid){
    User user = (User)session.getAttribute("user");
    if(user == null) return "fail";
    
    orderItemService.delete(oiid);

    return "success";
}
```


###业务层：
----

```
    public void delete(int oiid) {
        orderItemMapper.deleteByPrimaryKey(oiid);
    }
```



## 3 提交到结算页面

在选中了购物车中的任意商品之后，结算按钮呈现可点击状态。
点击之后，提交到结算页面，并**带上(多个)被选中的OrderItem对象的id**

例子：
```
 http://127.0.0.1:8080/tmall_ssm/forebuy?oiid=2&oiid=1&oiid=23
```
之后的流程就是**进入了结算页面的控制层上去了。**


	2018-09-30 01:17:49
kumika	实战天猫SSM---前端实现功能 2	#实战天猫SSM---前端实现功能 2 

# 具体单个产品页

产品的展示，需要产品图片，在页面上则需要一个集合好进行循环，不用一张张赋值，所以在product类上增加2个图片类型集合。


首页展示产品的页面：
```
<a href="foreproduct?pid=${p.id}"><img width="100px" src="img/ProductImage_middle/${p.firstProductImage.id}.jpg"></a>
```


跳转href的路径`foreproduct?pid=${p.id}`导致`ForeController.product()` 方法被调用

这里产品product，新增加了6个属性，
产品图片`firstProductImage`，
单个产品图片集合`productSingleImages`，
详情产品图片集合`productDetailImages`，
分类`category`，
累计评价`reviewCount`，
销量`saleCount`

评价对象review增加`user`属性

用户对象user增加一个显示匿名方法`getAnonymousName()`


方便页面进行展示产品。



**从首页的展示产品页面点击产品，触发跳转，调用ForeController的product()方法**

控制层：
----

[![单个产品页面.jpg](https://i.loli.net/2018/10/30/5bd81c4c16d4a.jpg)](https://i.loli.net/2018/10/30/5bd81c4c16d4a.jpg)


思路：

1 向方法注入 产品id 和模型
2 根据id获取产品
3 因为产品的新增属性值是null，所以需要自己赋值，根据产品id查找对应所有属性值

    3.1 查询产品图片集合，单个图片集合，详情图片集合
    3.2 查询产品所属于的分类
    3.3 查询产品所有的累积评价（返回评论对象集合）
    3.4 查询产品所有的销量
    3.5 查询产品的属性值（描述产品的性能，eg:手机屏幕参数····）

4 把查询得到的图片，分类，属性值，评价和销量赋值给产品
5 把产品，产品属性，评论放进模型（页面需要这3个对象），然后跳转到产品页，product.jsp


个人理解：

    数据库表上应该是定好的，页面展示出来，新增的属性应该是客户临时增加的要求，比如产品的属性，图片，累积评价····
    产品的属性和属性值 是2个对象。
    举例子：属性是屏幕，属性值是5.6寸， 屏幕是 porperty对象 和 5.6寸 propertyValue对象 这是作为2个对象看待的。


代码：
```
   @RequestMapping("foreproduct")
    //1. 获取参数pid
    public String product(int pid, Model model) {
        //2. 根据pid获取Product 对象p
        Product product = productService.get(pid);

        //3. 根据对象p，获取这个产品对应的单个图片集合
        //4. 根据对象p，获取这个产品对应的详情图片集合
        List<ProductImage> productSingleImages = productImageService.list(product.getId(), productImageService.type_single);
        List<ProductImage> productDetailImages = productImageService.list(product.getId(), productImageService.type_detail);


        //5. 获取产品的所有属性值
        List<PropertyValue> propertyValues = propertyValueService.list(product.getId());
        //6. 获取产品对应的所有的评价
        List<Review> reviews = reviewService.list(product.getId());
        //7. 设置产品的图片，分类,销量和评价数量
        productService.setSaleAndReviewNumber(product);
        product.setProductSingleImages(productSingleImages);
        product.setProductDetailImages(productDetailImages);


        model.addAttribute("reviews", reviews);
        model.addAttribute("product", product);
        model.addAttribute("propertyValues", propertyValues);

        return "fore/Product";
    }
```


业务层：
----

对产品操作的业务：

思路：

 根据产品id查询产品


    
因为查询返回产品对象后，新增的属性：分类，产品图片，2个图片类型集合，都是Null，所以要赋值。具体代码在首页功能那里粘贴了。（分类，产品图片这2个既是产品属性也是对象）
2个图片类型集合就先不用赋值，后面写。

一开始建立表格的时候是没有完善的，pojo类里新增的属性是方便页面展示需求，才增加的。2个图片类型集合就是方便页面展示产品图片所新增加的属性。



```
    @Override
    public Product get(int id) {
        Product product = productMapper.selectByPrimaryKey(id);
        setCategory(product);
        setFirstProductImage(product);
        return product;
    }
```







对图片操作的业务：

思路：

  **根据产品id 和 产品图片类型 查询出所要的产品图片类型集合**
  
 注意： 
 
 图片类型在jsp的提交页面上写死了，哪个div提交的图片就是什么类型的。
 
 图片类型，可以使用新的变量来表示，值一定要对，一般情况下都是这样想的。（物理学科上好像也是这样，出现不明原因，分出属性，一个个穷举验证）


**ProductImageServiceImpl：**

```
    @Override
    public List<ProductImage> list(int pid, String type) {
        ProductImageExample productImageExample = new ProductImageExample();
        productImageExample.createCriteria()
                .andPidEqualTo(pid)
                .andTypeEqualTo(type);
        productImageExample.setOrderByClause("id desc");

        return productImageMapper.selectByExample(productImageExample);
    }
```





对产品属性操作的业务：

产品 ---产品属性 -----产品属性值， 这个逻辑链条，3个都是对象，都有自己的属性



思路：

根据产品id 查询产品属性值对象，然后对每个产品属性值的属性赋值

**PropertyValueServiceImpl:**

```
    @Override
    public List<PropertyValue> list(int pid) {
        PropertyValueExample propertyValueExample = new PropertyValueExample();
        propertyValueExample.createCriteria()
                .andPidEqualTo(pid);

        List<PropertyValue> propertyValues = propertyValueMapper.selectByExample(propertyValueExample);

        for (PropertyValue propertyValue : propertyValues) {
            Property property = propertyService.get(propertyValue.getPtid());
            propertyValue.setProperty(property);
        }
        return propertyValues;
    }
```


对产品评价操作的业务：

思路：

根据产品Id 查询该产品的所有评论对象集合（方便页面需求，评论对象新增加个用户属性）


```
    @Override
    public List<Review> list(Integer pid) {
        ReviewExample reviewExample = new ReviewExample();
        reviewExample.createCriteria().andPidEqualTo(pid);
        reviewExample.setOrderByClause("id desc");

        List<Review> reviews = reviewMapper.selectByExample(reviewExample);

        setUser(reviews);

        return reviews;
    }
    
    public void setUser(List<Review> reviews) {
        for (Review review : reviews) {
            setUser(review);
        }
    }

    public void setUser(Review review) {
        int uid = review.getUid();
        User user = userService.get(uid);
        review.setUser(user);
    }
```



**对产品的评价数量，产品销量 查询操作业务：**


思路：

根据产品，查询 2个对象 评价数量和产品销量

 1 查询评论对象，然后对返回的评价对象集合计数**(调用到了评论对象的业务层)**
 2 因为产品销量是订单项的一个属性，所以查询产品销量是查询订单项对象**（调用到了订单项对象的业务层）**

```
    @Override
    public void setSaleAndReviewNumber(Product product) {
        int saleCount = orderItemService.getSaleCount(product.getId());
        product.setSaleCount(saleCount);

        int reviewCount = reviewService.getCount(product.getId());
        product.setReviewCount(reviewCount);
    }
```


评论对象查询评论数量的业务层：

思路：
　　根据产品id　查询评论对象，然后返回评价对象集合的数量
　　
**页面查询要是出现所有，全部···字眼，用list，而且要以产品为根，依靠产品属性查询需求对象，然后返回需求想要的值**　　

```
@Override
    public int getCount(Integer pid) {

        return list(pid).size();
    }
```




订单项对象查询订单产品数量的业务层

思路：
    
    产品作为根，依据产品Pid 外键获取所有订单，然后计算订单里面购买该产品的数量
    最后返回 该产品卖出的数量


**页面查询要是出现所有，全部···字眼，用list，而且要以产品为根，依靠产品属性查询需求对象，然后返回需求想要的值**　　
代码：

```
    @Override
    public int getSaleCount(Integer pid) {
        OrderItemExample orderItemExample = new OrderItemExample();
        orderItemExample.createCriteria().andPidEqualTo(pid);

        List<OrderItem> orderItems = orderItemMapper.selectByExample(orderItemExample);

        int result = 0;
        for (OrderItem orderItem : orderItems) {
            result += orderItem.getNumber();
        }

        return result;
    }
```


**完成显示产品的业务。**




#模仿登录

**使用jquery技术完成状态验证。**

在未登录状态下，点击购买或者加入购物车就会弹出这个模态对话框

在这个模态对话框上可以进行登录操作，如果账号和密码出错会出现 "账号密码错误" 提示


立即购买和加入购物车这两个按钮的监听是放在`imgAndInfo.jsp`页面中

这两个按钮都会通过JQuery的.post方法，用异步ajax的方式访问forecheckLogin，获取当前是否登录状态
如果返回的不是"success" 即表明是未登录状态，那么就会打开登录的模态窗口

    $("#loginModal").modal('show');


立即购买按钮：
```
$(".buyLink").click(function(){
    var page = "forecheckLogin";
    $.post(
            page,
            function(result){
                if("success"==result){
                   // 。。。略
                }
                else{
                    $("#loginModal").modal('show');                    
                }
            }
    );     
    return false;
});
```

加入购物车按钮：

```
$(".addCartLink").click(function(){
    var page = "forecheckLogin";
    $.post(
            page,
            function(result){
                if("success"==result){
                   // 。。。略
                }
                else{
                    $("#loginModal").modal('show');                    
                }
            }
    );     
    return false;
});
```


控制层：
----

ajax访问路径`/forecheckLogin`会导致`ForeController.checkLogin()`方法被调用。

思路：

**获取session中的"user"对象，判断user是否为空，完成状态判断。**
如果不为空，即表示已经登录，返回字符串"success"
如果为空，即表示未登录，返回字符串"fail"

**注意： 使用了异步ajax，在控制层都要使用@ResponseBody注解，不然数据传输不了**

代码：

```
  @RequestMapping("forecheckLogin")
    @ResponseBody
    public String checkLogin(HttpSession session) {
        User user = (User) session.getAttribute("user");
        if (null != user) {
            return "success";
        }
        return "fail";
    }
```


## 完成登录model.jsp

`modal.jsp` 页面被 `footer.jsp` 所包含，所以每个页面都是加载了的。
通过`imgAndInfo.jsp`页面中的购买按钮或者加入购物车按钮显示出来。

点击登录按钮时，使用`imgAndInfo.jsp` 页面中的ajax代码进行登录验证：


```
$("button.loginSubmitButton").click(function(){
            
            var name = $("#name").val();
            var password = $("#password").val();
            var page = "foreloginAjax";
            
            //判断账号，密码是否空
            if(0==name.length||0==password.length){
                $("span.errorMessage").html("请输入账号密码");
                $("div.loginErrorMessageDiv").show();
                return false;
            }
            /*post提交*/
            $.post(
                page,
                {"name":name,"password":password},
                function(result){
                    if("success"==result){
                        location.reload();
                    }
                    else{
                        $("span.errorMessage").html("账号密码错误");
                        $("div.loginErrorMessageDiv").show();
                    }
                }
            );

            return true;
        });
```



控制层：
----

访问路径`/foreloginAjax`,导致`ForeController.loginAjax()`方法被调用

    1. 获取账号密码
    2. 通过账号密码获取User对象
    2.1 如果User对象为空，那么就返回"fail"字符串。
    2.2 如果User对象不为空，那么就把User对象放在session中，并返回"success" 字符串


代码：
```
    @RequestMapping("foreloginAjax")
    @ResponseBody
    public String loginAjax(@RequestParam("name") String name,
                            @RequestParam("password") String password,
                            HttpSession session) {
        name = HtmlUtils.htmlEscape(name,"UTF-8");
        //查询得到user对象
        User user = userService.get(name, password);
        if (null == user) {
            return "fail";
        }
        session.setAttribute("user", user);
        return "success";
    }
```


业务层：
----

```
    @Override
    public User get(String name, String password) {
        UserExample userExample = new UserExample();
        userExample.createCriteria()
                .andNameEqualTo(name)
                .andPasswordEqualTo(password);
        List<User> users = userMapper.selectByExample(userExample);

        if (users.isEmpty()) {
            return null;
        }
        return users.get(0);
    }
```



#分类页（查询一类产品）

完成效果： **点击产品分类，查询完后跳转到分类页，此时没有排序。接着再分类页面上点击排序功能，页面按照排序更新**

分类页包含2个小页面
```
<%@include file="sortBar.jsp"%>
<%@include file="productByCategory.jsp"%>
```


分类这个页面有排序功能,下面主要讲分类页面上点击排序功能， 这个排序功能，展示产品就使用eachFor循环展示

[![大.jpg](https://i.loli.net/2018/10/08/5bbb7713c11c0.jpg)](https://i.loli.net/2018/10/08/5bbb7713c11c0.jpg)


**sortBar.jsp排序条上的script**

```
    $(function(){
        $("input.sortBarPrice").keyup(function(){
            //$(this).val() 相当于  $(this).attr(“value”);
            var num= $(this).val();
            if(num.length==0){
                $("div.productUnit").show();
                return;
            }

            num = parseInt(num);
            if(isNaN(num))
                num= 1;
            if(num<=0)
                num = 1;
            $(this).val(num);

            var begin = $("input.beginPrice").val();
            var end = $("input.endPrice").val();
            if(!isNaN(begin) && !isNaN(end)){
                console.log(begin);
                console.log(end);
                $("div.productUnit").hide();
                $("div.productUnit").each(function(){
                    var price = $(this).attr("price");
                    price = new Number(price);

                    if(price<=end && price>=begin)
                        $(this).show();
                });
            }

        });
    });
```



sortBar的div

根据sort参数判断哪个排序按钮高亮

复制修改review和href语句就可获得其他4个排序功能。


```
<td <c:if test="${'review' == param.sort}"> class="grayColumn"</c:if> >
                <a href="?cid=${category.id}&sort=review">
                    人气
                    <span class="glyphicon plyphicon-arrow-down"></span>
                </a>
            </td>
```

注意：

    href="?cid=${category.id}&sort=review"

这里href没有写明action，所以就是网址的`http://localhost:8888/forecategory?cid=357`中的`/foreCategory`作为action了，调用ForeController.category()方法



控制层：
----

[![查询一类.jpg](https://i.loli.net/2018/10/30/5bd81fcd02795.jpg)](https://i.loli.net/2018/10/30/5bd81fcd02795.jpg)


思路：
1 根据外键cid 查询到分类对象，并且填充
2 然后根据分类对象查询产品，
3 接着根据产品查询销量和评论，

4 获取参数sort

    4.1 如果sort==null，即不排序
    4.2 如果sort!=null，则根据sort的值，从5个Comparator比较器中选择一个对应的排序器进行排序

5 把category放在model中


```
    @RequestMapping("forecategory")
    public String category(int cid, String sort, Model model) {
        Category category = categoryService.get(cid);
        productService.fill(category);
        productService.setSaleAndReviewNumber(category.getProductList());
 /*
    Collections.sort(list, new PriceComparator())
            参数一：需要排序的list
            参数二：比较器，实现Comparator接口的类，返回一个int型的值，就相当于一个标志，告诉sort方法按什么顺序来对list进行排序。
            */
        if (null != sort) {
            switch (sort) {
                case "review":
                    Collections.sort(category.getProductList(), new ProductReviewComparator());
                    break;
                case "date":
                    Collections.sort(category.getProductList(), new ProductDateComparator());
                    break;
                case "saleCount":
                    Collections.sort(category.getProductList(), new ProductSaleCountComparator());
                    break;
                case "price":
                    Collections.sort(category.getProductList(), new ProductPriceComparator());
                    break;

                case "all":
                    Collections.sort(category.getProductList(), new ProductAllComparator());
                    break;
            }
        }
        model.addAttribute("category", category);
        return "fore/category";
    }
```



5个Comparator比较器：
----------------
Comparator是个接口，可重写compare()及equals()这两个方法,用于比较功能；
 如果是null的话，就是使用元素的默认顺序，如a,b,c,d,e,f,g，就是a,b,c,d,e,f,g这样，当然数字也是这样的。
 

1.ProductAllComparator 综合比较器
把 销量x评价 高的放前面

```
public class ProductAllComparator implements Comparator<Product> {
    @Override
    public int compare(Product o1, Product o2) {
        return o2.getReviewCount() * o2.getSaleCount() - o1.getReviewCount() * o1.getSaleCount();
    }
}
```

2.ProductReviewComparator 人气比较器
把 评价数量多的放前面

```
public class ProductReviewComparator implements Comparator<Product> {
    @Override
    public int compare(Product o1, Product o2) {
        return o2.getReviewCount() - o1.getReviewCount();
    }
}

```
3. ProductDateComparator 新品比较器
把 创建日期晚的放前面

```
public class ProductDateComparator implements Comparator<Product>{
    @Override
    public int compare(Product o1, Product o2) {
        return o2.getCreateDate().compareTo(o1.getCreateDate());
    }
}
```
4. ProductSaleCountComparator 销量比较器
把 销量高的放前面

```
public class ProductSaleCountComparator implements Comparator<Product> {

    @Override
    public int compare(Product o1, Product o2) {
        return o2.getSaleCount() - o2.getSaleCount();
    }
}
```
5. ProductPriceComparator 价格比较器
把 价格低的放前面

```
public class ProductPriceComparator implements Comparator<Product> {
    @Override
    public int compare(Product o1, Product o2) {
        /*(int) (o2.getPromotePrice() - o1.getPromotePrice());*/
        double result = o1.getPromotePrice() - o2.getPromotePrice();

        return (int) (result < 0 ? Math.floor(result) : Math.ceil(result));
    }
}
```



# 搜索

Mini-search..jsp或者search.jsp：

    <form action="foresearch" method="post" >
    <input type="text" name="keyword"  placeholder="平衡车 原汁机">



控制层：
----
[![搜索.jpg](https://i.loli.net/2018/10/30/5bd81edfca729.jpg)](https://i.loli.net/2018/10/30/5bd81edfca729.jpg)

思路：

1. 获取参数keyword
2. 根据keyword进行模糊查询，获取满足条件的前20个产品
3. 为这些产品设置销量和评价数量
4. 把产品结合设置在model的"productList"属性上
5. 服务端跳转到 searchResult.jsp 页面


代码：
```
    @RequestMapping("foresearch")
    public String search(String key, Model model) {
        PageHelper.offsetPage(0, 30);
        List<Product> productList = productService.search(key);
        productService.setSaleAndReviewNumber(productList);
        model.addAttribute("productList", productList);
        return "fore/searchResult";
    }
```




业务层：
----

思路：
    查询返回后，进行对产品的图片对象，分类对象赋值。而销量对象，评论对象的赋值是上面写过的。
    产品的4个新增对象，分成4个方法，分别赋值。这里有2个，上面的有2个。

```
    public List<Product> search(String key) {
        ProductExample productExample = new ProductExample();
        productExample.createCriteria().andNameLike("%" + key + "%");
        productExample.setOrderByClause("id desc");

        List result = productMapper.selectByExample(productExample);
        setFirstProductImage(result);
        setCategory(result);

        return result;
    }
```




	2018-10-09 16:05:06
kumika	实战天猫SSM---前端实现功能 4	# 实战天猫SSM---前端实现功能 4

# 订单状态


在开始实现订单相关功能之前，我们把订单的状态捋一捋，这样有助于代码思路更加清晰
1. 首先是创建订单，刚创建好之后，订单处于**`waitPay 待付款`**状态
2. 接着是付款，付款后，订单处于**`waitDelivery 待发货`**状态
3. 前两步都是前台用户操作导致的，接下来需要到后台做发货操作，发货后，订单处于**`waitConfirm 待确认收货`**状态
4. 接着又是前台用户进行确认收货操作，操作之后，订单处于**`waitReview 待评价`**状态
5. 最后进行评价，评价之后，订单处于**`finish 完成`**状态

以上状态都是一个接一个的，不能跳状态进行。
比较特殊的是，无论当前订单处于哪个状态，都可以进行删除操作。 像订单这样极其重要的业务数据，实际上是不允许真正从数据库中删除掉的，而是把状态标记为删除，以表示其被删掉了，所以在删除之后，订单处于 **`delete 已删除`**状态

[![订单流程.jpg](https://i.loli.net/2018/09/30/5bb0a9df2bda8.jpg)](https://i.loli.net/2018/09/30/5bb0a9df2bda8.jpg)






# 生成订单

效果：

在结算页面点击提交订单

[![提交订单.jpg](https://i.loli.net/2018/10/11/5bbecd550c600.jpg)](https://i.loli.net/2018/10/11/5bbecd550c600.jpg)

然后再数据库中生成一条Order记录，而且在OrderItem表oid字段也有这条order记录的id

[![记录.jpg](https://i.loli.net/2018/10/11/5bbece5a62c30.jpg)](https://i.loli.net/2018/10/11/5bbece5a62c30.jpg)



XML配置
-----

可能最开始就配好了，也可以现在配置，现在只是说明用处。

在spring-mybaits.xml上配置：
因为增加订单行为需要同时修改两个表

    1. 为Order表新增数据
    2. 修改OrderItem表
    所以需要进行事务管理，否则当新增了Order表的数据，还没有来得及修改OrderItem的时候出问题，
    比如突然断电，那么OrderItem的数据就会是脏数据了（没有指向正确的Order表数据）。

代码：
```
 <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--事务管理-->
    <tx:annotation-driven transaction-manager="transactionManager"/>
```


BuyPage.JSP页面：

点击提交，然后提交表单
 

    <form action="forecreateOrder" method="post">


跳转到控制层调用creaeteOrder（）方法

控制层：
----
表单提交数据由Pojo类对象Order接受。

[![生成订单.jpg](https://i.loli.net/2018/10/30/5bd8286d22455.jpg)](https://i.loli.net/2018/10/30/5bd8286d22455.jpg)


**ForeController：**
思路：

1  从session中获取user对象
2  根据当前时间+随机4位数生成订单号
3  通过表单参数Order对象接受表单上的地址，邮编，收货人···信息
4  根据上面的参数，对订单对象赋值（其实参数order就是了，自动创建了）。
5  把订单状态设置为等待支付。
6  从session中获取订单项集合（在，订单项集合被放到了session中）
7  把订单加入到数据库中，并且遍历订单项集合，设置每一个订单项的order，更新到数据库
8  统计本次订单的总金额
9  客户端跳转到确认支付页forealipay，并带上订单Id和总金额

代码：

```
@RequestMapping("forecreateOrder")
    public String creaeteOrder(Model model, Order order, HttpSession session) {
        //1. 从session中获取user对象
        User user = (User) session.getAttribute("user");
        //2. 根据当前时间加上一个4位随机数生成订单号
        String orderCode = new SimpleDateFormat("yyyyMMddHHmmssSSS").format(new Date()) + RandomUtils.nextInt(1000);
        //3. 通过参数Order接受地址，邮编，收货人，用户留言等信息
        //4. 根据上述参数，对订单对象赋值
        order.setOrderCode(orderCode);
        order.setCreateDate(new Date());
        order.setUid(user.getId());
        //5. 把订单状态设置为等待支付
        order.setStatus(OrderService.waitPay);
        //6. 从session中获取订单项集合 ( 在结算功能的ForeController.buy() 13行，订单项集合被放到了session中 )
        List<OrderItem> orderItems = (List<OrderItem>) session.getAttribute("orderItems");
        //7. 把订单加入到数据库，并且遍历订单项集合，设置每个订单项的order，更新到数据库
        //8. 统计本次订单的总金额
        float total = orderService.add(order, orderItems);
        //9. 客户端跳转到确认支付页forealipay，并带上订单id和总金额
        return "redirect:forealipay?oid=" + order.getId() + "&total=" + total;
    }
```


业务层：


**OrderServiceIMP:**

订单增加，此时有2个数据库操作，一个是对订单增加到数据库上，另外一个对在这个订单里面的订单项更新。
因为要求返还更新后的订单总价格，所以是浮点类型

思路：
1 订单增加到数据库
2 订单项更新属性值，增加oid的值

```
public float add(Order order, List<OrderItem> orderItems) {
    float total = 0;
    add(order);
    
    for(OrderItem orderItem : orderItems){
        orderItem.setOid(order.getId());
        OrderItemService.update(orderItem);
        total += orderItem.getProduct().getPromotePrice() * orderItem.getNumber();
    }
    return total;
}

 public void add(Order order) {
        orderMapper.insert(order);
    }
```



# 支付页面

经过创建订单后就跳转到支付页面。
路径/forealipay方法，导致PageController.alipay()方法被调用。
完成跳转到支付页面
```
    @RequestMapping("forealipay")
    public String aliPay() {
        return "fore/alipay";
    }
```


**支付页面：**


**alipayJsp：**
```
 <a href="forepayed?oid=${param.oid}&total=${param.total}"><button class="confirmPay">确认支付</button></a>
```


控制层：
----

确认访问按钮提交数据到/forepayed,导致ForeController.payed方法被调用

[![确认支付.jpg](https://i.loli.net/2018/10/30/5bd8289c4db32.jpg)](https://i.loli.net/2018/10/30/5bd8289c4db32.jpg)

**ForeController：**

思路：

1  获取参数oid
2  根据oid获取订单对象Order
3  修改order的属性：订单状态 ， 支付时间
4  更新order对象
5  把order对象放在model的属性attribute上
6  服务端跳转到payed.jsp


```
@RequestMapping("forepayed")
//1  获取参数oid ,注入参数oid
public String payed(int oid, Model model){
    //2  根据oid获取订单对象Order
    Order order = OrderService.get(oid);
    //3  修改order的属性：订单状态 ， 支付时间
    order.setStatus(OrderService.waitDelivery);
    order.setCreateDate(new Date());
    //
    orderSrvice.update(order);
    //5  把order对象放在model的属性attribute上
    model.setAttribute("order",order);
    //6  服务端跳转到payed.jsp
    return "fore/payed";
}
```



# 查看我的订单页

在每页的右上方可以点击我的订单，然后转到我的订单页

在top.jsp上代码：
```
<a href="forebought">我的订单</a>
```


控制层：
----

[![查看订单页面.jpg](https://i.loli.net/2018/10/30/5bd828b9e8a4e.jpg)](https://i.loli.net/2018/10/30/5bd828b9e8a4e.jpg)

/forebought导致ForeController.bought()方法被调用

1  通过session获取用户user
2  查询user所有的状态不是“delete” 的订单集合`orders`
3  为这些订单填充订单项
4  把`orders` 放在model的`attribute`上
5  服务器端跳转到bought.jsp

```
@RequestMappping("forebought")
public String bought(HttpSession session , Model model){
    User user = (User) session.getAttribute("user");
    //查询user所有的状态不是“delete” 的订单集合`orders`
    List<Order> orders = orderService.list(user.getId(),OrderService.delete);
    //为这些订单填充订单项
    OrderItemService.fill(orders);
    
    mdoel.addAttribute("orders",order);
    return "fore/bought";
}
```


业务层：
----

一种商品就是一个订单项（类似购物车只装一种商品，订单可以有多个购物车）

**OrderItemServiceImp:**
在`fill(List<Order> orders)` 中，就是遍历每个订单，然后挨个调用`fill(Order order)`

**为订单填充订单项**：
**fill(Order order) :**
     为什么要提供这个方法呢？ 因为在订单管理界面，首先是遍历多个订单，然后遍历这个订单下的多个订单项。
     而由MybatisGenerator逆向工程所创建的一套自动生成代码，是不具备一对多关系的，需要自己去二次开发。
     这里就是做订单与订单项的一对多关系。
     在fill(Order order)中：
     
     1. 根据订单id查询出其对应的所有订单项
     2. 通过setProduct为所有的订单项设置Product属性
     3. 遍历所有的订单项，然后计算出该订单的总金额和总数量
     4. 最后再把订单项设置在订单的orderItems属性上。

```
    public void fill(List<Order> orders) {
        for (Order order :  orders) {
            fill(order);
        }
    }
    
    
    public void fill(Order order) {
        OrderItemExample orderItemExample = new OrderItemExample();
        orderItemExample.createCriteria().andOidEqualTo(order.getId());
        orderItemExample.setOrderByClause("id desc");
        //1. 根据订单id查询出其对应的所有订单项
        List<OrderItem> orderItems = orderItemMapper.selectByExample(orderItemExample);
        //2. 通过setProduct为所有的订单项设置Product属性
        setProduct(orderItems);

        float total = 0;
        int totalNumber = 0;
        //3. 遍历所有的订单项，然后计算出该订单的总金额和总数量
        for (OrderItem orderItem : orderItems) {
            total += orderItem.getNumber() * orderItem.getProduct().getPromotePrice();
            totalNumber += orderItem.getNumber();
        }

        //4. 最后再把订单项设置在订单的orderItems属性上。
        order.setTotal(total);
        order.setTotalNumber(totalNumber);
        order.setOrderItems(orderItems);
    }
```


**OrderServiceIMP:**

查询user所有的状态不是“delete” 的订单集合`orders`

使用Mybatis的自带查询工具 `andUidEqualTo(uid).andStatusNotEqualTo(status);`
```
    public List list(Integer uid, String status) {
        OrderExample orderExample = new OrderExample();
        orderExample.createCriteria().andUidEqualTo(uid).andStatusNotEqualTo(status);
        orderExample.setOrderByClause("id desc");

        return orderMapper.selectByExample(orderExample);
    }
```



# 订单页操作

在我的订单页面，根据订单的不同状态，可以做出如下不同的操作：

    1. 付款 —— 已经生成，但是未付款
    2. 确认收货 —— 通过后台发货后
    3. 评价 —— 确认收货后, 讲在评价产品知识点讲解，这里只是提到
    4. 删除 —— 任意状态下

[![订单详细操作.jpg](https://i.loli.net/2018/10/30/5bd828e44eebe.jpg)](https://i.loli.net/2018/10/30/5bd828e44eebe.jpg)

## 1 付款

前面的提交订单，点击提交，生成订单，跳转到支付页面，点击确认支付，完成付款（这是生成订单----支付页面的内容，也就是已经实现了）




## 2 确认收货

**注意： 确认收货后，流程是再进行一次确认支付，这里一起写**

[![342.jpg](https://i.loli.net/2018/10/13/5bc17fc5da169.jpg)](https://i.loli.net/2018/10/13/5bc17fc5da169.jpg)

因为发货了，此时后台已经把`order`对象的`status`属性值修改为`waitConfirm`

在用户订单页面上

只有订单的`status`属性值是`waitConfirm`才会显示确认按钮

```
<c:if test="${order.status == 'waitConfirm'}">
    <a href="foreconfirmPay?oid=${order.id}">
       <button class="orderListItemConfirm">确认收货</button>
    </a>
</c:if>
```



###控制层：
----

点击确认收货后，访问地址`/foreconfirmPay`，调用ForeController的confirmPay()方法。

思路：

1 获取参数oid
2 通过oid获取订单对象order
3 为订单对象order填充订单项
4 模型model的attribute增加订单对象order
5 跳转到确认支付页面confirmPay。jsp


```
@RequestMapping("foreconfirmPay")
public String confirmPay(int oid ,Model model){
    Order order = orderService.get(pid);
    //3 为订单对象order填充订单项
    orderItemService.fill(order);
    
    model.addAttribute("order",order);
    return "fore/confirmPay";
}
```


###业务层：
----

OrderItemServiceIMP:

订单对象填充订单项，在查看我的订单页面上有写这个方法，所以就不重复了



### 再确认支付

**PageController:**
  跳转到页面alipay
```
    @RequestMapping("forealipay")
      public String aliPay() {
        return "fore/alipay";
    }
```


**再确认支付页面：**

alipay页面的主要显示页面是confirmPayPage。jsp

confrimPayPage.jsp:
```
<a href="foreorderConfirmed?oid=${order.id}">
    <button class="confirmPayButton">确认支付</button>
</a>
```

####控制层
---

**ForeController:**

最后的确认支付按钮，提交到路径`/foreorderConfirmed`，导致ForeController.`orderConfirmed()`方法被调用


思路：

1  获取参数oid
2  根据参数oid获取Order对象
3  修改order的status属性值，改为等待评价状态`waitReview`,修改其确认支付时间
4  更新数据库
5  服务端跳转到orderConfirmed.jsp页面


```
@RequestMapping("foreorderConfirmed")
public String orderConfirmed(Model model , int oid){
    Order order= orderService.get(oid);
    
    order.setStatus(OrderService.waitReview);
    order.setConfirmDate(new Date());
    
    orderServive.update(order);
   
    return "fore/orderConfirmed";
}
```

## 3 评价

评价 会单独讲

## 4 删除订单项


在我的订单页 上点击删除按钮，根据 boughtPage.jsp 中的ajax操作，会访问路径/foredeleteOrder，导致ForeController.deleteOrder方法被调用

boughtPage.jsp 中的javascript代码获取返回字符串是success的时候，隐藏掉当前这行订单数据。

script:
```

var page="foredeleteOrder";
$.post(
    page,
    {"oid":deleteOrderid},
        function(result){
        if("success"==result){
            $("table.orderListItemTable[oid="+deleteOrderid+"]").hide();
        }
        else{
           location.href="loginPage";
        }
    }
);
```



###控制层：
----

**foreController:**

1 获取参数Oid
2 根据oid 获取订单对象order
3 修改order的status属性值，修改为delete
4 更新数据库
5 返回success

注意： 因为是ajax，所以要加上注解@ResponseBody

```
@RequestMapping("foredeleteOrder")
@ResponseBody
public String delete(int oid,Model model){
    Order order = orderService.get(oid);
    order.setStatus(OrderService.delete);
    
    orderService.update(order);
    
    return "success";
}
```

###业务层：
----
orderServivceIMP:
```
public void update(Order order) {
        orderMapper.updateByPrimaryKeySelective(order);
    }
```


# 评价产品

最终效果：
  **要是订单中有多个产品，则点击订单上的评价，则评价的是订单上显示第一个商品，
要是只有一个商品，则评价该商品。**


通过点击评价按钮，来到路径`/forereview`，导致`ForeController.review()`方法被调用


**ReviewPage.jsp：**

```
<form method="post" action="foredoreview">
```


控制层：
----

[![评论页面.jpg](https://i.loli.net/2018/10/30/5bd82919638e3.jpg)](https://i.loli.net/2018/10/30/5bd82919638e3.jpg)

思路：

1 获取参数oid 
2 根据oid获取订单对象order
3 order填充订单项
4 获取第一个订单项对应的产品,因为在评价页面需要显示一个产品图片，那么就使用这第一个产品的图片了

5 获取该产品的评价集合
6 设置该产品的评价数量和销量
7 把产品，订单，评价集合放在Model上
8 跳转到review.jsp上


```
@RequestMapping()
Public String review(int oid,Model model){
    Order order = orderServie.get(oid);
    orderItemServie.fill(order);
    Product product = order.getOrderItems().get(0).getProduct();
    List<Review> reviews = reviewService.list(product.getId());
    productService.setSaleAndReviewNumber(product);
    
    model.addAttribute("product",product);
    model.addAttribute("order",order);
    model.addAttribute("reviews",reviews);
    return "fore/review";
}
```


业务层：
----


**OrderItemServiceIMP:**

orderItemServie.fill(order);
这个填充订单项，目的：
1 订单项对象要填充商品
2 订单对象要赋值订单项总价格
3 订单对象要赋值订单项总商品数量
4 订单对象要赋值订单项对象
前面粘贴过代码，这里不重复了

===========================================
```
    public int getSaleCount(Integer pid) {
        OrderItemExample orderItemExample = new OrderItemExample();
        orderItemExample.createCriteria().andPidEqualTo(pid);

        List<OrderItem> orderItems = orderItemMapper.selectByExample(orderItemExample);

        int result = 0;
        for (OrderItem orderItem : orderItems) {
            result += orderItem.getNumber();
        }

        return result;
    }
```


**ReviewServiceIMP:**

因为显示留言评论是要显示用户的，所以这里增加了用户属性，不在数据库表格上，所以要赋值。

```
    public List<Review> list(Integer pid) {
        ReviewExample reviewExample = new ReviewExample();
        reviewExample.createCriteria().andPidEqualTo(pid);
        reviewExample.setOrderByClause("id desc");

        List<Review> reviews = reviewMapper.selectByExample(reviewExample);

        setUser(reviews);

        return reviews;
    }
    public void setUser(List<Review> reviews) {
        for (Review review : reviews) {
            setUser(review);
        }
    }

    public void setUser(Review review) {
        int uid = review.getUid();
        User user = userService.get(uid);
        review.setUser(user);
    }
    //产品查询评价数量的方法
    public int getCount(Integer pid) {

        return list(pid).size();
    }
```


**ProductServiceIMP:**

```
    public void setSaleAndReviewNumber(List<Product> productList) {
        for (Product product : productList) {
            setSaleAndReviewNumber(product);
        }
    }
    public void setSaleAndReviewNumber(Product product) {
        int saleCount = orderItemService.getSaleCount(product.getId());
        product.setSaleCount(saleCount);

        int reviewCount = reviewService.getCount(product.getId());
        product.setReviewCount(reviewCount);
    }
```



# 提交评价

提交页面：

```
 <form method="post" action="foredoreview">
      <input type="hidden" value="${order.id}" name="oid">
      <input type="hidden" value="${product.id}" name="pid">
      <button type="submit">提交评价</button>
 </form>
```

在评价产品页面点击提交评价，就把数据提交到了`/foredoreview`路径，导致`ForeController.doreview`方法被调用


控制层：
----


[![提交评论.jpg](https://i.loli.net/2018/10/30/5bd8292810232.jpg)](https://i.loli.net/2018/10/30/5bd8292810232.jpg)

思路：

1 获取参数oid 
2 根据oid获取订单对象order
3 修改订单对象order的属性status的值，修改为`finish`状态
4 更新订单对象order到数据库

5 获取参数pid

6 获取参数content
7 对content的值进行转义（防止乱码）
8 从session中获取当前用户

9 创建评价对象review
10 评价对象设置属性:评价信息，产品，时间，用户
11 增加到数据库
12 跳转到评价产品页面，而且带上参数showonly=true

在reviewPage.jsp中，当参数showonly==true，那么就显示当前产品的所有评价信息


```
@RequestMapping("foredoreview")
public String doreview( Model model,HttpSession session,@RequestParam("oid") int oid,@RequestParam("pid") int pid,String content) {
    Order order = orderService.get(oid);
    order.setStatus(OrderService.finish);
    orderService.update(order);
    
    
    content = HtmlUtil.htmlEscape(content);
    
    User user = (User)session.getAttribute("user");
    
    Review review = new Review();
    review.setContent(content);
    review.setPid(pid);
    review.setCreateTime(new Date());
    review.setUid(user.getId());
    
    reviewService.add(review);
    
    return "redirect: forereview?oid="+oid+"&showonly=true";
}
```




业务层：
----

**ReviewServiceIMP:**
```
 public void add(Review review) {
        reviewMapper.insert(review);
    }
```





	2018-10-19 09:42:04
kumika	SSM博客实战---建立表格sql语句	# SSM博客实战---建立表格sql语句



文章
--
```
drop table if exists article;
create table article(
    article_id int(11) unsigned not null auto_increment primary key,
    article_user_id int(11) unsigned default '1',
    article_title varchar(225) default null,
    article_content mediumtext,
    article_parent_category_id int(11) default null,
    article_child_category_id int(11) default null,
    article_tag_ids varchar(50) default null,
    article_view_count int(11) default '0',
    article_comment_count int(5) default '0',
    article_like_count int(5) default '0',
    article_post_time datetime default null,
    article_update_time datetime default null,
    article_is_comment int(5) unsigned default null,
    article_status int(5) unsigned default '1',
    article_order int(5) unsigned default null
)
```




分类：
---

```
drop table if exists category;
create table category(
    category_id int(11) unsigned not null auto_increment primary key,
    category_pid int(5) default null,
    category_name varchar(50) default null unique key,
    category_description varchar(255) default null,
    category_order int(2) unsigned default '1',
    category_icon varchar(20) default null,
    category_status int(2) unsigned default '1'
)
```

评论
--

```
drop table if exists comment;
create table comment(
    comment_id int(11) unsigned not null auto_increment primary key,
    comment_pid int(11) unsigned default '0',
    comment_pname varchar(255) default null,
    comment_article_id int(11) unsigned default null,
    comment_author_name varchar(50) default null,
    comment_author_email varchar(50) default null,
    comment_author_url varchar(50) default null,
    comment_content varchar(1000) default null,
    comment_agent varchar(50) default null,
    comment_ip varchar(50) default null,
    comment_create_time datetime default null,
    comment_role int(11) default null,
    comment_status int(11) unsigned default '1'
)
```


连接link
----

```
drop table if exists link;
create table link(
    link_id int(11) unsigned not null auto_increment primary key,
    link_url varchar(255) default null,
    link_name varchar(255) default null unique key,
    link_image varchar(255) default null,
    link_description varchar(255) default null,
    link_owner_nickname varchar(255) default null,
    link_owner_contact varchar(255) default null,
    link_update_time datetime default null,
    link_create_time datetime default null,
    link_order int(11) unsigned default '1',
    link_status int(11) unsigned default '1'
)
```


目录：
---

```
drop table if exists menu;
create table menu(
    menu_id int(11) not null auto_increment primary key,
    menu_name varchar(255) default null unique key,
    menu_url varchar(255) default null,
    menu_level int(11) default null,
    menu_icon varchar(255) default null,
    menu_order int(11) default null,
    menu_status int(11) default '1'
)
```

提示
--

```
drop table if exists notice;
create table notice (
    notice_id int(11) not null auto_increment primary key,
    notice_title varchar(255) default null,
    notice_content varchar(20000) default null,
    notice_create_time datetime default null,
    notice_update_time datetime default null,
    notice_status int(11) default null,
    notice_order int(11) default null
)
```


选择
--

```
drop table if exists optiones;
create table options(
    option_id int(11) not null primary key,
    option_site_title varchar(255) default null,
    option_site_description varchar(255) default null,
    option_meta_description varchar(255) default null,
    option_meta_keyword varchar(255) default null,
    option_aboutsite_avatar varchar(255) default null,
    option_aboutsite_title varchar(255) default null,
    option_aboutsite_content varchar(255) default null,
    option_aboutsite_wechat varchar(255) default null,
    option_aboutsite_qq varchar(255) default null,
    option_aboutsite_github varchar(255) default null,
    option_aboutsite_weibo varchar(255) default null,
    option_tongji varchar(255) default null,
    option_status int(111) default '1'
)
```



页面：
---

```
drop table if exists page;
create table page(
    page_id int(11) unsigned not null auto_increment primary key,
    page_key varchar(255) default null unique key,
    page_title varchar(255) default null,
    page_content mediumtext,
    page_create_time datetime default null,
    page_update_time datetime default null,
    page_view_count int(11) unsigned default '0',
    page_comment_count int(11) unsigned default '0',
    page_status int(11) unsigned default '1'
)
```


标签tag:
------

```
drop table if exists tag;
create table tag(
    tag_id int(11) unsigned not null auto_increment primary key,
    tag_name varchar(25) default null unique key,
    tag_description varchar(255) default null,
    tag_status int(11) unsigned default '1'
)
```


用户：
---


```
drop table if exists user;
create table user(
    user_id int(11) unsigned not null auto_increment primary key,
    user_name varchar(255) not null  default '' unique key,
    user_pass varchar(255) not null default '',
    user_nickname varchar(255) not null default '',
    user_email varchar(255) default '' unique key,
    user_url varchar(255) default '',
    user_avatar varchar(255) default null,
    user_last_login_ip varchar(255) default null,
    user_register_time datetime default null,
    user_last_login_time datetime default null,
    user_status int(11) unsigned default '1'
)
```

	2018-11-01 15:16:31
kumika	SSM博客实战---前后台需求	# SSM博客实战---前后台需求


#后台：
---

[![后台需求.jpg](https://i.loli.net/2018/11/02/5bdbd1429f58c.jpg)](https://i.loli.net/2018/11/02/5bdbd1429f58c.jpg)





#前台
---

[![qiant.jpg](https://i.loli.net/2018/11/02/5bdbd6c47da9e.jpg)](https://i.loli.net/2018/11/02/5bdbd6c47da9e.jpg)

	2018-11-02 11:26:34
kumika	SSM博客实战---配置文件	# SSM博客实战---配置文件

```
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd">
```


#spring-MVC
----------

```
    <context:component-scan base-package="foreBlog.controller"/>

    <!--启动注解识别-->
    <mvc:annotation-driven/>
    <!--开通静态资源的访问，否则访问图片，css,js等文件可能出错-->
    <mvc:default-servlet-handler/>

    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" >
        <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
        <property name="prefix" value="/WEB-INF/views/"/>
        <property name="suffix" value=".jsp"/>
    </bean>
```

#Spring-Mybatis
--------------

根据项目，这里的配置会更新


```
<context:component-scan base-package="foreBlog.Service"/>
    <context:property-placeholder location="classpath:db.properties"/>


    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">
        <property name="url" value="${jdbc_url}"/>
        <property name="username" value="${jdbc_user}"/>
        <property name="password" value="${jdbc_password}"/>


        <!-- 配置初始化大小、最小、最大 -->
        <property name="initialSize" value="1"/>
        <property name="minIdle" value="1"/>
        <property name="maxActive" value="20"/>

        <!-- 配置获取连接等待超时的时间 -->
        <property name="maxWait" value="60000"/>

        <!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->
        <property name="timeBetweenEvictionRunsMillis" value="60000"/>

        <!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->
        <property name="minEvictableIdleTimeMillis" value="300000"/>

        <property name="validationQuery" value="SELECT 'x'"/>
        <property name="testWhileIdle" value="true"/>
        <property name="testOnBorrow" value="false"/>
        <property name="testOnReturn" value="false"/>

        <!-- 打开PSCache，并且指定每个连接上PSCache的大小 -->
        <property name="poolPreparedStatements" value="true"/>
        <property name="maxPoolPreparedStatementPerConnectionSize" value="20"/>

        <!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 -->
        <property name="filters" value="stat"/>

    </bean>

    <!--dao（mapper）xml-->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <property name="mapperLocations" value="classpath:config/mapper/*.xml"/>
        <property name="typeAliasesPackage" value="foreBlog.pojo"/>
    </bean>


    <!--dao（mapper）接口类-->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="foreBlog.Mapper"/>
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
    </bean>

    <!--事务管理-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <tx:annotation-driven transaction-manager="transactionManager"/>
```


#WEB.xml
-------
**重要的3个配置：**
加载spring容器   `<context-param>`
配置监听器，来加载spring容器  `<listener>`
springmvc前端控制器   `<servlet>`

```
  <!--post乱码过滤器-->
  <!-- 配置springMVC编码过滤器 -->
  <filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <!-- 设置过滤器中的属性值 -->
    <init-param>
      <param-name>encoding</param-name>
      <param-value>UTF-8</param-value>
    </init-param>
    <!-- 启动过滤器 -->
    <init-param>
      <param-name>foreEncoding</param-name>
      <param-value>true</param-value>
    </init-param>
  </filter>

  <filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <!-- 过滤所有请求 -->
    <url-pattern>/*</url-pattern>
  </filter-mapping>

  <!--加载spring容器-->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:spring/spring-*.xml</param-value>
  </context-param>

  <!--配置监听器，来加载spring容器-->
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>

  <!-- 以下3项参数与log4j的配置相关 -->
  <context-param>
    <param-name>log4jConfigLocation</param-name>
    <param-value>classpath:log4j.properties</param-value>
  </context-param>

  <context-param>
    <param-name>log4jRefreshInterval</param-name>
    <param-value>60000</param-value>
  </context-param>

  <listener>
    <listener-class>org.springframework.web.util.Log4jConfigListener</listener-class>
  </listener>

  <!--springmvc前端控制器 -->
  <servlet>
    <servlet-name>ForestBlog</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:spring/spring-mvc.xml</param-value>
    </init-param>
  </servlet>

  <servlet-mapping>
    <servlet-name>ForestBlog</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>


  <!-- 4、使用Rest风格的URI，将页面普通的post请求转为指定的delete或者put请求 -->
  <filter>
    <filter-name>HiddenHttpMethodFilter</filter-name>
    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
  </filter>
  <filter-mapping>
    <filter-name>HiddenHttpMethodFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>


  <filter>
    <filter-name>HttpFormContentFilter</filter-name>
    <filter-class>org.springframework.web.filter.HttpPutFormContentFilter</filter-class>
  </filter>
  <filter-mapping>
    <filter-name>HttpFormContentFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>


  <filter>
    <filter-name>DuridWebStatFilter</filter-name>
    <filter-class>com.alibaba.druid.support.http.WebStatFilter</filter-class>
    <init-param>
      <param-name>exclusion</param-name>
      <param-value>*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>DuridWebStatFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>


  <welcome-file-list>
    <welcome-file>index.jsp</welcome-file>
  </welcome-file-list>

```










	2018-11-03 12:27:26
kumika	SSM博客实战---后台功能实现1	# SSM博客实战---后台功能实现1

**数据库里面表格没有外键的代价就是pojo类的对象是很多的，依赖pojo类进行联系**


#管理员：
-----

#访问首页：
-----


##控制层：

**具体的完整思路图：**
[![首页.jpg](https://i.loli.net/2018/11/09/5be567377dd02.jpg)](https://i.loli.net/2018/11/09/5be567377dd02.jpg)

思路：
1      拿到视图和模型
     2      对评论数进行查询
     3      对评论列表进行查询
     4      对文章列表进行查询
     5      模型增加属性上面3个查询返回的对象
     6      视图增加访问路径/Admin/index

```
@RequestMapping("/admin")
    public ModelAndView index() {
        ModelAndView modelAndView = new ModelAndView();

        //评论数
        Integer allCommentCount = commentService.countComment(null);
        Integer approvedCommentCount = commentService.countComment(1);
        Integer hiddenCommentCount = commentService.countComment(2);

        //评论列表
        List<CommentListVo> commentList = commentService.ListCommentVo(null);

        //文章列表
        List<ArticleListVo> articleList = articleService.ListArticleVo(null);

        modelAndView.addObject("allCommentCount", allCommentCount);
        modelAndView.addObject("approvedCommentCount", approvedCommentCount);
        modelAndView.addObject("hiddenCommentCount", hiddenCommentCount);

        modelAndView.addObject("commentListVoList", commentList);

        modelAndView.addObject("articleCustomList", articleList);

        modelAndView.setViewName("/Admin/index");
        return modelAndView;
    }
```


##业务层：

###评论业务层：

[![查询评论列表对象.jpg](https://i.loli.net/2018/11/09/5be56a2a0668b.jpg)](https://i.loli.net/2018/11/09/5be56a2a0668b.jpg)

思路：

**查询评论信息列表对象CommentList：**

     1 创建评论列表对象集合commentList
     2 创建评论者信息对象集合commentCustomList

     3 根据commentCustomList的长度使用for循环，填充每一个评论者信息
        3.1 创建单个评论信息对象 commentListVo
        3.2 根据commentListVo获取文章id，根据id查询文章对象articleCustom
        3.3 把文章填充到单个评论信息对象 commentListVo上

        3.4 根据commentListVo配合for循环的i变量获取评论者对象commentCustom
        3.5 根据email获取头像字符串avatar，借用function里的方法把字符串变换成头像
        3.6 把头像avatar填充到评论者对象commentCustom

        3.7 commentCustom填充到单个评论信息对象 commentListVo
        3.8 commentListVo填充到评论列表commentList上，完成一次for循环
     4 返回CommentList


```
//查询评论数量
@Override
public Integer countComment(Integer status) {
        Integer commentCount = commentMapperCustom.countComment(status);
        return commentCount;
    }

//查询评论信息列表对象
@Override
public List<CommentListVo> ListCommentVo(Integer status) {
        //评论信息列表对象集合
        List<CommentListVo> commentList = new ArrayList<>();

        //评论者信息对象集合
        List<CommentCustom> commentCustomList = commentMapperCustom.ListComment(status);

        for (int i= 0; i< commentCustomList.size();i++) {
            //单个评论信息对象
            CommentListVo commentListVo = new CommentListVo();
            //获得文章信息
            Integer articleId = commentCustomList.get(i).getComment_article_id();
            ArticleCustom articleCustom = articleMapperCustom.getArticleById(status, articleId);
            commentListVo.setArticleCustom(articleCustom);

            //评论者信息
            CommentCustom commentCustom = commentCustomList.get(i);

            //评论者的头像(根据email获得头像)
            String avatar = Functions.getGravatar(commentCustom.getComment_author_email());
            commentCustom.setCommentAuthorAvatar(avatar);
            commentListVo.setCommentCustom(commentCustom);
            commentList.add(commentListVo);
        }
        return commentList;
    }
```


###文章业务层：
------

[![文章列表查询.jpg](https://i.loli.net/2018/11/09/5be56a9fbdff2.jpg)](https://i.loli.net/2018/11/09/5be56a9fbdff2.jpg)


思路：

**获取文章列表对象：**


    1 创建文章总信息列表对象ArticleList，列表元素是单篇文章总信息对象articleListVo
    2 查询获得所有文章列表对象articleCustomList，列表元素单篇文章对象articleCustom
    3 for循环对articleListVo的4个属性填充，（ 文章分类列表对象   单篇文章列表对象   作者信息对象   文章标签列表对象）
            
            3.1  创建单篇文章总信息对象articleListVo（里面属性包括文章，文章标签，作者信息，文章分类对象）
            3.2  配合for循环的i变量从所有文章对象articleCustomList列表中拿出单篇文章对象articleCustom
            3.3  再把单篇文章对象articleCustom增加到单篇文章总信息对象articleListVo上
            
            
            3.4  创建文章分类列表对象categoryCustomList
            3.5  配合for循环的i变量从所有文章对象articleCustomList列表中出单篇文章对象articleCustom的父子分类id
            3.6  根据这2个分类id查询返回它们的分类对象categoryCustom，categoryCustom2
            3.7  判断分类对象是否为空，然后增加到文章分类列表对象categoryCustomList上
            3.8  再把categoryCustomList增加到单篇文章总信息对象articleListVo上
            
            
            3.9  创建文章标签列表对象tagCustomList
            3.10 配合for循环的i变量从所有文章对象articleCustomList列表中拿出单篇文章对象articleCustom的标签属性值：tagIds
            3.11 将tagIds分成String数组
            3.12 将使用for循环分别将标签数组内的Id 全部查询，返回全部的标签对象tag
            3.13 判断tag是否为空，不为空就创建文章标签对象tagCustom，使用BeanUtil的方法进行赋值给文章标签对象tagCustom
            3.14 将tagCustom增加到文章标签列表对象tagCustomList
            3.15 再把tagCustomList增加到单篇文章总信息对象articleListVo上
            
            
            3.16 创建用户信息对象UserCustom
            3.17 根据已经知道的配合i变量的单篇文章对象articleCustom，得到User的id
            3.18 根据用户id查询数据库，返回用户对象User
            3.19 使用BeanUtil的方法把user的所有属性赋值给UserCustom
            
            
            3.20 再把UserCustom增加到单篇文章总信息对象articleListVo上
            3.21  文章总信息列表对象ArticleList增加元素articleListVo，完成一次for循环
          4 返回文章总信息列表对象ArticleList


```
public List<ArticleListVo> ListArticleVo(Integer status) {
        //文章总信息列表
        List<ArticleListVo> ArticleList = new ArrayList<ArticleListVo>();

        //获得文章信息列表（获得所有文章）
        List<ArticleCustom> articleCustomList = articleMapperCustom.listArticle(status);


        //获得分类信息
        for (int i = 0; i < articleCustomList.size(); i++) {
            //单篇文章总信息
            ArticleListVo articleListVo = new ArticleListVo();

            //1、将文章信息装到 单篇文章总信息articleListVoList 中
            ArticleCustom articleCustom = articleCustomList.get(i);
            articleListVo.setArticleCustom(articleCustom);

            //2、将分类信息装到 单篇文章总信息articleListVoList 中
            List<CategoryCustom> categoryCustomList = new ArrayList<>();

            Integer parentCategoryId = articleCustomList.get(i).getArticle_parent_category_id();
            Integer childCategoryId = articleCustomList.get(i).getArticle_child_category_id();

            CategoryCustom categoryCustom = categoryMapperCustom.getCategoryById(1, parentCategoryId);
            CategoryCustom categoryCustom2 = categoryMapperCustom.getCategoryById(1, childCategoryId);

            if (categoryCustom != null) {
                categoryCustomList.add(categoryCustom);
            }
            if (categoryCustom2 != null) {
                categoryCustomList.add(categoryCustom2);
            }

            articleListVo.setCategoryCustomList(categoryCustomList);

            //3、获得标签信息
            List<TagCustom> tagCustomList = new ArrayList<>();

            String tagIds = articleCustomList.get(i).getArticle_tag_ids();

            //防止该文章没有分类，空指针
            if (tagIds != null && tagIds != "") {
                String[] tagId = tagIds.split(",");
                for (int j= 0; j<tagIds.length();j++) {
                    Tag tag = tagMapper.selectByPrimaryKey(Integer.valueOf(tagId[j]));
                    //防止标签不存在，被删除
                    if (tag != null) {
                        TagCustom tagCustom = new TagCustom();
                        // tag is source  tagCustom is target
                        // Copy the property values of the given source bean into the target bean.
                        BeanUtils.copyProperties(tag, tagCustom);
                        tagCustomList.add(tagCustom);
                    }
                }
            }
            articleListVo.setTagCustomList(tagCustomList);


            //4、获得作者信息
            Integer userId = articleCustom.getArticle_user_id();

            User user = userMapper.selectByPrimaryKey(userId);
            UserCustom userCustom = new UserCustom();
            BeanUtils.copyProperties(user, userCustom);
            articleListVo.setUserCustom(userCustom);


            ArticleList.add(articleListVo);
        }

        return ArticleList;
    }
```


##Dao（Mapper）层：

###评论类
```
<sql id="comment_table_all_columns">
        comment_id,
        comment_pid,
        comment_pname,
        comment_article_id,
        comment_author_name,
        comment_author_email,
        comment_author_url,
        comment_content,
        comment_agent,
        comment_ip,
        comment_create_time,
        comment_role,
        comment_status
    </sql>
    
    <!--统计评论数-->
    <select id="countComment" parameterType="Integer" resultType="Integer">
        SELECT  count(*) from comment
        <where>
            <if test="status != null">
                comment_status=#{status}
            </if>
        </where>
    </select>

    <!--查询评论列表对象-->
    <select id="ListComment"  resultType="foreBlog.pojo.Custom.CommentCustom">
        SELECT  <include refid="comment_table_all_columns"/> from comment
        <where>
            <if test="status != null">
                comment_status=#{status}
            </if>
        </where>
        ORDER  BY  comment_id ASC
    </select>
```


###文章类
```
    <sql id="article_table_all_columns">
        article_id,
        article_user_id,
        article_title,
        article_content,
        article_parent_category_id,
        article_child_category_id,
        article_tag_ids,
        article_view_count,
        article_comment_count,
        article_like_count,
        article_post_time,
        article_update_time,
        article_is_comment,
        article_status,
        article_order
    </sql>
    <!--获得所有文章(文章归档)-->
    <select id="listArticle" parameterType="Integer" resultType="foreBlog.pojo.Custom.ArticleCustom">
        SELECT <include refid="article_table_all_columns"/> from article
        <where>
            <if test="status != null">
                article_status=#{status}
            </if>
        </where>
        order BY article_status ASC ,article_order desc, article_id DESC
    </select>

    <!--根据id查询文章信息-->
    <select id="getArticleById" parameterType="Integer" resultType="foreBlog.pojo.Custom.ArticleCustom">
        SELECT  * from article
        <where>
            article_id=#{id} AND
            <if test="status != null">
                article_status=#{status}
            </if>
        </where>
    </select>
```


###分类类

```
<sql id="category_table_all_column">
        category_id,category_pid,category_name,category_description,category_order,category_icon,category_status
    </sql>
   <!--根据分类id获得分类信息-->
    <select id="getCategoryById" parameterType="Integer" resultType="foreBlog.pojo.Custom.CategoryCustom">
        SELECT <include refid="category_table_all_column"/> from category
        <where>

            <if test="status != null">
                category_status=#{status}
            </if>
            and  category_id=#{id}
        </where>
    </select>
```


#登录和登录验证

##跳转登录
--

直接跳转
```
    @RequestMapping("login")
    public String login() {
        return "/Admin/login";
    }
```



##登录和登录验证
-------

这里使用了cookie

[![登录和登录验证.jpg](https://i.loli.net/2018/11/10/5be6ba3d90a53.jpg)](https://i.loli.net/2018/11/10/5be6ba3d90a53.jpg)



**思路：**

    1 提交用户名和密码
    2 创建map对象map
    3 根据密码和用户名进行查询返回user对象
    4 判断user对象是否为空
     4.1 要是空的，map放入键值对“code” 0，根据code，判断页面是否跳出用户名错误提示
     4.2 不为空，则map放入键值对“code” 1 ，判断页面直接跳转后台首页
    
    ***5 创建2个cookie对象，存放用户名和密码，设置保存时间***
    ***6 把cookie增加到request请求上***
    
    7 设置用户的最后登录时间
    8 设置用户的最后登录ip
    
    9 更新用户数据到数据库
    
    10 把map对象转换成json对象，然后json对象转换成string语句，返回string语句


###JSP页面
-----
自动读取cookie，在页面上写脚本

```
String username = "";
String password = "";
Cookie[] cookies = request.getCookies();
for(i =0; i < cookies.length();i++){
    if("username".equals(cookies[i].getName())) username = cookies[i].getValue();
    if("password".equals(cookies[i].getName())) password = cookies[i].getValue();
}
```


###控制层
---
```
    @RequestMapping(value = "/loginVerify", method = RequestMethod.POST)
    @ResponseBody
    public String loginVerify(HttpServletResponse response, HttpServletRequest request,
                              User user,
                              @RequestParam("username")String username,
                              @RequestParam("password")String pasword,
                              @RequestParam("rememberme")String rememberme) {

        Map<String, Object> map = new HashMap<String, Object>();

        User user2 = userService.getUserByNameOrEmail(username);

        if (user2 == null) {
            map.put("code", 0);
            map.put("msg", "用户名无效");
        } else if (!user2.getUser_pass().equals(pasword)) {
            map.put("code", 0);
            map.put("msg", "密码错误");
        } else {
            //登录成功,直接跳转到管理员首页页面/admin
            map.put("code", 1);
            map.put("msg", "");
            //添加session
            request.getSession().setAttribute("user", user2);
            //添加cookie
            if (rememberme != null) {
                //创建2个cookie对象
                Cookie namecookie = new Cookie("username", username);
                //设置Cookie的有效期为3天
                namecookie.setMaxAge(60 * 60 * 24 * 7);

                Cookie passwordCookie = new Cookie("password", pasword);
                passwordCookie.setMaxAge(60 * 60 * 24 * 7);

                response.addCookie(namecookie);
                response.addCookie(passwordCookie);
            }
            //用户最后登录时间
            user2.setUser_last_login_time(new Date());
            //用户最后登录ip
            user2.setUser_last_login_ip(getIpAddr(request));

            userService.updateUser(user2);

        }


        String result = new JSONObject(map).toString();
        return result;
    }
```

###User业务层
---

```
 @Override
    public User getUserByNameOrEmail(String str) {
        User user = userMapperCustom.getUserByNameOrEmail(str);
        return null;
    }

    @Override
    public void updateUser(User user2) {
        userMapper.updateByPrimaryKeySelective(user2);
    }
```


###Dao层
----

```
<select id="getUserByNameOrEmail" parameterType="String" resultType="foreBlog.pojo.User">
        SELECT * from `user`
        <where>
            user_name=#{value} OR  user_email=#{value}
        </where>
        AND  user_status>0 limit 1
    </select>
```


#退出登录

把session上的user属性进行删除

##控制层
---

```
@RequestMapping
```


	2018-11-07 09:16:33
kumika	SSM博客实战---后台功能实现2	# SSM博客实战---后台功能实现2

#文章管理


#后台文章列表显示


##控制层：
----
思路：

     * 1  创建modelAndView
     * 2  自己写死了每页的文章数量 pageSize = 30;
     * 3  根据参数 status=1， pageNow=null，pageSize 查询全部文章列表
     * 4  根据参数status=0，查询全部的草稿文章
     * 5  把返回的2个对象draftArticleList，和publishedArticleListVoList放入到modelAndView上
     * 6  配置访问的JSP====Admin/Article/index


```
    @RequestMapping("")
    public ModelAndView index() {
        ModelAndView modelAndView = new ModelAndView();

        //分页显示已发布文章
        Integer pageSize = 30;
        //根据页数查询文章列表
        List<ArticleListVo> publishedArticleListVoList = articleService.ListArticleByPage(1, null, pageSize);
        modelAndView.addObject("publishedArticleListVoList", publishedArticleListVoList);

        //不分页显示，草稿文章
        List<ArticleListVo> draftArticleList = articleService.ListArticleVo(0);
        modelAndView.addObject("draftArticleList", draftArticleList);
        modelAndView.setViewName("Admin/Article/index");
        return modelAndView;
    }
```


##业务层：
----
**文章业务层；**

[![显示后台全部文章.jpg](https://i.loli.net/2018/11/15/5bec6062083cd.jpg)](https://i.loli.net/2018/11/15/5bec6062083cd.jpg)

思路：

      1 创建文章总信息列表对象ArticleList，列表元素是单篇文章总信息对象articleListVo
      2 查询获得所有文章列表对象articleCustomList，列表元素单篇文章对象articleCustom
      3 for循环对articleListVo的4个属性填充，1 文章分类列表对象  2 单篇文章列表对象  3 作者信息对象  4 文章标签列表对象

        3.1  创建单篇文章总信息对象articleListVo（里面属性包括文章，文章标签，作者信息，文章分类对象）
        3.2  配合for循环的i变量从所有文章对象articleCustomList列表中拿出单篇文章对象articleCustom
        3.3  再把单篇文章对象articleCustom增加到单篇文章总信息对象articleListVo上

        3.4  创建文章分类列表对象categoryCustomList
        3.5  配合for循环的i变量从所有文章对象articleCustomList列表中出单篇文章对象articleCustom的父子分类id
        3.6  根据这2个分类id查询返回它们的分类对象categoryCustom，categoryCustom2
        3.7  判断分类对象是否为空，然后增加到文章分类列表对象categoryCustomList上
        3.8  再把categoryCustomList增加到单篇文章总信息对象articleListVo上

        3.9  创建文章标签列表对象tagCustomList
        3.10 配合for循环的i变量从所有文章对象articleCustomList列表中拿出单篇文章对象articleCustom的标签属性值：tagIds
        3.11 将tagIds分成String数组
        3.12 将使用for循环分别将标签数组内的Id 全部查询，返回全部的标签对象tag
        3.13 判断tag是否为空，不为空就创建文章标签对象tagCustom，使用BeanUtil的方法进行赋值给文章标签对象tagCustom
        3.14 将tagCustom增加到文章标签列表对象tagCustomList
        3.15 再把tagCustomList增加到单篇文章总信息对象articleListVo上

        3.16 创建用户信息对象UserCustom
        3.17 根据已经知道的配合i变量的单篇文章对象articleCustom，得到User的id
        3.18 根据用户id查询数据库，返回用户对象User
        3.19 使用BeanUtil的方法把user的所有属性赋值给UserCustom
        3.20 再把UserCustom增加到单篇文章总信息对象articleListVo上

        3.21  文章总信息列表对象ArticleList增加元素articleListVo，完成一次for循环

      4 返回文章总信息列表对象ArticleList


代码：
```
 public List<ArticleListVo> ListArticleVo(Integer status) {
        //文章总信息列表
        List<ArticleListVo> ArticleList = new ArrayList<ArticleListVo>();

        //获得文章信息列表（获得所有文章）
        List<ArticleCustom> articleCustomList = articleMapperCustom.listArticle(status);


        //获得分类信息
        for (int i = 0; i < articleCustomList.size(); i++) {
            //单篇文章总信息
            ArticleListVo articleListVo = new ArticleListVo();

            //1、将文章信息装到 单篇文章总信息articleListVoList 中
            ArticleCustom articleCustom = articleCustomList.get(i);
            articleListVo.setArticleCustom(articleCustom);

            //2、将分类信息装到 单篇文章总信息articleListVoList 中
            List<CategoryCustom> categoryCustomList = new ArrayList<>();

            Integer parentCategoryId = articleCustomList.get(i).getArticle_parent_category_id();
            Integer childCategoryId = articleCustomList.get(i).getArticle_child_category_id();

            CategoryCustom categoryCustom = categoryMapperCustom.getCategoryById(1, parentCategoryId);
            CategoryCustom categoryCustom2 = categoryMapperCustom.getCategoryById(1, childCategoryId);

            if (categoryCustom != null) {
                categoryCustomList.add(categoryCustom);
            }
            if (categoryCustom2 != null) {
                categoryCustomList.add(categoryCustom2);
            }

            articleListVo.setCategoryCustomList(categoryCustomList);

            //3、获得标签信息
            List<TagCustom> tagCustomList = new ArrayList<>();

            String tagIds = articleCustomList.get(i).getArticle_tag_ids();

            //防止该文章没有分类，空指针
            if (tagIds != null && tagIds != "") {
                String[] tagId = tagIds.split(",");
                for (int j= 0; j<tagId.length;j++) {
                    Tag tag = tagMapper.selectByPrimaryKey(Integer.valueOf(tagId[j]));
                    //防止标签不存在，被删除
                    if (tag != null) {
                        TagCustom tagCustom = new TagCustom();
                        // tag is source  tagCustom is target
                        // Copy the property values of the given source bean into the target bean.
                        BeanUtils.copyProperties(tag, tagCustom);
                        tagCustomList.add(tagCustom);
                    }
                }
            }
            articleListVo.setTagCustomList(tagCustomList);


            //4、获得作者信息
            Integer userId = articleCustom.getArticle_user_id();

            User user = userMapper.selectByPrimaryKey(userId);
            UserCustom userCustom = new UserCustom();
            BeanUtils.copyProperties(user, userCustom);
            articleListVo.setUserCustom(userCustom);


            ArticleList.add(articleListVo);
        }

        return ArticleList;
    }
```

##**Dao层：**
-----
**文章Dao层：**
```
    <!--获得所有文章(文章归档)-->
    <select id="listArticle" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT * from article
        <where>
            <if test="status != null">
                article_status=#{status}
            </if>
        </where>
        order BY article_status ASC ,article_order desc, article_id DESC
    </select>
```

**分类dao层；**

```
    <!--根据分类id获得分类信息-->
    <select id="getCategoryById" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.CategoryCustom">
        SELECT * from category
        <where>

            <if test="status != null">
                category_status=#{status}
            </if>
            and  category_id=#{id}
        </where>
    </select>
```





#文章分页显示

##控制层：
----

思路：

     * 注入页面动态的当前页数pageNow，
     * 如何获取，使用注解@PathVariable("pageNow")和@RequestMapping("/p/{pageNow}")
     * 1  创建modelAndView
     * 2  自己写死了每页的文章数量 pageSize = 30;
     * 3  根据参数 status=1， pageNow=动态当前页数，pageSize 查询全部文章列表
     * 4  根据参数status=0，查询全部的草稿文章
     * 5  把返回的2个对象draftArticleList，和publishedArticleListVoList放入到modelAndView上
     * 6  配置访问的JSP====Admin/Article/index

```
    @RequestMapping("/p/{pageNow}")
    @ResponseBody
    public ModelAndView ArticleListByPageView(@PathVariable("pageNow") Integer pageNow) {
        ModelAndView modelAndView = new ModelAndView();
        //分页显示已经发布文章
        Integer pageSize = 30;
        List<ArticleListVo> publishedArticleListVoList = articleService.ListArticleByPage(1, pageNow, pageSize);
        modelAndView.addObject("publishedArticleListVoList", publishedArticleListVoList);

        //不分页显示，草稿文章
        List<ArticleListVo> draftArticleList = articleService.ListArticleVo(0);
        modelAndView.addObject("draftArticleList", draftArticleList);
        modelAndView.setViewName("Admin/Article/index");
        return modelAndView;
    }
```


##业务层：
----
**文章业务层：**
思路：

[![文章分页显示.jpg](https://i.loli.net/2018/11/15/5bec6105007fa.jpg)](https://i.loli.net/2018/11/15/5bec6105007fa.jpg)

     *传入参数：文章的状态属性status, 当前页数pageNow， 每页的文章数量pageSize
     *
     * 1    创建文章总信息列表对象articleListVoList
     * 2    创建文章列表对象articleCustomList
     * 3    创建分页对象Page（实际作用是作为页面上的各种分页数据，整合到一个对象上，根据分页查询的时候，好调用分页数据）
     * 4    根据属性status查询该属性下的所有文章对象的数量totalCount
     * 5    判断当前页数是否为空pageNow, 若不为空，则创建分页，对象属性参数是totalCount，pageNow，pageSize
     * 5.1  根据创建的分页对象page查询文章列表对象articleCustomList
     *
     * 6    就是之前完成过的对文章列表的元素进行填充属性
     *
     * 7    当文章总信息列表对象articleListVoList的元素 多的时候，把分页对象page设置到列表对象的第一个元素上
     * 8    返回articleListVoList

**和上面的查询全部文章的差别在于pageNow的值**
```
    @Override
    public List<ArticleListVo> ListArticleByPage(Integer status, Integer pageNow, Integer pageSize) {
        List<ArticleListVo> articleListVoList = new ArrayList<>();


        //获得文章列表信息和分页信息
        List<ArticleCustom> articleCustomList = new ArrayList<>();
        Page page = null;
        int totalCount = articleMapperCustom.countArticle(status);
        if (pageNow != null) {
            page = new Page(totalCount, pageNow, pageSize);
            articleCustomList = articleMapperCustom.ListArticleByPage(status, page.getStartPos(), pageSize);
        } else {
            page = new Page(totalCount, 1, pageSize);
            articleCustomList = articleMapperCustom.ListArticleByPage(status, page.getStartPos(), pageSize);
        }

        //填充返回的文章列表对象的所有元素
        for (int i = 0;i < articleCustomList.size();i++) {
            ArticleListVo articleListVo = new ArticleListVo();

            ArticleCustom articleCustom = articleCustomList.get(i);

            List<CategoryCustom> categoryCustomList = new ArrayList<>();
            Integer parentCategoryId = articleCustom.getArticle_parent_category_id();
            Integer childCategoryId = articleCustom.getArticle_child_category_id();

            CategoryCustom categoryCustom = categoryMapperCustom.getCategoryById(status,parentCategoryId);
            CategoryCustom categoryCustom2 = categoryMapperCustom.getCategoryById(status, childCategoryId);

            if (categoryCustom != null) {
                categoryCustomList.add(categoryCustom);
            }
            if (categoryCustom2 != null) {
                categoryCustomList.add(categoryCustom2);
            }
            articleListVo.setCategoryCustomList(categoryCustomList);


            List<TagCustom> tagCustomList = new ArrayList<>();

            String tagIds = articleCustom.getArticle_tag_ids();
            if (tagIds != null && tagIds != "") {
                String[] tagId = tagIds.split(",");
                for (int j = 0; j < tagId.length;j++) {
                    Tag tag = tagMapper.selectByPrimaryKey(Integer.valueOf(tagId[j]));
                    if (tag != null) {
                        TagCustom tagCustom =  new TagCustom();
                        BeanUtils.copyProperties(tag, tagCustom);
                        tagCustomList.add(tagCustom);
                    }
                }
            }
            articleListVo.setTagCustomList(tagCustomList);

            User user = userMapper.selectByPrimaryKey(articleCustom.getArticle_user_id());
            UserCustom userCustom = new UserCustom();
            BeanUtils.copyProperties(user, userCustom);

            articleListVo.setUserCustom(userCustom);

            articleListVoList.add(articleListVo);
        }
        //当文章总信息列表对象articleListVoList的元素 多的时候，把分页对象page设置到列表对象的第一个元素上
        if (articleListVoList.size() > 0) {
            articleListVoList.get(0).setPage(page);
        }

        return articleListVoList;
    }
```


**##Dao层：**

**文章Dao层；**

```
    <!--/*获取文章总数*/-->
    <select id="countArticle" parameterType="Integer" resultType="Integer">
        SELECT  count(*) from article
        <where>
            <if test="status != null">
               article_status = #{status}
            </if>
        </where>
    </select>
    
    <!--  /*根据页数查询分页，==》分页显示()*/-->
    <select id="ListArticleByPage" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT * from article
        <where>
            <if test="status != null">
                article_status = #{status}
            </if>
        </where>
        Order BY  article_status ASC  ,article_id DESC  ,article_order DESC
        limit #{startPos},#{pageSize}
    </select>
```


#后台添加文章页面显示（显示）


##控制层：
----
思路：

     * 1   创建 ModelAndView
     * 2   根据status=1 查询分类列表对象categoryCustomList
     * 3   根据status=1 查询标签列表对象tagCustomList
     * 4   categoryCustomList，tagCustomList增加到ModelAndView
     * 5   ModelAndView写入跳转到到JSP======/Admin/Article/insert


```
    @RequestMapping("/insert")
    public ModelAndView insertArticleView() {
        ModelAndView modelAndView = new ModelAndView();

        //属于是写死的，不知道是不是正确的获得属性status
        //ServiceIMP还没有写, 泛型里面的类要是还有别的属性是不存在数据库的字段上的话，则根据要求填充
        List<CategoryCustom> categoryCustomList = categoryService.listCategory(1);
        List<TagCustom> tagCustomList = tagService.listTag(1);

        //Mapper还没有写
        modelAndView.addObject("categoryCustomList", categoryCustomList);
        modelAndView.addObject("tagCustomList", tagCustomList);

        modelAndView.setViewName("/Admin/Article/insert");
        return modelAndView;
    }
```


##业务层：
----

[![后台添加文章页面显示.jpg](https://i.loli.net/2018/11/15/5bec6229e420b.jpg)](https://i.loli.net/2018/11/15/5bec6229e420b.jpg)


###**分类业务层：**
思路：

     *  1       根据status查询分类对象categoryCustom，返回列表categoryCustomList
     *  2       因为分类对象存在一个数据库上表格没有的字段属性ArticleCount--分类下的文章数量，所以需要自己填充数据
     *  2.1     for循环遍历categoryCustomList，获取每一个分类id----categoryId
     *  2.2     categoryId和status作为参数，在文章Dao层创建一个
     *  根据分类id查询文章数量的方法countArticleByCategoryId（），返回文章数量count
     *  2.3     把count设置到分类对象categoryCustom上
     *  3       返回categoryCustomList

代码：
```
    public List<CategoryCustom> listCategory(Integer status) {
        List<CategoryCustom> categoryCustomList = categoryMapperCustom.listCategory(status);
        //查询该分类下的文章数量
        for (int i =0;i < categoryCustomList.size();i++) {
            Integer categoryId = categoryCustomList.get(i).getCategory_id();
            Integer count = articleMapperCustom.countArticleByCategoryId(status, categoryId);
            categoryCustomList.get(i).setArticleCount(count);
        }

        return categoryCustomList;
    }
```

###**标签业务层：**
思路：

     *      1       根据status查询分类对象tagCustom，返回列表tagCustomList
     *      2       因为tagCustom类的属性articleCount 是后面增加的，数据库没有该字段，所以要自己填充
     *      2.1     for循环遍历tagCustomList，获取每一个分类id----tagId
     *      2.2     tagId和status作为参数，在文章Dao层创建一个
     *  根据分类id查询文章数量的方法countArticleByTagId（），返回标签数量count
     *      2.3     把count设置到分类对象tagCustom上
     *      3       返回tagCustomList

代码：
```
    public List<TagCustom> listTag(Integer status) {

        List<TagCustom> tagCustomList = tagMapperCustom.listTag(status);
        //因为tagCustom类的属性articleCount 是自己后面增加的，所以要自己填充
        //属性articleCount是统计相同一个标签有多少篇文章，所以需要tagId作为参数，在article业务层的方法
        for (int i = 0; i< tagCustomList.size();i++) {
            Integer id = tagCustomList.get(i).getTag_id();
            Integer count = articleMapperCustom.countArticleByTagId(status, id);

            tagCustomList.get(i).setArticleCount(count);
        }
        return tagCustomList;
    }
```


##**Dao层：**
-----
###**文章Dao层：**

一定要注意，当查询的条件是**文字类条件的时候，用% %号，like作为关键字**

```
    <!--查询该分类下的文章数量-->
    <select id="countArticleByCategoryId" resultType="Integer">
        SELECT  count(*) from article
        <where>

            <if test="status != null">
                article_status=#{status}
            </if>
            AND
            article_parent_category_id
            OR
            article_child_category_id
        </where>
    </select>
    
    
    <!--统计该标签下有多少文章,-->
    <select id="countArticleByTagId" parameterType="Integer" resultType="Integer">
        SELECT count(*) from article
        <where>
            article_tag_id=#{id}
            OR  article_tag_id LIKE  "${id},%"
            OR  article_tag_id LIKE  "%,${id},%"
            OR  article_tag_id LIKE  "%,${id}"
            <if test="status != null">
                article_status = #{status}
            </if>
        </where>
    </select>

```

**分类Dao层；**
-------
```
   <!-- //获得分类列表-->
    <select id="listCategory" resultType="Com.zhihu.foreBlog.pojo.Custom.CategoryCustom">
        SELECT * from category
        <where>
            <if test="status != null">
                category_status =#{status}
            </if>
        </where>
        ORDER BY  category_status ASC ,category_order DESC ,category_id ASC
    </select>
```

#后台添加文章提交操作（包括提交草稿）


##控制层：
----

思路：

     * 1 注入页面提交上来的参数article
     * 2 设置article的一些自己增加的数据
     * 3 增加article到数据库上
     * 4 跳转到/admin/article
     *

```
    @RequestMapping(value = "/insertSubmit", method = RequestMethod.POST)
    public String insertArticleSubmit(Article article) {
        article.setArticle_post_time(new Date());
        article.setArticle_update_time(new Date());
        article.setArticle_is_comment(1);
        article.setArticle_view_count(0);
        article.setArticle_like_count(0);
        article.setArticle_comment_count(0);
        article.setArticle_status(1);
        article.setArticle_order(1);

        articleService.insertArticle(article);
        return "redirect:/admin/article";
    }
```


##业务层：
----


###**文章业务层：**


[![后台添加文章（包括草稿）.jpg](https://i.loli.net/2018/11/15/5bec627d3a086.jpg)](https://i.loli.net/2018/11/15/5bec627d3a086.jpg)

```
    public void insertArticle(Article article) {
        //不能为空，insert是可以有空数据
        articleMapper.insertSelective(article);
    }
```





#搜索实现(动态获得当前页数)

搜索全部的文章  与 在分页上搜索文章的差别：

**当前页数pageNow的值，分页是动态获取，搜索全部是pageNow=null的**
    搜索全部： @RequestMapping("/search")
     分页是动态获取： @RequestMapping("/p/{pageNow}/search")
##控制层：
----

**搜索全部的文章**

     * 1    注入4个参数：request，model，搜索提交的信息语句query
     * 2    根据这3个条件，加上自己写死的pageSize=30, status=1 ，pageNow= null，这6个变量作为文章业务层listSearchResultByPage方法的参数
     * 2.1  这6个搜索条件下，查询文章总信息列表对象articleSearchVoList，返回文章总信息列表对象
     * 3    articleSearchVoList增加到model和视图view上
     * 4    跳转到/Admin/Article/search


**在分页上搜索文章：**

     * 1    注入4个参数：request，model，动态当前页数pageNow，搜索提交的信息语句query
     * 2    根据这4个条件，加上自己写死的pageSize=30, status=1 这6个变量作为文章业务层listSearchResultByPage方法的参数
     * 2.1  这6个搜索条件下，查询文章总信息列表对象articleSearchVoList，返回文章总信息列表对象
     * 3    articleSearchVoList增加到model和视图view上
     * 4    跳转到/Admin/Article/search

```
    @RequestMapping("/p/{pageNow}/search")
    @ResponseBody
    public ModelAndView SearchPageByPageView(HttpServletRequest request, HttpServletResponse response,
                                             Model model, @PathVariable("pageNow") Integer pageNow,
                                             @RequestParam("query") String query) {
        ModelAndView modelAndView = new ModelAndView();
        int pageSize = 30;

        List<ArticleListVo> articleSearchVoList = articleService.listSearchResultByPage(1, request, model, pageNow, pageSize, query);
        modelAndView.addObject(articleSearchVoList);
        modelAndView.setViewName("/Admin/Article/search");

        return modelAndView;
    }
```


##业务层：
----
**文章业务层：**

[![搜索（动态分页）实现.jpg](https://i.loli.net/2018/11/15/5bec650ec3b17.jpg)](https://i.loli.net/2018/11/15/5bec650ec3b17.jpg)

思路：

     * 1    创建分页对象 Page = null，创建文章总信息列表articleSearchVoList
     * 2    创建单篇文章对象列表articleCustomList
     * 3    把条件query变量和status作为参数，查询getSearchResultCount方法（），该条件下有多少个结果，返回totalCount
     * 4    判断当前页数对象 pageNow，是否为空
     * 4.1  pageNow若不为空，则根据totalCount，pageNow,PageSize, 构建分页对象page
     * 4.2  根据status,query，page的选择记录的初始位置，pageSize，4个参数，
     * 查询方法listSearchResultByPage（），返回单篇文章对象列表articleCustomList
     *
     * 4.3  pageNow若是空的，则根据totalCount，pageNow = 1 ,PageSize，构建分页对象page
     * 4.4  根据status,query，page的选择记录的初始位置，pageSize，4个参数，
     * 查询方法listSearchResultByPage（），返回单篇文章对象列表articleCustomList
     *
     * 5    if判断搜索返回结果totalCount是否为0
     * 5.1  totalCount不为0，遍历单篇文章列表对象articleCustomList，
     * 执行对单篇文章总信息的4个属性（文章对象，分类对象，标签对象，User对象）的数据填充，
     * 完成后增加到articleSearchVoList
     *
     * 5.2  totalCount为0 ，创建一个文章总信息对象，作用是存储分页信息和查询关键字，
     * 完成后增加到articleSearchVoList
     *
     * 6    将查询到的关键字词和page信息存储到 文章总信息列表的第一个元素
     *
     * 7    返回articleSearchVoList

代码：

```
    @Override
    public List<ArticleListVo> listSearchResultByPage(Integer status, HttpServletRequest request, Model model, Integer pageNow, Integer pageSize, String query) {
        Page page = null;
        List<ArticleListVo> articleListVoList = new ArrayList<>();
        List<ArticleCustom> articleCustomList = new ArrayList<>();

        int totalCount = articleMapperCustom.getSearchResultCount(query,status);

        if (pageNow != null) {
            page = new Page(totalCount, pageNow, pageSize);
            articleCustomList = articleMapperCustom.listSearchResultByPage(status, query, page.getStartPos(), page.getPageSize());
        } else {
            page = new Page(totalCount, 1, pageSize);
            articleCustomList = articleMapperCustom.listSearchResultByPage(status, query, page.getStartPos(), page.getPageSize());
        }

        if (totalCount != 0) {
            for (int i=0; i < articleCustomList.size();i++) {
                ArticleListVo articleListVo = new ArticleListVo();
                ArticleCustom articleCustom = articleCustomList.get(i);


                List<CategoryCustom> categoryCustomList = new ArrayList<>();
                Integer categoryChildId = articleCustom.getArticle_child_category_id();
                Integer categoryParentId = articleCustom.getArticle_parent_category_id();


                CategoryCustom categoryCustom = categoryMapperCustom.getCategoryById(status,categoryChildId);
                CategoryCustom categoryCustom2 = categoryMapperCustom.getCategoryById(status, categoryParentId);

                if (categoryCustom != null) {
                    categoryCustomList.add(categoryCustom);
                }
                if (categoryCustom2 != null) {
                    categoryCustomList.add(categoryCustom2);
                }

                List<TagCustom> tagCustomList = new ArrayList<>();
                String ids = articleCustom.getArticle_tag_ids();
                String[] TagIds = ids.split(",");
                for (int j=0;j < TagIds.length;j++) {
                    Integer tagIds = Integer.valueOf(TagIds[j]);
                    Tag tag = tagMapper.selectByPrimaryKey(tagIds);
                    TagCustom tagCustom = null;
                    BeanUtils.copyProperties(tag,tagCustom);
                    tagCustomList.add(tagCustom);
                }

                UserCustom userCustom = null;
                Integer userId = articleCustom.getArticle_user_id();
                User user = userMapper.selectByPrimaryKey(userId);
                BeanUtils.copyProperties(user, userCustom);

                articleListVo.setArticleCustom(articleCustom);
                articleListVo.setCategoryCustomList(categoryCustomList);
                articleListVo.setTagCustomList(tagCustomList);
                articleListVo.setUserCustom(userCustom);

                articleListVoList.add(articleListVo);
            }

        } else {
            //不执行的话，也要创建一个元素，作用是存储分页信息和查询关键字
            ArticleListVo articleListVo = new ArticleListVo();
            articleListVoList.add(articleListVo);
        }
        //将查询到的关键字词和page信息存储到 文章总信息列表的第一个元素
        articleListVoList.get(0).setPage(page);
        articleListVoList.get(0).setQuery(query);

        return articleListVoList;
    }
```



##**Dao层：**
-----


###**文章Dao层：**

**要注意当前页数的意义，是作为开始查询的起始编号startPos进行查询，范围是pageSize，条件是status,query**

```
    <!--查询结果统计-->
    <select id="getSearchResultCount" resultType="Integer">
        select count(*) from article
        <where>
            <if test="status != null">
                article_status =#{status}
            </if>
            AND article_status > 0
            AND article_title LIKE "%${query}%"
            OR  article_content like "%${query}%"
        </where>
    </select>
    
    <!--根据分页的当前页数的开始编号startPos进行查询，范围是pageSize，条件是status,query-->
    <select id="listSearchResultByPage" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT * from article
        <where>
            <if test="status != null">
                article_status=#{status}
            </if>
            AND article_status > 0
            AND article_title like "%${query}%"
            OR article_content like "%${query}%"
        </where>
        ORDER  BY article_status ASC ,article_order DESC  , article_id DESC
        limit #{startPos},#{pageSize}
    </select>
```


###**分类Dao层：**

```
    <!--根据分类id获得分类信息-->
    <select id="getCategoryById" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.CategoryCustom">
        SELECT <include refid="category_table_all_column"/> from category
        <where>

            <if test="status != null">
                category_status=#{status}
            </if>
            and  category_id=#{id}
        </where>
    </select>
```


#单个和批量删除文章


##控制层：
----

思路：

     * 1   注入参数 删除的文章编号（可多个）ids
     * 2   将字符串的ids 分成String数组arr[]
     * 3   根据String数组arr[]的长度，创建Integer数组ids[]
     * 4   for循环将遍历ids[]，把全部的文章编号转换成Integer类型的
     * 5   调用ArticleService的批量删除方法deleteArticleBatch(Integer数组)

代码：
```
    //删除文章
    @RequestMapping("/delete/{id}")
    public void deleteArticle(@PathVariable("id") Integer id) {
        //调用service批量删除
        articleService.deleteArticle(id);
    }

    //批量删除文章
    @RequestMapping("/deleteBatch")
    public void deleteArticle(HttpServletRequest request) {
        String str = request.getParameter("ids");
        String[] arr = str.split(",");
        Integer[] ids = new Integer[arr.length];

        for (int i = 0; i < arr.length; i++) {
            ids[i] = Integer.valueOf(arr[i]);
        }
        //调用service批量删除
        articleService.deleteArticleBatch(ids);
    }

```

##业务层：
----

[![单个删除和批量删除.jpg](https://i.loli.net/2018/11/15/5bec661334dcb.jpg)](https://i.loli.net/2018/11/15/5bec661334dcb.jpg)

```
    //删除
    @Override
    public void deleteArticle(Integer id) {
        //调用service批量删除
        articleMapper.deleteByPrimaryKey(id);
    }
     //批量删除
    @Override
    public void deleteArticleBatch(Integer[] ids) {
        for (int i = 0;i < ids.length; i++) {
            articleMapper.deleteByPrimaryKey(ids[i]);
        }
    }
```





#编辑文章页面显示


##控制层：
----

思路：

     * 1    注入参数id
     * 2    根据id查询文章对象articleCustom
     * 3    根据status=1 查询分类列表对象categoryCustomList
     * 4    根据status=1 查询标签列表对象tagCustomList
     * 5    3个对象都增加到modelAndView
     * 6    modelAndView设置跳转到到JSP===Admin/Article/edit
代码：

```
    @RequestMapping("/edit/{id}")
    @ResponseBody
    public ModelAndView editArticleView(@PathVariable("id") Integer id) {
        ModelAndView modelAndView = new ModelAndView();

        ArticleCustom articleCustom = articleService.getArticleById(null, id);

        List<CategoryCustom> categoryCustomList = categoryService.listCategory(1);

        List<TagCustom> tagCustomList = tagService.listTag(1);


        modelAndView.addObject("articleCustom", articleCustom);
        modelAndView.addObject("categoryCustomList", categoryCustomList);
        modelAndView.addObject("tagCustomList", tagCustomList);

        modelAndView.setViewName("Admin/Article/edit");
        return modelAndView;
    }
```

##业务层：
----

[![编辑页面显示（先查询到文章才可以编辑啊）.jpg](https://i.loli.net/2018/11/15/5bec66133bab9.jpg)](https://i.loli.net/2018/11/15/5bec66133bab9.jpg)

```
    @Override
    public ArticleCustom getArticleById(Integer status, Integer id) {
        return articleMapperCustom.getArticleById(status, id);
    }
```


##**Dao层：**
-----
**文章dao层：**
```
    <!--根据id查询文章信息-->
    <select id="getArticleById" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT  * from article
        <where>
            article_id=#{id} AND
            <if test="status != null">
                article_status=#{status}
            </if>
        </where>
    </select>
```


**标签Dao层：**
```
    <!--获得标签列表-->
    <select id="listTag" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.TagCustom">
        SELECT  * from tag
        <where>
            <if test="status != null">
                tag_status = #{status}
            </if>
        </where>
        ORDER BY  tag_status ASC
    </select>
```

#编辑文章提交


##控制层：
----
思路：

     *  1   注入参数： 草稿文章对象articleCustom
     *  2   从articleCustom得到文章id
     *  3   设置articleCustom的更新时间属性为当前时间
     *  4   更新articleCustom对象到数据库上
     *  5   跳转到/admin/article

代码：

```
    //编辑文章提交
    @RequestMapping(value = "/editSubmit", method = RequestMethod.POST)
    public String editArticleSubmit(ArticleCustom articleCustom) {
        Integer id = articleCustom.getArticle_id();
        articleCustom.setArticle_update_time(new Date());
        articleService.updateArticle(id, articleCustom);
        return "redirect:/admin/article";
    }
```



##业务层：
----

[![提交编辑文章.jpg](https://i.loli.net/2018/11/15/5bec66133b4a6.jpg)](https://i.loli.net/2018/11/15/5bec66133b4a6.jpg)


思路：

     * 因为articleCustom是自己创建的对象，在数据库中没有表格的，
     * articleCustom是继承了article
     * 更新的时候是更新到article表格上（只是共有属性）
     
代码：

```
    @Override
    public void updateArticle(Integer id, Article article) {
        //添加业务校验，通常在service接口对关键
        article.setArticle_id(id);
        articleMapper.updateByPrimaryKeySelective(article);
    }
```




	2018-11-10 19:26:02
kumika	SSM博客实战---后台功能实现3	# SSM博客实战---后台功能实现3

#后台分类管理

    @Controller
    @RequestMapping("/admin/category")


#后台分类列表显示


##控制层：
思路：

     * 1    创建modelAndView对象
     * 2    查询分类总信息对象列表categoryCustomList，参数：null，方法ListCategory（）
     * 3    增加到 modelAndView上
     * 4    跳转到Admin/Category/index


代码：
```
    @RequestMapping("")//因为类的上面写了路径，这就不用了
    public ModelAndView categoryList() {
        ModelAndView modelAndView = new ModelAndView();

        List<CategoryCustom> categoryCustomList = categoryService.listCategory(null);
        modelAndView.addObject("categoryCustomList", categoryCustomList);

        modelAndView.setViewName("Admin/Category/index");
        return modelAndView;
    }
```


##业务层：

[![后台分类列表显示.jpg](https://i.loli.net/2018/11/16/5bee3fcc1e959.jpg)](https://i.loli.net/2018/11/16/5bee3fcc1e959.jpg)

**使用了2个业务对象，一个是分类，一个是文章**

思路：

     *  1       根据status查询分类对象categoryCustom，返回列表categoryCustomList
     *  2       因为分类对象存在一个数据库上表格没有的字段属性ArticleCount--分类下的文章数量，所以需要自己填充数据
     *  2.1     for循环遍历categoryCustomList，获取每一个分类id----categoryId
     *  2.2     categoryId和status作为参数，在文章Dao层创建一个
     *  根据分类id查询文章数量的方法countArticleByCategoryId（），返回文章数量count
     *  2.3     把count设置到分类对象categoryCustom上
     *  3       返回categoryCustomList


```
    @Override
    public List<CategoryCustom> listCategory(Integer status) {
        List<CategoryCustom> categoryCustomList = categoryMapperCustom.listCategory(status);
        //查询该分类下的文章数量
        for (int i =0;i < categoryCustomList.size();i++) {
            Integer categoryId = categoryCustomList.get(i).getCategory_id();
            //统计该分类下有多少文章
            Integer count = articleMapperCustom.countArticleByCategoryId(status, categoryId);
            categoryCustomList.get(i).setArticleCount(count);
        }

        return categoryCustomList;
    }
```



#后台添加分类提交

##控制层
思路：

     *  1   注入分类对象category
     *  2   把category插入到数据库上
     *  3   跳转redirect:/admin/category

代码：

```
    @RequestMapping(value = "/insertSubmit", method = RequestMethod.POST)
    public String insertCategorySubmit(Category category) {
        categoryService.insertCategory(category);
        return "redirect:/admin/category";
    }
```

##业务层

```
    public void insertCategory(Category category) {
        categoryMapper.insertSelective(category);
    }
```



#删除分类


##控制层

思路：

     * 使用@PathVariable注解动态获取Id
     *  1    方法注入动态获取删除目标的id
     *  2    统计该分类下有多少文章，查询该id下的文章数量，返回文章的数量
     *  3    根据id进行删除分类
     *  4     跳转redirect:/admin/category

代码：

```
    @RequestMapping("/delete/{id}")
    public String deleteCategory(@PathVariable("id") Integer id) {
        //禁止删除有文章的分类
        //-统计该分类下有多少文章
        int count = articleService.countArticleWithCategory(null, id);

        if (count == 0) {
            categoryService.deleteCategory(id);
        }
        return "redirect:/admin/category";
    }
```



##业务层

```
    public void deleteCategory(Integer id) {
        categoryMapper.deleteByPrimaryKey(id);
    }
```


#编辑分类页面显示



##控制层

思路：

     *  1       方法注入动态获取要编辑分类的id
     *  2       创建modelAndView 对象
     *  3       根据动态获取的Id和status=null作为参数，查询方法getCategoryById（），返回分类对象categoryCustom
     *  4       查询全部的分类对象，使用listCategory（）方法，返回分类对象列表categoryCustomList
     *  5       把2个对象都放入modelAndView上
     *  6       跳转"Admin/Category/edit"


代码：

```
    @RequestMapping("/edit/{id}")
    public ModelAndView editCategoryView(@PathVariable("id") Integer id) {
        ModelAndView modelAndView = new ModelAndView();

        CategoryCustom categoryCustom = categoryService.getCategoryById(null, id);

        List<CategoryCustom> categoryCustomList = categoryService.listCategory(null);

        modelAndView.addObject("categoryCustom", categoryCustom);
        modelAndView.addObject("categoryCustomList", categoryCustomList);

        modelAndView.setViewName("Admin/Category/edit");
        return modelAndView;
    }
```


##业务层

```
    //根据id查询分类信息
    @Override
    public CategoryCustom getCategoryById(Integer status, Integer id) {
        CategoryCustom categoryCustom = categoryMapperCustom.getCategoryById(status, id);
        return categoryCustom;
    }
```



#编辑分类提交


##控制层

思路：

     *   1      获取提交的编辑分类对象category
     *   2      更新到数据库上
     *   3      跳转redirect:/admin/category

代码：
```
    @RequestMapping(value = "/editSubmit", method = RequestMethod.POST)
    public String editCategorySubmit(Category category) {
        categoryService.updateCategory(category);
        return "redirect:/admin/category";
    }
```

##业务层


```
    @Override
    public void updateCategory(Category category) {
        categoryMapper.updateByPrimaryKeySelective(category);
    }
```




	2018-11-16 11:30:28
kumika	SSM博客实战---后台功能实现4	# SSM博客实战---后台功能实现4

```
@Controller
@RequestMapping("/admin/comment")
public class CommentController 
```

#后台评论列表显示


##控制层

思路：

     * 1     创建ModelAndView 对象，定死页面显示评论数量为30条
     * 2     根据status = null，pageNow= null,  pageSize 作为参数， 查询评论总信息对象CommentListVo，返回列表commentListVoList
     * 3     根据status = 0 作为参数，查询属性status=0的所有评论总信息对象CommentListVo， 返回列表hiddenCommentListVoList
     * 4     把这2个列表放到modelAndView上
     * 5     跳转路径Admin/Comment/index
     
     
代码：

```
    @RequestMapping("")
    public ModelAndView commentListView() {
        ModelAndView modelAndView = new ModelAndView();
        Integer pageSize = 30;

        //正常评论显示
        List<CommentListVo> commentListVoList = commentService.listCommentByPage(null, null, pageSize);
        
        //待审核评论不分页显示
        List<CommentListVo> hiddenCommentListVoList = commentService.ListCommentVo(0);

        modelAndView.addObject("commentListVoList", commentListVoList);
        modelAndView.addObject("hiddenCommentListVoList", hiddenCommentListVoList);
        modelAndView.setViewName("Admin/Comment/index");

        return modelAndView;
    }
```



##业务层

###**listCommentByPage方法的思路：**
---------------------------

[![查询评论.jpg](https://i.loli.net/2018/11/18/5bf13fa4e372f.jpg)](https://i.loli.net/2018/11/18/5bf13fa4e372f.jpg)

思路：
     
     *      根据3个参数，查询评论信息列表对象
     1      创建评论列表对象集合commentListVoList
     2      创建评论者信息对象集合commentCustomList，创建分页对象page
     3      根据status查找属性是status评论的评论数量，返回totalcount
     4      判断动态获取的当前页数pageNow是否为空
        4.1    pageNow不为空，根据totalcount，pageNow，pageSize，构建page对象，
     然后以status，page的startPos属性值，pagesize作为参数，查询评论对象，返回评论列表commentCustomList
        4.2    pageNow为空，则根据totalcount，pageNow = 1，pageSize，构建page对象，
     然后以status，page的startPos属性值，pagesize作为参数，查询评论对象，返回评论列表commentCustomList
     5       根据commentCustomList的长度使用for循环，填充每一个评论者信息
         5.1        创建单个评论信息对象 commentListVo
         5.2        根据commentListVo获取文章id，根据id查询文章对象articleCustom
         5.3        把文章填充到单个评论信息对象 commentListVo上

         5.4        根据commentListVo配合for循环的i变量获取评论者对象commentCustom
         5.5        根据email获取头像字符串avatar，借用function里的方法把字符串变换成头像
         5.6        把头像avatar填充到评论者对象commentCustom

         5.7        commentCustom填充到单个评论信息对象 commentListVo
         5.8        commentListVo填充到评论列表commentListVoList上，完成一次for循环

     6      判断commentListVoList的大小是否 >  0 ,要是大于0，则把分页page赋值在列表的第一个元素中
     7      返回commentListVoList


代码：
```
    public List<CommentListVo> listCommentByPage(Integer status, Integer pageNow, Integer pageSize) {
        //评论信息对象
        List<CommentListVo> commentListVoList = new ArrayList<>();
        //有头像的评论对象
        List<CommentCustom> commentCustomList = new ArrayList<>();

        Page page = null;
        int totalCount = commentMapperCustom.countComment(status);
        //获得评论列表分页
        if (pageNow != null) {
            page = new Page(totalCount, pageNow, pageSize);
            commentCustomList = commentMapperCustom.listCommentByPage(status, page.getStartPos(), pageSize);
        } else {
            page = new Page(totalCount, 1, pageSize);
            commentCustomList = commentMapperCustom.listCommentByPage(status, page.getStartPos(), pageSize);
        }

        for (int i=0;i<commentCustomList.size();i++) {
            CommentListVo commentListVo = new CommentListVo();
            //获取文章信息
            Integer articleId = commentCustomList.get(i).getComment_article_id();
            ArticleCustom articleCustom = articleMapperCustom.getArticleById(status, articleId);
            commentListVo.setArticleCustom(articleCustom);

            //评论信息
            CommentCustom commentCustom = commentCustomList.get(i);

            //评论者Gravatar头像
            String avatar = Functions.getGravatar(commentCustom.getComment_author_email());
            commentCustom.setCommentAuthorAvatar(avatar);
            commentListVo.setCommentCustom(commentCustom);

            commentListVoList.add(commentListVo);
        }
        if (commentListVoList.size() > 0) {
            //将Page信息存储在第一个元素中
            commentListVoList.get(0).setPage(page);
        }

        return commentListVoList;
    }
```


###**ListCommentVo的思路：**

     查询评论信息列表对象

     1 创建评论列表对象集合commentList
     2 创建评论者信息对象集合commentCustomList

     3 根据参数status，进行查询属性为status的所有评论对象CommentCustom，返回列表commentCustomList

     4 根据commentCustomList的长度使用for循环，填充每一个评论者信息
        4.1 创建单个评论信息对象 commentListVo
        4.2 根据commentListVo获取文章id，根据id查询文章对象articleCustom
        4.3 把文章填充到单个评论信息对象 commentListVo上

        4.4 根据commentListVo配合for循环的i变量获取评论者对象commentCustom
        4.5 根据email获取头像字符串avatar，借用function里的方法把字符串变换成头像
        4.6 把头像avatar填充到评论者对象commentCustom

        4.7 commentCustom填充到单个评论信息对象 commentListVo
        4.8 commentListVo填充到评论列表commentList上，完成一次for循环
     5 返回CommentList

代码：
```
    public List<CommentListVo> ListCommentVo(Integer status) {
        //评论信息列表对象集合
        List<CommentListVo> commentList = new ArrayList<>();

        //评论者信息对象集合，根据status查询全部评论对象
        List<CommentCustom> commentCustomList = commentMapperCustom.ListComment(status);

        for (int i= 0; i< commentCustomList.size();i++) {
            //单个评论信息对象
            CommentListVo commentListVo = new CommentListVo();
            //获得文章信息
            Integer articleId = commentCustomList.get(i).getComment_article_id();
            ArticleCustom articleCustom = articleMapperCustom.getArticleById(status, articleId);
            commentListVo.setArticleCustom(articleCustom);

            //评论者信息
            CommentCustom commentCustom = commentCustomList.get(i);

            //评论者的头像(根据email获得头像)
            String avatar = Functions.getGravatar(commentCustom.getComment_author_email());
            commentCustom.setCommentAuthorAvatar(avatar);
            commentListVo.setCommentCustom(commentCustom);
            commentList.add(commentListVo);
        }
        return commentList;
    }
```

##Dao层

注意根据页数查询的时候，

    select * from table limit m,n

**其中m是指记录开始的index，从0开始，表示第一条记录
n是指从第m+1条开始，取n条。**
```
    <!--根据页数获取评论-->
    <select id="listCommentByPage" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.CommentCustom">
        SELECT * from comment
        <where>
            <if test="status!= null">
                comment_status = #{status}
            </if>
        </where>
        ORDER by comment_status ASC ,comment_id DESC
        limit #{startPos},#{pageSize}
    </select>
    
    <!--查询评论列表对象-->
    <select id="ListComment"  resultType="Com.zhihu.foreBlog.pojo.Custom.CommentCustom">
        SELECT  <include refid="comment_table_all_columns"/> from comment
        <where>
            <if test="status != null">
                comment_status=#{status}
            </if>
        </where>
        ORDER  BY  comment_id ASC
    </select>
```




#后台评论分页显示
**适合RESTful**


##控制层

思路：

     * 动态获取当前页数pageNow, 使用注解@PathVariable
     *
     * 1     创建ModelAndView 对象，定死页面显示评论数量为30条
     * 2     根据status = null，pageNow= 动态获取的pageNow,  pageSize 作为参数， 查询评论总信息对象CommentListVo，返回列表commentListVoList
     * 3     根据status = 0 作为参数，查询属性status=0的所有评论总信息对象CommentListVo， 返回列表hiddenCommentListVoList
     * 4     把这2个列表放到modelAndView上
     * 5     跳转路径Admin/Comment/index

代码：

```
    @RequestMapping("p/{pageNow}")
    @ResponseBody
    public ModelAndView commentListByPageView(@PathVariable("pageNow") Integer pageNow) {
        ModelAndView modelAndView = new ModelAndView();
        Integer pageSize = 30;

        //全部评论分页显示
        List<CommentListVo> commentListVoList = commentService.listCommentByPage(null, pageNow, pageSize);

        //待审核评论不分页显示
        List<CommentListVo> hiddenCommentListVoList = commentService.ListCommentVo(0);
        
        modelAndView.addObject("commentListVoList", commentListVoList);
        modelAndView.addObject("hiddenCommentListVoList", hiddenCommentListVoList);
        modelAndView.setViewName("Admin/Comment/index");

        return modelAndView;
    }
```



#添加评论

##控制层
思路：

     *  页面提交评论对象comment
     *  1   对comment的创建时间进行赋值，为当前时间
     *  2   根据request 和  comment  作为参数，进行插入到数据库上
     *  3   因为评论增加了，所以要更新文章的评论数量，根据评论对象上的文章id，查询文章article
     *  4   根据文章的id进行更新文章的数据库数据，因为评论已经增加了，这时候在计算评论数量就会增加，
     *  相当于已知变量是评论数量，而现在不需要在方法中增加什么变量，只需要在数据库上统计就知道这个变量了

代码：

```
    @RequestMapping(value = "/insert", method = RequestMethod.POST)
    @ResponseBody
    public void insertComment(HttpServletRequest request, Comment comment) {
        //添加评论
        comment.setComment_create_time(new Date());
        commentService.insertComment(request, comment);

        //更新文章评论数
        Article article = articleService.getArticleById(null, comment.getComment_article_id());
        articleService.updateCommentCount(article.getArticle_id());
    }
```




##业务层

思路：

     *  1   从request上得到用户的Ip地址，然后制作成头像
     *  2   对comment对IP属性进行赋值
     *  3   更新到数据库


代码：
```
    @Override
    public void insertComment(HttpServletRequest request, Comment comment) {
        String IP = Functions.getIpAddr(request);
        comment.setComment_ip(IP);
        commentMapper.insertSelective(comment);
    }
```








#删除评论

##控制层

思路：

     * 方法注入 目标的id  动态获取@PathVariable
     *
     *  1       根据参数id查询评论对象comment
     *  2       根据参数id，删除评论
     *  3       因为评论可能有子评论，也要删除，所以根据id，获取子评论childComment, 返回列表childCommentList
     *  4       for循环遍历childCommentList，获取子评论的id，然后对子评论一个个的删除
     *  5       根据评论对象comment，获取文章的id，然后根据文章id，更新文章对象
     
代码：

```
    @RequestMapping("/delete/{id}")
    public void deleteComment(@PathVariable("id") Integer id) {
        Comment comment = commentService.getCommentById(id);

        //删除评论
        commentService.deleteComment(id);
        //删除其子评论
        List<Comment> childCommentList = commentService.listChildComment(id);
        for (int i = 0; i < childCommentList.size(); i++) {
            commentService.deleteComment(childCommentList.get(i).getComment_id());
        }

        //更新文章评论属性
        Article article = articleService.getArticleById(null, comment.getComment_article_id());
        articleService.updateCommentCount(article.getArticle_id());
    }
```


##业务层


```
    @Override
    public CommentCustom getCommentById(Integer id) {
        CommentCustom commentCustom = new CommentCustom();
        Comment comment = commentMapper.selectByPrimaryKey(id);
        BeanUtils.copyProperties(comment, commentCustom);
        return commentCustom;
    }
    @Override
    public void deleteComment(Integer id) {
        commentMapper.deleteByPrimaryKey(id);
    }
```


#编辑评论页面显示



##控制层

思路：

     *  动态获取id   @PathVariable，方法注入参数id
     *  1       创建ModelAndView
     *  2       根据id查找评论信息对象CommentCustom
     *  3       把comment Custom放入modelAndView上
     *  4       跳转Admin/Comment/edit

代码：

```
    @RequestMapping("/edit/{id}")
    public ModelAndView editCommentView(@PathVariable("id") Integer id) {
        ModelAndView modelAndView = new ModelAndView();

        CommentCustom commentCustom = commentService.getCommentById(id);

        modelAndView.addObject("commentCustom", commentCustom);
        modelAndView.setViewName("Admin/Comment/edit");
        return modelAndView;
    }
```


#编辑评论提交



##控制层

思路：

     *  网页提交comment
     *  1       更新comment到数据库上
     *  2       获取comment的id
     *  3       根据comment的属性status判断是否是屏蔽的评论（楼主提交屏蔽请求）
            3.1     status=0，是屏蔽评论，那就根据comment的id获取它的子评论，返回childCommentList
            3.2     for循环遍历childCommentList，把全部的子评论的status属性设置为0，然后更新评论

            3.3     status=1，不是屏蔽评论，那就根据comment的id获取它的子评论，返回childCommentList
            3.4     for循环遍历childCommentList，把全部的子评论的status属性设置为1，然后更新评论
     *  4       跳转redirect:/admin/comment

[![编辑评论提交.jpg](https://i.loli.net/2018/11/19/5bf196f2a0ff5.jpg)](https://i.loli.net/2018/11/19/5bf196f2a0ff5.jpg)

代码：

```
    @RequestMapping(value = "/editSubmit", method = RequestMethod.POST)
    public String editCommentSubmit(Comment comment) {
        commentService.updateComment(comment);
        Integer id = comment.getComment_id();
        //如果是屏蔽评论
        if (comment.getComment_status() == 0) {
            //屏蔽其子评论
            List<Comment> childCommentList = commentService.listChildComment(id);
            for (int i = 0; i < childCommentList.size(); i++) {
                Comment childComment = childCommentList.get(i);
                childComment.setComment_status(0);
                commentService.updateComment(comment);
            }
        }
        //如果是批准评论
        else {
            //批准其子评论
            List<Comment> childCommentList = commentService.listChildComment(id);
            for (int i = 0; i < childCommentList.size(); i++) {
                Comment childComment = childCommentList.get(i);
                childComment.setComment_status(1);
                commentService.updateComment(childComment);
            }
        }
        return "redirect:/admin/comment";
    }
```



##业务层

```
    @Override
    public void updateComment(Comment comment) {
        commentMapper.updateByPrimaryKeySelective(comment);
    }
    
    @Override
    public List<Comment> listChildComment(Integer id) {
        List<Comment> childCommentList = commentMapperCustom.listChildComment(id);
        return childCommentList;
    }
```


##Dao层

```
    <!--获取子评论-->
    <select id="listChildComment" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Comment">
        SELECT * from  comment  
        <where>
            comment_pid=#{id}
        </where>
    </select>
```



#批准评论


##控制层

[![批准评论.jpg](https://i.loli.net/2018/11/19/5bf19ea274704.jpg)](https://i.loli.net/2018/11/19/5bf19ea274704.jpg)

思路：

     * 动态获取id  @PathVariable  ，方法注入id
     * 1        根据id，获取评论comment
     * 2        对评论comment的status属性设置为1
     * 3        更新到数据库
     * 4        根据id，获取comment的子评论，返回列表childCommentList
     * 5        for循环遍历childCommentList，把全部的子评论的status属性设置为1，然后更新评论\
     * 6        因为评论更新了，所以文章的评论数量也要更新，所以根据comment的外键（文章id），获取文章article
     * 7        根据文章的id，对文章进行更新，更新到数据库


代码：

```
    @RequestMapping("/approve/{id}")
    public void approveComment(@PathVariable("id") Integer id) {
        Comment comment = commentService.getCommentById(id);
        //批准评论
        comment.setComment_status(1);
        commentService.updateComment(comment);
        //批准其子评论
        List<Comment> childCommentList = commentService.listChildComment(id);
        for (int i = 0; i < childCommentList.size(); i++) {
            Comment childComment = childCommentList.get(i);
            childComment.setComment_status(1);
            commentService.updateComment(childComment);
        }

        //更新文章的评论数量
        Article article = articleService.getArticleById(null, comment.getComment_article_id());
        articleService.updateCommentCount(article.getArticle_id());
    }
```

##业务层

文章业务层：

```
    //更新文章的评论数
    @Override
    public void updateCommentCount(Integer article_id) {
        articleMapperCustom.updateCommentCount(article_id);
    }
```



##Dao层

```
    <!--//更新文章的评论数-->
    <select id="updateCommentCount" parameterType="Integer">
        UPDATE article
        SET article_comment_count =
        (
            SELECT  count(*) from comment where article_id = comment_article_id AND comment_status= 1
        )
        where article_id=#{articleId}
    </select>
```




#屏蔽评论



##控制层

思路：

     * 动态获取id，  @PathVariable，方法注入id
     *  1       根据id获取评论对象comment
     *  2       设置评论comment的status为0，屏蔽状态
     *  3       更新comment到数据库
     *  4       根据id查询评论的子评论，返回列表childCommentList
     *  5       for循环遍历childCommentList，把全部的子评论的status属性设置为1，然后更新评论
     *  6       因为评论更新了，所以文章的评论数量也要更新，所以根据comment的外键（文章id），获取文章article
     *  7       根据文章的id，对文章进行更新，更新到数据库
    
代码：

```
    @RequestMapping("/hide/{id}")
    @ResponseBody
    public void hideComment(@PathVariable("id") Integer id) {
        Comment comment = commentService.getCommentById(id);

        //屏蔽评论
        comment.setComment_status(0);
        commentService.updateComment(comment);
        //屏蔽其子评论
        List<Comment> ChildCommentList = commentService.listChildComment(id);
        for (int i = 0; i < ChildCommentList.size(); i++) {
            Comment childComment = ChildCommentList.get(i);
            childComment.setComment_status(0);
            commentService.updateComment(childComment);
        }

        //更新文章子评论的数量

        //??????????????和上面的好像理解出现错误，多了个废变量
        Integer articleId = comment.getComment_article_id();
        Article article = articleService.getArticleById(null, articleId);
        articleService.updateCommentCount(articleId);
    }
```




#回复评论页面显示



##控制层

思路：

     *  动态获取id，  @PathVariable，方法注入id
     *  1       创建ModelAndView对象
     *  2       根据id获取评论对象commentCustom
     *  3       增加到modelAndView上
     *  4       跳转Admin/Comment/reply
     
     
代码：

```
    @RequestMapping("/reply/{id}")
    @ResponseBody
    public ModelAndView replyCommentView(@PathVariable("id") Integer id) {
        ModelAndView modelAndView = new ModelAndView();

        CommentCustom commentCustom = commentService.getCommentById(id);
        modelAndView.addObject("commentCustom", commentCustom);
        modelAndView.setViewName("Admin/Comment/reply");
        return modelAndView;
    }
```








#回复评论提交


##控制层

思路：

     *  方法提交评论comment，request
     *  1       从评论的属性articleId得到文章id   根据status，文章id作为参考，得到文章对象article
     *  2       从文章对象article得到评论数量comment_count，然后数量+1
     *  3       再设置到文章对象article上
     *  4       article更新到数据库上
     *  5       comment设置为当前时间，status设置为1
     *  6       comment增加到数据库上
     *  7       跳转redirect:/admin/comment

代码：

```
    @RequestMapping(value = "/replySubmit", method = RequestMethod.POST)
    public String replyCommentSubmit(HttpServletRequest request, Comment comment) {
        //文章评论数+1
        Article article = articleService.getArticleById(null, comment.getComment_article_id());
        article.setArticle_comment_count(article.getArticle_comment_count() + 1);
        articleService.updateArticle(article.getArticle_id(),article);
        //添加评论
        comment.setComment_create_time(new Date());
        comment.setComment_status(1);
        commentService.insertComment(request, comment);
        return "redirect:/admin/comment";
    }
```



##业务层

思路：

     *  1   从request上得到用户的Ip地址，然后制作成头像
     *  2   对comment对IP属性进行赋值
     *  3   更新到数据库

代码：
```
    public void insertComment(HttpServletRequest request, Comment comment) {
        String IP = Functions.getIpAddr(request);
        comment.setComment_ip(IP);
        commentMapper.insertSelective(comment);
    }
```





















	2018-11-18 17:26:55
kumika	SSM博客实战---后台功能实现5	# SSM博客实战---后台功能实现5


```
@Controller
@RequestMapping("/admin/link")
```


#后台连接列表显示


##控制层：

思路：

```
     *   1      创建ModelAndView
     *   2      查询全部的连接对象link， 方法listLink,  返回列表linkCustomList
     *   3      把linkCustomList增加到modelAndView上
     *   4      跳转路径Admin/Link/index
```
代码：
```
    @RequestMapping("")
    public ModelAndView linkList() {
        ModelAndView modelAndView = new ModelAndView();

        List<LinkCustom> linkCustomList = linkService.listLink(null);

        modelAndView.addObject("linkCustomList", linkCustomList);
        modelAndView.setViewName("Admin/Link/index");
        return modelAndView;
    }
```


##业务层：

Link的业务层 : 方法：listLink（status）
```
    @Override
    public List<LinkCustom> listLink(Integer status) {
        List<LinkCustom> linkList = linkMapperCustom.listLink(status);
        return linkList;
    }
```



##Dao层：

```
    <!--获取链接列表-->
    <select id="listLink" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.LinkCustom">
        SELECT * from link
        <where>
            <if test="status != null">
                link_status =#{status}
            </if>
        </where>
        ORDER BY link_status ASC ,link_order DESC ,link_id ASC
    </select>
```

#后台添加链接页面显示



##控制层：

主要目的： 是跳转到insert页面上，把对象也带到页面上

思路：
```
     *  1      创建ModelAndView
     *  2      查询全部的连接对象link， 方法listLink,  返回列表linkCustomList
     *  3      把linkCustomList增加到modelAndView上
     *  4      跳转路径Admin/Link/insert
```

代码：
```
    @RequestMapping("/insert")
    public ModelAndView insertLinkView() {
        ModelAndView modelAndView = new ModelAndView();

        List<LinkCustom> linkCustomList = linkService.listLink(null);

        modelAndView.addObject("linkCustomList", linkCustomList);
        modelAndView.setViewName("Admin/Link/insert");
        return modelAndView;
    }

```






#后台添加链接页面提交



##控制层：

思路：
```
     *      页面提交连接对象link
     * 1        方法注入link
     * 2        设置link的属性创建时间和更新时间，还有status属性为 1
     * 3        插入到数据库上
     * 4        跳转到redirect:/admin/link/insert
```
代码：
```
    @RequestMapping(value = "/insertSubmit", method = RequestMethod.POST)
    public String insertLinkSubmit(Link link) {
        link.setLink_create_time(new Date());
        link.setLink_update_time(new Date());
        link.setLink_status(1);
        linkService.insertLink(link);
        return "redirect:/admin/link/insert";
    }
```


##业务层：

link业务层： insertLink（link）

```
    @Override
    public void insertLink(Link link) {
        linkMapper.insertSelective(link);
    }
```



##Dao层：

因为使用的是Mybatis的自动生成代码，所以不写出来了



#删除链接

##控制层：
思路：

```
     *  动态获取id， @PathVariable
     *  1       方法注入id
     *  2       根据id进行删除
     *  3       跳转redirect:/admin/link
```

代码：
```
    @RequestMapping("/delete/{id}")
    @ResponseBody
    public String deleteLink(@PathVariable("id") Integer id) {
        linkService.deleteLink(id);
        return "redirect:/admin/link";
    }
```

##业务层：

link业务层：deleteLink(id)

```
    @Override
    public void deleteLink(Integer id) {
        linkMapper.deleteByPrimaryKey(id);
    }
```


##Dao层：

因为使用的是Mybatis的自动生成代码，所以不写出来了


#编辑链接页面显示


##控制层：

思路：因为页面上需要这2个对象，所以要查询得到它们，条件是什么呢？（id啊）

```
     *  动态获取id  @PathVariable
     *  1       方法注入id
     *  2       创建ModelAndView对象
     *  3       根据id查询链接对象LinkCustom
     *  4       根据id查询链接对象列表linkCustomList
     *  5       2个对象都增加到ModelAndView上
     *  6       跳转Admin/Link/edit
```

代码：
```
    @RequestMapping("/edit/{id}")
    @ResponseBody
    public ModelAndView editLinkView(@PathVariable("id") Integer id) {
        ModelAndView modelAndView = new ModelAndView();

        LinkCustom linkCustom = linkService.getLinkById(id);

        List<LinkCustom> linkCustomList = linkService.listLink(null);

        modelAndView.addObject("linkCustom", linkCustom);
        modelAndView.addObject("linkCustomList", linkCustomList);
        modelAndView.setViewName("Admin/Link/edit");
        return modelAndView;
    }
```


##业务层：

LInk业务层：getLinkById(id)

**因为数据库上表格是link类，而linkCustom 是自己创建的pojo类，所以查询返回的是link类，然后借用beanUtils进行赋值给linkCustom类**

```
    @Override
    public LinkCustom getLinkById(Integer id) {
        Link link = linkMapper.selectByPrimaryKey(id);
        LinkCustom linkCustom = new LinkCustom();
        BeanUtils.copyProperties(link, linkCustom);
        return linkCustom;
    }
```

##Dao层：

因为使用的是Mybatis的自动生成代码，所以不写出来了


#编辑链接提交

##控制层：

思路：
```
     * 网页提交链接对象link
     *  1    方法注入link
     *  2    设置link的更新时间属性为当前时间
     *  3    更新到数据库上
     *  4    跳转redirect:/admin/link
```

代码：
```
    @RequestMapping(value = "/editSubmit", method = RequestMethod.POST)
    public String editLinkSubmit(Link link) {
        link.setLink_update_time(new Date());
        linkService.updateLink(link);
        return "redirect:/admin/link";
    }
```

##业务层：

Link业务层：updateLink(link)

```
    @Override
    public void updateLink(Link link) {
        linkMapper.updateByPrimaryKeySelective(link);
    }
```


	2018-11-23 18:16:17
kumika	SSM博客实战---后台功能实现6	# SSM博客实战---后台功能实现6

#后台菜单列表显示

##控制层
思路：
```
     *  1       创建modelAndView
     *  2       查询全部的菜单对象，使用listMenu方法，参数为null, 返回对象列表  menuCustomList
     *  3       menuCustomList增加到modelAndView上
     *  4       跳转Admin/Menu/index
```
代码：

```
    @RequestMapping("")
    public ModelAndView menuList() {
        ModelAndView modelAndView = new ModelAndView();

        List<MenuCustom> menuCustomList = menuService.listMenu(null);

        modelAndView.addObject("menuCustomList", menuCustomList);
        modelAndView.setViewName("Admin/Menu/index");

        return modelAndView;
    }
```

##业务层

菜单业务层：listMenu(null)
```
    @Override
    public List<MenuCustom> listMenu(Integer status) {
        List<MenuCustom> menuCustomList = menuMapperCustom.listMenu(status);
        return menuCustomList;
    }
```

##dao层

```
    <!--获得菜单列表-->
    <select id="listMenu" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.MenuCustom">
        SELECT * from menu
        <where>
            <if test="status != null">
                menu_status=#{status}
            </if>
        </where>
        ORDER  BY menu_id ASC ,menu_order DESC ,menu_status ASC
    </select>
```


#添加菜单内容提交

##控制层

思路：
```
     *  1       网页提交菜单对象menu，注入方法
     *  2       menu设置属性status 为 1  ，order 为  1
     *  3       把menu增加到数据库上
     *  4       跳转redirect:/admin/menu
```
代码：

```
    @RequestMapping(value = "/insertSubmit", method = RequestMethod.POST)
    public String insertMenuSubmit(Menu menu) {
        menu.setMenu_status(1);
        menu.setMenu_order(1);
        menuService.insertMenu(menu);
        return "redirect:/admin/menu";
    }
```


##业务层

Menu业务层：insertMenu(menu)
```
    @Override
    public void insertMenu(Menu menu) {
        menuMapper.insertSelective(menu);
    }
```





#删除菜单内容

##控制层

思路：

    动态获得删除id
    执行删除
    跳转redirec:/admin/menu


代码：
```
    @RequestMapping("/delete/{id}")
    @ResponseBody
    public String deleteMenu(@PathVariable("id") Integer id) {
        menuService.deleteMenu(id);
        return "redirec:/admin/menu";
    }
```


##业务层

菜单业务层：deleteMenu(id)
```
    @Override
    public void deleteMenu(Integer id) {
        menuMapper.deleteByPrimaryKey(id);
    }
```






#编辑菜单内容显示


##控制层

思路：
```
     *  页面显示菜单内容，所以首先要查询，条件是id
     *  1       动态获得id，方法注入id
     *  2       创建modelAndView对象
     *  3       根据id查询菜单对象menu， 返回对象menuCustom
     *  4       查询全部的菜单对象，返回列表menuCustomList
     *  5       2个对象都增加到modelAndView上
     *  6       跳转Admin/Menu/edit
```

代码：
```
    @RequestMapping("/edit/{id}")
    @ResponseBody
    public ModelAndView editMenuView(@PathVariable("id") Integer id) {
        ModelAndView modelAndView = new ModelAndView();

        MenuCustom menuCustom = menuService.getMenuById(id);
        List<MenuCustom> menuCustomList = menuService.listMenu(null);

        modelAndView.addObject("menuCustom", menuCustom);
        modelAndView.addObject("menuCustomList", menuCustomList);
        modelAndView.setViewName("Admin/Menu/edit");

        return modelAndView;
    }
```

##业务层

菜单业务层：
**getMenuById(id)**
**listMenu(null)//前面写过 了**

```
    @Override
    public MenuCustom getMenuById(Integer id) {

        Menu menu = menuMapper.selectByPrimaryKey(id);

        MenuCustom menuCustom = new MenuCustom();
        BeanUtils.copyProperties(menu, menuCustom);
        return menuCustom;
    }
```





#编辑菜单内容提交


##控制层

思路：
```
     *   1       网页提交上来的菜单对象Menu,  注入方法
     *   2       更新到数据库
     *   3       跳转redirect:/admin/menu
```
代码：
```
    @RequestMapping(value = "/editSubmit", method = RequestMethod.POST)
    public String editMenuSubmit(Menu menu) {
        menuService.updateMenu(menu);
        return "redirect:/admin/menu";
    }
```


##业务层

```
    @Override
    public void updateMenu(Menu menu) {
        menuMapper.updateByPrimaryKeySelective(menu);
    }
```




#显示菜单内容

隐藏或者显示判断都是对象里面的一个属性，根据属性值是否是判断值，然后决定在页面上是否显示


##控制层

思路：
```
     *  1       动态获得id， 注入方法
     *  2       创建一个菜单对象menu
     *  3       根据注入的id，设置menu的id， 也设置status为 1 
     *  4       更新menu到数据库
```
代码：
```
    @RequestMapping(value = "/show/{id}", method = RequestMethod.POST)
    public void showMenu(@PathVariable("id") Integer id) {
        Menu menu = new Menu();

        menu.setMenu_id(id);
        menu.setMenu_status(1);
        menuService.updateMenu(menu);
    }
```






#隐藏菜单内容



##控制层

思路：
```
     *  1       动态获得id， 注入方法
     *  2       创建一个菜单对象menu
     *  3       根据注入的id，设置menu的id， 也设置status为 0
     *  4       更新menu到数据库
```

代码：
```
    @RequestMapping(value = "/hide/{id}", method = RequestMethod.POST)
    public void hideMenu(@PathVariable("id") Integer id) {
        Menu menu = new Menu();
        menu.setMenu_id(id);
        menu.setMenu_status(0);
        menuService.updateMenu(menu);
    }
```

	2018-11-23 18:51:12
kumika	SSM博客实战---后台功能实现7	# SSM博客实战---后台功能实现7





#后台公告列表显示


##控制层

思路：
```
     *   需求： 显示全部的公告
     *   1      创建ModelAndView 对象
     *   2      查询全部的公告，使用listNotice(null), 参数为null , 返回对象列表noticeCustomList
     *   3      noticeCustomList 增加到modelAndView上
     *   4      跳转Admin/Notice/index
```

代码：
```
    @RequestMapping("")
    public ModelAndView index() {
        ModelAndView modelAndView = new ModelAndView();

        List<NoticeCustom> noticeCustomList = noticeService.listNotice(null);

        modelAndView.addObject("noticeCustomList", noticeCustomList);
        modelAndView.setViewName("Admin/Notice/index");
        return modelAndView;
    }
```

##业务层

公告业务层：listNotice(null)
```
    @Override
    public List<NoticeCustom> listNotice(Integer status) {
        List<NoticeCustom> noticeCustomList = noticeMapperCustom.listNotice(status);
        return noticeCustomList;
    }
```


##Dao层

```
    <!--获取公告列表-->
    <select id="listNotice" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.NoticeCustom">
        SELECT * from notice
        <where>
            <if test="status != null">
                notice_status=#{status}
            </if>
        </where>
        ORDER BY notice_status ASC, notice_order DESC, notice_id ASC
    </select>
```


#添加公告显示


##控制层

其实作用就是跳转，就是跳转Admin/Notice/insert

```
    @RequestMapping("/insert")
    public ModelAndView insertNoticeView() {
        ModelAndView modelAndView = new ModelAndView();

        modelAndView.setViewName("Admin/Notice/insert");
        return modelAndView;
    }
```



#添加公告提交


##控制层
思路：
```
     *  1       网页上提交公告对象notice,  方法注入参数notice
     *  2       notice设置属性创建时间，更新时间 都为当前时间
     *  3       notice设置属性status  为  1 ， order  为  1  
     *  4       更新到数据库
     *  5       跳转redirect:/admin/notice
```
代码：

```
    @RequestMapping(value = "/insertSubmit", method = RequestMethod.POST)
    public String insertNoticeSubmit(Notice notice) {
        notice.setNotice_create_time(new Date());
        notice.setNotice_update_time(new Date());
        notice.setNotice_status(1);
        notice.setNotice_order(1);
        noticeService.insertNotice(notice);
        return "redirect:/admin/notice";
    }
```

##业务层

公告业务层：insertNotice(notice)
```
    @Override
    public void insertNotice(Notice notice) {
        noticeMapper.insertSelective(notice);
    }
```




#删除公告

##控制层

思路：


     *   动态获取id  
     *   1      方法注入
     *   2      执行删除

代码：

```
    @RequestMapping("/delete/{id}")
    public String deleteNotice(@PathVariable("id") Integer id) {
        noticeService.deleteNotice(id);
        return "redirect:/admin/notice";
    }
```


##业务层

公告业务层:  deleteNotice(id)
```
    @Override
    public void deleteNotice(Integer id) {
        noticeMapper.deleteByPrimaryKey(id);
    }
```


#编辑公告页面显示



##控制层

思路：
```
     * 动态获得id， 方法注入id
     *  1       创建modelAndView对象
     *  2       根据id查询公告对象noticeCustom
     *  3       noticeCustom增加到modelAndView上
     *  4       跳转Admin/Notice/edit
```
代码：
```
    @RequestMapping("/edit/{id}")
    public ModelAndView editNoticeView(@PathVariable("id") Integer id) {
        ModelAndView modelAndView = new ModelAndView();

        NoticeCustom noticeCustom = noticeService.getNoticeById(id);

        modelAndView.addObject("noticeCustom", noticeCustom);
        modelAndView.setViewName("Admin/Notice/edit");

        return modelAndView;
    }
```


##业务层

公告业务层：getNoticeById(id)

```
    @Override
    public NoticeCustom getNoticeById(Integer id) {
        Notice notice = noticeMapper.selectByPrimaryKey(id);
        NoticeCustom noticeCustom = new NoticeCustom();
        BeanUtils.copyProperties(notice, noticeCustom);
        return noticeCustom;
    }
```





#编辑公告提交


##控制层
思路：
```
     *  更新公告
     *  1       网页提交上的公告notice
     *  2       notice 设置 更新时间 为 当前时间
     *  3       更新到数据库
     *  4       跳转redirect:/admin/notice
```

代码：
```
    @RequestMapping(value = "/editSubmit", method = RequestMethod.POST)
    public String editNoticeSubmit(Notice notice) {
        notice.setNotice_update_time(new Date());
        noticeService.updateNotice(notice);
        return "redirect:/admin/notice";
    }
```


##业务层

```
    @Override
    public void updateNotice(Notice notice) {
        noticeMapper.updateByPrimaryKeySelective(notice);
    }
```

	2018-11-23 22:17:14
kumika	SSM博客实战---后台功能实现8	# SSM博客实战---后台功能实现8

#基本信息显示

##控制层
```
    @RequestMapping("")
    public ModelAndView index() {
        ModelAndView modelAndView = new ModelAndView();

        OptionsCustom optionsCustom = optionService.getOptions();

        modelAndView.addObject("optionsCustom", optionsCustom);
        modelAndView.setViewName("Admin/Options/index");
        return modelAndView;
    }
```

##业务层

```
    @Override
    public OptionsCustom getOptions() {
        Options options = optionsMapperCustom.getOptions();
        OptionsCustom optionsCustom = new OptionsCustom();

        if (options != null) {
            BeanUtils.copyProperties(options, optionsCustom);
        }
        return optionsCustom;
    }
```

##dao层

```
    <select id="getOptions" resultType="Com.zhihu.foreBlog.pojo.Options">
        select * from options limit 1
    </select>
```

#编辑基本信息显示


##控制层

```
    @RequestMapping("/edit")
    public ModelAndView editOptionView() {
        ModelAndView modelAndView = new ModelAndView();

        OptionsCustom optionsCustom = optionService.getOptions();

        modelAndView.addObject("optionsCustom", optionsCustom);
        modelAndView.setViewName("Admin/Options/edit");
        return modelAndView;
    }
```



#编辑基本信息提交



##控制层

思路：
```
     *  1       网页提交基本信息对象options
     *  2       查找基本总信息对象optionsCustom
     *  3       当 optionsCustom的id是空的时候，插入options对象
     *  4       当 optionsCustom的id存在的时候，更新options对象
     *  5       返回redirect:/admin/options
```


代码：
```
    @RequestMapping(value = "/editSubmit", method = RequestMethod.POST)
    public String editOptionsSubmit(Options options) {
        //如果记录不存在，那就新建
        OptionsCustom optionsCustom = optionService.getOptions();
        if (optionsCustom.getOption_id() == null) {
            optionService.insertOptions(options);
        } else {
            optionService.updateOptions(options);
        }

        return "redirect:/admin/options";
    }
```

##业务层

```
    @Override
    public void insertOptions(Options options) {
        optionMapper.insertSelective(options);
    }

    @Override
    public void updateOptions(Options options) {
        optionMapper.updateByPrimaryKeySelective(options);
    }
```



















	2018-11-23 23:04:08
kumika	SSM博客实战---后台功能实现9	# SSM博客实战---后台功能实现9

```
@Controller
@RequestMapping("/admin/page")
```

#后台页面列表显示


##控制层：

思路：  

**查询全部的分页**

```
    @RequestMapping("")
    public ModelAndView index() {
        ModelAndView modelAndView = new ModelAndView();
        List<PageCustom> pageCustomList = pageService.listPage(null);

        modelAndView.addObject("pageCustomList", pageCustomList);
        modelAndView.setViewName("Admin/Page/index");
        return modelAndView;
    }
```

##业务层：

分页业务层：listPage(null)

```
    @Override
    public List<PageCustom> listPage(Integer status) {
        List<PageCustom> pageCustomList = pageMapperCustom.listPage(status);
        return pageCustomList;
    }
```


##dao层：

```
    <select id="listPage" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.PageCustom">
        select * from page
        <where>
            <if test="status != null">
                page_status = #{status}
            </if>
        </where>
    </select>
```

#后台添加页面页面显示

##控制层：


跳转
```
    @RequestMapping("/insert")
    public ModelAndView insertPageView() {
        ModelAndView modelAndView = new ModelAndView();

        modelAndView.setViewName("Admin/Page/index");
        return modelAndView;
    }

```


#后台添加页面提交操作



##控制层：
思路：
```
     *  1       提交上来分页page
     *  2       根据page的key属性查询数据库是否存在，并且返回对象checkPage
     *  3       若对象checkPage为空，则设置创建时间，更新时间，status属性值为 1  ，然后增加到数据库
     *  4       跳转redirect:/admin/page
```

代码：
```
    @RequestMapping(value = "/insertSubmit", method = RequestMethod.POST)
    public String insertPageSubmit(Page page) {

        PageCustom checkPage = pageService.getPageByKey(null, page.getPage_key());
        //判断别名是否存在
        if (checkPage == null) {
            page.setPage_create_time(new Date());
            page.setPage_update_time(new Date());
            page.setPage_status(1);
            pageService.insertPage(page);
        }
        return "redirect:/admin/page";
    }
```



##业务层：

分页业务层：
根据id，Key查询分页：getPageByKey(null, page.getPage_key())
```
    @Override
    public PageCustom getPageById(Integer id) {
        Page page = pageMapper.selectByPrimaryKey(id);
        PageCustom pageCustom = new PageCustom();

        BeanUtils.copyProperties(page, pageCustom);

        return pageCustom;
    }
```

增加分页：insertPage(page)
```
    @Override
    public void insertPage(Page page) {
        pageMapper.insertSelective(page);
    }
```


#删除页面


##控制层：

动态获取id，然后进行删除
```
    @RequestMapping("/delete/{id}")
    public String deletePage(@PathVariable("id") Integer id) {
        pageService.deletePage(id);
        return "redirect:/admin/page";
    }
```

##业务层：

```
    @Override
    public void deletePage(Integer id) {
        pageMapper.deleteByPrimaryKey(id);
    }
```



#编辑页面页面显示


##控制层：
动态获取id

根据id 查询分页对象，然后跳转到编辑页面
```
    @RequestMapping("/edit/{id}")
    public ModelAndView editPageView(@PathVariable("id") Integer id) {
        ModelAndView modelAndView = new ModelAndView();

        PageCustom pageCustom = pageService.getPageById(id);

        modelAndView.addObject("pageCustom", pageCustom);
        modelAndView.setViewName("Admin/Page/edit");
        return modelAndView;
    }
```





#编辑页面提交


##控制层：
思路：
```
     * 1        提交编辑后的page
     * 2        根据page的key属性查询数据库是否存在，并且返回对象checkPage
     * 3        判断checkpage，是否与提交上来的Page的id相同
     * 4        假如相同，则设置checkpage的更新时间属性 ，为当前时间
     * 5        更新到数据库
     * 6        跳转redirect:/admin/page
```
代码：
```
    @RequestMapping(value = "/editSubmit", method = RequestMethod.POST)
    public String editPageSubmit(Page page) {
        PageCustom checkPage = pageService.getPageByKey(null, page.getPage_key());
        //判断别名是否存在且不是这篇文章
        if (checkPage.getPage_id() == page.getPage_id()) {
            page.setPage_update_time(new Date());
            pageService.updatePage(page);
        }
        return "redirect:/admin/page";
    }
```

##业务层：

分页业务层:

getPageByKey(null, page.getPage_key())
```
    @Override
    public PageCustom getPageByKey(Integer status, String key) {
        PageCustom pageCustom = pageMapperCustom.getPageByKey(status, key);
        return pageCustom;
    }

```

updatePage(page)
```
    @Override
    public void updatePage(Page page) {
        pageMapper.updateByPrimaryKeySelective(page);
    }
```

##dao层：

```
    <!--根据key获得-->
    <select id="getPageByKey" resultType="Com.zhihu.foreBlog.pojo.Custom.PageCustom">
        select * from page
        <where>
            <if test="status != null">
                page_status = #{status} AND
            </if>
            page_key=#{key}
        </where>
    </select>
```


	2018-11-24 00:39:34
kumika	SSM博客实战---后台功能实现10	# SSM博客实战---后台功能实现10





#后台标签列表显示


##控制层
查询全部的标签
```
    @RequestMapping("")
    public ModelAndView index() {
        ModelAndView modelAndView = new ModelAndView();

        List<TagCustom> tagCustomList = tagService.listTag(null);

        modelAndView.addObject("tagCustomList", tagCustomList);
        modelAndView.setViewName("Admin/Tag/index");
        return modelAndView;
    }
```
##业务层

 **标签业务层：listTag(null)**
思路：
```
     *      1       根据status查询分类对象tagCustom，返回列表tagCustomList
     *      2       因为tagCustom类的属性articleCount 是后面增加的，数据库没有该字段，所以要自己填充
     *      2.1     for循环遍历tagCustomList，获取每一个分类id----tagId
     *      2.2     tagId和status作为参数，在文章Dao层创建一个
     *  根据分类id查询文章数量的方法countArticleByTagId（），返回标签数量count
     *      2.3     把count设置到分类对象tagCustom上
     *      3       返回tagCustomList
```
代码：
```
    @Override
    public List<TagCustom> listTag(Integer status) {

        List<TagCustom> tagCustomList = tagMapperCustom.listTag(status);
        //因为tagCustom类的属性articleCount 是自己后面增加的，所以要自己填充
        //属性articleCount是统计相同一个标签有多少篇文章，所以需要tagId作为参数，在article业务层的方法
        for (int i = 0; i< tagCustomList.size();i++) {
            Integer id = tagCustomList.get(i).getTag_id();
            Integer count = articleMapperCustom.countArticleByTagId(status, id);

            tagCustomList.get(i).setArticleCount(count);
        }
        return tagCustomList;
    }
```





##Dao层

**标签Dao层：listTag(status)**
```
    <!--获得标签列表-->
    <select id="listTag" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.TagCustom">
        SELECT  * from tag
        <where>
            <if test="status != null">
                tag_status = #{status}
            </if>
        </where>
        ORDER BY  tag_status ASC
    </select>
```


**文章DAO层：countArticleByTagId(status, id)**
```
    <!--查询该分类下的文章数量-->
    <select id="countArticleByCategoryId" resultType="Integer">
        SELECT  count(*) from article
        <where>

            <if test="status != null">
                article_status=#{status}
            </if>
            AND
            article_parent_category_id
            OR
            article_child_category_id
        </where>
    </select>
```



#后台添加分类页面显示



##控制层

跳转到标签首页

```
    @RequestMapping(value = "/insertSubmit", method = RequestMethod.POST)
    public String insertTagSubmit(Tag tag) {
        tagService.insertTag(tag);
        return "redirect:/admin/tag";
    }
```




#删除标签



##控制层
**动态获取id, 查询标签是否存在文章，返回数量，要是数量=0，进行删除**

```
    @RequestMapping("/delete/{id}")
    public String deleteTag(@PathVariable("id") Integer id) {
        //禁止删除有文章的分类
        int count = articleService.countArticleWithTag(null, id);
        if (count == 0) {
            tagService.deleteTag(id);
        }
        return "redirect:/admin/tag";
    }
```

##业务层

```
    @Override
    public void deleteTag(Integer id) {
        tagMapper.deleteByPrimaryKey(id);
    }
```





#编辑标签页面显示


##控制层

思路：
```
     * 带着对象跳转到显示网页上，动态获取id，注入方法
     * 1        创建modelAndView对象
     * 2        根据id查询标签对象tag
     * 3        查询全部的标签对象，返回标签列表tagCustomList
     * 4        2个对象都增加到modelAndView上
     * 5        跳转Admin/Tag/edit
```
代码:
```
    @RequestMapping("/edit/{id}")
    public ModelAndView editTagView(@PathVariable("id") Integer id) {
        ModelAndView modelAndView = new ModelAndView();

        TagCustom tagCustom = tagService.getTagById(id);
        List<TagCustom> tagCustomList = tagService.listTag(null);

        modelAndView.addObject("tagCustom", tagCustom);
        modelAndView.addObject("tagCustomList", tagCustomList);

        modelAndView.setViewName("Admin/Tag/edit");
        return modelAndView;
    }
```

##业务层

标签业务层：getTagById(id)

```
    @Override
    public TagCustom getTagById(Integer id) {
        Tag tag = tagMapper.selectByPrimaryKey(id);
        TagCustom tagCustom = new TagCustom();
        BeanUtils.copyProperties(tag, tagCustom);
        return tagCustom;
    }
```







#编辑标签提交


##控制层

网页提交上来对象，进行更新
```
    @RequestMapping(value = "/editSubmit", method = RequestMethod.POST)
    public String editTagSubmit(Tag tag) {
        tagService.updateTag(tag);
        return "redirect:/admin/tag";
    }
```


##业务层
```
    @Override
    public void updateTag(Tag tag) {
        tagMapper.updateByPrimaryKeySelective(tag);
    }
```

	2018-11-24 09:00:58
kumika	SSM博客实战---后台功能实现11	# SSM博客实战---后台功能实现11


#后台用户列表显示


##控制层：

思路：
查询全部的用户信息

```
    @RequestMapping("")
    public ModelAndView userList() {
        ModelAndView modelAndView = new ModelAndView();

        List<UserCustom> userCustomList = userService.listUser();

        modelAndView.addObject("userCustomList", userCustomList);
        modelAndView.setViewName("Admin/User/index");
        return modelAndView;
    }
```

##业务层：

###用户业务层:listUser()
----------------

**查询完了用户信息后，还要统计一下每个用户有多少篇文章数量，所以要使用文章业务层countArticleByUser(userCustomList.get(i).getUser_id())**

```
    @Override
    public List<UserCustom> listUser() {

        List<UserCustom> userCustomList = userMapperCustom.listUser();
        for(int i=0;i<userCustomList.size();i++) {
            Integer articleCount = userMapperCustom.countArticleByUser(userCustomList.get(i).getUser_id());
            userCustomList.get(i).setArticleCount(articleCount);
        }
        return userCustomList;
    }
```


**文章业务层：countArticleByUser(userCustomList.get(i).getUser_id())**
```
    //<!--统计该分类下有多少文章-->
    @Override
    public int countArticleWithCategory(Integer status, Integer id) {
        int count = articleMapperCustom.countArticleWithCategory(status, id);
        return count;
    }
```


##Dao层：
用户dao层：
```
    <select id="listUser" resultType="Com.zhihu.foreBlog.pojo.Custom.UserCustom">
        select * from `user` ORDER BY user_status ASC
    </select>
```

文章Dao层：
```
    <select id="countArticleByUser" resultType="Integer">
        SELECT COUNT(*) from article
        <where>
            ariticle_user_id =#{id}
        </where>
    </select>
```


#后台添加用户页面显示


##控制层：

跳转的作用

```
    @RequestMapping("/insert")
    public ModelAndView insertUserView() {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("Admin/User/insert");
        return modelAndView;
    }
```


#检查用户名称

##控制层：

思路：
```
     *   1      获取提交上来的用户名userName，和id
     *   2      根据用户名查找用户对象User， 创建Map对象
     *   3      把id转换成int类型
     *   4      判断user是否为空，user不为空则设置提示用户名已经存在，code的值为 1 
     *   5      user为空，则设置提示为0，code的值为 0 
     *   6      把map转换成json,然后再把json转换成String类型
     *   7      返回json
```
代码：
```
    @RequestMapping(value = "/checkUserName", method = RequestMethod.POST)
    @ResponseBody
    public String checkUserName(HttpServletRequest request) {

        Map<String, Object> map = new HashMap<>();

        String username = request.getParameter("username");
        User user = userService.getUserByName(username);

        int id = Integer.valueOf(request.getParameter("id"));
        //用户名已存在,但不是当前用户(编辑用户的时候，不提示)
        if (user != null) {
            if (user.getUser_id() != id) {
                map.put("code", 1);
                map.put("msg", "用户名已存在！");
            }
        } else {
            map.put("code", 0);
            map.put("msg", 0);
        }
        String result = new JSONObject(map).toString();
        return result;
    }
```
##业务层：

用户业务层:getUserByName(username)
```
    @Override
    public User getUserByName(String username) {
        User user = userMapperCustom.getUserByName(username);
        return user;
    }
```



##Dao层：

```
    <select id="getUserByName" resultType="Com.zhihu.foreBlog.pojo.User">
        SELECT * from `user`
        <where>
            user_name=#{username}
        </where>
        limit 1
    </select>
```


#检查用户邮箱


##控制层：
思路：
```
     *   1      获取提交上来的邮箱Email，和id
     *   2      根据Email查找用户对象User， 创建Map对象
     *   3      把id转换成int类型
     *   4      判断User是否为空，user不为空则设置提示Email已经存在，code的值为 1
     *   5      user为空，则设置提示为0，code的值为 0
     *   6      把map转换成json,然后再把json转换成String类型
     *   7      返回json
```
代码：
```
    @RequestMapping(value = "/checkUserEmail", method = RequestMethod.POST)
    @ResponseBody
    public String checkUserEmail(HttpServletRequest request) {
        Map<String, Object> map = new HashMap<>();
        String email = request.getParameter("email");
        User user = userService.getUserByEmail(email);
        int id = Integer.valueOf(request.getParameter("id"));
        //用户名已存在,但不是当前用户(编辑用户的时候，不提示)
        if (user != null) {
            if (user.getUser_id() != id) {
                map.put("code", id);
                map.put("msg", "电子邮箱已存在！");
            }
        } else {
            map.put("code", 0);
            map.put("msg", "");
        }
        String result = new JSONObject(map).toString();
        return result;
    }
```
##业务层：

```
    @Override
    public User getUserByEmail(String email) {
        User user = userMapperCustom.getUserByEmail(email);
        return user;
    }
```

##Dao层：

```
    <select id="getUserByEmail" resultType="Com.zhihu.foreBlog.pojo.User">
        select * from `user`
        <where>
            user_eamil=#{email}
        </where>
        limit 1
    </select>
```


#后台添加用户页面提交


##控制层：
思路：
```
     *  页面提交user对象
     *  1       根据user的用户名username查询user对象user2
     *  2       根据user的邮箱Email查询user对象user3
     *  3       判断2个对象是否同时为空，都为空则进行设置user的属性：注册时间为当前时间，status = 1，最后增加到数据库 
     *  4       返回redirect:/admin/user
```

代码：
```
    @RequestMapping(value = "/insertSubmit", method = RequestMethod.POST)
    public String insertUserSubmit(User user) {
        User user2 = userService.getUserByName(user.getUser_name());
        User user3 = userService.getUserByEmail(user.getUser_email());

        if (user2 == null && user3 == null) {
            user.setUser_register_time(new Date());
            user.setUser_status(1);
            userService.insertUser(user);
        }
        return "redirect:/admin/user";
    }
```

##业务层：

用户业务层：insertUser(user)
```
    @Override
    public void insertUser(User user) {
        userMapper.insertSelective(user);
    }
```





#删除用户


##控制层：

```
    @RequestMapping("/delete/{id}")
    public String deleteUser(@PathVariable("id") Integer id) {
        userService.deleteUser(id);
        return "redirect:/admin/user";
    }
```


##业务层：

```
    @Override
    public void deleteUser(Integer id) {
        userMapper.deleteByPrimaryKey(id);
    }
```



#编辑用户页面显示



##控制层：
思路：
**动态获取id， 获得对象，然后跳转到目标页面**

```
    //编辑用户页面显示
    @RequestMapping("/edit/{id}")
    public ModelAndView editUserView(@PathVariable("id") Integer id) {
        ModelAndView modelAndView = new ModelAndView();

        UserCustom userCustom = userService.getUserById(id);

        modelAndView.addObject("userCustom", userCustom);
        modelAndView.setViewName("Admin/User/edit");
        return modelAndView;
    }
```


##业务层：

用户业务层:
getUserById(id)
```
    @Override
    public UserCustom getUserById(Integer id) {
        User user = userMapper.selectByPrimaryKey(id);
        UserCustom userCustom = new UserCustom();
        BeanUtils.copyProperties(user, userCustom);
        return userCustom;
    }
```




#编辑用户提交


##控制层：

思路：  把提交上来的对象，更新，然后跳转
```
    //编辑用户提交
    @RequestMapping(value = "/editSubmit", method = RequestMethod.POST)
    public String editUserSubmit(User user) {
        userService.updateUser(user);
        return "redirect:/admin/user";
    }
```


##业务层：

    @Override
    public void updateUser(User user2) {
        userMapper.updateByPrimaryKeySelective(user2);
    }





#基本信息页面显示



##控制层：

思路：     
     
     * 动态获取id
     * 1        根据id查询对象User
     * 2        增加到modelAndView上
     * 3        跳转Admin/User/profile
     
```
    @RequestMapping("/profile/{id}")
    public ModelAndView userProfileView(@PathVariable("id") Integer id) {
        ModelAndView modelAndView = new ModelAndView();

        UserCustom userCustom = userService.getUserById(id);

        modelAndView.addObject("userCustom", userCustom);
        modelAndView.setViewName("Admin/User/profile");
        return modelAndView;
    }
```



	2018-11-24 10:50:27
kumika	SSM博客实战---前台功能实现1	# SSM博客实战---前台功能实现1


#文章详情页显示


##控制层

思路：

     * 动态获取文章articleid
     *  1       创建ModelAndView 对象
     *  2       创建文章详细信息对象articleDetailVo， 然后根据id查找articleDetailVo，方法getArticleDetailById(articleId)
     *  
     *  3       判断articleDetailVo是否为空
     *  3.1     不为空， articleDetailVo增加到modelAndView上
     *  3.1.2           根据文章id和status= 1 查询获得文章，在文章的属性上获取上级分类id--parentCategoryId，下级分类id--childCategoryId
     *  3.1.3           查询相类似的文章，返回文章列表similarArticleList， 4个参数：status= 1，2个分类的id，返回限制数量5个 ，方法listArticleWithSameCategory
     *  3.1.4           猜你喜欢，2个参数status = 1，返回限制数量5个， 返回文章列表mostViewArticleList， 方法listArticleByViewCount
     *  3.1.5           获取下一篇文章   2个参数 status= 1，文章id  返回文章对象AfterArticle
     *  3.1.6           获取上一篇文章   2个参数 status= 1，文章id  返回文章对象beforeArticle
     *  3.1.7           把返回的4个对象beforeArticle，AfterArticle，mostViewArticleList，similarArticleList都放进ModelAndView上，
     *  3.1.8           跳转Home/Page/articleDetail
     *  
     *  3.2     为空，跳转Home/Error/404
     *  
     *  4        返回modelAndView对象


代码：
```
    @RequestMapping("/article/{articleId}")
    @ResponseBody //适合RESTful
    public ModelAndView ArticleDetailView(@PathVariable("articleId") Integer articleId) {
        ModelAndView modelAndView = new ModelAndView();

        //文章信息，分类，标签，作者，评论
        ArticleDetailVo articleDetailVo = articleService.getArticleDetailById(articleId);
        if (articleDetailVo != null) {
            modelAndView.addObject("articleDetailVo", articleDetailVo);

            //相关文章
            Integer parentCategoryId = articleService.getArticleById(1, articleId).getArticle_parent_category_id();
            Integer childCategoryId = articleService.getArticleById(1, articleId).getArticle_child_category_id();

            List<ArticleCustom> similarArticleList = articleService.listArticleWithSameCategory(1, parentCategoryId, childCategoryId, 5);

            //猜你喜欢
            List<ArticleCustom> mostViewArticleList = articleService.listArticleByViewCount(1, 5);

            //获取下一篇文章
            ArticleCustom AfterArticle = articleService.getAfterArticle(1, articleId);

            //获取上一篇文章
            ArticleCustom beforeArticle = articleService.getPreArticle(1, articleId);

            modelAndView.addObject("similarArticleList", similarArticleList);
            modelAndView.addObject("mostViewArticleList", mostViewArticleList);
            modelAndView.addObject("afterArticle", AfterArticle);
            modelAndView.addObject("preArticle", beforeArticle);
            modelAndView.setViewName("Home/Page/articleDetail");
        } else {
            modelAndView.setViewName("Home/Error/404");
        }
        //不会被解析为跳转路径，而是直接写入HTTP response body中
        return modelAndView;
    }
```


##业务层：

思路：
[![前台文章控制思路.jpg](https://i.loli.net/2018/11/29/5bfec7f6170e3.jpg)](https://i.loli.net/2018/11/29/5bfec7f6170e3.jpg)

代码：
```
    //文章详情页面显示
    @Override
    public ArticleDetailVo getArticleDetailById(Integer articleId) {

        ArticleDetailVo articleDetailVo = new ArticleDetailVo();

        //1、获得文章信息
        ArticleCustom articleCustom = articleMapperCustom.getArticleById(1, articleId);
        if (articleCustom == null) {
            return null;
        }
        articleDetailVo.setArticleCustom(articleCustom);

        //2、将分类信息装到 articleListVoList 中
        List<CategoryCustom> categoryCustomList = new ArrayList<>();
        Integer cate = articleCustom.getArticle_parent_category_id();
        Integer cate2 = articleCustom.getArticle_child_category_id();

        CategoryCustom categoryCustom = categoryMapperCustom.getCategoryById(1, cate);
        CategoryCustom categoryCustom2 = categoryMapperCustom.getCategoryById(1, cate2);

        if (categoryCustom != null) {
            categoryCustomList.add(categoryCustom);
        }
        if (categoryCustom2 != null) {
            categoryCustomList.add(categoryCustom2);
        }

        articleDetailVo.setCategoryCustomList(categoryCustomList);


        //3、获得文章的标签
        String tagIds = articleCustom.getArticle_tag_ids();
        List<TagCustom> tagCustomList = new ArrayList<>();

        if (tagIds != null && tagIds != "") {
            String[] tags = tagIds.split(",");
            int tagLength = tags.length;

            for (int i =0;i < tagLength;i++) {
                Tag tag = tagMapper.selectByPrimaryKey(Integer.valueOf(tags[i]));
                if (tag != null) {
                    TagCustom tagCustom = new TagCustom();
                    BeanUtils.copyProperties(tag, tagCustom);
                    tagCustomList.add(tagCustom);
                }
            }
        }
        articleDetailVo.setTagCustomList(tagCustomList);


        //4、获得文章的作者
        Integer userId = articleCustom.getArticle_user_id();
        User user = userMapper.selectByPrimaryKey(userId);
        UserCustom userCustom = new UserCustom();
        BeanUtils.copyProperties(user, userCustom);

        articleDetailVo.setUserCustom(userCustom);

        //5、获取评论信息列表
        List<CommentCustom> commentCustomList = commentMapperCustom.listCommentByArticleId(1, articleId);
        //给每个评论用户添加头像
        for (int i=0; i < commentCustomList.size();i++) {
            String avatar = Functions.getGravatar(commentCustomList.get(i).getComment_author_email());
            commentCustomList.get(i).setCommentAuthorAvatar(avatar);
        }
        articleDetailVo.setCommentCustomList(commentCustomList);

        return articleDetailVo;
    }

    //相似文章获取
    @Override
    public List<ArticleCustom> listArticleWithSameCategory(Integer status, Integer parentCategoryId, Integer childCategoryId, Integer limit) {
        List<ArticleCustom> similarArticleList = articleMapperCustom.listArticleWithSameCategory(status, parentCategoryId, childCategoryId, limit);
        return similarArticleList;
    }

    //访问量从多到少的文章获取
    @Override
    public List<ArticleCustom> listArticleByViewCount(Integer status, Integer limit) {
        List<ArticleCustom> mostViewArticleList = articleMapperCustom.listArticleByViewCount(status, limit);
        return mostViewArticleList;
    }

    //获取下一篇文章
    @Override
    public ArticleCustom getAfterArticle(Integer status, Integer articleId) {
        ArticleCustom articleCustom = articleMapperCustom.getAfterArticle(status, articleId);
        return articleCustom;
    }

    //获取上一篇文章
    @Override
    public ArticleCustom getPreArticle(Integer status, Integer articleId) {
        ArticleCustom articleCustom = articleMapperCustom.getPreArticle(status, articleId);
        return articleCustom;
    }

```


##Dao层

文章Dao层：
```
    <select id="listArticleWithSameCategory" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        select * from article

        <trim prefix="where" prefixOverrides="AND | OR" suffixOverrides="AND | OR">
            <if test="status != null">
                article_status=#{status} AND
            </if>
            <if test="parentCategoryId !=null">
                article_parent_category_id =#{parentCategoryId} OR
            </if>
            <if test="childCategoryId != null">
                article_child_category_id = #{childCategoryId}
            </if>
        </trim>
        ORDER BY  article_status ASC, article_order DESC, article_id DESC
        limit #{limit}
    </select>
    
    
    <!--猜你喜欢-->
    <select id="listArticleByViewCount" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT  * from article
        <where>
            <if test="status != null">
                article_status=#{status} AND
            </if>
        </where>
        ORDER BY article_view_count DESC,article_order DESC, article_id DESC
        limit #{limit}
    </select>
        <!--获得下一篇的文章-->
    <select id="getAfterArticle" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT * from article
        <where>
            <![CDATA[ article_id > #{articleId}]]>
            <if test="status != null">
                and article_status=#{status}
            </if>
        </where>
        ORDER  BY article_id
        limit 1
    </select>

    <!--获得上一篇的文章-->
    <select id="getPreArticle"  resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT * from `article`
        <where>
            <![CDATA[article_id < #{articleId}]]>
            <if test="status != null">
               AND article_status =#{status}
            </if>
        </where>
        ORDER BY article_id
        limit 1
    </select>
```

评论Dao层：
```
    <select id="listCommentByArticleId" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.CommentCustom">
        select * from comment
        <where>
            <if test="status != null">
                comment_status = #{status} AND
            </if>
            comment_article_id = #{articleId}
        </where>
    </select>
```


#文章点赞数增加+1


##控制层
思路：
```
     * 动态获取id
     * 1        根据status= 1 和id查询文章对象articleCustom
     * 2        获取文章喜欢数量Article_like_count
     * 3        文章重新赋值喜欢数量，Article_like_count + 1
     * 4        更新到数据库
     * 5        返回Article_like_count + 1
```

代码：
```
    @RequestMapping(value = "/article/addLike/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Integer increaseLikeCount(@PathVariable("id") Integer id) {

        ArticleCustom articleCustom = articleService.getArticleById(1, id);

        int ArticleCount = articleCustom.getArticle_like_count();

        articleCustom.setArticle_like_count(ArticleCount + 1);
        articleService.updateArticle(id, articleCustom);

        return ArticleCount + 1;
    }
```





#文章访问量数增加+1


##控制层

思路：
```
     *  动态获取id
     *  1       根据status = 1 和id  查询文章对象
     *  2       获取文章的查看数量Article_view_count
     *  3       文章重新赋值查看数量，Article_view_count + 1
     *  4       更新到数据库
     *  5       返回Article_view_count + 1
```
代码：
```
    @RequestMapping(value = "/article/addView/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Integer increaseViewCount(@PathVariable("id") Integer id) {
        ArticleCustom articleCustom = articleService.getArticleById(1, id);

        int articleCount = articleCustom.getArticle_view_count();

        articleCustom.setArticle_view_count(articleCount + 1);
        articleService.updateArticle(id, articleCustom);
        return articleCount + 1;
    }
```







#文章信息修改提交

**就是更新操作**

##控制层
```
    @RequestMapping(value = "/editArticleSubmit", method = RequestMethod.POST)
    public String editArticleSubmit(Integer id, ArticleCustom articleCustom) {
        articleService.updateArticle(id, articleCustom);
        return "redirect:articleList.action";
    }
```





#文章搜索实现



##控制层

思路：
```
     * 获取提交上来的 搜索文本query
     * 1        根据status = 1 ，request，model ，pageSize，query ，pageNow = null, 6个参数 进行查询文章，返回文章列表articleSearchVoList
     * 2        判断articleSearchVoList是否为空
     * 2.1      不为空，增加到modelAndView上
     * 2.2      为空，null 增加到modelAndView上
     * 3        跳转Home/Page/search
```
代码：
```
    public ModelAndView SearchPageView(HttpServletRequest request, Model model) {
        ModelAndView modelAndView = new ModelAndView();
        //设置每页显示的数量
        int pageSize = 10;
        String query = request.getParameter("query");
        List<ArticleListVo> articleSearchVoList = articleService.listSearchResultByPage(1, request, model, null, pageSize, query);

        if (articleSearchVoList != null) {
            modelAndView.addObject("articleSearchVoList", articleSearchVoList);
        } else {
            modelAndView.addObject("articleSearchVoList", null);
        }
        modelAndView.setViewName("Home/Page/search");
        return modelAndView;
    }
```


##业务层：

[![文章查询结果分页.jpg](https://i.loli.net/2018/11/29/5bfed0025d522.jpg)](https://i.loli.net/2018/11/29/5bfed0025d522.jpg)

思路：
```
     * 1    创建分页对象 Page = null，创建文章总信息列表articleSearchVoList
     * 2    创建单篇文章对象列表articleCustomList
     * 3    把条件query变量和status作为参数，查询getSearchResultCount方法（），该条件下有多少个结果，返回totalCount
     * 4    判断当前页数对象 pageNow，是否为空
     * 4.1  pageNow若不为空，则根据totalCount，pageNow,PageSize, 构建分页对象page
     * 4.2  根据status,query，page的选择记录的初始位置，pageSize，4个参数，
     * 查询方法listSearchResultByPage（），返回单篇文章对象列表articleCustomList
     *
     * 4.3  pageNow若是空的，则根据totalCount，pageNow = 1 ,PageSize，构建分页对象page
     * 4.4  根据status,query，page的选择记录的初始位置，pageSize，4个参数，
     * 查询方法listSearchResultByPage（），返回单篇文章对象列表articleCustomList
     *
     * 5    if判断搜索返回结果totalCount是否为0
     * 5.1  totalCount不为0，遍历单篇文章列表对象articleCustomList，
     * 执行对单篇文章总信息的4个属性（文章对象，分类对象，标签对象，User对象）的数据填充，
     * 完成后增加到articleSearchVoList
     *
     * 5.2  totalCount为0 ，创建一个文章总信息对象，作用是存储分页信息和查询关键字，
     * 完成后增加到articleSearchVoList
     *
     * 6    将查询到的关键字词和page信息存储到 文章总信息列表的第一个元素
     *
     * 7    返回articleSearchVoList
```
代码：
```
    @Override
    public List<ArticleListVo> listSearchResultByPage(Integer status, HttpServletRequest request, Model model, Integer pageNow, Integer pageSize, String query) {
        Page page = null;
        List<ArticleListVo> articleListVoList = new ArrayList<>();
        List<ArticleCustom> articleCustomList = new ArrayList<>();

        int totalCount = articleMapperCustom.getSearchResultCount(query,status);

        if (pageNow != null) {
            page = new Page(totalCount, pageNow, pageSize);
            articleCustomList = articleMapperCustom.listSearchResultByPage(status, query, page.getStartPos(), page.getPageSize());
        } else {
            page = new Page(totalCount, 1, pageSize);
            articleCustomList = articleMapperCustom.listSearchResultByPage(status, query, page.getStartPos(), page.getPageSize());
        }

        if (totalCount != 0) {
            for (int i=0; i < articleCustomList.size();i++) {
                ArticleListVo articleListVo = new ArticleListVo();
                ArticleCustom articleCustom = articleCustomList.get(i);


                List<CategoryCustom> categoryCustomList = new ArrayList<>();
                Integer categoryChildId = articleCustom.getArticle_child_category_id();
                Integer categoryParentId = articleCustom.getArticle_parent_category_id();


                CategoryCustom categoryCustom = categoryMapperCustom.getCategoryById(status,categoryChildId);
                CategoryCustom categoryCustom2 = categoryMapperCustom.getCategoryById(status, categoryParentId);

                if (categoryCustom != null) {
                    categoryCustomList.add(categoryCustom);
                }
                if (categoryCustom2 != null) {
                    categoryCustomList.add(categoryCustom2);
                }

                List<TagCustom> tagCustomList = new ArrayList<>();
                String ids = articleCustom.getArticle_tag_ids();
                String[] TagIds = ids.split(",");
                for (int j=0;j < TagIds.length;j++) {
                    Integer tagIds = Integer.valueOf(TagIds[j]);
                    Tag tag = tagMapper.selectByPrimaryKey(tagIds);
                    TagCustom tagCustom = null;
                    BeanUtils.copyProperties(tag,tagCustom);
                    tagCustomList.add(tagCustom);
                }

                UserCustom userCustom = null;
                Integer userId = articleCustom.getArticle_user_id();
                User user = userMapper.selectByPrimaryKey(userId);
                BeanUtils.copyProperties(user, userCustom);

                articleListVo.setArticleCustom(articleCustom);
                articleListVo.setCategoryCustomList(categoryCustomList);
                articleListVo.setTagCustomList(tagCustomList);
                articleListVo.setUserCustom(userCustom);

                articleListVoList.add(articleListVo);
            }

        } else {
            //不执行的话，也要创建一个元素，作用是存储分页信息和查询关键字
            ArticleListVo articleListVo = new ArticleListVo();
            articleListVoList.add(articleListVo);
        }
        //将查询到的关键字词和page信息存储到 文章总信息列表的第一个元素
        articleListVoList.get(0).setPage(page);
        articleListVoList.get(0).setQuery(query);

        return articleListVoList;
    }
```

##Dao层

文章Dao层：
```
    <select id="listSearchResultByPage" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT * from article
        <where>
            <if test="status != null">
                article_status=#{status}
            </if>
            AND article_status > 0
            AND article_title like "%${query}%"
            OR article_content like "%${query}%"
        </where>
        ORDER  BY article_status ASC ,article_order DESC  , article_id DESC
        limit #{startPos},#{pageSize}
    </select>
    
    <!--查询结果统计-->
    <select id="getSearchResultCount" resultType="Integer">
        select count(*) from article
        <where>
            <if test="status != null">
                article_status =#{status}
            </if>
            AND article_status > 0
            AND article_title LIKE "%${query}%"
            OR  article_content like "%${query}%"
        </where>
    </select>
    
```



#文章搜索分页实现


##控制层
**和上面的区别在于动态获取当前页面pageNow** 
思路：
```
     * 动态获取pageNow
     * 1        根据status = 1 ，request，model ，pageSize，query ，pageNow = 动态获取值, 6个参数 进行查询文章，返回文章列表articleSearchVoList
     * 2        判断articleSearchVoList是否为空
     * 2.1      不为空，增加到modelAndView上
     * 2.2      为空，null 增加到modelAndView上
     * 3        跳转Home/Page/search
```
代码:
```
    public ModelAndView SearchPageByPageView(HttpServletRequest request, Model model, @PathVariable("pageNow") Integer pageNow) {
        ModelAndView modelAndView = new ModelAndView();
        //设置每页显示的数量
        int pageSize = 10;
        String query = request.getParameter("query");
        List<ArticleListVo> articleListVoList = articleService.listSearchResultByPage(1, request, model, pageNow, pageSize, query);
        modelAndView.addObject("articleSearchVoList", articleListVoList);
        modelAndView.setViewName("Home/Page/search");
        return modelAndView;
    }

```






	2018-11-27 18:28:56
kumika	SSM博客实战---前台功能实现2	# SSM博客实战---前台功能实现2



前台----分类
--------




#根据分类查询文章


##控制层

思路：
```
     *  动态获取分类id，方法注入分类Id
     *  1       创建modelAndView 对象
     *  2       设置每一页的pageSize数量为10
     *  3       根据分类id和每页条数，status= 1，pageNow= null 4个参数，进行查询文章列表articleListVoList
     *  4       articleListVoList增加到modelAndView上
     *  5       根据分类id和status = 1，2个参数，查询分类对象查询分类对象categoryCustom
     *  6       categoryCustom增加到modelAndView上
     *  7       跳转Home/Page/articleListByCategory
     *  8       返回
```
代码：
```
    @RequestMapping("/category/{cateId}")
    @ResponseBody
    public ModelAndView ArticleListByCategoryView(@PathVariable("cateId") Integer cateId) {
        ModelAndView modelAndView = new ModelAndView();

        //设置每页显示条数
        int pageSize = 10;
        //根据分类id和分页条数查询文章
        List<ArticleListVo> articleListVoList = categoryService.listArticleWithCategoryByPage(1, null, pageSize, cateId);

        //如果articleListVoList=null表示该分类不存在，如果=0表示该分类暂时没有文章
        modelAndView.addObject("articleListVoList", articleListVoList);


        //该分类信息
        CategoryCustom categoryCustom = categoryService.getCategoryById(1, cateId);
        modelAndView.addObject("categoryCustom", categoryCustom);
        modelAndView.setViewName("Home/Page/articleListByCategory");
        return modelAndView;
    }
```

##业务层

分类业务层

[![根据分类查询文章.jpg](https://i.loli.net/2018/11/29/5bff9e47dcc10.jpg)](https://i.loli.net/2018/11/29/5bff9e47dcc10.jpg)
思路：
```
     *  1       创建分类总信息articleListVoList，文章列表articleCustomList
     *  2       根据分类id获取分类对象category
     *  3       根据status，分类id，查询该分类下文章的数量，返回数量totalCount
     *  4       判断pageNow是否为null
     *  4.1     不为null，根据totalCount，pageNow = 动态获取值,pageSize，构建分页对象page
     *  4.2     为null， 根据totalCount，pageNow = 1 ,pageSize，构建分页对象page
     *  5       把articleCustom文章信息对象，categoryCustomList分类信息列表，2个对象装入文章总信息对象articleListVo中
     *  再把articleListVo装入列表articleListVoList上
     *  6       判断totalCount是否为0，不为0，则将Page信息存储在articleListVoList的第一个元素中
     *  7       返回articleListVoList
```
代码：
```
    @Override
    public List<ArticleListVo> listArticleWithCategoryByPage(Integer status, Integer pageNow, Integer pageSize, Integer cateId) {
        List<ArticleListVo> articleListVoList = new ArrayList<>();
        List<ArticleCustom> articleCustomList = new ArrayList<>();

        //获得分类的信息
        Category category = categoryMapper.selectByPrimaryKey(cateId);
        //如果没有这个分类，返回null
        if (category == null) {
            return null;
        }

        //分页显示
        Page page = null;
        int totalCount = articleMapperCustom.countArticleByCategoryId(status, cateId);
        if (pageNow != null) {
            page = new Page(totalCount, pageNow, pageSize);
            articleCustomList = categoryMapperCustom.listArticleWithCategoryByPage(status, cateId, page.getStartPos(), page.getPageSize());
        } else {
            page = new Page(totalCount, 1, pageSize);
            articleCustomList = categoryMapperCustom.listArticleWithCategoryByPage(status, cateId, page.getStartPos(), page.getPageSize());
        }

        for(int i=0;i < articleCustomList.size();i++) {
            ArticleListVo articleListVo = new ArticleListVo();

            //1、将文章信息装入 articleListVo
            ArticleCustom articleCustom = articleCustomList.get(i);
            articleListVo.setArticleCustom(articleCustom);

            //2、将分类信息装到 articleListVoList 中
            List<CategoryCustom> categoryCustomList = new ArrayList<>();
            Integer parentCategoryId = articleCustomList.get(i).getArticle_parent_category_id();
            Integer childCategoryId = articleCustomList.get(i).getArticle_child_category_id();

            CategoryCustom categoryCustom = categoryMapperCustom.getCategoryById(status, parentCategoryId);
            CategoryCustom categoryCustom2 = categoryMapperCustom.getCategoryById(status, childCategoryId);
            if (categoryCustom != null) {
                categoryCustomList.add(categoryCustom);
            }
            if (categoryCustom2 != null) {
                categoryCustomList.add(categoryCustom2);
            }
            articleListVo.setCategoryCustomList(categoryCustomList);
            articleListVoList.add(articleListVo);
        }

        //如果该分类还没有文章if
        if (totalCount != 0) {
            //2、将Page信息存储在第一个元素中
            articleListVoList.get(0).setPage(page);
        }
        return articleListVoList;
    }
```




##Dao层


```
    <!--获得含有该分类的文章列表-->
    <select id="listArticleWithCategoryByPage" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT * from article
        <where>
            <if test="status != null">
                article_status=#{status} AND
            </if>
            article_parent_category_id=#{cateId}
            OR
            article_child_category_id =#{cateId}
        </where>
        ORDER BY article_id DESC
        limit #{startPos},#{pageSize}
    </select>
    
    <!--根据分类id获得分类信息-->
    <select id="getCategoryById" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.CategoryCustom">
        SELECT <include refid="category_table_all_column"/> from category
        <where>

            <if test="status != null">
                category_status=#{status}
            </if>
            and  category_id=#{id}
        </where>
    </select>
```


#根据分类查询文章分页




##控制层

和上面的方法相比就是多了个动态获取当前页数pageNow

思路：
```
     *      *  动态获取分类id和当前页数pageNow，方法注入分类Id,pageNow
     *  1       创建modelAndView 对象
     *  2       设置每一页的pageSize数量为10
     *  3       根据分类id和每页条数，status= 1，pageNow= 动态获取的值， 4个参数，进行查询文章列表articleListVoList
     *  4       articleListVoList增加到modelAndView上
     *  5       根据分类id和status = 1，2个参数，查询分类对象查询分类对象categoryCustom
     *  6       categoryCustom增加到modelAndView上
     *  7       跳转Home/Page/articleListByCategory
     *  8       返回
```

代码：
```
    @RequestMapping("/category/{cateId}/p/{pageNow}")
    @ResponseBody
    public ModelAndView ArticleListByCategoryAndPageView(@PathVariable("pageNow") Integer pageNow, @PathVariable("cateId") Integer cateId) {
        ModelAndView modelAndView = new ModelAndView();

        //设置每页显示条数
        int pageSize = 10;
        List<ArticleListVo> articleListVoList = categoryService.listArticleWithCategoryByPage(1, pageNow, pageSize, cateId);
        modelAndView.addObject("articleListVoList", articleListVoList);
        modelAndView.setViewName("Home/Page/articleListByCategory");

        //该分类信息
        CategoryCustom categoryCustom = categoryService.getCategoryById(1, cateId);
        modelAndView.addObject("categoryCustom", categoryCustom);
        return modelAndView;
    }
```







	2018-11-29 01:32:44
kumika	SSM博客实战---前台功能实现3	# SSM博客实战---前台功能实现3   



#评论


#增加评论

##控制层

```
    //添加评论
    //不需要变量，因为在更新了评论对象之后，数据库的数据就更新了，
    // 变量就是当前数据库的评论数量，不需要重新输入什么变量，直接在表格上获取评论数，然后文章表格上更新就是了
    @RequestMapping(value = "/comment/insert", method = RequestMethod.POST)
    @ResponseBody
    public void insertComment(HttpServletRequest request, Comment comment) {
        comment.setComment_create_time(new Date());
        commentService.insertComment(request, comment);
        //更新文章的评论数
        Article article = articleService.getArticleById(null, comment.getComment_article_id());
        articleService.updateCommentCount(article.getArticle_id());
    }
```

##业务层

评论业务层：

     *  1   从request上得到用户的Ip地址，然后制作成头像
     *  2   对comment对IP属性进行赋值
     *  3   更新到数据库


代码：
```
    @Override
    public void insertComment(HttpServletRequest request, Comment comment) {
        String IP = Functions.getIpAddr(request);
        comment.setComment_ip(IP);
        commentMapper.insertSelective(comment);
    }
```

文章业务层：
```
    //更新文章的评论数
    @Override
    public void updateCommentCount(Integer article_id) {
        articleMapperCustom.updateCommentCount(article_id);
    }
```


##Dao层

文章Dao层：
```
    <!--//更新文章的评论数-->
    <select id="updateCommentCount" parameterType="Integer">
        UPDATE article
        SET article_comment_count =
        (
            SELECT  count(*) from comment where article_id = comment_article_id AND comment_status= 1
        )
        where article_id=#{articleId}
    </select>
```



	2018-11-29 16:12:31
kumika	SSM博客实战---前台功能实现4	# SSM博客实战---前台功能实现4  

**首页**

```
    @ModelAttribute
    public void init(Model model) {
        //友情连接
        List<LinkCustom> linkCustomList = linkService.listLink(1);

        //公告
        List<NoticeCustom> noticeCustomList = noticeService.listNotice(1);

        model.addAttribute("linkCustomList", linkCustomList);
        model.addAttribute("noticeCustomList", noticeCustomList);
    }
```
**以上的意思是Model是要自带2个对象列表，公告对象列表noticeCustomList，友情链接对象列表linkCustomList**


#首页显示


##控制层

思路：
```
     *  1       查询文章总信息列表articleListVoList，参数：status= 1，pageNow= null, pageSize  返回为文章列表articleListVoList
     *  2       articleListVoList增加到ModelAndView上
     *  3       跳转/Home/index
```
代码：
```
    @RequestMapping("/")
    public ModelAndView Index() {
        ModelAndView modelAndView = new ModelAndView();
        //文章列表
        int pageSize = 10;
        List<ArticleListVo> articleListVoList = articleService.ListArticleByPage(1, null, pageSize);
        modelAndView.addObject("articleListVoList", articleListVoList);
        modelAndView.setViewName("/Home/index");
        return modelAndView;
    }
```







#文章分页显示



##控制层
思路：
```
     * 动态获取当前页数pageNow    方法注入pageNow
     *  1       查询文章总信息列表articleListVoList，参数：status= 1，pageNow= 动态获取值, pageSize  返回为文章列表articleListVoList
     *  2       articleListVoList增加到ModelAndView上
     *  3       跳转/Home/index
```

代码：
```
    @RequestMapping("p/{pageNow}")
    @ResponseBody
    public ModelAndView ArticleListByPageView(@PathVariable("pageNow") Integer pageNow) {
        ModelAndView modelAndView = new ModelAndView();
        //设置每页显示的数量
        int pageSize = 10;

        List<ArticleListVo> articleListVoList = articleService.ListArticleByPage(1, pageNow, pageSize);
        modelAndView.addObject("articleListVoList", articleListVoList);
        modelAndView.setViewName("Home/index");
        //不会被解析为跳转路径，而是直接写入HTTP response body中
        return modelAndView;
    }
```



#链接应用跳转

```
    @RequestMapping("/applyLink")
    public ModelAndView applyLinkView() {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("Home/Page/applyLink");
        return modelAndView;
    }
```


#链接应用点击提交

```
    @RequestMapping(value = "/applyLinkSubmit", method = RequestMethod.POST)
    @ResponseBody
    public void applyLinkSubmit(Link link) {
        link.setLink_status(0);
        link.setLink_create_time(new Date());
        link.setLink_update_time(new Date());
        linkService.insertLink(link);
    }
```



#公告详情页显示


##控制层
```
     * 动态获取公告id，方法注入noticeId
     * 1        根据noticeId, 查询公告对象noticeCustom
     * 2        noticeCustom增加到modelAndView上
     * 3        跳转Home/Page/noticeDetail
```

代码：
```
    @RequestMapping("/notice/{noticeId}")
    @ResponseBody
    public ModelAndView NoticeDetailView(@PathVariable("noticeId") Integer noticeId) {
        ModelAndView modelAndView = new ModelAndView();

        //公告内容和信息显示
        NoticeCustom noticeCustom = noticeService.getNoticeById(noticeId);

        modelAndView.addObject("noticeCustom", noticeCustom);
        modelAndView.setViewName("Home/Page/noticeDetail");
        return modelAndView;
    }
```


##业务层：

```
    @Override
    public NoticeCustom getNoticeById(Integer id) {
        Notice notice = noticeMapper.selectByPrimaryKey(id);
        NoticeCustom noticeCustom = new NoticeCustom();
        BeanUtils.copyProperties(notice, noticeCustom);
        return noticeCustom;
    }
```




	2018-11-29 16:24:02
kumika	SSM博客实战---前台功能实现5	# SSM博客实战---前台功能实现5   



#页面




#页面显示

##控制层

思路：
```
     *  动态获取key，方法注入key
     *  1       创建ModelAndView对象
     *  2       根据2个参数：status = 1，key ，查询分页对象pageCustom
     *  3       判断pageCustom 是否为空
     *  3.1     不为空： 把pageCustom增加到modelAndView上，并且跳转 Home/Page/page
     *  3.2     为空：   跳转Home/Error/404
     *  4       返回modelAndView
```
代码:
```
    @RequestMapping("/{key}")
    public ModelAndView ArticleDetailView(@PathVariable("key") String key) {
        ModelAndView modelAndView = new ModelAndView();

        PageCustom pageCustom = pageService.getPageByKey(1, key);

        if (pageCustom != null) {
            modelAndView.addObject("pageCustom", pageCustom);
            modelAndView.setViewName("Home/Page/page");
        } else {
            modelAndView.setViewName("Home/Error/404");
        }
        return modelAndView;
    }
```

##业务层；


页面业务层：
```
    @Override
    public PageCustom getPageByKey(Integer status, String key) {
        PageCustom pageCustom = pageMapperCustom.getPageByKey(status, key);
        return pageCustom;
    }
```

##Dao层；

```
    <!--根据key获得-->
    <select id="getPageByKey" resultType="Com.zhihu.foreBlog.pojo.Custom.PageCustom">
        select * from page
        <where>
            <if test="status != null">
                page_status = #{status} AND
            </if>
            page_key=#{key}
        </where>
    </select>
```

#文章归档页面显示

就是跳转作用

##控制层
思路：
```
     *  1       查询属性status = 1 的全部的文章
     *  2       增加到ModelAndView上
     *  3       跳转Home/Page/articleFile
     *  4       返回
```
代码：
```
    @RequestMapping("/articleFile")
    public ModelAndView articleFile() {
        ModelAndView modelAndView = new ModelAndView();
        List<ArticleListVo> articleList = articleService.ListArticleVo(1);
        modelAndView.addObject("articleList", articleList);
        modelAndView.setViewName("Home/Page/articleFile");
        return modelAndView;
    }

```





#站点地图显示

 **页面要求显示文章列表，分类列表，标签列表，所以要全部查询status= 1的这3个类的对象**
 
##控制层：
 
```
    @RequestMapping("/map")
    public ModelAndView siteMap() {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("Home/Page/siteMap");

        //文章显示
        List<ArticleListVo> articleList = articleService.ListArticleVo(1);
        modelAndView.addObject("articleList", articleList);

        //分类显示
        List<CategoryCustom> categoryCustomList = categoryService.listCategory(1);
        modelAndView.addObject("categoryCustomList", categoryCustomList);

        //标签显示
        List<TagCustom> tagCustomList = tagService.listTag(1);
        modelAndView.addObject("tagCustomList", tagCustomList);

        return modelAndView;
    }
```
##业务层；

**文章业务层：**
查询文章对象（写了多次了，不想重复）

    ListArticleVo(1)




分类业务层：

    listCategory(1)

思路：
```
     *  1       根据status查询分类对象categoryCustom，返回列表categoryCustomList
     *  2       因为分类对象存在一个数据库上表格没有的字段属性ArticleCount--分类下的文章数量，所以需要自己填充数据
     *  2.1     for循环遍历categoryCustomList，获取每一个分类id----categoryId
     *  2.2     categoryId和status作为参数，在文章Dao层创建一个
     *  根据分类id查询文章数量的方法countArticleByCategoryId（），返回文章数量count
     *  2.3     把count设置到分类对象categoryCustom上
     *  3       返回categoryCustomList
```
代码：
```
    @Override
    public List<CategoryCustom> listCategory(Integer status) {
        List<CategoryCustom> categoryCustomList = categoryMapperCustom.listCategory(status);
        //查询该分类下的文章数量
        for (int i =0;i < categoryCustomList.size();i++) {
            Integer categoryId = categoryCustomList.get(i).getCategory_id();
            //统计该分类下有多少文章
            Integer count = articleMapperCustom.countArticleByCategoryId(status, categoryId);
            categoryCustomList.get(i).setArticleCount(count);
        }
        return categoryCustomList;
    }
```

标签业务层:

思路：
```
     *      1       根据status查询分类对象tagCustom，返回列表tagCustomList
     *      2       因为tagCustom类的属性articleCount 是后面增加的，数据库没有该字段，所以要自己填充
     *      2.1     for循环遍历tagCustomList，获取每一个分类id----tagId
     *      2.2     tagId和status作为参数，在文章Dao层创建一个
     *  根据分类id查询文章数量的方法countArticleByTagId（），返回标签数量count
     *      2.3     把count设置到分类对象tagCustom上
     *      3       返回tagCustomList
```
代码：

```
    @Override
    public List<TagCustom> listTag(Integer status) {

        List<TagCustom> tagCustomList = tagMapperCustom.listTag(status);
        //因为tagCustom类的属性articleCount 是自己后面增加的，所以要自己填充
        //属性articleCount是统计相同一个标签有多少篇文章，所以需要tagId作为参数，在article业务层的方法
        for (int i = 0; i< tagCustomList.size();i++) {
            Integer id = tagCustomList.get(i).getTag_id();
            Integer count = articleMapperCustom.countArticleByTagId(status, id);

            tagCustomList.get(i).setArticleCount(count);
        }
        return tagCustomList;
    }
```


##Dao层；

分类Dao层：
```
   <!-- //获得分类列表-->
    <select id="listCategory" resultType="Com.zhihu.foreBlog.pojo.Custom.CategoryCustom">
        SELECT * from category
        <where>
            <if test="status != null">
                category_status =#{status}
            </if>
        </where>
        ORDER BY  category_status ASC ,category_order DESC ,category_id ASC
    </select>
```


标签Dao层：
```
    <!--获得标签列表-->
    <select id="listTag" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.TagCustom">
        SELECT  * from tag
        <where>
            <if test="status != null">
                tag_status = #{status}
            </if>
        </where>
        ORDER BY  tag_status ASC
    </select>
```


#留言板

**跳转到Home/Page/message**


```
    @RequestMapping(value = "/message")
    public ModelAndView message() throws Exception {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("Home/Page/message");
        return modelAndView;
    }
```



	2018-11-29 18:46:13
kumika	SSM博客实战---前台功能实现6	# SSM博客实战---前台功能实现6




#标签




#根据标签查询文章


##控制层：

思路：
```
     * 动态获取tagId,  方法注入
     * 1        创建ModelAndView对象
     * 2        根据status = 1，pageSize = 10, tagId , pageNow = null 这4个参数，
     * 根据分页数据查询文章列表方法  getArticleListByPage(1, null, pageSize, tagId) ， 返回文章列表articleListVoList
     * 3        根据tagId , 查询标签对象TagCustom，返回标签对象TagCustom
     * 4        把2个对象articleListVoList，和TagCustom 增加到modelAndView上
     * 5        跳转Home/Page/articleListByTag
```
代码：
```
    @RequestMapping("tag/{tagId}")
    @ResponseBody
    public ModelAndView ArticleListByTagView(@PathVariable("tagId") Integer tagId) {
        ModelAndView modelAndView = new ModelAndView();
        int pageSize =10;
        List<ArticleListVo> articleListVoList = tagService.getArticleListByPage(1, null, pageSize, tagId);
        modelAndView.addObject("articleListVoList", articleListVoList);

        //标签信息
        TagCustom tagCustom = tagService.getTagById(tagId);
        modelAndView.addObject("tagCustom", tagCustom);
        modelAndView.setViewName("Home/Page/articleListByTag");
        return modelAndView;
    }
```

##业务层：

标签业务层:
**根据标签Id进行查询文章对象，然后进行填充分类对象，和标签对象**

思路：
```
     * 根据分页数据查询文章总信息列表，文章总信息对象中包含这标签对象，分类对象，文章对象，
     * 数据库的表格上没有，需要填充，所以会用到3个业务层方法
     * 方法注入4个参数： status ，pageNow, pageSize, tagId
     * 1        创建文章总信息对象列表articleListVoList， 和单篇文章列表articleCustomList
     * 2        根据tagId，查询标签对象tag
     * 3        根据status和tagId，查询在tagId下的文章数量，返回数量Count
     * 4        判断当前页数是否为Null
     * 4.1      不为null：   根据count ，pageNow, pageSize构建一个分页对象page, 然后根据
     * status，page的属性startPos, tagId , page的属性pageSize  4个参数，查询文章对象列表articleCustomList
     * 4.2      为null：    根据count ，pageNow = 1 , pageSize构建一个分页对象page, 然后根据
     * status，page的属性startPos, tagId , page的属性pageSize  4个参数，查询文章对象列表articleCustomList
     * 5        遍历articleCustomList，把每一个文章对象articleCustom都填充标签对象，分类对象，文章对象
     * 6        判断count是否问空，不为空，则把分页对象page装入articleListVoList的第一个元素上
     * 7        返回articleListVoList
```

代码：

```
    public List<ArticleListVo> getArticleListByPage(Integer status, Integer pageNow, Integer pageSize, Integer tagId) {

        List<ArticleListVo> articleListVoList = new ArrayList<>();
        List<ArticleCustom> articleCustomList = new ArrayList<>();

        //获得该标签的具体信息
        Tag tag = tagMapper.selectByPrimaryKey(tagId);
        if (tag == null) {
            return null;
        }

        //分页显示
        Page page = null;

        int totalCount = articleMapperCustom.countArticleByTagId(status, tagId);
        if (pageNow != null) {
            page = new Page(totalCount, pageNow,pageSize);
            articleCustomList = tagMapperCustom.listArticleWithTagByPage(status,tagId,page.getStartPos(), page.getPageSize());
        } else {
            page = new Page(totalCount, 1,pageSize);
            articleCustomList = tagMapperCustom.listArticleWithTagByPage(status,tagId,page.getStartPos(), page.getPageSize());
        }

        for(int i=0;i<articleCustomList.size();i++) {
            ArticleListVo articleListVo = new ArticleListVo();
            //1、将文章装入 articleListVo
            ArticleCustom articleCustom = articleCustomList.get(i);
            articleListVo.setArticleCustom(articleCustom);
            //2、将分类信息装到 articleListVoList 中
            List<CategoryCustom> categoryCustomList = new ArrayList<CategoryCustom>();
            Integer cate = articleCustomList.get(i).getArticle_parent_category_id();
            Integer cate2 = articleCustomList.get(i).getArticle_child_category_id();
            CategoryCustom categoryCustom  = categoryMapperCustom.getCategoryById(status,cate);
            CategoryCustom categoryCustom2 = categoryMapperCustom.getCategoryById(status,cate2);
            if(categoryCustom!=null) {
                categoryCustomList.add(categoryCustom);
            }
            if(categoryCustom2!=null) {
                categoryCustomList.add(categoryCustom2);
            }
            articleListVo.setCategoryCustomList(categoryCustomList);

            articleListVoList.add(articleListVo);
        }

        //确保该标签有文章，防止空指针
        if (totalCount != 0) {
            //3、将Page存储在 articleListVoList 第一个元素中
            articleListVoList.get(0).setPage(page);

            //4、将标签信息 装入  articleListVoList 第一个元素中
            List<TagCustom> tagCustomList = new ArrayList<>();
            TagCustom tagCustom = new TagCustom();
            BeanUtils.copyProperties(tag, tagCustom);
            tagCustomList.add(tagCustom);
            articleListVoList.get(0).setTagCustomList(tagCustomList);
        }
        return articleListVoList;
    }
```


##Dao层：


```
    <select id="listArticleWithTagByPage" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        select * from article
        <where>
            <if test="status != null">
                article_status = #{status} AND
            </if>
            article_tag_ids = #{tagId} OR
            article_tag_ids LIKE "${tagId},%" OR
            article_tag_ids LIKE "%,${tagId},%" OR
            article_tag_ids LIKE "%,${tagId}"
            limit #{starPos},#{pageSize}
        </where>
    </select>
```



#根据标签查询文章分页

和上面的方法区别就是：

    **动态获取tagId和当前页数PageNow,  方法注入2个参数**



##控制层：

思路：
```
     * 动态获取tagId和当前页数PageNow,  方法注入2个参数
     * 1        创建ModelAndView对象
     * 2        根据status = 1，pageSize = 10, tagId , pageNow = 动态获取 这4个参数，
     * 根据分页数据查询文章列表方法  getArticleListByPage(1, 动态获取, pageSize, tagId) ， 返回文章列表articleListVoList
     * 3        根据tagId , 查询标签对象TagCustom，返回标签对象TagCustom
     * 4        把2个对象articleListVoList，和TagCustom 增加到modelAndView上
     * 5        跳转Home/Page/articleListByTag
```

代码：
```
    @RequestMapping("tag/{tagId}/p/{pageNow}")
    @ResponseBody
    public ModelAndView ArticleListByTagAndPageView(@PathVariable("pageNow") Integer pageNow, @PathVariable("tagId") Integer tagId) {
        ModelAndView modelAndView = new ModelAndView();

        int pageSize = 10;

        List<ArticleListVo> articleListVoList = tagService.getArticleListByPage(1, pageNow, pageSize, tagId);

        modelAndView.addObject("articleListVoList", articleListVoList);
        modelAndView.setViewName("Home/Page/articleListByTag");

        //标签信息
        TagCustom tagCustom = tagService.getTagById(tagId);
        modelAndView.addObject("tagCustom", tagCustom);

        return modelAndView;
    }

```




	2018-11-29 19:00:14
kumika	SSM博客实战---前台功能实现7	# SSM博客实战---前台功能实现7

#上传文件


     * 方法注入网页提交上来的文件file， 注意文件的类型是MultipartFile
     *  1       本地使用,上传位置
     *  2       获取file的完整名称，fileName
     *  3       根据indexOf，substring，lastIndexOf获取fileName的文件名和后缀名
     *  4       根据当前时间创建年月文件 dateDirs
     *  5       文件路径+ 年月文件+文件名创建 目标文件descFile
     
     *  6       若存在相同的文件名称，则创建一个String变量：fileName赋值给它 ，新的文件名newFileName
     *  6.1     目标文件存在，则赋值newFileName, 值是文件名 + 随便数字 + 后缀
     *  6.2     获取文件路径的上级路径parentPath= descFile.getParent();
     *  6.3     根据parentPath + 随机数字 + newFileName创建一个新的目标文件
     
     *  7       判断目标文件是否存在，如果目标文件所在的目录不存在，则创建父目录
     *  8       将内存中的数据写入磁盘（提交上来的文件，存放入服务器）
     *  9       根据/upload/ + 年月文件 + / + newFileName 创建一个完整的url----fileUrl
     *  10      创建ResultVO对象，和UploadFileVo对象
     *  11      ResultVO赋值 Code 为0 ，MSG为”成功“
     *  12      UploadFileVo赋值 Title为 文件名newFileName， SRC 为 fileUrl,
     *  13      Result设置date为uploadFileVo，返回resultVo

代码：
```
    @RequestMapping(value = "/uploadFile", method = RequestMethod.POST)
    @ResponseBody
    public ResultVO uploadFile(@Param("file") MultipartFile file) throws IOException {

        //本地使用,上传位置
        String rootPath = "/Users/lenovo/Desktop/ForestBlog-master/ForestBlog-master/uploads/www/uploads/";

        //文件的完整名称,如spring.jpeg
        String fileName = file.getOriginalFilename();
        //文件名,如spring
        String name = fileName.substring(0, fileName.indexOf("."));
        //文件后缀,如.jpeg
        String suffix = fileName.substring(fileName.lastIndexOf("."));


        //创建年月文件夹
        Calendar date = Calendar.getInstance();
        File dateDirs = new File(date.get(Calendar.YEAR)+File.separator+(date.get(Calendar.MONTH)));


        //目标文件，文件路径+ 时间文件+文件名创建
        File descFile = new File(rootPath + File.separator + dateDirs + File.separator + fileName);

        int i = 1;
        //若文件存在重命名
        String newFilename = fileName;

        while (descFile.exists()) {
            newFilename = name + "(" + i + ")" +suffix;
            String parentPath = descFile.getParent();
            descFile = new File(parentPath + File.separator + newFilename);
            i++;
        }

        //判断目标文件所在的目录是否存在
        if (!descFile.getParentFile().exists()) {
            //如果目标文件所在的目录不存在，则创建父目录
            descFile.getParentFile().mkdirs();
        }


        //将内存中的数据写入磁盘
        file.transferTo(descFile);

        //完整的url
        String fileUrl = "/uploads/" + dateDirs + "/" + newFilename;


        ResultVO resultVO = new ResultVO();
        resultVO.setCode(0);//错误码
        resultVO.setMsg("成功");

        UploadFileVo uploadFileVo = new UploadFileVo();
        uploadFileVo.setTitle(fileName);
        uploadFileVo.setSrc(fileUrl);
        resultVO.setData(uploadFileVo);
        return resultVO;
    }

```


**基本的大概套路是：
（区别在于创建文件的属性，判断文件的条件····）
网页提交上传文件UploadFile
1   获取文件名 fileName
2   获取存放文件的路径 rootPath
3   根据fileName + rootPath 创建目标文件targetFile
4   如果targetFile所在目录不存在，则要创建父目录
5   UploadFile传输数据给targetFile，将内存中的数据写入磁盘
这就大致完成上传功能。**









	2018-12-02 10:05:41
kumika	SSM博客实战---安全And资源拦截器	# SSM博客实战---安全And资源拦截器

注意：



使用拦截器，要记得配置在springMVC上，而且**拦截器在springMVC上进行配置的时候，注意部署的顺序**， 不然会一直拦截进不去的



#安全拦截器：

##安全拦截器SecurityInterceptor
```
public class SecurityInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception {
        System.out.println("SecurityInterceptor(安全检查拦截)...preHandle...");
        //这里可以根据session的用户来判断角色的权限，根据权限来转发不同的页面
        if (request.getSession().getAttribute("user") == null) {
            response.sendRedirect("/login");
            return false;
        }
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {

    }
}
```





#资源拦截器

##准备首页资源拦截器

```
public class HomeResourceInterceptor implements WebRequestInterceptor{

    @Autowired
    CategoryService categoryService;

    @Autowired
    MenuService menuService;

    @Autowired
    TagService tagService;

    @Autowired
    ArticleService articleService;

    @Autowired
    CommentService commentService;

    @Autowired
    LinkService linkService;

    @Autowired
    OptionService optionService;

    /**
     * 在请求处理之前执行，该方法主要是用于准备资源数据的，然后可以把它们当做请求属性放到WebRequest中
     */
    @Override
    public void preHandle(WebRequest webRequest) throws Exception {
        System.out.println("HomeResourceInterceptor（首页请求处理之前拦截，用于准备资源数据）...preHandle......");
        //导航主要菜单显示
        //分类目录显示
        List<CategoryCustom> categoryCustomList = categoryService.listCategory(1);
        webRequest.setAttribute("categoryList",categoryCustomList,webRequest.SCOPE_REQUEST);


        //菜单显示
        List<MenuCustom> menuCustomList = menuService.listMenu(1);
        webRequest.setAttribute("menuCustomList", menuCustomList, webRequest.SCOPE_REQUEST);


        //侧边栏显示
        //标签列表显示
        List<TagCustom> tagList = tagService.listTag(1);
        webRequest.setAttribute("tagList", tagList, webRequest.SCOPE_REQUEST);
        //获得随机文章
        List<ArticleCustom> randomArticleList = articleService.listRandomArticle(1,8);
        webRequest.setAttribute("randomArticleList", randomArticleList, webRequest.SCOPE_REQUEST);
        //获得热评文章
        List<ArticleCustom> mostCommentArticleList = articleService.listArticleByCommentCount(1, 8);
        webRequest.setAttribute("mostCommentArticleList", mostCommentArticleList, webRequest.SCOPE_REQUEST);
        //最新评论
        List<CommentListVo> recentCommentList = commentService.listRecentComment(10);
        webRequest.setAttribute("recentCommentList", recentCommentList, webRequest.SCOPE_REQUEST);

        //获得网站概况
        List<String> siteBasicStatistics = new ArrayList<String>();
        // 文章总数
        siteBasicStatistics.add(articleService.countArticle(1) + "");
        //留言数量
        siteBasicStatistics.add(articleService.countArticleComment(1) + "");
        //分类数量
        siteBasicStatistics.add(categoryService.countCategory(1) + "");
        //标签总数
        siteBasicStatistics.add(tagService.countTag(1) + "");
        //链接数量
        siteBasicStatistics.add(linkService.countLink(1) + "");
        //浏览总量
        siteBasicStatistics.add(articleService.countArticleView(1) + "");
        webRequest.setAttribute("siteBasicStatistics", siteBasicStatistics, webRequest.SCOPE_REQUEST);

        //最后更新文章
        ArticleCustom lastUpdateArticle = articleService.getLastUpdateArticle();
        webRequest.setAttribute("lastUpdateArticle", lastUpdateArticle, webRequest.SCOPE_REQUEST);

        //页脚显示
        //博客基本信息显示
        Options options = optionService.getOptions();
        webRequest.setAttribute("options", options, webRequest.SCOPE_REQUEST);

    }
    /**
     * 该方法将在Controller执行之后，返回视图之前执行，ModelMap表示请求Controller处理之后返回的Model对象，所以可以在
     * 这个方法中修改ModelMap的属性，从而达到改变返回的模型的效果。
     */
    @Override
    public void postHandle(WebRequest webRequest, ModelMap modelMap) throws Exception {

    }
    /**
     * 该方法将在整个请求完成之后，也就是说在视图渲染之后进行调用，主要用于进行一些资源的释放
     */
    @Override
    public void afterCompletion(WebRequest webRequest, Exception e) throws Exception {

    }
}
```






##后台资源拦截器


```
public class AdminResourceInterceptor implements WebRequestInterceptor {

    @Autowired
    HttpSession httpSession;

    @Autowired
    UserService userService;


    /**
     * 在请求处理之前执行，该方法主要是用于准备资源数据的，然后可以把它们当做请求属性放到WebRequest中
     */
    @Override
    public void preHandle(WebRequest webRequest) throws Exception {
        User user = (User) httpSession.getAttribute("user");
        User user2 = userService.getUserById(user.getUserId());
        webRequest.setAttribute("loginUser", user2, webRequest.SCOPE_SESSION);
    }

    /**
     * 该方法将在Controller执行之后，返回视图之前执行，ModelMap表示请求Controller处理之后返回的Model对象，所以可以在
     * 这个方法中修改ModelMap的属性，从而达到改变返回的模型的效果。
     */
    @Override
    public void postHandle(WebRequest webRequest, ModelMap modelMap) throws Exception {

    }

    /**
     * 该方法将在整个请求完成之后，也就是说在视图渲染之后进行调用，主要用于进行一些资源的释放
     */
    @Override
    public void afterCompletion(WebRequest webRequest, Exception e) throws Exception {

    }
}
```






#springMVC上的配置

```
    <mvc:interceptors>
        <mvc:interceptor>
            <!--需要拦截的页面路径-->
            <mvc:mapping path="/**"/>
            <bean class="Com.zhihu.foreBlog.Interceptor.HomeResourceInterceptor"/>
        </mvc:interceptor>


        <mvc:interceptor>
            <!--需要拦截的页面路径-->
            <mvc:mapping path="/admin"/>
            <bean class="Com.zhihu.foreBlog.Interceptor.SecurityInterceptor"/>
        </mvc:interceptor>
        <mvc:interceptor>
            <!--需要拦截的页面路径-->
            <mvc:mapping path="/admin/**"/>
            <bean class="Com.zhihu.foreBlog.Interceptor.SecurityInterceptor"/>
        </mvc:interceptor>



        <mvc:interceptor>
            <!--需要拦截的页面路径-->
            <mvc:mapping path="/admin"/>
            <bean class="Com.zhihu.foreBlog.Interceptor.AdminResourceInterceptor"/>
        </mvc:interceptor>
        <mvc:interceptor>
            <!--需要拦截的页面路径-->
            <mvc:mapping path="/admin/**"/>
            <bean class="Com.zhihu.foreBlog.Interceptor.AdminResourceInterceptor"/>
        </mvc:interceptor>
        
    </mvc:interceptors>
```



	2018-12-03 21:31:47
kumika	SSM博客实战---需求到实现过程1	# SSM博客实战---需求到实现过程1

**这是简单复习博客的实现过程，会有纰漏，不一定要很详细。**

从后台开始把

#后台管理员

因为没有注册这个功能，所以直接就是在数据库增加用户实现注册。
只实现了登陆

##登陆

需求： 登陆
------

1 访问admin路径的时候拦截器跳转到登陆页面，点击登陆按钮
2 点击登陆按钮

###**提交对象**

3个参数：  

`username`  和  `password`  （其实可以是user对象） 最后是变量：`remember`（使用cookie标志）


###**实现过程**


**Admin控制层(实现Cookie)：**

1 根据username 和password作为参数，查询返回user， 
1.1  判断user是否为空而且和提交上来的username,password是否一致
1.2     空则返回login页面
1.3     不为空而且username和password都一致则跳转到后台首页,session增加“user”属性

2 **实现Cookie，判断remeber是否为null，不为null则进行增加cookie操作**
2.1     **创建2个cookie：** 

    Cookie NameCookie = new Cookie("username",username);

    Cookie PassCookie = new Cookie("password",password);

2.2     **设置cookie的属性： 比如有效期**
   

     NameCookie.setMaxAge(60 * 60 * 24 * 7);
     PassCookie.setMaxAge(60 * 60 * 24 * 7);
    
2.3     **把cookie装到浏览器上（输入cookie，依靠response）**

    response.addCookie(NameCookie);
    response.addCookie(PassCookie);

2.4     **在浏览器上写脚本：（读取cookie）**

    Cookie[] cookies = request.getCookies();

脚本：
```
    <%
         String username = "";
         String password = "";
         //获取当前站点的所有Cookie
         Cookie[] cookies = request.getCookies();
         for (int i = 0; i < cookies.length; i++) {//对cookies中的数据进行遍历，找到用户名、密码的数据
             if ("username".equals(cookies[i].getName())) {
                    username = cookies[i].getValue();
             } else if ("password".equals(cookies[i].getName())) {
                 password = cookies[i].getValue();
             }
         }
         %>
```

**User业务层:**

```
User user = userMapper.getUserByUserNameAndPassword(username,password);
```


**Mybatis实现Sql**
```
select * from user where username=#{username} and password=#{password}
```




#访问后台首页

准备首页资源数据
首页有很多对象需要展示，所以有很多的对象需要查询，JSP也分成几个页面来完成整体的需求


需求：
---

##**1 拦截器准备首页资源**


准备资源数据的，然后可以把它们当做请求属性放到WebRequest中

###**导航主要菜单显示**
**分类目录显示**
[![分类列表.jpg](https://i.loli.net/2018/12/06/5c0813d29311d.jpg)](https://i.loli.net/2018/12/06/5c0813d29311d.jpg)


**C控制层：**
根据status查询分类对象列表categoryList

**Category业务层：**
注意：因为分类对象有一个文章数量属性，所以要自己填充

1   根据status查询分类对象列表categoryList
2   遍历categoryList，根据分类id，在**文章业务层**查询文章数量count，count赋值到每一个分类的文章数量属性上


**Dao层：**

分类dao层：
```
   <!-- //获得分类列表-->
    <select id="listCategory" resultType="Com.zhihu.foreBlog.pojo.Custom.CategoryCustom">
        SELECT * from category
        <where>
            <if test="status != null">
                category_status =#{status}
            </if>
        </where>
        ORDER BY  category_status ASC ,category_order DESC ,category_id ASC
    </select>
```
文章dao层：
```
    <!--查询该分类下的文章数量-->
    <select id="countArticleByCategoryId" resultType="Integer">
        SELECT  count(*) from article
        <where>

            <if test="status != null">
                article_status=#{status}
            </if>
            AND
            article_parent_category_id =#{id}
            OR
            article_child_category_id =#{id}
        </where>
    </select>
```

**菜单显示**

[![剩余菜单.jpg](https://i.loli.net/2018/12/06/5c0813d293212.jpg)](https://i.loli.net/2018/12/06/5c0813d293212.jpg)


**控制层：**

根据status查询菜单列表MenuList

**业务层:**

根据status查询菜单列表MenuList


**Dao 层：**

```
    <!--获得菜单列表-->
    <select id="listMenu" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.MenuCustom">
        SELECT * from menu
        <where>
            <if test="status != null">
                menu_status=#{status}
            </if>
        </where>
        ORDER  BY menu_id ASC ,menu_order DESC ,menu_status ASC
    </select>
```



###**侧边栏显示**

**标签列表显示**

[![标签列表.jpg](https://i.loli.net/2018/12/06/5c081e5be09c6.jpg)](https://i.loli.net/2018/12/06/5c081e5be09c6.jpg)

**控制层：**

根据status查询标签对象列表tagList

**标签业务层:**

根据status查询标签对象列表tagList

**Dao层：**
```
    <!--获得标签列表-->
    <select id="listTag" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.TagCustom">
        SELECT  * from tag
        <where>
            <if test="status != null">
                tag_status = #{status}
            </if>
        </where>
        ORDER BY  tag_status ASC
    </select>
```

**获得随机文章**
[![随机文章列表.jpg](https://i.loli.net/2018/12/06/5c081e5be2197.jpg)](https://i.loli.net/2018/12/06/5c081e5be2197.jpg)

**关键点在于随机，在SQL语句里面根据rand()函数作为随机条件。**
虽然自己的想法是在控制层OR业务层上获取随机条件，然后作为参数进行查询，但是这里先跳过这个想法了。

**控制层：**

根据status和限制数量limit，查询随便文章列表randomArticleList

**业务层**


根据status和限制数量limit，查询随便文章列表randomArticleList


**Dao层：**
随机条件：`ORDER BY  RAND()`
```
    <!--获得随机文章-->
    <select id="listRandomArticle" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT * from article
        <where>
            <if test="status != null">
                article_status=#{status}
            </if>
        </where>
        ORDER BY  RAND()
        limit #{limit}
    </select>
```

**获得热评文章**
[![热评文章.jpg](https://i.loli.net/2018/12/06/5c081e5be3a7d.jpg)](https://i.loli.net/2018/12/06/5c081e5be3a7d.jpg)

**热评，最多浏览，点赞最多····这样的要求首先看查询对象的属性有是否可用的，然后看其他表格的字段，最后看MYSQL的函数**


**控制层:**

根据status和限制数量limit，查询热评文章列表mostCommentArticleList


**业务层:**

根据status和限制数量limit，查询热评文章列表mostCommentArticleList



**Dao层:**

重点：`article_comment_count DESC`

```
    <!--//获得评论数较多的文章  ,  首先看表格是否有直接用的字段，没有才开始使用别的字段，最后才用函数计算得到的变量-->
    <select id="listArticleByCustomList" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        select * from article
        <where>
            <if test="status != null">
                article_status = #{status}
            </if>
        </where>
        ORDER  BY
        article_comment_count DESC ,article_order DESC ,article_id DESC
        limit #{limit}
    </select>
```

获得网站概况
[![网站概况.jpg](https://i.loli.net/2018/12/06/5c081e5bdeff2.jpg)](https://i.loli.net/2018/12/06/5c081e5bdeff2.jpg)

**都是根据status查询相关对象的数量，直接写sql**

在查询数量的sql中，多是使用对象表格的`字段`和`mysql上的函数`

文章总数：
`字段`和`mysql上的函数`： **count(*)**
```
    <!--/*获取文章总数*/-->
    <select id="countArticle" parameterType="Integer" resultType="Integer">
        SELECT  count(*) from article
        <where>
            <if test="status != null">
               article_status = #{status}
            </if>
        </where>
    </select>
```


留言数量：
留言是指文章的留言，不是评论啊；
`字段`和`mysql上的函数`：sum(article_comment_count)
```
    <!--获得文章留言总数-->
    <select id="countArticleComment" resultType="Integer">
        select sum(article_comment_count) from article
        <where>
            <if test="status != null">
                article_status =#{status}
            </if>
        </where>
    </select>
```


分类数量
`字段`和`mysql上的函数`：count(*)
```
    <!--获得分类总数-->
    <select id="countCategory" resultType="Integer">
        select count(*) from category
        <where>
            <if test="status != null">
                category_status=#{status}
            </if>
        </where>
    </select>
```


标签总数
`字段`和`mysql上的函数`：count(*)
```
    <select id="countTag" resultType="Integer">
        select count(*) from tag
        <where>
            <if test="status != null">
                tag_status = #{status}
            </if>
        </where>
    </select>
```


链接数量
`字段`和`mysql上的函数`：count(*)
```
    <select id="countLink" resultType="Integer">
        select count(*) from link
        <where>
            <if test="status != null">
                link_status=#{status}
            </if>
        </where>
    </select>
```


浏览总量
`字段`和`mysql上的函数`：sum(article_view_count)
```
    <select id="countArticleView" resultType="Integer">
        select sum(article_view_count) from article
        <where>
            <if test="status != null">
                article_status =#{status}
            </if>
        </where>
    </select>
```


最新评论
根据限制数量10 查询最新的评论对象
`字段`和`mysql上的函数`：
```
    <!--获得最近评论 ?? 为什么没有出现时间判断-->
    <select id="listRecentComment" resultType="Com.zhihu.foreBlog.pojo.Custom.CommentCustom">
        select * from comment
        <where>
            comment_status=1 AND  comment_role=0
        </where>
        Order BY comment_id DESC
        limit #{limit}
    </select>
```


最后更新文章

`字段`和`mysql上的函数`： max(article_update_time)
```
    <select id="getLastUpdateArticle" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        select * from article
        WHERE article_update_time =
         (
         select max(article_update_time) from article
         )
    </select>
```

博客基本信息显示

```
    <select id="getOptions" resultType="Com.zhihu.foreBlog.pojo.Options">
        select * from options limit 1
    </select>
```



##**2 后台首页**

[![后台首页.jpg](https://i.loli.net/2018/12/07/5c0a3df02b10d.jpg)](https://i.loli.net/2018/12/07/5c0a3df02b10d.jpg)


###**评论数**
status = null，是查询全部的评论数量；
status = 1，是查询待审的评论数量；
status = 2，是查询已经批准的评论数量


**控制层,业务层：**
根据status ，查询评论数量

**Dao层**：
```
    <!--统计评论数-->
    <select id="countComment" parameterType="Integer" resultType="Integer">
        SELECT  count(*) from comment
        <where>
            <if test="status != null">
                comment_status=#{status}
            </if>
        </where>
    </select>
```


###**评论者列表**

**控制层：**
根据status = null，查询评论总信息对象列表

**业务层：**

这里的评论对象中有用户头像，用户发布文章信息（文章对象），数据库的表格中没有这2个对象，所以需要填充。
1   创建评论总信息对象列表`commentList`

2   根据status= null 查询评论对象列表`commentCustomList`，

3   创建评论总信息对象`commentListVo`，遍历`commentCustomList`，获取列表中每一个评论对象，然后根据评价对象的文章外键属性，查询得到文章对象，填充到评论总信息对象`commentListVo`中

4   根据评价对象的邮箱属性，借用工具类获取用户头像，头像在设置到评论对象上，然后**评论对象填充到评论总信息对象**`commentListVo`中

5   将评论总信息对象`commentListVo`增加到评论总信息对象列表`commentList` 上

6   返回列表

**Dao层：**
根据外键查询文章对象，就没有写，下面是查询评论对象的
```
    <!--查询评论列表对象-->
    <select id="ListComment"  resultType="Com.zhihu.foreBlog.pojo.Custom.CommentCustom">
        SELECT  * from comment
        <where>
            <if test="status != null">
                comment_status=#{status}
            </if>
        </where>
        ORDER  BY  comment_id ASC
    </select>
```

###**文章列表**
status = null，查询全部文章对象

**业务层：**
1   根据status查询文章对象列表
2   创建文章总信息对象列表
3   遍历文章对象列表，创建文章总信息对象，把文章增加到总信息对象上
4   根据文章的3个外键和status（分类，用户，标签），查询3个对象，都增加到总信息对象上
5   总信息对象增加到文章总信息对象列表上
6   返回文章总信息对象列表

**Dao层：**
只写查询文章的，像查询分类，标签，用户，就懒得写了,容易乱。
```
    <!--获得所有文章(文章归档)-->
    <select id="listArticle" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT * from article
        <where>
            <if test="status != null">
                article_status=#{status}
            </if>
        </where>
        order BY article_status ASC ,article_order desc, article_id DESC
    </select>
```

#用户退出

session移除user对象，然后跳转到登陆页面

    session.removeAttribute("user");


	2018-12-03 22:01:55
kumika	SSM博客实战---需求到实现过程2	# SSM博客实战---需求到实现过程2


#后台文章管理

#显示全部文章
**（就是查询全部的文章，然后按照XX篇显示文章，从第一页显示，形成分页）**
[![后台文章显示.jpg](https://i.loli.net/2018/12/08/5c0b7a7e1df84.jpg)](https://i.loli.net/2018/12/08/5c0b7a7e1df84.jpg)

需求：
**显示全部的文章（包括草稿），而且是分页显示，从第一页开始**


控制层：

1   写死每页显示文章数量pageSize为30篇
2   根据status = 1，pageNow= null，pageSize，查询文章对象列表
3   根据status = 0，查询草稿文章列表
4   返回2个列表

业务层：

这里有一个多变量集合到一起的对象：分页page
为什么要有这个对象？
因为你输入的参数不能直接到数据库上查询（数据需要转换）


一般分页：

    网页输入：    status，对象id， 当前XX页，      pageSize（可能后台写死）
    数据库查询：  status，对象id， 查询表格里字段的起始编号，pageSize


所以就是**当前XX页=====》转换======》查询表格里字段的起始编号**。这就是分页对象page的作用

在page对象中的具体转换：

    currentPage ： 当前XX页
    
    startPos ： 查询表格里字段的起始编号
    
    startPos = currentPage X pageSize 



业务思路：
1   创建文章总信息对象列表
2   根据status= 1，查询全部文章的数量totalCount
3   判断pageNow是否为Null

    3.1     当pageNow = null ，构建分页对象page： new Page(totalCount, 1, pageSize)
    3.2     当pageNow != null , 构建分页对象page： new Page(totalCount, pageNow, pageSize) 

4   根据status ，分页page转换得到的startPos，pageSize，这3个参数，查询文章列表，俗称根据分页查询文章。
5   遍历文章列表，创建文章总信息对象，然后填充4个对象（文章，分类，标签，用户）
6   把文章总信息对象增加到文章总信息对象列表上，然后返回

#文章分页显示
**（就是查询全部的文章，然后按照XX篇显示文章，从当前页数显示，形成分页）**

[![分页显示.jpg](https://i.loli.net/2018/12/08/5c0b7a7e1c26e.jpg)](https://i.loli.net/2018/12/08/5c0b7a7e1c26e.jpg)


**就将上面的代码复制一遍，然后区别就是pageNow是动态获取的，方法是使用注解@PathVariable和  @RequestMapping("/p/{pageNow}")**



#后台添加文章

基本思路：

    1   先是准备好显示的资源对象，然后跳转到操作页面
    2   提交对象，增加到数据库，完成添加

[![增加文章.jpg](https://i.loli.net/2018/12/09/5c0cda77ef29b.jpg)](https://i.loli.net/2018/12/09/5c0cda77ef29b.jpg)

##1 准备资源和跳转页面

###**准备资源：**
**分类对象：**
根据status 查询全部的分类对象
**Dao层：**
```
   <!-- //获得分类列表-->
    <select id="listCategory" resultType="Com.zhihu.foreBlog.pojo.Custom.CategoryCustom">
        SELECT * from category
        <where>
            <if test="status != null">
                category_status =#{status}
            </if>
        </where>
        ORDER BY  category_status ASC ,category_order DESC ,category_id ASC
    </select>
```


**标签对象：**
根据status 查询全部的标签对象
**Dao层：**
```
    <!--获得标签列表-->
    <select id="listTag" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.TagCustom">
        SELECT  * from tag
        <where>
            <if test="status != null">
                tag_status = #{status}
            </if>
        </where>
        ORDER BY  tag_status ASC
    </select>
```

**跳转到页面:**

    return "/Admin/Article/insert";

##2 提交文章对象

此时是在增加文章（包括草稿）的页面上

提交上来的文章对象里有值的属性： id，标签，分类，文章内容，文章标题
但是数据库不止这几个，所以要先设置（注意草稿的属性）然后增加到数据库上。

业务层；

    articleMapper.insertSelective(article);




#搜索实现


**需求：**
**搜索查询，搜索的范围是文章标题，内容（在Sql中实现搜索范围）**

***分页搜索： 就是第一页搜索，和在第XX页搜索的区别，重点在于获取当前页数pageNow***

##没有动态获取当前页数
###控制层：
----

方法注入搜索条件参数：query

  搜索方法： 6个参数 status = 1，model，request，pageNow = null, pageSize, query 
**(其中query，status 是进入数据库查询的，其他的在业务层)**

###业务层:
----
1   根据status= 1 和 搜索条件query 查询有关的文章的数量totalCount
2   判断PageNow是否为null
        2.1 pageNow = null ，根据`totalCount，pageNow= 1, pageSize`,构建分页对象page，然后根据`分页page的属性startPos, pageSize,status, query`  4个参数进行搜索，返回文章列表
        2.2 pageNow != null ，根据`totalCount，pageNow= 动态获取值, pageSize`,构建分页对象page，然后根据`分页page的属性startPos, pageSize,status, query`  4个参数进行搜索，返回文章列表
3   遍历文章列表，创建文章总信息对象，填充4个对象进去
4   返回文章总信息列表
5   跳转Admin/Article/search

###Dao层：
搜索的范围： 这里是根据表格的字段来进行搜索的
搜索文章标题：`article_title LIKE "%${query}%"`
搜索文章内容：`article_content like "%${query}%"`

注意：为什么2个方法的搜索条件引用符号不一致啊

        article_title like '%${query}%'
    article_content like '"%${query}%"'
**Sql:**
```
    <!--查询结果统计-->
    <select id="getSearchResultCount" resultType="Integer">
        select count(*) from article
        <where>
            <if test="status != null">
                article_status =#{status}
            </if>
            AND article_status > 0
            AND article_title LIKE "%${query}%"
            OR  article_content like "%${query}%"
        </where>
    </select>

    <!--搜索-->
    <select id="listSearchResultByPage" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT * from article
        <where>
            <if test="status != null">
                article_status=#{status} AND
            </if>
            article_status > 0
            AND article_title like '%${query}%'
            OR article_content like '"%${query}%"'
        </where>
        ORDER  BY article_status ASC ,article_order DESC  , article_id DESC
        limit #{startPos},#{pageSize}
    </select>
```


##有动态获取当前页数

在控制层中，方法增加注入动态获取当前页数PageNow

    @PathVariable("pageNow") Integer pageNow
    @RequestParam("query") String query




#删除文章


##单个删除

**控制层：** 

方法注入动态获取删除文章的id：
`@PathVariable("id") Integer id`
然后进行删除

##批量删除

**ids获取删除文章id的这个过程是前端技术，了不了解看自己心情。**


**控制层：**
1   方法注入参数 删除的文章编号（可多个）ids
`@PathVariable("ids") String ids`
2   将字符串的ids 分成String数组arr[]
3   根据String数组arr[]的长度，创建Integer数组ids[]
4   for循环将遍历ids[]，把全部的文章编号转换成Integer类型的
5   调用ArticleService的批量删除方法deleteArticleBatch(Integer数组)



**业务层:**

for循环遍历Integer数组，一个个删除
```
 for (int i = 0;i < ids.length; i++) {
            articleMapper.deleteByPrimaryKey(ids[i]);
        }
```


#编辑文章（更新）

**基本思路： 任何更新，都是先知道更新的对象，然后在进行更新**


##获取更新对象
**控制层：**
1   方法动态获取文章id

    @PathVariable("id") Integer id

2   根据id和status查询分类对象和标签

3   跳转到Admin/Article/edit

##进行更新

**控制层：**
1   根据提交上来的文章对象，更新文章对象的更新时间
2   更新到数据库上


#相似文章获取

**需求：**
**根据一个文章id，查询一系列文章**，这种类似查询一定要有别的变量作为基础条件才能查询，单靠一个文章id是不能查询的。

**变量过程：**
输入的变量： status，文章id
输入数据库的变量： status， 2个分类id
输出的变量： 文章对象列表

关键点：
**类似是以分类为基础的，根据分类id，查询就可以了**


**控制层：**

    1   根据文章id，查询文章对象
    2   根据文章对象上的属性，获取分类id（有上下级2个分类id）
    3   根据status = 1，2个分类id，这3个参数，查询文章列表


**Dao层：**

mybatis的 trim 标签，知道怎么用可以了

```
    <select id="listArticleWithSameCategory" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        select * from article

        <trim prefix="where" prefixOverrides="AND | OR" suffixOverrides="AND | OR">
            <if test="status != null">
                article_status=#{status} AND
            </if>
            <if test="parentCategoryId !=null">
                article_parent_category_id =#{parentCategoryId} OR
            </if>
            <if test="childCategoryId != null">
                article_child_category_id = #{childCategoryId}
            </if>
        </trim>
        ORDER BY  article_status ASC, article_order DESC, article_id DESC
        limit #{limit}
    </select>
```


#猜你喜欢

**需求：**
**获取数据库浏览数量最多的，返回给客户。**

根据表格的字段：浏览最多，来进行查询返回（定死了属性）

**变量过程**
输入变量：status = 1 ，limit = 5
输出变量： 文章列表

**关键点：**
 排列，是根据**哪个字段进行排列**的

**控制层**

根据status = 1，返回数量limit = 5， 查询浏览最多文章列表

**Dao层：**


```
    <!--猜你喜欢-->
    <select id="listArticleByViewCount" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT  * from article
        <where>
            <if test="status != null">
                article_status=#{status}
            </if>
        </where>
        ORDER BY article_view_count DESC,article_order DESC, article_id DESC
        limit #{limit}
    </select>
```




#获取下一篇文章

需求：
 点击 next，获取下一篇文章

关键点： 
**获取当前文章id，以文章id为基准，在数据库中筛选，以排列顺序作为筛选的条件：大于文章id，然后限制返回数量为1**


**控制层：**

    1   动态获取当前文章的id
    2   根据status = 1，文章id，查询文章对象


**Dao层：**

```
    <!--获得下一篇的文章-->
    <select id="getAfterArticle" resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT * from article
        <where>
            <![CDATA[ article_id > #{articleId}]]>
            <if test="status != null">
                and article_status=#{status}
            </if>
        </where>
        ORDER  BY article_id
        limit 1
    </select>
```



#获取上一篇文章



**关键点思路：**
**以当前文章id为基准，排序的筛选条件： 小于文章id，返回数量为1**


**控制层：**

    1   动态获取当前文章的id
    2   根据status = 1，文章id，查询文章对象



**Dao层：**

```
   <!--获得上一篇的文章-->
    <select id="getPreArticle"  resultType="Com.zhihu.foreBlog.pojo.Custom.ArticleCustom">
        SELECT * from `article`
        <where>
            <![CDATA[article_id < #{articleId}]]>
            <if test="status != null">
               AND article_status =#{status}
            </if>
        </where>
        ORDER BY article_id
        limit 1
    </select>
```


和下一篇 的区别： 
**在排列的筛选条件**，  
当前文章id  《  字段 ，这是查询下一篇文章

当前文章id   》 字段， 这是查询上一篇文章




#文章点赞数增加+1
**类似文章访问量数增加+1**

关键点：
**（对象的属性包括字段数量的情况下）**

    1   这类字段数量+1的更新，都是获取id，查询得到对象，
    2   从对象的属性上得到字段数量
    3   字段数量+1
    4   赋值给对象
    5   更新到数据库





	2018-12-07 19:26:37
kumika	SSM博客实战---需求到实现过程3	# SSM博客实战---需求到实现过程3



#分类



#后台分类全部显示

**需求： 要有全部的分类对象，也要知道在分类对象下的文章数量**

##**控制层：**

根据status = null ，查询全部的分类对象

##**业务层:**

根据status = null，查询分类对象，返回分类列表
遍历分类列表，获取分类id，然后根据分类id，调用文章业务层的方法查询分类下文章的数量，最后设置到分类属性中。


##**Dao层；**

分类dao层
```
   <!-- //获得分类列表-->
    <select id="listCategory" resultType="Com.zhihu.foreBlog.pojo.Custom.CategoryCustom">
        SELECT * from category
        <where>
            <if test="status != null">
                category_status =#{status}
            </if>
        </where>
        ORDER BY  category_status ASC ,category_order DESC ,category_id ASC
    </select>
```


#分类添加

网页提交上分类对象，然后就直接增加到数据库上



#分类删除

需求：删除分类，**要是分类下还要文章是不能删除的**

**控制层:**

1   动态获取删除分类id，然后方法注入`@PathVariable("id") Integer id`
2   根据status = null，分类id，查询文章数量count
3   判断count是否为0，是0就能够删除


#编辑分类（更新）


##查询需要编辑的分类

1   动态获取需要编辑的分类`@PathVariable("id") Integer id`
2   根据status= null，分类id，查询目标分类
3   根据status= null，查询全部的分类对象（页面显示需求）

**Dao层：**
```
    <!--根据分类id获得分类信息-->
    <select id="getCategoryById" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.CategoryCustom">
        SELECT <include refid="category_table_all_column"/> from category
        <where>

            <if test="status != null">
                category_status=#{status}  and
            </if>
             category_id=#{id}
        </where>
    </select>
```

##提交到数据库

**控制层：**

获取提交上来的分类对象，然后更新到数据库

Dao层:
```
  <update id="updateByPrimaryKeySelective" parameterType="Com.zhihu.foreBlog.pojo.Category" >
    update category
    <set >
      <if test="categoryPid != null" >
        category_pid = #{categoryPid,jdbcType=INTEGER},
      </if>
      <if test="categoryName != null" >
        category_name = #{categoryName,jdbcType=VARCHAR},
      </if>
      <if test="categoryDescription != null" >
        category_description = #{categoryDescription,jdbcType=VARCHAR},
      </if>
      <if test="categoryOrder != null" >
        category_order = #{categoryOrder,jdbcType=INTEGER},
      </if>
      <if test="categoryIcon != null" >
        category_icon = #{categoryIcon,jdbcType=VARCHAR},
      </if>
      <if test="categoryStatus != null" >
        category_status = #{categoryStatus,jdbcType=INTEGER},
      </if>
    </set>
    where category_id = #{categoryId,jdbcType=INTEGER}
  </update>
```











	2018-12-10 11:40:05
kumika	SSM博客实战---需求到实现过程4	# SSM博客实战---需求到实现过程4


#评论


#后台显示全部评论

评论中有2中状态的评论对象，正常显示的，屏蔽的。所以查询全部的评论对象就是2种都要查询。
[![评论.jpg](https://i.loli.net/2018/12/10/5c0e2a34c717e.jpg)](https://i.loli.net/2018/12/10/5c0e2a34c717e.jpg)

**控制层：**

    1   根据status = null，pageNow= null, pageSize， 3个参数查询正常的评论总信息对象（分页显示，所以需要page）
    2   根据status = 0 查询屏蔽的评论总信息对象（不分页显示，所以不需要page）


**业务层：**

查询正常状态的评论对象：

    1   根据status = 1，查询正常状态评论对象的数量count
    2   根据count，pageNow, pageSize，构建分页对象page，然后以status，page的属性startPos，pageSize，这3个参数查询正常状态的评论对象，返回评论列表
    
    3   遍历列表，创建评论总信息对象，然后依靠评论对象的外键，查询文章对象，头像，最后把评论对象，文章，头像都放入总信息对象上。
    4   总信息对象放入列表上，然后列表的第一个元素存放分页page
    5   返回列表


查询屏蔽状态的评论对象：


    1   根据status = 0，查询屏蔽状态的评论对象，返回评论列表
    2   遍历列表，创建评论总信息对象，然后依靠评论对象的外键，查询文章对象，头像，最后把评论对象，文章，头像都放入总信息对象上。
    3   总信息对象放入列表上，然后列表的第一个元素存放分页page
    4   返回列表




**Dao层：**

根据分页查询：

```
    <!--统计评论数-->
    <select id="countComment" parameterType="Integer" resultType="Integer">
        SELECT  count(*) from comment
        <where>
            <if test="status != null">
                comment_status=#{status}
            </if>
        </where>
    </select>
    <!--根据页数获取评论-->
    <select id="listCommentByPage" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.CommentCustom">
        SELECT * from comment
        <where>
            <if test="status!= null">
                comment_status = #{status}
            </if>
        </where>
        ORDER by comment_status ASC ,comment_id DESC
        limit #{startPos},#{pageSize}
    </select>
```

根据status查询：

```
    <!--查询评论列表对象-->
    <select id="ListComment"  resultType="Com.zhihu.foreBlog.pojo.Custom.CommentCustom">
        SELECT  <include refid="comment_table_all_columns"/> from comment
        <where>
            <if test="status != null">
                comment_status=#{status}
            </if>
        </where>
        ORDER  BY  comment_id ASC
    </select>
```



#分页显示评论

和上面是一样的过程，区别在方法上动态获取当前页数pageNow，  `@PathVariable("pageNow") Integer pageNow`



#增加评论


需求：
有2个回复区域

    1   文章下面的回复区（类似贴吧）
    2   后台评论的回复按钮

**但是这里有个BUG，没有显示自己回复自己的评论，在后台回复也有几率在前台没有显示。
增加评论，和回复评论有区别吗？**


因为脑子不够用，所以问题就先搁置把。

**控制层：**


1   方法注入提交上来的评论对象
2   设置评论对象的创建时间
3   插入到数据库上

4   因为增加了评论，所以要更新文章对象上的评论数量属性，所以根据status = null，评论对象的外键，查询文章对象
5   根据文章id，更新文章对象的评论数量   


**业务层：**

**评论业务层:**
插入到数据库上


**文章业务层:**


根据文章id ，更新文章评论数量


**Dao层：**

评论Dao层：
```
  <insert id="insertSelective" parameterType="Com.zhihu.foreBlog.pojo.Comment" >
    insert into comment
    <trim prefix="(" suffix=")" suffixOverrides="," >
      <if test="commentId != null" >
        comment_id,
      </if>
      <if test="commentPid != null" >
        comment_pid,
      </if>
      <if test="commentPname != null" >
        comment_pname,
      </if>
      <if test="commentArticleId != null" >
        comment_article_id,
      </if>
      <if test="commentAuthorName != null" >
        comment_author_name,
      </if>
      <if test="commentAuthorEmail != null" >
        comment_author_email,
      </if>
      <if test="commentAuthorUrl != null" >
        comment_author_url,
      </if>
      <if test="commentContent != null" >
        comment_content,
      </if>
      <if test="commentAgent != null" >
        comment_agent,
      </if>
      <if test="commentIp != null" >
        comment_ip,
      </if>
      <if test="commentCreateTime != null" >
        comment_create_time,
      </if>
      <if test="commentRole != null" >
        comment_role,
      </if>
      <if test="commentStatus != null" >
        comment_status,
      </if>
    </trim>
    <trim prefix="values (" suffix=")" suffixOverrides="," >
      <if test="commentId != null" >
        #{commentId,jdbcType=INTEGER},
      </if>
      <if test="commentPid != null" >
        #{commentPid,jdbcType=INTEGER},
      </if>
      <if test="commentPname != null" >
        #{commentPname,jdbcType=VARCHAR},
      </if>
      <if test="commentArticleId != null" >
        #{commentArticleId,jdbcType=INTEGER},
      </if>
      <if test="commentAuthorName != null" >
        #{commentAuthorName,jdbcType=VARCHAR},
      </if>
      <if test="commentAuthorEmail != null" >
        #{commentAuthorEmail,jdbcType=VARCHAR},
      </if>
      <if test="commentAuthorUrl != null" >
        #{commentAuthorUrl,jdbcType=VARCHAR},
      </if>
      <if test="commentContent != null" >
        #{commentContent,jdbcType=VARCHAR},
      </if>
      <if test="commentAgent != null" >
        #{commentAgent,jdbcType=VARCHAR},
      </if>
      <if test="commentIp != null" >
        #{commentIp,jdbcType=VARCHAR},
      </if>
      <if test="commentCreateTime != null" >
        #{commentCreateTime,jdbcType=TIMESTAMP},
      </if>
      <if test="commentRole != null" >
        #{commentRole,jdbcType=INTEGER},
      </if>
      <if test="commentStatus != null" >
        #{commentStatus,jdbcType=INTEGER},
      </if>
    </trim>
  </insert>
```

文章Dao层：
```
    <!--//更新文章的评论数-->
    <select id="updateCommentCount" parameterType="Integer">
        UPDATE article
        SET article_comment_count =
        (
            SELECT  count(*) from comment where article_id = comment_article_id AND comment_status= 1
        )
        where article_id=#{articleId}
    </select>
```




#删除评论

需求：
---

**删除评论，而且也要删除其子评论**



**控制层：**

1   动态获取删除评论的id，注入方法中
2   根据id，删除评论对象
3   根据id，查询评论的子评论对象列表
4   遍历子评论列表，获取子评论id，然后删除子评论

因为删除评论了
5   更新文章评论数量




**业务层：**

评论业务层：
根据id，删除评论对象


文章业务层：
根据评论id，更新文章对象的评论数量




**Dao层：**

评论Dao层：
```
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" >
    delete from comment
    where comment_id = #{commentId,jdbcType=INTEGER}
  </delete>
```


文章Dao层：
```
    <!--//更新文章的评论数-->
    <select id="updateCommentCount" parameterType="Integer">
        UPDATE article
        SET article_comment_count =
        (
            SELECT  count(*) from comment where article_id = comment_article_id AND comment_status= 1
        )
        where article_id=#{articleId}
    </select>
```


#编辑评论

[![编辑评论.jpg](https://i.loli.net/2018/12/14/5c131530a19e7.jpg)](https://i.loli.net/2018/12/14/5c131530a19e7.jpg)

**需求：**
    **能更改评论内容，和评论状态**

##查询编辑的评论

**控制层：**

    1   获取提交上来 的需要编辑的评论id
    2   根据id查询评论


##更新到数据库
**控制层：**

    1   获取提交上来的评论对象
    2   更新到数据库上
    3   从评论对象获取评论id
    4   **判断提交上来的评论对象的属性status 是1还是0**
    5   是0，就是屏蔽状态，其子评论也要屏蔽，也要设置为0，所以根据id，查询子评论对象，返回子评论列表
    6   遍历子评论列表，把每一个子评论的属性status都设置为0，然后更新到数据库
    
    7   是1，就是批准状态，其子评论也是批准状态，也要设置为1，所以根据id，查询子评论对象，返回子评论列表
    8   遍历子评论列表，把每一个子评论的属性status都设置为1，然后更新到数据库
    
    9   跳转redirect:/admin/comment


**业务层：**
根据id，查询子评论列表

**Dao层:**

```
    <!--获取子评论-->
    <select id="listChildComment" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Comment">
        SELECT * from  comment
        <where>
            comment_pid=#{id}
        </where>
    </select>
```


#后台批准评论

**需求：**
**点击批准，完成更改评论的状态**
[![批准.jpg](https://i.loli.net/2018/12/14/5c131c1929d86.jpg)](https://i.loli.net/2018/12/14/5c131c1929d86.jpg)

**控制层:**

    1   动态获取提交上来的评论id
    2   根据id，查询评论对象
    3   设置评论的属性status = 1
    4   更新到数据库上
    5   根据id，查询子评论，返回列表
    6   遍历子评论列表，把每一个子评论的属性status都设置为1，然后更新到数据库
    
    7   根据评论的外键获取文章id
    8   根据文章id，查询文章对象
    9   更新文章的评论数量


**Dao层:**

**文章Dao层：**
`更新评论数量`
没有输入的变量的话，可以使用别的表格来获取需要的变量，所以没有输入的变量（使用2个表格或者2个以上）
```
    <!--//更新文章的评论数-->
    <select id="updateCommentCount" parameterType="Integer">
        UPDATE article
        SET article_comment_count =
        (
            SELECT  count(*) from comment where article_id = comment_article_id AND comment_status= 1
        )
        where article_id=#{articleId}
    </select>
```


#后台屏蔽评论

**需求：**

**点击屏蔽，就更改评论对象的状态**

[![屏蔽.jpg](https://i.loli.net/2018/12/14/5c13257c67618.jpg)](https://i.loli.net/2018/12/14/5c13257c67618.jpg)


**就是把上面的方法写一遍，把status= 1 改成status = 0** 




#回复评论

需求：
**点击回复，回复评论，类似贴吧。**
一种更新。

##获取需要回复的评论

    1   动态获取需要回复对象的id
    2   根据id，查询评论对象（你要回复的对象）
    3   返回到页面

##提交回复

**控制层：**

    1   方法注入网页提交评论对象，和 request
    2   根据评论对象的外键，查询文章id，查询文章
    3   设置文章的评论数量（在原来的数量上+1）
    4   更新到数据库
    5   对提交上来的评论对象，设置创建日期，状态status为1
    6   request，评论对象作为参数，增加到数据库

**业务层：**

    1   根据request，使用工具类，获取评论头像，设置到评论对象上
    2   把评论对象插入到数据库上



##回复的主要思想是链表
这里的回复都是
----获取要回复的对象，它的id ,用户名，文章id，都赋值给新的评论对象里代表上级的属性，`Pid,PName，ArticleId`

**网页赋值的代码：**
```
        <input type="hidden" name="commentPid" value="${commentCustom.commentId}">
        <input type="hidden" name="commentPname" value="${commentCustom.commentAuthorName}">
        <input type="hidden" name="commentArticleId" value="${commentCustom.commentArticleId}">
```

然后**新的评论对象**在增加到数据库后，这3个作为**链条**，**连接**着评论


**网页上回复的评论对象**
[![回复的评论对象1.jpg](https://i.loli.net/2018/12/14/5c136b2beeeb9.jpg)](https://i.loli.net/2018/12/14/5c136b2beeeb9.jpg)

比如：言777是上一楼的评论者，5444是2楼的评论者，下面提交的评论就是3楼了，然后注意看下图，提交评论对象的属性，**PName,Pid都是2楼的，AeritcleId都是16**


**提交的评论**
[![提交1.jpg](https://i.loli.net/2018/12/14/5c136b2b8cd54.jpg)](https://i.loli.net/2018/12/14/5c136b2b8cd54.jpg)




**增加评论/帖子的过程，就是链表增加的过程**


	2018-12-10 16:39:30
kumika	SSM博客实战---需求到实现过程5	# SSM博客实战---需求到实现过程5

#连接


#显示后台全部的链接对象

**控制层：**
根据status = null，查询全部的链接对象


**Dao层：**
```
    <!--获取链接列表-->
    <select id="listLink" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.LinkCustom">
        SELECT * from link
        <where>
            <if test="status != null">
                link_status =#{status}
            </if>
        </where>
        ORDER BY link_status ASC ,link_order DESC ,link_id ASC
    </select>
```



#后台添加链接页面显示

需求：

就是跳转到增加页面，而且显示全部的链接对象


#后台增加链接

**控制层：**

    1   提交上来链接对象
    2   设置链接的创建日期，更新日期，status = 1
    3   更新到数据库上
    4   跳转到redirect:/admin/link/insert



#删除链接对象

**控制层:**

    1   动态获取目标id
    2   根据id，进行删除
    3   跳转redirect:/admin/link


#编辑链接对象


##查询需要编辑的对象

**控制层：**

    1   动态获取链接id，注入方法
    2   根据id，查询链接对象
    3   跳转编辑页面："Admin/Link/edit"

##编辑链接提交


    1   获取提交上来的链接对象
    2   设置链接更新日期
    3   更新到数据库
    4   跳转redirect:/admin/link










	2018-12-14 16:18:17
kumika	SSM博客实战---需求到实现过程7	# SSM博客实战---需求到实现过程7


#公告


#显示全部的公告

**控制层：**

    1   根据status = null，查询全部的公告
    2   跳转


#添加公告

##跳转到添加页面

1   跳转



##增加公告提交

**控制层**

    1   获取提交上来的公告对象
    2   设置公告页面表格没显示的属性（不成熟的开发）
    3   增加到数据库上
    4   跳转



#删除公告

**控制层：**

    1   动态获取目标id
    2   根据id，进行删除




#编辑公告


##获取编辑对象

    1   动态获取id
    2   根据id查询公告对象
    3   跳转


##提交编辑对象


    1   获取提交上来公告对象
    2   设置网页没有设置的属性（不成熟）
    3   更新到数据库上
    4   跳转













	2018-12-14 16:59:37
kumika	SSM博客实战---需求到实现过程6	# SSM博客实战---需求到实现过程6


#**菜单**


#后台全部显示菜单

**控制层：**

1   根据status = null，查询全部的菜单对象
2   跳转Admin/Menu/index


**Dao层:**

```
    <!--获得菜单列表-->
    <select id="listMenu" parameterType="Integer" resultType="Com.zhihu.foreBlog.pojo.Custom.MenuCustom">
        SELECT * from menu
        <where>
            <if test="status != null">
                menu_status=#{status}
            </if>
        </where>
        ORDER  BY menu_id ASC ,menu_order DESC ,menu_status ASC
    </select>
```


#添加菜单

**控制层：**

    1   获取提交的菜单对象
    2   设置菜单的属性status = 1，order = 1
    3   增加到数据库上
    4   跳转redirect:/admin/menu


#删除菜单

**控制层：**

    1   动态获取删除目标id
    2   进行删除
    3   跳转redirec:/admin/menu





#编辑菜单

##获取编辑对象

**控制层：**

    1   动态获取菜单id
    2   根据菜单id，查询菜单对象
    3   跳转Admin/Menu/edit



##提交对象


**控制层：**

    1   获取编辑的菜单对象
    2   更新到数据库
    3   跳转redirect:/admin/menu







	2018-12-14 17:00:13
kumika	SSM博客实战---需求到实现过程8	# SSM博客实战---需求到实现过程8


#基本信息

#显示全部

根据status = null，查询全部的基本信息对象


#编辑基本信息

##跳转到编辑页面

1   跳转


##提交编辑对象

    1   获取提交上来的对象
    2   判断对象的id是否为null
    2.1     要是null，则是增加到数据库上
    2.2     要是不为null，则更新到数据库上
    3   跳转























	2018-12-14 18:17:28
kumika	SSM博客实战---需求到实现过程9	# SSM博客实战---需求到实现过程9


#页面

#后台页面列表显示

根据status = null，查询全部的页面


#后台添加页面


##跳转到增加页面

跳转


##提交页面

**控制层：**

    1   获取提交的页面对象
    2   根据status= null，和页面对象的属性PageKey，判断提交上来的页面对象在数据库上是否存在
    3   不存在，则进行设置一些页面没有的属性设置
    4   增加到数据库山
    5   跳转


**Dao层：**
```
    <!--根据key获得-->
    <select id="getPageByKey" resultType="Com.zhihu.foreBlog.pojo.Custom.PageCustom">
        select * from page
        <where>
            <if test="status!=null">
                page_status = #{status} AND
            </if>
            page_key=#{key}
        </where>
    </select>
```



#删除页面

1   获取删除页面对象的id
2   根据id，进行删除



#编辑页面

##获取页面

1   动态获取页面对象的id
2   根据id，进行查询


##提交页面

    1   获取提交上来的页面对象
    2   根据status = null，和页面对象的属性PageKey
    3   判断提交上来的页面对象在数据库上是否存在
    4   不存在，则进行更新
    5   跳转




	2018-12-14 18:21:57
kumika	SSM博客实战---需求到实现过程10	# SSM博客实战---需求到实现过程10



#标签

#后台标签列表显示

根据status = null，查询全部的标签


#添加标签

不跳转了

1   获取提交上来的标签
2   增加到数据库上



#删除标签

需求：
    **能删除的标签，必须要标签下的文章数量为0**

    1   动态获取删除的标签id
    2   根据标签id和status = null，查询标签，查看文章数量属性
    3   判断文章数量是否等于0
    4   等于0 ，根据标签id，进行删除
    5   跳转


#编辑标签

##获取标签对象

1   动态获取标签id
2   根据id，进行查询
3   跳转


##提交标签对象

1   获取提交上来的标签对象
2   更新到数据库上
3   跳转


	2018-12-14 23:00:28
kumika	SSM博客实战---需求到实现过程11	# SSM博客实战---需求到实现过程11


#用户




#后台用户列表显示

查询全部的用户
跳转


#检查用户名称

**控制层**

    1   获取request和用户名Username
    2   根据userName查询用户对象
    3   从request获取id
    4   判断用户对象是否为null
    5   判断用户的id是否和从request获取的id是否一致
    6   一致，则说明存在
    7   不一致，则说明不存在
    8   返回

Dao层：
```
    <select id="getUserByNameOrEmail" parameterType="String" resultType="Com.zhihu.foreBlog.pojo.User">
        SELECT * from `user`
        <where>
            user_name=#{value} OR  user_email=#{value} AND
        </where>
          user_status>0 limit 1
    </select>
```

#检查邮箱

将上面的Username，更改成Email就可以了

**Dao层：**
```
    <select id="getUserByNameOrEmail" parameterType="String" resultType="Com.zhihu.foreBlog.pojo.User">
        SELECT * from `user`
        <where>
            user_name=#{value} OR  user_email=#{value} AND
        </where>
          user_status>0 limit 1
    </select>
```


#后台添加用户

##跳转添加页面

跳转


##提交用户
**控制层：**

    1   获取提交上来的用户对象User
    2   根据用户对象User的Username，查询用户对象，返回User2
    3   根据用户对象User的Email，查询用户对象，返回User3   
    4   判断User2 和User3 是否都是null
    5   都是，则设置注册日期，status = 1
    6   增加到数据库上
    7   跳转



#删除用户

动态获取目标id
根据id，进行删除



#编辑用户


##获取用户

1   动态获取用户id
2   根据id，查询用户
3   跳转



##编辑用户提交

1   获取提交的用户
2   更新到数据库山
















	2018-12-14 23:07:26
kumika	SSM博客实战---上传文件功能	# SSM博客实战---上传文件功能


疑问：
    这个上传文件返回的是哪里呢？
    答： 上传页面上的script
    

**这里只能实现上传，但是没有实现页面显示上传的图片**


#配置文章：
在Spring-MVC上
```
    <!--文件上传-->
    <bean id="multiparResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
        <!--设置上传最大尺寸为50MB-->
        <property name="maxUploadSizePerFile" value="52428800"/>
        <property name="defaultEncoding" value="UTF-8"/>
        <property name="resolveLazily" value="true"/>
    </bean>
```


#Controller

    /**
     * 方法注入网页提交上来的文件file， 注意文件的类型是MultipartFile
     *  1       本地使用,上传位置
     *  2       获取file的完整名称，fileName
     *  3       根据indexOf，substring，lastIndexOf获取fileName的文件名和后缀名
     *  4       根据当前时间创建年月文件 dateDirs
     *  5       文件路径+ 年月文件+文件名创建 目标文件descFile
     *  6       若存在相同的文件名称，则创建一个String变量：fileName赋值给它 ，新的文件名newFileName
     *  6.1     目标文件存在，则赋值newFileName, 值是文件名 + 随便数字 + 后缀
     *  6.2     获取文件路径的上级路径parentPath= descFile.getParent();
     *  6.3     根据parentPath + 随机数字 + newFileName创建一个新的目标文件
     *
     *  7       判断目标文件是否存在，如果目标文件所在的目录不存在，则创建父目录
     *  8       将内存中的数据写入磁盘（提交上来的文件，存放入服务器）
     *  9       根据/upload/ + 年月文件 + / + newFileName 创建一个完整的url----fileUrl
     *  10      创建ResultVO对象，和UploadFileVo对象
     *  11      ResultVO赋值 Code 为0 ，MSG为”成功“
     *  12      UploadFileVo赋值 Title为 文件名newFileName， SRC 为 fileUrl,
     *  13      Result设置date为uploadFileVo，返回resultVo
     * @param file
     * @return
     * @throws IOException
     */

**代码：**

```
    //上传文件
    @RequestMapping(value = "/uploadFile", method = RequestMethod.POST)
    @ResponseBody
    public ResultVO uploadFile(@Param("file") MultipartFile file) throws IOException {

        //本地使用,上传位置
        String rootPath = "I:/ideaDExiangmu/Forest22Blog/uploads/";

        //文件的完整名称,如spring.jpeg
        String fileName = file.getOriginalFilename();
        //文件名,如spring
        String name = fileName.substring(0, fileName.indexOf("."));
        //文件后缀,如.jpeg
        String suffix = fileName.substring(fileName.lastIndexOf("."));


        //创建年月文件夹
        Calendar date = Calendar.getInstance();
        File dateDirs = new File(date.get(Calendar.YEAR)+File.separator+(date.get(Calendar.MONTH)));


        //目标文件，文件路径+ 时间文件+文件名创建
        File descFile = new File(rootPath + File.separator + dateDirs + File.separator + fileName);

        int i = 1;
        //若文件存在重命名
        String newFilename = fileName;

        while (descFile.exists()) {
            newFilename = name + "(" + i + ")" +suffix;
            String parentPath = descFile.getParent();
            descFile = new File(parentPath + File.separator + newFilename);
            i++;
        }

        //判断目标文件所在的目录是否存在
        if (!descFile.getParentFile().exists()) {
            //如果目标文件所在的目录不存在，则创建父目录
            descFile.getParentFile().mkdirs();
        }


        //将内存中的数据写入磁盘
        file.transferTo(descFile);

        //完整的url
        String fileUrl = "/uploads/" + dateDirs + "/" + newFilename;


        ResultVO resultVO = new ResultVO();
        resultVO.setCode(0);//错误码
        resultVO.setMsg("成功");

        UploadFileVo uploadFileVo = new UploadFileVo();
        uploadFileVo.setTitle(fileName);
        uploadFileVo.setSrc(fileUrl);
        resultVO.setData(uploadFileVo);
        return resultVO;
    }
```






我不知道在上传后回显图片的JSP代码是怎么执行的？

在保存图片后，返回图片地址，在JSP的哪里读取？



天猫的回显：
1   上传完成后，带着产品id，跳转到根据产品id查询图片的方法上
2   根据产品id进行查询，返回对象为图片list
3   把图片list设置到session的属性上
4   jsp上根据session进行赋值




博客的回显：

静态回显：
先在文件上有编号的图片，然后再去读取，并不是上传然后读取
```
 src="/img/thumbnail/random/img_${a.articleCustom.articleId%400}.jpg"
```

tomcat设置虚拟路径，现在不知道是路径配置出错，还是原本项目的代码错了？

参考:  https://www.cnblogs.com/badboyh2o/p/9578994.html

3个设置点：

##Tomcat的配置文件service.xml：

```
<Context docBase="d:\images" path="/photos" reloadable="true"/> <!-- 设置虚拟路径 -->
```

现在自己的：

图片：
```
 <Context path="/pic" docBase="D:\upload\temp\img" crossContext="true" trusted="true" reloadable="true"/>
```


文件：
```
<Context path="/file" docBase="D:\upload\temp\file" crossContext="true" trusted="true" reloadable="true"/>
```


##项目的Java类：

```
　File file=new File("d:\\images\\"+fileRealName); //图片上传路径
　　...
　　String path="/photos/"+fileRealName; //保存到数据库的虚拟路径 path
　　...

```


现在自己的：

```

```


##项目的JSP页面：

```
<img src="${path==''?'':path }" width="200px" style="margin:20px 0px 0px 100px;" /> <!-- 使用虚拟路径 -->
```


现在自己的：

```

```


现在不知道是

配置虚拟路径之后，上传失败


==========================================

没有配置虚拟路径，上传失败，出现404

没有配置虚拟路径，上传成功

成功与失败的原因：

idea的配置deployment 没有增加定向文件就上传成功了

Tomcat的service.xml文件没有配置就上传

==============================


配置虚拟路径之后，上传失败 出现404
应该是不关kind editor的问题


1   上传成功但是回显图片失败 
2   配置虚拟路径后，上传失败，出现404
3   配置虚拟路径后，能访问文件夹里面的图片

上传失败，文件没有存在，所以是URL的问题吗


上传失败，页面显示的文件名是原文件名

上传成功，后台返回的是新文件名，但是页面显示的还是原文件名


所以要看 kind editor的上传方法

    DispatcherServlet with name 'springmvc' processing POST request for








	2018-12-14 23:42:35
kumika	实战Production---数据库SQL	# 实战Production---数据库SQL

#表格

大概30个表格


[![production-SSM.jpg](https://i.loli.net/2018/12/16/5c16524dd92a0.jpg)](https://i.loli.net/2018/12/16/5c16524dd92a0.jpg)

[![sys的外键联系.jpg](https://i.loli.net/2018/12/27/5c249ac3e3584.jpg)](https://i.loli.net/2018/12/27/5c249ac3e3584.jpg)



客户
--

```
drop table if exists `custom`;
create table `custom`(
    `custom_id` varchar(40) not null primary key,
    `custom_name` varchar(20) default null,
    `full_name` varchar(100) default null,
    `address` varchar(100) default null,
    `fax` varchar(20) default null,
    `email` varchar(20) default null,
    `owner_name` varchar(20) default null,
    `ower_tel` varchar(20) default null,
    `status` int(11) default null,
    `note` varchar(2000) default null
)
```
-------------------------------------------------------

导出来的：
```
DROP TABLE IF EXISTS `custom`;
CREATE TABLE `custom` (
  `custom_id` varchar(40) NOT NULL,
  `custom_name` varchar(20) DEFAULT NULL,
  `full_name` varchar(100) DEFAULT NULL,
  `address` varchar(100) DEFAULT NULL,
  `fax` varchar(20) DEFAULT NULL,
  `email` varchar(20) DEFAULT NULL,
  `owner_name` varchar(20) DEFAULT NULL,
  `owner_tel` varchar(20) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `note` varchar(2000) DEFAULT NULL,
  PRIMARY KEY (`custom_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


客户Order
-------
```
drop table if exists `c_order`;
create table `c_order`(
    `order_id` varchar(40) not null primary key,
    `custom_id` varchar(40) default null,
    `product_id` varchar(40) default null,
    `orde_date` datetime default null,
    `request_date` datetime default null,
    `note` varchar(5000) default null,
    `quantity` int(11) default null,
    `unit_price` decimal(10,2) default null,
    `unit` varchar(10) default null,
    `image` varchar(200) default null,
    `file` varchar(200) default null,
    `status` int(11) default nul,
    
    constraint `FK_Reference_28` foreign key(product_id) references `product`(product_id) on delete cascade on update cascade,
    constraint FK_Reference_5 foreign key(custom_id) references `custom`(custom_id) on delete cascade on update cascade
)
```
_______________________________________________________

```
DROP TABLE IF EXISTS `c_order`;
CREATE TABLE `c_order` (
  `order_id` varchar(40) NOT NULL,
  `custom_id` varchar(40) DEFAULT NULL,
  `product_id` varchar(40) DEFAULT NULL,
  `order_date` datetime DEFAULT NULL,
  `request_date` datetime DEFAULT NULL,
  `note` varchar(5000) DEFAULT NULL,
  `quantity` int(11) DEFAULT NULL,
  `unit_price` decimal(10,2) DEFAULT NULL,
  `unit` varchar(10) DEFAULT NULL,
  `image` varchar(200) DEFAULT NULL,
  `file` varchar(200) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  PRIMARY KEY (`order_id`),
  KEY `FK_Reference_28` (`product_id`),
  KEY `FK_Reference_5` (`custom_id`),
  CONSTRAINT `FK_Reference_28` FOREIGN KEY (`product_id`) REFERENCES `product` (`product_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `FK_Reference_5` FOREIGN KEY (`custom_id`) REFERENCES `custom` (`custom_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

公寓
--
```
drop table if exists department;
create table department(
    department_id varchar(40) not null primary key,
    department_name varchar(100) default null,
    note varchar(2000) default null
)
```
========================================================

```
DROP TABLE IF EXISTS `department`;
CREATE TABLE `department` (
  `department_id` varchar(40) NOT NULL,
  `department_name` varchar(100) DEFAULT NULL,
  `note` varchar(2000) DEFAULT NULL,
  PRIMARY KEY (`department_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

设备
--
```
drop table if exists device;
create table device(
    device_id varchar(40) not null primary key,
    device_name varchar(40) default null,
    device_type_id varchar(40) default null,
    device_status_id varchar(40) default null,
    device_status varchar(100) default null,
    device_purchase_date datetime default null,
    device_pruchase_price decimal(10,2) default null,
    device_manufacture_date datetime default null,
    device_service_life datetime default null,
    device_keeper_id varchar(40) default null,
    note varchar(5000) default null,
    constraint FK_Reference_18 foreign key(device_type_id) references `device_type`(device_type_id) on delete cascade on update cascade
)
```
------------------------------------------------------------

```
DROP TABLE IF EXISTS `device`;
CREATE TABLE `device` (
  `device_id` varchar(40) NOT NULL,
  `device_name` varchar(100) DEFAULT NULL,
  `device_type_id` varchar(40) DEFAULT NULL,
  `device_status_id` varchar(40) DEFAULT NULL,
  `device_status` varchar(100) DEFAULT NULL,
  `device_purchase_date` datetime DEFAULT NULL,
  `device_purchase_price` decimal(10,2) DEFAULT NULL,
  `device_manufacture_date` datetime DEFAULT NULL,
  `device_service_life` datetime DEFAULT NULL,
  `device_keeper_id` varchar(40) DEFAULT NULL,
  `note` varchar(5000) DEFAULT NULL,
  PRIMARY KEY (`device_id`),
  KEY `FK_Reference_18` (`device_type_id`),
  CONSTRAINT `FK_Reference_18` FOREIGN KEY (`device_type_id`) REFERENCES `device_type` (`device_type_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


设备检查
----
```
drop table if exists device_check;
create table device_check(
    device_check_id varchar(40) not null primary key,
    device_id varchar(40) default null,
    device_check_emp_id varchar(40) default null,
    device_check_date datetime default null,
    device_check_result varchar(5000) default null,
    device_check_fault_id varchar(40) default null,
    constraint FK_Reference_20 foreign key(device_id) references device(device_id) on delete cascade on update cascade
)
```
---------------------------------------------------------
```
DROP TABLE IF EXISTS `device_check`;
CREATE TABLE `device_check` (
  `device_check_id` varchar(40) NOT NULL,
  `device_id` varchar(40) DEFAULT NULL,
  `device_check_emp_id` varchar(40) DEFAULT NULL,
  `device_check_date` datetime DEFAULT NULL,
  `device_check_result` varchar(5000) DEFAULT NULL,
  `device_check_fault_id` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`device_check_id`),
  KEY `FK_Reference_20` (`device_id`),
  CONSTRAINT `FK_Reference_20` FOREIGN KEY (`device_id`) REFERENCES `device` (`device_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


设备故障
----
```
drop table if exists device_fault;
create table device_fault(
    device_fault_id varchar(40) not null primary key,
    device_id varchar(40) default null,
    device_fault_cause varchar(100) default null,
    device_fault_detail varchar(5000) defualt null,
    device_fault_date datetime default null,
    device_fault_maintenance varchar(500)default null,
    constraint FK_Reference_21 foreign key (device_id) references device(device_id) on delete cascade on update cascade
)
```
----------------------------------------------------------

```
DROP TABLE IF EXISTS `device_fault`;
CREATE TABLE `device_fault` (
  `device_fault_id` varchar(40) NOT NULL,
  `device_id` varchar(40) DEFAULT NULL,
  `device_fault_cause` varchar(100) DEFAULT NULL,
  `device_fault_detail` varchar(5000) DEFAULT NULL,
  `device_fault_date` datetime DEFAULT NULL,
  `device_fault_maintenance` varchar(500) DEFAULT NULL,
  PRIMARY KEY (`device_fault_id`),
  KEY `FK_Reference_21` (`device_id`),
  CONSTRAINT `FK_Reference_21` FOREIGN KEY (`device_id`) REFERENCES `device` (`device_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

```

设备保养
----
```
DROP TABLE IF EXISTS `device_maintain`;
CREATE TABLE `device_maintain` (
  `device_maintain_id` varchar(40) NOT NULL,
  `device_fault_id` varchar(40) DEFAULT NULL,
  `device_maintain_emp_id` varchar(10) DEFAULT NULL,
  `device_maintain_date` datetime DEFAULT NULL,
  `device_maintain_result` varchar(100) DEFAULT NULL,
  `device_maintain_cost` decimal(10,2) DEFAULT NULL,
  `note` varchar(5000) DEFAULT NULL,
  PRIMARY KEY (`device_maintain_id`),
  KEY `FK_Reference_22` (`device_fault_id`),
  CONSTRAINT `FK_Reference_22` FOREIGN KEY (`device_fault_id`) REFERENCES `device_fault` (`device_fault_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```



设备类型
----
```
DROP TABLE IF EXISTS `device_type`;
CREATE TABLE `device_type` (
  `device_type_id` varchar(40) NOT NULL,
  `device_type_name` varchar(100) DEFAULT NULL,
  `device_type_model` varchar(200) DEFAULT NULL,
  `device_type_spec` varchar(200) DEFAULT NULL,
  `device_type_supplier` varchar(100) DEFAULT NULL,
  `device_type_producer` varchar(100) DEFAULT NULL,
  `device_type_quantity` int(11) DEFAULT NULL,
  `device_type_warranty` datetime DEFAULT NULL,
  PRIMARY KEY (`device_type_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

员工
--
```
DROP TABLE IF EXISTS `employee`;
CREATE TABLE `employee` (
  `emp_id` varchar(40) NOT NULL,
  `emp_name` varchar(40) DEFAULT NULL,
  `sex` char(1) DEFAULT NULL,
  `id_code` varchar(20) DEFAULT NULL,
  `birthday` date DEFAULT NULL,
  `join_date` date DEFAULT NULL,
  `status` varchar(20) DEFAULT NULL,
  `education` varchar(20) DEFAULT NULL,
  `degree` varchar(20) DEFAULT NULL,
  `major` varchar(40) DEFAULT NULL,
  `graduate_school` varchar(40) DEFAULT NULL,
  `education_form` varchar(40) DEFAULT NULL,
  `department_id` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`emp_id`),
  KEY `FK_Reference_30` (`department_id`),
  CONSTRAINT `FK_Reference_30` FOREIGN KEY (`department_id`) REFERENCES `department` (`department_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


最后计数检查
------
```
DROP TABLE IF EXISTS `final_count_check`;
CREATE TABLE `final_count_check` (
  `f_count_check_id` varchar(40) NOT NULL,
  `order_id` varchar(40) DEFAULT NULL,
  `check_item` varchar(40) DEFAULT NULL,
  `sample` int(11) DEFAULT NULL,
  `check_number` int(11) DEFAULT NULL,
  `unqualify` int(11) DEFAULT NULL,
  `qualify` decimal(3,2) DEFAULT NULL,
  `cdate` datetime DEFAULT NULL,
  `measure_data` varchar(2000) DEFAULT NULL,
  `emp_id` varchar(40) DEFAULT NULL,
  `result` varchar(2000) DEFAULT NULL,
  `note` varchar(5000) DEFAULT NULL,
  PRIMARY KEY (`f_count_check_id`),
  KEY `FK_Reference_25` (`order_id`),
  CONSTRAINT `FK_Reference_25` FOREIGN KEY (`order_id`) REFERENCES `c_order` (`order_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

最后测量检查
------
```
DROP TABLE IF EXISTS `final_measuret_check`;
CREATE TABLE `final_measuret_check` (
  `f_measure_check_id` varchar(40) NOT NULL,
  `order_id` varchar(40) DEFAULT NULL,
  `check_item` varchar(40) DEFAULT NULL,
  `cdate` datetime DEFAULT NULL,
  `measure_data` varchar(2000) DEFAULT NULL,
  `emp_id` varchar(40) DEFAULT NULL,
  `result` varchar(2000) DEFAULT NULL,
  `note` varchar(5000) DEFAULT NULL,
  PRIMARY KEY (`f_measure_check_id`),
  KEY `FK_Reference_27` (`order_id`),
  CONSTRAINT `FK_Reference_27` FOREIGN KEY (`order_id`) REFERENCES `c_order` (`order_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


加工
--
```
DROP TABLE IF EXISTS `manufacture`;
CREATE TABLE `manufacture` (
  `manufacture_sn` varchar(40) NOT NULL,
  `order_id` varchar(40) DEFAULT NULL,
  `technology_id` varchar(40) DEFAULT NULL,
  `launch_quantity` int(11) DEFAULT NULL,
  `begin_date` datetime DEFAULT NULL,
  `end_date` datetime DEFAULT NULL,
  PRIMARY KEY (`manufacture_sn`),
  KEY `FK_Reference_26` (`order_id`),
  KEY `FK_Reference_9` (`technology_id`),
  CONSTRAINT `FK_Reference_26` FOREIGN KEY (`order_id`) REFERENCES `c_order` (`order_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `FK_Reference_9` FOREIGN KEY (`technology_id`) REFERENCES `technology` (`technology_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


原料
--
```
DROP TABLE IF EXISTS `material`;
CREATE TABLE `material` (
  `material_id` varchar(40) NOT NULL,
  `material_type` varchar(100) DEFAULT NULL,
  `status` varchar(100) DEFAULT NULL,
  `remaining` int(11) DEFAULT NULL,
  `note` varchar(2000) DEFAULT NULL,
  PRIMARY KEY (`material_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```



原料消耗
----
```
DROP TABLE IF EXISTS `material_consume`;
CREATE TABLE `material_consume` (
  `consume_id` varchar(40) NOT NULL,
  `work_id` varchar(40) DEFAULT NULL,
  `material_id` varchar(40) DEFAULT NULL,
  `consume_amount` int(11) DEFAULT NULL,
  `consume_date` datetime DEFAULT NULL,
  `sender` varchar(40) DEFAULT NULL,
  `receiver` varchar(40) DEFAULT NULL,
  `note` varchar(2000) DEFAULT NULL,
  PRIMARY KEY (`consume_id`),
  KEY `FK_Reference_16` (`material_id`),
  KEY `FK_Reference_33` (`work_id`),
  CONSTRAINT `FK_Reference_16` FOREIGN KEY (`material_id`) REFERENCES `material` (`material_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `FK_Reference_33` FOREIGN KEY (`work_id`) REFERENCES `work` (`work_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


原料接受
----
```
DROP TABLE IF EXISTS `material_receive`;
CREATE TABLE `material_receive` (
  `receive_id` varchar(40) NOT NULL,
  `material_id` varchar(40) DEFAULT NULL,
  `amount` int(11) DEFAULT NULL,
  `receive_date` datetime DEFAULT NULL,
  `sender` varchar(100) DEFAULT NULL,
  `receiver` varchar(40) DEFAULT NULL,
  `note` varchar(2000) DEFAULT NULL,
  PRIMARY KEY (`receive_id`),
  KEY `FK_Reference_15` (`material_id`),
  CONSTRAINT `FK_Reference_15` FOREIGN KEY (`material_id`) REFERENCES `material` (`material_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


工序
--
```
DROP TABLE IF EXISTS `process`;
CREATE TABLE `process` (
  `process_id` varchar(40) NOT NULL,
  `technology_plan_id` varchar(40) DEFAULT NULL,
  `sequence` int(11) DEFAULT NULL,
  `quota` int(11) DEFAULT NULL,
  PRIMARY KEY (`process_id`),
  KEY `FK_Reference_32` (`technology_plan_id`),
  CONSTRAINT `FK_Reference_32` FOREIGN KEY (`technology_plan_id`) REFERENCES `technology_plan` (`technology_plan_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


工序计数检查
------
```
DROP TABLE IF EXISTS `process_count_check`;
CREATE TABLE `process_count_check` (
  `p_count_check_id` varchar(40) NOT NULL,
  `process_id` varchar(40) DEFAULT NULL,
  `check_item` varchar(40) DEFAULT NULL,
  `sample` int(11) DEFAULT NULL,
  `check_number` int(11) DEFAULT NULL,
  `unqualify` int(11) DEFAULT NULL,
  `qualify` decimal(3,2) DEFAULT NULL,
  `cdate` datetime DEFAULT NULL,
  `measure_data` varchar(2000) DEFAULT NULL,
  `emp_id` varchar(40) DEFAULT NULL,
  `result` varchar(2000) DEFAULT NULL,
  `note` varchar(5000) DEFAULT NULL,
  PRIMARY KEY (`p_count_check_id`),
  KEY `FK_Reference_24` (`process_id`),
  CONSTRAINT `FK_Reference_24` FOREIGN KEY (`process_id`) REFERENCES `process` (`process_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


工序测量检查
------
```
DROP TABLE IF EXISTS `process_measure_check`;
CREATE TABLE `process_measure_check` (
  `p_measure_check_id` varchar(40) NOT NULL,
  `process_id` varchar(40) DEFAULT NULL,
  `check_item` varchar(40) DEFAULT NULL,
  `cdate` datetime DEFAULT NULL,
  `measure_data` varchar(2000) DEFAULT NULL,
  `emp_id` varchar(40) DEFAULT NULL,
  `result` varchar(2000) DEFAULT NULL,
  `note` varchar(5000) DEFAULT NULL,
  PRIMARY KEY (`p_measure_check_id`),
  KEY `FK_Reference_23` (`process_id`),
  CONSTRAINT `FK_Reference_23` FOREIGN KEY (`process_id`) REFERENCES `process` (`process_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


产品
--
```
DROP TABLE IF EXISTS `product`;
CREATE TABLE `product` (
  `product_id` varchar(40) NOT NULL,
  `product_name` varchar(100) DEFAULT NULL,
  `product_type` varchar(100) DEFAULT NULL,
  `image` varchar(200) DEFAULT NULL,
  `note` varchar(5000) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  PRIMARY KEY (`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```



系统认证（认可）
--------
```
DROP TABLE IF EXISTS `sys_permission`;
CREATE TABLE `sys_permission` (
  `id` bigint(20) NOT NULL COMMENT '主键',
  `name` varchar(128) NOT NULL COMMENT '资源名称',
  `type` varchar(32) NOT NULL COMMENT '资源类型：menu,button,',
  `url` varchar(128) DEFAULT NULL COMMENT '访问url地址',
  `percode` varchar(128) DEFAULT NULL COMMENT '权限代码字符串',
  `parentid` bigint(20) DEFAULT NULL COMMENT '父结点id',
  `parentids` varchar(128) DEFAULT NULL COMMENT '父结点id列表串',
  `sortstring` varchar(128) DEFAULT NULL COMMENT '排序号',
  `available` char(1) DEFAULT NULL COMMENT '是否可用,1：可用，0不可用',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


系统角色
----

```
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role` (
  `role_id` varchar(36) NOT NULL,
  `role_name` varchar(128) NOT NULL,
  `available` char(1) DEFAULT NULL COMMENT '是否可用,1：可用，0不可用',
  PRIMARY KEY (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


系统角色权限
------
```
DROP TABLE IF EXISTS `sys_role_permission`;
CREATE TABLE `sys_role_permission` (
  `id` varchar(50) NOT NULL,
  `sys_role_id` varchar(50) NOT NULL COMMENT '角色id',
  `sys_permission_id` varchar(300) DEFAULT NULL COMMENT '权限id',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

系统用户
----

```
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user` (
  `id` varchar(36) NOT NULL COMMENT '主键',
  `username` varchar(64) DEFAULT NULL COMMENT '姓名',
  `password` varchar(32) DEFAULT NULL COMMENT '密码',
  `locked` char(1) DEFAULT NULL COMMENT '账号是否锁定，1：锁定，0未锁定',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


系统用户角色
------
```
DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role` (
  `id` varchar(36) NOT NULL,
  `sys_user_id` varchar(32) NOT NULL,
  `sys_role_id` varchar(50) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```



任务
--
```
DROP TABLE IF EXISTS `task`;
CREATE TABLE `task` (
  `task_id` varchar(40) NOT NULL,
  `manufacture_sn` varchar(40) DEFAULT NULL,
  `work_id` varchar(40) DEFAULT NULL,
  `task_quantity` int(11) DEFAULT NULL,
  `working_hours` decimal(10,0) DEFAULT NULL,
  PRIMARY KEY (`task_id`),
  KEY `FK_Reference_34` (`manufacture_sn`),
  KEY `FK_Reference_6` (`work_id`),
  CONSTRAINT `FK_Reference_34` FOREIGN KEY (`manufacture_sn`) REFERENCES `manufacture` (`manufacture_sn`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `FK_Reference_6` FOREIGN KEY (`work_id`) REFERENCES `work` (`work_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```



技术
--

```
DROP TABLE IF EXISTS `technology`;
CREATE TABLE `technology` (
  `technology_id` varchar(40) NOT NULL,
  `technology_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `price` decimal(10,2) DEFAULT NULL,
  `vital_process_period` varchar(50) DEFAULT NULL,
  `standard_capacity` int(11) DEFAULT NULL,
  `overtime_standard_capacity` int(11) DEFAULT NULL,
  `overtime_overfulfil_capacity` int(11) DEFAULT NULL,
  `double_capacity` int(11) DEFAULT NULL,
  `overfulfil_capacity` int(11) DEFAULT NULL,
  PRIMARY KEY (`technology_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```




技术计划
----
```
DROP TABLE IF EXISTS `technology_plan`;
CREATE TABLE `technology_plan` (
  `technology_plan_id` varchar(40) NOT NULL,
  `technology_id` varchar(40) DEFAULT NULL,
  `batch_amount` int(11) DEFAULT NULL,
  `start_plan` datetime DEFAULT NULL,
  `end_plan` datetime DEFAULT NULL,
  `commit_plan` datetime DEFAULT NULL,
  `technology_plan_start` datetime DEFAULT NULL,
  `technology_plan_end` datetime DEFAULT NULL,
  PRIMARY KEY (`technology_plan_id`),
  KEY `FK_Reference_31` (`technology_id`),
  CONSTRAINT `FK_Reference_31` FOREIGN KEY (`technology_id`) REFERENCES `technology` (`technology_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


技术需求
----
```
DROP TABLE IF EXISTS `technology_requirement`;
CREATE TABLE `technology_requirement` (
  `technology_requirement_id` varchar(40) NOT NULL,
  `technology_id` varchar(40) DEFAULT NULL,
  `requirement` varchar(2000) DEFAULT NULL,
  `add_time` datetime DEFAULT NULL,
  `revise_time` datetime DEFAULT NULL,
  PRIMARY KEY (`technology_requirement_id`),
  KEY `FK_Reference_10` (`technology_id`),
  CONSTRAINT `FK_Reference_10` FOREIGN KEY (`technology_id`) REFERENCES `technology` (`technology_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```



不合格品申请
------

```
DROP TABLE IF EXISTS `unqualify_apply`;
CREATE TABLE `unqualify_apply` (
  `unqualify_apply_id` varchar(40) NOT NULL,
  `product_id` varchar(40) DEFAULT NULL,
  `unqualify_item` varchar(200) DEFAULT NULL,
  `unqualify_count` int(11) DEFAULT NULL,
  `assembly_date` datetime DEFAULT NULL,
  `emp_id` varchar(40) DEFAULT NULL,
  `apply_date` datetime DEFAULT NULL,
  `note` varchar(5000) DEFAULT NULL,
  PRIMARY KEY (`unqualify_apply_id`),
  KEY `FK_Reference_29` (`product_id`),
  CONSTRAINT `FK_Reference_29` FOREIGN KEY (`product_id`) REFERENCES `product` (`product_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```


工作
--
```
DROP TABLE IF EXISTS `work`;
CREATE TABLE `work` (
  `work_id` varchar(40) NOT NULL,
  `process_number` varchar(40) DEFAULT NULL,
  `product_id` varchar(40) DEFAULT NULL,
  `process_id` varchar(40) DEFAULT NULL,
  `device_id` varchar(40) DEFAULT NULL,
  `rating` int(11) DEFAULT NULL,
  PRIMARY KEY (`work_id`),
  KEY `FK_Reference_12` (`process_id`),
  KEY `FK_Reference_17` (`device_id`),
  KEY `FK_Reference_7` (`product_id`),
  CONSTRAINT `FK_Reference_12` FOREIGN KEY (`process_id`) REFERENCES `process` (`process_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `FK_Reference_17` FOREIGN KEY (`device_id`) REFERENCES `device` (`device_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `FK_Reference_7` FOREIGN KEY (`product_id`) REFERENCES `product` (`product_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```
	2018-12-16 21:48:15
kumika	实战Production---基本配置文件	"# 实战Production---基本配置文件


连接数据库
-----

jdbc.properties

```
jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306//production_ssm?useUnicode=true&characterEncoding=utf8
jdbc.username=root
jdbc.password=123
```


log4j日志
-------
```
# Global logging configuration\uff0c\u5efa\u8bae\u5f00\u53d1\u73af\u5883\u4e2d\u8981\u7528debug
log4j.rootLogger=DEBUG, stdout

# Console output...
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n
```



#Spring

**这就分成Dao，service，安全控制shiro**
配置
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
		http://www.springframework.org/schema/context
		http://www.springframework.org/schema/context/spring-context-4.0.xsd
		http://www.springframework.org/schema/aop
		http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
		http://www.springframework.org/schema/tx
		http://www.springframework.org/schema/tx/spring-tx-4.0.xsd">
```

##Spring--Dao
```
    <!-- 指明数据库配置文件存放位置 -->
    <context:property-placeholder location="classpath:jdbc.properties"/>

    <!-- druid  -->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">
        <!-- 基本属性 url、user、password -->
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>

        <!-- 配置初始化大小、最小、最大 -->
        <property name="initialSize" value="3" />
        <property name="minIdle" value="1" />
        <property name="maxActive" value="20" />

        <!-- 配置获取连接等待超时的时间 -->
        <property name="maxWait" value="60000" />

        <!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->
        <property name="timeBetweenEvictionRunsMillis" value="60000" />

        <!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->
        <property name="minEvictableIdleTimeMillis" value="300000" />

        <property name="validationQuery" value="SELECT 'x'" />
        <property name="testWhileIdle" value="true" />
        <property name="testOnBorrow" value="false" />
        <property name="testOnReturn" value="false" />

        <!-- mysql 不支持 poolPreparedStatements-->
        <!-- 打开PSCache，并且指定每个连接上PSCache的大小 -->
        <!--<property name="poolPreparedStatements" value="true" />-->
        <!--<property name="maxPoolPreparedStatementPerConnectionSize" value="20" />-->

        <!-- 配置监控统计拦截的filters -->
        <property name="filters" value="stat"/>
    </bean>


    <!-- sqlSessionFactory spring和myBatis整合 -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>

        <!-- mybatis配置文件 -->
        <property name="configLocation" value="classpath:mybaits/sqlMapConfig.xml"/>
    </bean>


    <!--
    MapperScannerConfigurer：mapper的扫描器，将包下边的mapper接口自动创建代理对象，
    自动创建到spring容器中，bean的id是mapper的类名（首字母小写）

        扫描Dao接口类
     -->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <!-- 配置扫描包的路径
    如果要扫描多个包，中间使用半角逗号分隔
    要求mapper.xml和mapper.java同名且在同一个目录
     -->
        <property name="basePackage" value="Com.CB.Production.mapper"/>
        <!-- 使用sqlSessionFactoryBeanName -->
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
    </bean>

    <!-- 事务管理器 -->
    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>


    <!-- 通知 -->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <tx:attributes>
            <tx:method name="find*" read-only="true" />
            <tx:method name="get*" read-only="true" />
            <tx:method name="view*" read-only="true" />
            <tx:method name="insert*" propagation="REQUIRED" />
            <tx:method name="update*" propagation="REQUIRED" />
            <tx:method name="delete*" propagation="REQUIRED" />
            <tx:method name="*" propagation="REQUIRED" /><!-- 防止漏网之鱼 -->
        </tx:attributes>
    </tx:advice>

    <!-- 切面 -->
    <aop:config>
        <!-- 切点 管理所有Service的方法 -->
        <aop:pointcut id="transactionPointCut" expression="execution(* Com.CB.Production.service.*.*(..))"/>
        <!-- 增强，进行事务控制 Advisor -->
        <aop:advisor advice-ref="txAdvice" pointcut-ref="transactionPointCut"/>
    </aop:config>
```



##Spring--service

```
    <!-- service包扫描 -->
    <context:component-scan base-package="Com.CB.Production.service"/>
```



##安全控制Shiro

[![shiro图解.jpg](https://i.loli.net/2018/12/27/5c245b63382ce.jpg)](https://i.loli.net/2018/12/27/5c245b63382ce.jpg)



一共使用了9个bean
**Bean：**

    1   shiro的web过滤器
    2   securityManager安全管理器
    3   realm
    4   凭证匹配器
    5   缓存管理器
    6   会话管理器
    7   sessionIdCookie
    8   rememberMeManager管理器
    9   rememberMeCookie

[![](https://ae01.alicdn.com/kf/Hf0d4c0393d99460b828960811712de73w.png)](https://ae01.alicdn.com/kf/Hf0d4c0393d99460b828960811712de73w.png)

具体配置代码：
```
    <!-- web.xml中shiro的filter对应的bean -->
    <!-- Shiro 的Web过滤器 -->
    <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <property name="securityManager" ref="securityManager"/>

        <!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证，请求此地址将由formAuthenticationFilter进行表单认证 -->
        <property name="loginUrl" value="/"/>

        <!-- 认证成功统一跳转到first.action，建议不配置，shiro认证成功自动到上一个请求路径 -->
        <!-- <property name="successUrl" value="/first.action"/> -->
        <!-- 通过unauthorizedUrl指定没有权限操作时跳转页面-->
        <property name="unauthorizedUrl" value="/refuse.jsp"/>

        <!-- 过虑器链定义，从上向下顺序执行，一般将/**放在最下边 -->
        <property name="filterChainDefinitions">
            <value>
                <!-- 对静态资源设置匿名访问 -->
                /images/** = anon
                /js/** = anon
                /styles/** = anon
                <!-- 验证码，可匿名访问 -->
                /validatecode.jsp = anon
                /login.jsp = anon
                /ajaxLogin = anon
                <!-- 请求 logout.action地址，shiro去清除session-->
                /logout = logout
                <!--商品查询需要商品查询权限 ，取消url拦截配置，使用注解授权方式 -->
                <!-- /items/queryItems.action = perms[item:query]
                /items/editItems.action = perms[item:edit] -->
                <!-- 配置记住我或认证通过可以访问的地址 -->
                /home = user
                /index.jsp  = user
                /first.action = user
                /welcome.jsp = user
                /order/edit_judge = authc
                <!-- /** = authc -->
                <!-- /** = authc 所有url都必须认证通过才可以访问-->
                <!-- /** = anon所有url都可以匿名访问 -->
            </value>
        </property>
    </bean>


    <!-- securityManager安全管理器 -->
    <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="realm" ref="customRealm"/>
        <!-- 注入缓存管理器 -->
        <!--<property name="cacheManager" ref="cacheManager"/>-->
        <!-- 注入session管理器 -->
        <property name="sessionManager" ref="sessionManager"/>
        <!-- 记住我 -->
        <property name="rememberMeManager" ref="rememberMeManager"/>
    </bean>
    
    
    <!-- realm -->
    <bean id="customRealm" class="Com.CB.Production.shiro.CustomRealm">
        <!-- 将凭证匹配器设置到realm中，realm按照凭证匹配器的要求进行散列 -->
        <property name="credentialsMatcher" ref="credentialsMatcher"/>
    </bean>


    <!-- 凭证匹配器 -->
    <bean id="credentialsMatcher"
          class="org.apache.shiro.authc.credential.SimpleCredentialsMatcher">
    </bean>

    <!-- 缓存管理器 -->
    <bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager">
        <property name="cacheManagerConfigFile" value="classpath:shiro-ehcache.xml"/>
    </bean>

    
    <!-- 会话管理器 -->
    <bean id="sessionManager" class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager">
        <!-- session的失效时长，单位毫秒 ，这里设置为10分钟-->
        <property name="globalSessionTimeout" value="600000"/>
        <!-- 删除失效的session -->
        <property name="deleteInvalidSessions" value="true"/>
        <!-- 指定本系统sessionId,
        默认为: JSESSIONID 问题: 与Servlet容器名冲突,
         如Jetty, Tomcat等默认JSESSIONID,
         当跳出shiro Servlet时
         如Error-page容器会为JSESSIONID重新分配值导致登录会话丢失! -->
        <property name="sessionIdCookie" ref="sessionIdCookie"/>
    </bean>


    <bean id="sessionIdCookie" class="org.apache.shiro.web.servlet.SimpleCookie">
        <!--ycyintang.session.id是哪里的值？-->
        <constructor-arg name="name" value="ycyintang.session.id"/>
    </bean>

    <!-- rememberMeManager管理器，写cookie，取出cookie生成用户信息 -->
    <bean id="rememberMeManager" class="org.apache.shiro.web.mgt.CookieRememberMeManager">
        <property name="cookie" ref="rememberMeCookie"/>
    </bean>

    <!-- 记住我cookie -->
    <bean id="rememberMeCookie" class="org.apache.shiro.web.servlet.SimpleCookie">
        <!-- rememberMe是cookie的名字 -->
        <constructor-arg value="rememberMe"/>
        <!-- 记住我cookie生效时间30天 -->
        <property name="maxAge" value="2592000"/>
    </bean>
    
    
    <!-- 自定义form认证过虑器 -->
    <!-- 基于Form表单的身份验证过滤器，不配置将也会注册此过虑器，表单中的用户账号、密码及loginurl将采用默认值，建议配置 -->
    <!--<bean id="formAuthenticationFilter" class="org.hqu.production_ms.shiro.CustomFormAuthenticationFilter">
        表单中账号的input名称
        <property name="usernameParam" value="username" />
        表单中密码的input名称
        <property name="passwordParam" value="password" />
        记住我input的名称
        <property name="rememberMeParam" value="rememberMe"/>
    </bean> -->
```





#SpringMVC

文件头：
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans.xsd
	    http://www.springframework.org/schema/mvc
	    http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
	    http://www.springframework.org/schema/context
	    http://www.springframework.org/schema/context/spring-context.xsd
	    http://www.springframework.org/schema/aop
		http://www.springframework.org/schema/aop/spring-aop-4.0.xsd">
```

**具体代码：**
```
    <context:component-scan base-package="Com.CB.Production.controller"/>

    <!-- 注解驱动  启动注解识别 -->
    <mvc:annotation-driven />

    <mvc:default-servlet-handler/>


    <!-- 开启aop，对类代理 -->
    <aop:config proxy-target-class="true"/>

    <!-- 配置内部资源视图解析器，要求将jstl的包加到classpath -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/jsp"/>
        <property name="suffix" value=".jsp"/>
    </bean>
    <!-- 资源映射 -->
    <mvc:resources location="/WEB-INF/css/" mapping="/css/**"/>
    <mvc:resources location="/WEB-INF/js/" mapping="/js/**"/>
    <mvc:resources location="/WEB-INF/image/" mapping="/image/**"/>
    
    <!-- 000000000000000000000分割线00000000000000000000000000 -->
```




#Mybatis配置文件

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>
        <typeAliases>
            <!--
                通过package, 可以直接指定package的名字， mybatis会自动扫描你指定包下面的javabean,
                并且默认设置一个别名，默认的名字为： javabean 的首字母小写的非限定类名来作为它的别名。
                也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user)
                -->
            <package name="Com.CB.Production.domain"/>
            <package name="Com.CB.Production.domain.authority"/>
            <package name="Com.CB.Production.domain.vo"/>
        </typeAliases>


    <!-- 配置分页插件 -->
    <plugins>
        <plugin interceptor="com.github.pagehelper.PageHelper">
            <!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库-->
            <property name="dialect" value="mysql"/>
        </plugin>
    </plugins>
</configuration>
```




#web.xml


比较重要的：

    1   spring容器监听器
    2   前端控制器---就是springMVC嘛
    3   安全权限shiroFilter

具体代码：
```
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.4"
         xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">

  <!-- Spring容器监听器 -->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:spring/spring--*.xml</param-value>
  </context-param>
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>


  <!-- 前端控制器 -->
  <servlet>
    <servlet-name>springMVC</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!-- 加载springmvc配置 -->
    <init-param>
      <!-- 配置文件的地址 如果不配置contextConfigLocation， 默认查找的配置文件名称classpath下的：servlet名称+"-serlvet.xml"
        即：springmvc-serlvet.xml -->
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:spring/springMVC--servlet.xml</param-value>
    </init-param>
  </servlet>

  <servlet-mapping>
    <servlet-name>springMVC</servlet-name>
    <!-- 可以配置/ ，此工程 所有请求全部由springmvc解析，此种方式可以实现 RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析
        也可以配置*.do或*.action，所有请求的url扩展名为.do或.action由springmvc解析，此种方法常用 不可以/*，
        如果配置/*，返回jsp也由springmvc解析，这是不对的。 -->
    <url-pattern>/</url-pattern>
  </servlet-mapping>

  <!-- shiro的filter -->
  <!-- shiro过虑器，DelegatingFilterProxy通过代理模式将spring容器中的bean和filter关联起来 -->
  <filter>
    <filter-name>shiroFilter</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    <!-- 设置true由servlet容器控制filter的生命周期 -->
    <init-param>
      <param-name>targetFilterLifecycle</param-name>
      <param-value>true</param-value>
    </init-param>
  </filter>

  <filter-mapping>
    <filter-name>shiroFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>

  <!-- post乱码处理 -->
  <filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
      <param-name>encoding</param-name>
      <param-value>utf-8</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>

  <!-- 错误页面 -->
  <error-page>
    <exception-type>java.lang.Throwable</exception-type>
    <location>/500.jsp</location>
  </error-page>
  <error-page>
    <error-code>500</error-code>
    <location>/500.jsp</location>
  </error-page>
  <error-page>
    <error-code>404</error-code>
    <location>/404.jsp</location>
  </error-page>

</web-app>
```

#参考：

shiro：https://www.cnblogs.com/learnhow/p/5694876.html
"	2018-12-17 11:08:40
kumika	实战Production--基本需求	# 实战Production--基本需求


[![基本需求.jpg](https://i.loli.net/2018/12/19/5c1a652fbb3b3.jpg)](https://i.loli.net/2018/12/19/5c1a652fbb3b3.jpg)



#登陆

**启动项目就是登陆了**

登陆2个验证，验证码的判断，用户名密码的验证

##控制层


思路：
**1   先把验证码给验证了（是传入X和在SESSION上的X进行对比，完成验证）
2   使用shiro工具，就按照它的流程来，拿到subject，然后根据username和password创建令牌token，根据token使用subject的login方法进行登陆**
具体：
```
     *   1      获取用户名，密码，验证码，session 这4个参数
     *   2      从传过来的验证码和直接从session拿的验证码进行对比，判断验证码是否正确，不正确直接返回页面
     *   3      从security Utils拿出subject（类似idea先创建项目project）
     *   4      判断subject是否已经验证
     *   5      把用户名，密码作为参数，创建令牌UsernamePasswordToken，得到令牌对象token
     *   6      把令牌token作为参数，使用subject的方法login，跳转到RealM中的doGetAuthenticationInfo()方法，完成用户名，密码的验证
     *   6.1    怎么跳转到RealM上？（这看配置文件怎么配置了）
```
因为是使用Ajax，所以要记得使用`@ResponseBody`
代码：
```
    @RquestMapper("/ajaxLogin")
    public Map<String, Object> ajaxLogin(@RequestParam String username,
                                         @RequestParam String password,
                                         @RequestParam(required = false) String randomcode,
                                         HttpSession session) {
        //登陆出现错误，在页面上需要显示错误问题
        Map <String, Object> map = CollectionsFactory.newHashMap();
        if(!randomcode.equals("")&& randmcode!= null){
             //取出session的验证码（正确的验证码）
             String  sName = session.getAttribute("validateCode");
             //页面中输入的验证和session中的验证进行对比
             if(sName != null && !sName.equals(randomcode)){
                //如果校验失败，将验证码错误失败信息放入map中
                map.put("msg","randomcode_error");
                //直接返回，不再校验账号和密码
                return map;
             }
        }
        //创建shiro项目，就是从SecurityUtils中拿一个
        Subject currentUser = SecurityUtils.getSubject();
        //判断currentUser是否已经验证
        if(!currentUser.isAuthenticated()){
            //创建令牌Token
            UsernamePasswordToken token = new UsernamePasswordToken(username,password);
            try {
                //进行登陆
                currentUser.login(token);
            } catch (UnknownAccountException ex) {
                map.put("msg", "account_error");
            } catch (IncorrectCredentialsException ex) {
                map.put("msg", "password_error");
            } catch (AuthenticationException ex) {
                map.put("msg", "authentication_error");
            }
        }
        //返回json数据
        return map;
}                                         
```

##业务层
在操作，跳经过shiro的管理器sessionManager转到RealM上进行业务操作，也就是这个Shiro工具给我操作的地方在RealM上，目的重写2个方法，一个是授权，一个是身份验证

**·授权：**

在Controller层中subject的isPermitted（）方法，或者@RequiresPermissions这个注解就开始调用授权方法

**思路：**

     * 1        从 principals获取主身份信息，赋值给用户身份信息对象ActiveUser
     * 2        根据ActiveUser获取User的id，查询并且返回权限列表数据permissionsList
     * 3        创建String类型的授权信息List对象---permissions，并遍历permissionsList，将属性PerCode增加到permissions上
     * 4        创建授权信息对象simpleAuthorizationInfo
     * 5        将上边查询到授权信息permissions填充到simpleAuthorizationInfo对象中
     * 6        返回simpleAuthorizationInfo

代码：
```
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {

        //从 principals获取主身份信息
        //将getPrimaryPrincipal方法返回值转为真实身份类型（在上边的doGetAuthenticationInfo认证通过填充到SimpleAuthenticationInfo中身份类型），
        ActiveUser activeUser = (ActiveUser) principals.getPrimaryPrincipal();

        //根据身份信息从数据库获取到权限数据
        List<SysPermission> permissionsList = null;

        try {
            permissionsList = sysService.findMenuListByUserId(activeUser.getUserid());
        } catch (Exception e) {
            logger.error(e.getMessage());
        }
        List<String> permissions = new ArrayList<>();
        if (permissionsList != null) {
            for (SysPermission sysPermission : permissionsList) {
                permissions.add(sysPermission.getPercode());
            }
        }

        //查到权限数据，返回授权信息(要包括 上边的permissions)
        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();

        //将上边查询到授权信息填充到simpleAuthorizationInfo对象中
        simpleAuthorizationInfo.addStringPermissions(permissions);

        return simpleAuthorizationInfo;
    }
```

**身份验证**：

关键是要知道数据库上用户和权限对象之间的关系

权限----系统角色权限认证----用户角色----角色----系统用户

[![sys的外键联系.jpg](https://i.loli.net/2018/12/27/5c249ac3e3584.jpg)](https://i.loli.net/2018/12/27/5c249ac3e3584.jpg)


要清楚本项目的**身份安全数据源里的属性**：  



    用户名称    username
    用户状态    userStatus-------数据库中SysUser的locked字段
    角色名称    rolename
    角色状态    roleStatus-------数据库中SysRole的available字段
    菜单        menus-----------数据库中Syspermission表格返回的对象的集合
    
**填充完成这个身份安全数据源，生成simpleAuthenticationInfo对象，就算完成Shiro工具给你操作的部分了，其他的是工具完成。**


**思路：**
realm的认证方法，从数据库查询用户信息

     * 1        token是用户输入的用户名和密码,第一步从token中取出用户名
     * 2        根据用户输入的username从数据库查询，返回用户对象SysUser
     * 3        判断SysUser是否为空，是空就返回null
     * 4        从SysUser拿出password
     * 5        创建用户身份信息ActiveUser对象
     * 6        根据SysUser的属性（Id，name，用户状态Locked），设置给ActiveUser
     * 7        根据SysUser的id，查询并且返回权限对象sysRole
     * 8        sysRole的属性：name，Available 都赋值给ActiveUser
     * 9        根据SysUser的id，查询并且返回菜单对象menus
     * 10       将用户菜单menus设置到activeUser
     * 11       根据activeUser,password,当前RealM类的完整包路径，这3个作为参数，创建身份认证对象---simpleAuthenticationInfo对象
     * 12       返回simpleAuthenticationInfo





**代码：**

```
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {

        // token是用户输入的用户名和密码,第一步从token中取出用户名
        String username = (String) token.getPrincipal();//获取用户名，在controller层创建Token的时候，getPrincipal方法返回的值就是Username

        // 第二步：根据用户输入的username从数据库查询
        SysUser sysUser = null;

        try {
            sysUser = sysService.getSysUserByName(username);
        } catch (Exception e) {
            logger.error(e.getMessage());
        }

        // 如果查询不到返回null
        if (sysUser == null) {
            if (logger.isDebugEnabled()) {
                logger.debug("user not exist!");
            }
            return null;
        }
        String password = sysUser.getPassword();

        // 如果查询到返回认证信息AuthenticationInfo
        //activeUser就是用户身份信息
        ActiveUser activeUser = new ActiveUser();

        activeUser.setUserid(sysUser.getId());
        activeUser.setUsername(sysUser.getUsername());
        activeUser.setUserStatus(sysUser.getLocked());
        //权限对象
        RoleVo sysRole = null;
        try {
            sysRole = roleService.findRoleByUserId(sysUser.getId());
        } catch (Exception e) {
            logger.error(e.getMessage());
        }
        //身份信息进行设置权限名，权限
        activeUser.setRolename(sysRole.getRoleName());
        activeUser.setRoleStatus(sysRole.getAvailable());

        logger.info(activeUser.getUsername());

        //根据用户id取出菜单
        List<SysPermission> menus = null;

        try {
            //通过service取出菜单，
            // 这是根据值查询，不是一般的根据字段查询，卧槽第一次看见这样的查询
            menus = sysService.findMenuListByUserId(sysUser.getId());
        } catch (Exception e) {
            logger.error(e.getMessage());
        }

        //将用户菜单设置到activeUser
        activeUser.setMenus(menus);

        //ByteSource q = ByteSource.Util.bytes(sysUser.getSalt());
        //将activeUser设置simpleAuthenticationInfo
        SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(activeUser,password,this.getName());

        return simpleAuthenticationInfo;
    }
```


##Dao层：


权限----系统角色权限认证----用户角色----角色----系统用户

明白这个表格关系后，我只写特殊的查询，一般的查询，都交给`example`和`criteria`来处理了。在查询的时候，一定要清楚明白自己要查询的对象是什么，返回的对象是什么，**也就是输入是什么变量，输出是什么变量，2个变量在数据库的表格之间有什么关联（外键）**。这样无论查询用到多少个表格都是不怎么重要的了。


###**需求:**
根据用户id取出菜单

根据用户id查询菜单 ，菜单是在系统认证表格上的值，不是字段，这里第一次碰见使用值的，type关键字
         使用了3张表，系统权限《======》系统用户权限《===》系统用户角色，
         要清楚输入的变量是在哪张表，输出的变量是在哪张表，辨析之间的联系


输入变量：**sysUser.getId()**
输出变量：

     List<SysPermission> menu = sysPermissionMapperCustom.findMenuListByUserId(id);

**SQL:**     
```
    <select id="findMenuListByUserId" parameterType="String" resultType="Com.CB.Production.domain.authority.SysPermission">
        SELECT * from sys_permission WHERE  type = 'menu' AND  id IN
          (SELECT sys_permission_id from sys_role_permission WHERE  sys_role_id IN
              (SELECT sys_role_id FROM  sys_user_role WHERE sys_user_id = #{id})
          )
    </select>
```

	2018-12-19 23:33:27
kumika	实战Production---首页	"# 实战Production---首页


#首页

页面ajax登陆验证，
完成后	`location.href = "${baseurl}home";`，
就是跳转路径/home，访问首页

##网页需求： 
单纯的需要**权限列表，身份数据源**

##控制层



思路：
 

     * 1        从SecurityUtils中获取shiro的项目subject
     * 2        创建身份信息源ActiveUser，并且subject上的principal赋值给ActiveUser
     * （一样的类，变量名不一样，具体看RealM的方法中身份验证的部分）
     * 3        创建权限列表对象 permissionList
     * 4        根据身份信息源上的UserId，使用认证授权服务接口SysService，进行查询权限列表对象permissionList
     * 5        创建String类型的系统权限列表 sysPermissionList
     * 6        判断permissionList是否为null，
     * 然后遍历permissionList，向sysPermissionList 增加permissionList的属性：权限代码字符串percode
     * 7        Model增加attribute，key为：“activeUser” value为ActiveUser
     * 8        session设置attribute，key为“sysPermissionList”，value为sysPermissionList
     * 9        返回home


代码：
```
    @RequestMapping("/home")
    public String home(HttpSession session, Model model) {
        Subject subject = SecurityUtils.getSubject();
        ActiveUser activeUser = (ActiveUser) subject.getPrincipal();
        List<SysPermission> permissionList = null;

        //根据身份信息源上的UserId，使用认证授权服务接口SysService，进行查询权限列表对象permissionList
        permissionList = sysService.findPermissionListByUserId(activeUser.getUserid());

        //本来可以直接创建ArrayList列表的，但是体检使用单例模式？
        List<String> sysPermissionList = CollectionsFactory.newArrayList();
        if (permissionList != null) {
            for (int i = 0;i < permissionList.size();i++) {
                sysPermissionList.add(permissionList.get(i).getPercode());
            }
        }
        model.addAttribute("ACTIVE_USER", activeUser);
        session.setAttribute("sysPermissionList", sysPermissionList);
        return "home";
    }
```


##业务层

     *  思路：
     *  输入的是用户id，输出的是权限对象，这之间使用3个表格 sys-user-role, sys-role-permission, sys-permission
     *  1       根据UserId, 查询用户权限id
     *  2       根据用户权限id，查询权限对象（使用的是example）

代码：
```
    public List<SysPermission> findPermissionListByUserId(String userid) {
        //根据用户id查询权限id
        String permission = this.sysPermissionMapperCustom.findPermissionByUseriId(userid);
        if (permission != null) {
            String[] permissionIds = permission.split(",");
            List<Long> ids = CollectionsFactory.newArrayList();
            for (int i=0;i < permissionIds.length;i++) {
                ids.add(Long.valueOf(permissionIds[i]));
            }
            SysPermissionExample example = new SysPermissionExample();
            SysPermissionExample.Criteria criteria = example.createCriteria();
            criteria.andIdIn(ids);

            List<SysPermission>sysPermissionList =  sysPermissionMapper.selectByExample(example);

            return sysPermissionList;
        }
        //自己的想法：3个表连查
/*        List<SysPermission> sysPermissionList = sysPermissionMapperCustom.findPermissionByUserId(userid);
        if (sysPermissionList != null) {
            return sysPermissionList;
        }*/
        return null;
    }
```




##Dao层：

```
    <!-- 根据用户id查询权限id -->
    <select id="findPermissionByUseriId" resultType="String" parameterType="String">
        select sys_permission_id from sys_role_permission WHERE sys_role_id IN
        (select sys_role_id from sys_user_role WHERE sys_user_id =#{userid})
    </select>
    
    
        <!--自己的想法：3个表格一起查询，根据用户id查询url-->
    <select id="findPermissionByUserId" parameterType="String" resultType="Com.CB.Production.domain.authority.SysPermission">
         select * from sys_permission WHERE id IN
         (select sys_permission_id from sys_role_permission WHERE sys_role_id IN
            (select sys_role_id from sys_user_role WHERE sys_user_id =#{userid})
          )
    </select>
```




权限：

登录之后，根据userId查询获取权限对象，然后把这些权限对象放入session中，当需要权限操作的时候，jsp上就根据XXX值和session上的权限对象的值进行判断，一致就能进行操作，不一致就没有权限。
（获取全部的权限对象，放到session上，遇到判断就拿来用，主体是session）

自己的理解就是：  当点击权限操作的时候，此时jsp就对用户User的属性值进行判断（类似身上随时带的钥匙，主体是user）









"	2018-12-28 11:42:16
kumika	实战Production---问题集合	"# 实战Production---问题集合


#问题1 Mybatis查询返回对象为空

具体描述：
`Mybatis`的`XXXMapper.xml`里面`resultMap`的类型和`ServiceIMPL`方法上实体类的类型不一样**（属性一致，名字不一样）**，为什么会导致查询返回的resultMap对象是null。
答：    
因为mybatis中就规定有：
            Dao  的 方法名 与 Mapper 的 id 一致
            Dao  的 类名   与 Mapper 的 返回集合类型一致
**当2项中的一项符合的时候，返回对象就会为null（毕竟没有创建对象嘛）。**
当2项都有，但是Mapper的属性只要有一个和类对象的属性一致，就会有对象，而且只有相匹配的属性有值。          


简单点说就是：**myBatis和数据库进行映射的？**

答：
    看源码吧，我不知道啊，过程都没有明白。





#问题2

具体描述：
权限是怎么进行判断到网页上哪个能进行编辑操作的

答：好像交给shiro判断获取相对应的权限了，我能控制的只有获取uri

##获取uri期间出现派生问题：

具体描述：
在点击编辑，增加，删除···操作，跳出新的页面时候出现超出数组范围异常

答：使用自定义异常类，返回一个新的ModelAndView，记得在spring MVC上配置。**为什么要使用异常类？流程是怎么？**



答： 
        因为目标是要实现SpringMVC的一个功能:**异常统一处理方式**。
 具体实现： 
     实现接口类：HandlerExceptionResolver
     重写方法`resolveException`（返回值是固定的，一个new ModelAndView()）
     **要记得在springMVC 的配置文件上配置实现类**
```
  <!-- 定义统一异常处理器 -->
<bean class="Com.CB.Production.exception.CustomExceptionResolver"/>
```
JSP：
    点击 编辑 
      执行判断权限	`$.get("order/edit_judge"`
       
 
控制层:
@RequestMapping("*/*_judge")

**根据uri,使用shiro判断相应权限**  
uri：
   字符串“ /order/edit_judge ”中获取


在跳转错误页面的时候，页面显示出框框, 具体是怎么跳转的，
目的是什么？为什么要使用error.jsp来进行跳转呢？
答：
    出现错误了，就会跳转到错误页面，但是这里是使用请求转发，重新回到发出请求的页面上（妈的，就是自己主动创造一个错误，然后依靠错误返回一个null的ModleAndView，完成请求。）


在自定义异常类上返回一个新的modelAndView，就直接完成数据传输，跳转到页面，页面完成匹配。
问题是： 返回的modelAndView 是发挥什么作用的?
答：    固定是要返回modelAndView，作用看源码，然后看了也不知道。

在判断完了权限之后，进行更新`$.post("order/update_note"`







#问题3  

具体描述：

在点击左边结构树进入页面，页面此时发送的请求是/order/list，问题是：它是如何产生的，表单是怎么包装成后台对象的？

easyui-datagrid  id="orderList"  url:'order/list'


答：
    datagrid初始化的时候，url会发出请求!**(原因：html代码中利用class声明了datagrid，导致easyUI解析class代码的时候先解析class声明中的datagrid，这样组件就请求了一次url)**
    
    



#问题4

为什么需要这个`deviceTypeIdd`  ，在哪里的网页上需要

不知道。





#问题5

在系统区里点击 角色管理表格的权限，调用javascript，当你点击超链接《权限》的时候，是出现查询吗？


答:
    应该说，从查询全部对象，到点击单个对象的权限超链接，是有2次请求的。查询全部对象一次，查询单个对象的权限 一次，都是**在不用的页面上发出的请求**。
具体流程:
-----

1     点击权限超链接，
2     JavaScript执行此操作，

    <div id="permissionWindow" href:'role/permission'

3   跳转到`role`的控制层，然后跳转到`role_permission`页面

    @RequestMapping("/permission")
    public String permission() throws Exception{
        return "role_permission";
    }


4   在role_permission页面上，ajax执行请求：


        var roleId = $('#permissionForm [name=roleId]').val();
    $.get("permission/get_permission", {roleId : roleId}


5   跳转到`Permission`的控制层，进行查询

    @RequestMapping("/get_permission")
    @ResponseBody
    public SysRolePermission getPermission(String roleId) throws Exception{
        return permissionService.getByRoleId(roleId);
    }


6   返回的对象在页面如何显示应该属于前端的事情把？！





#问题7

问题描述：
使用kindEditor富文本编辑器进行上传图片，当配置Tomcat的虚拟路径的时候，无法上传图片，出现404
当没有配置虚拟路径的时候，能上传，但是没有回显图片





#问题8 

问题描述：
idea配置上了项目名，结果session权限没有了？

答：
权限是根据Uri进行判断的，目的是为了实现统一处理异常，这个功能，卧槽了这个项目






"	2018-12-29 12:08:32
kumika	实战Production---计划进度列表	# 实战Production---计划进度列表



#订单管理

注意方法:
1       getList()  多表联查
2       deleteBatch()   数组删除
3       searchOrderByOrderId（） 多表联查
4       searchOrderByOrderCustom（）
5       searchOrderByProductName（）
6       changeStatus()    数组更改

注意Mybatis的XXMapper.xml中的resultMap类型，也是可以链表的


**关联表格，然后根据连接的表格的字段查询，完成之前的填充动作，之前的表格是完全没有外键，这里有外键，所以可以在SQL完成填充。**

**使用Mybatis的XML标签：《association》**   ，**注意此时主表和副表之间的外键FK，在主表是不需要 的，需要出现在副表上。此时的主表的PoJo类应该有副表的对象作为属性（有几个副表就有几个属性）**

getList() 是查询全部的订单对象，因为订单对象里有2个其他类的对象（在数据库中存在表格）


疑问：  在点击客户，产品的时候，怎么关联到custom和product里面其他的字段是怎么填充的？
答： 网页显示全部的表格内容，确实查询了custom和product，也是返回了id，name。这是完成了一次访问，你说的关联到2个对象的其他字段，是另外的一次访问了。----------------也就是显示条例一次访问，点击custom和product显示具体内容是另外的一次访问。




点击custom和product显示具体内容是另外的一次访问：

网页上的ajax: 

输入的是CustomId，和productId，都是查询各自的对象

    $.get("custom/get/"+row.custom.customId,'',function(data)
    $.get("product/get/"+row.product.productId,'',function(data){



##订单内容

###订单对象的属性

订单id：    custom_id
订单日期：  order_date
订单要求：  request_date
备注：      note
订购数量:   quantity
税前单价：  unit_price
单位：      unit
状态：      status
相关图片：  image
订单附件：  file


###订单属性内包含另外的对象（在数据库中有表单）
订购客户：  custom
订购产品：  product

##Dao层:

**一定要注意resultMap：**

```
  <resultMap id="BaseResultMap" type="Com.CB.Production.domain.vo.COrderVo">
    <id column="order_id" jdbcType="VARCHAR" property="orderId" />
  <!--  <result column="custom_id" jdbcType="VARCHAR" property="customId" />-->
   <!-- <result column="product_id" jdbcType="VARCHAR" property="productId" />-->
    <result column="order_date" jdbcType="TIMESTAMP" property="orderDate" />
    <result column="request_date" jdbcType="TIMESTAMP" property="requestDate" />
    <result column="note" jdbcType="VARCHAR" property="note" />
    <result column="quantity" jdbcType="INTEGER" property="quantity" />
    <result column="unit_price" jdbcType="DECIMAL" property="unitPrice" />
    <result column="unit" jdbcType="VARCHAR" property="unit" />
    <result column="image" jdbcType="VARCHAR" property="image" />
    <result column="file" jdbcType="VARCHAR" property="file" />
    <result column="status" jdbcType="INTEGER" property="status" />

<!--关联其他的表，association处理has-a关系-->
    <association property="custom" javaType="custom">
      <id column="custom_id" property="customId" jdbcType="VARCHAR" />
      <result column="custom_name" property="customName" jdbcType="VARCHAR" />
      <result column="full_name" property="fullName" jdbcType="VARCHAR" />
      <result column="address" property="address" jdbcType="VARCHAR" />
      <result column="fax" property="fax" jdbcType="VARCHAR" />
      <result column="email" property="email" jdbcType="VARCHAR" />
      <result column="owner_name" property="ownerName" jdbcType="VARCHAR" />
      <result column="owner_tel" property="ownerTel" jdbcType="VARCHAR" />
      <result column="c_state" property="state" jdbcType="INTEGER" />
      <result column="manager_tel" property="managerTel" jdbcType="VARCHAR" />
      <result column="c_note" property="note" jdbcType="VARCHAR" />
    </association>
    <association property="product" javaType="product">
      <id column="product_id" property="productId" jdbcType="VARCHAR" />
      <result column="product_name" property="productName" jdbcType="VARCHAR" />
      <result column="product_type" property="productType" jdbcType="VARCHAR" />
      <result column="drawing" property="drawing" jdbcType="VARCHAR" />
    </association>

  </resultMap>
```

###根据批量id修改状态
输入的变量是数组

mybatis中foreach的用法

    item:       循环体中的具体对象
    
    collection:     要做foreach的对象，作为入参时，List<?>对象默认用list代替作为键，数组对象有array代替作为键，Map对象用map代替作为键。
    
    separator:  元素之间的分隔符
    open:       foreach代码的开始符号
    close:      foreach代码的关闭符号


Sql：
```
update from  
        c_order 
set 
        status=#{status} 
where 
        order_id
in
<foreach collection="array" item="id" open="(" close=")" separator=",">
    #{id}
</foreach>        
```



###批量id删除对象

```
delete from c_order where order_id in <foreach collection="array" item="id" open="(" close=")" separator=",">
    #{id}
</foreach> 
```





###查询全部的订单对象(对象需要填充2个)
没有输入变量
```
select 
        order_id,
        order_date,
        request_date,
        c_order.note,
        quantity,
        unit_price,
        unit,
        status,
        c_order.image,
        file,
        custom.custom_id,
        custom_name,
        product.product_id,
        product_name
from
    c_order
    left join custom  on custom.custom_id = c_order.custom_id,
    left join product on product.product_id = c_order.product_id
<if test="status != null"> 
    status=#{status}
</if>
order by c_order.order_date
```

###根据订单编号查询

使用myBatis的模糊查询like concat('%',#{XXX},'%')

```
select
        order_id,
        order_date,
        request_date,
        c_order.note,
        quantity,
        unit_price,
        unit,
        status,
        c_order.image,
        file,
        custom.custom_id,
        custom_name,
        product.product_id,
        product_name
from 
    c_order
    left join custom on custom.custom_id = c_order.custom_id,
    left join product on product.custom_id = product.product_id
where  
    order_id like concat('%',#{orderId},'%')
Order by  c_order.order_date
```

###根据客户名称查询

```
select
        order_id,
        order_date,
        request_date,
        c_order.note,
        quantity,
        unit_price,
        unit,
        status,
        c_order.image,
        file,
        custom.custom_id,
        custom_name,
        product.product_id,
        product_name
from 

    c_order

    left join custom on custom.custom_id = c_order.custom_id,
    left join product on product.product_id = c_order.product_id
where 
    custom_name like concat('%',#{customName},'%')
Order by c_order.order_date
```

###根据产品名称查询

```
select 
        order_id,
        order_date,
        request_date,
        c_order.note,
        quantity,
        unit_price,
        unit,
        status,
        c_order.image,
        file,
        custom.custom_id,
        custom_name,
        product.product_id,
        product_name
from 
    c_order
    left join custom on custom.custom_id = c_order.custom_id,
    left join product on product.product_id = c_order.product_id
where 
    product_name like concat('%',#{productName},'%')
Order by  c_order.order_date
```




#客户管理

**因为网页需要显示的客户对象的属性里没有别的对象，所以就没有关联别的表格。**



注意方法
1       getItemList()   为什么要用example  因为没有使用criteria就是全部查询，使用了criteria就是增加条件
     

##查询全部客户
使用example

##批量id更新对象状态
```
update from custom set status=#{status} where custom_id in
<foreach collection="array" item="id" open="(" close=")" separator=",">
    #{id}
</foreach>
```

##批量id删除对象

```
delete from custom where custom_id in
<foreach collection="array" item="id" open="(" close=")" separator=",">
    #{id}
</foreach>
```

##根据客户编号查询对象

```
select * from custom where custom_id like concat('%',#{customId},'%')
```

##根据客户名称查询对象
```
select * from custom where custom_id like concat('%',#{customName},'%')
```


#产品管理

因为产品没有关联其他的表格，所以也可以使用  *

##批量删除和更新

和上面的客户一样的语句，改变表名，字段就可以了


##根据产品id查询对象
```
select * from product where product_Id like concat('%',#{productId},'%')
```

##根据产品名称查询对象

```
select * from product where product_name like concat('%',#{productName},'%')
```

#作业管理

因为页面表格上出现3个另外的对象，**产品，工序，设备，**所以要关联3个表格

ResultMap: 带有3个关联表格

    <association property="product" javaType="product">
      <id column="product_id" property="productId" jdbcType="VARCHAR" />
      <result column="product_name" property="productName" jdbcType="VARCHAR" />
      <result column="product_type" property="productType" jdbcType="VARCHAR" />
      <result column="image" property="image" jdbcType="VARCHAR" />
      <result column="note" property="note" jdbcType="VARCHAR" />
      <result column="status" property="status" jdbcType="INTEGER" />
    </association>
    
    
    <association property="process" javaType="process">
      <id column="process_id" property="processId" jdbcType="VARCHAR" />
      <result column="technology_plan_id" property="technologyPlanId" jdbcType="VARCHAR" />
      <result column="sequence" property="sequence" jdbcType="INTEGER" />
      <result column="quota" property="quota" jdbcType="INTEGER" />
    </association>
    
    
    
    <association property="device" javaType="device">
      <id column="device_id" property="deviceId" jdbcType="VARCHAR" />
      <result column="device_name" property="deviceName" jdbcType="VARCHAR" />
      <result column="device_type_id" property="deviceTypeId" jdbcType="VARCHAR" />
      <result column="device_status_id" property="deviceStatusId" jdbcType="VARCHAR" />
      <result column="device_status" property="deviceStatus" jdbcType="VARCHAR" />
      <result column="device_purchase_date" property="devicePurchaseDate" jdbcType="TIMESTAMP" />
      <result column="device_purchase_price" property="devicePurchasePrice" jdbcType="DECIMAL" />
      <result column="device_manufacture_date" property="deviceManufactureDate" jdbcType="TIMESTAMP" />
      <result column="device_service_life" property="deviceServiceLife" jdbcType="TIMESTAMP" />
      <result column="device_keeper_id" property="deviceKeeperId" jdbcType="VARCHAR" />
      <result column="note" property="note" jdbcType="VARCHAR" />
    </association>

##批量删除对象

```
delete from work where work_id in
<foreach collection="array" item="id" open="(" close=")" separator=",">
    #{id}
</foreach>
```
##查询全部对象

```
select 
    work_id,
    work.process_id,
    work.product_id,
    work.device_id,
    process_number,
    rating,
    device_name,
    product_name
from 
    work
left join product on product.product_id = work.produtc_id
left join process on process.process_id = work.process_id
left join device on device.device_id = work.device_id
```
##根据作业编号查询

```
select 
    work_id,
    work.process_id,
    work.product_id,
    work.device_id,
    process_number,
    rating,
    device_name,
    product_name
from 
    work
left join product on product.product_id = work.produtc_id
left join process on process.process_id = work.process_id
left join device on device.device_id = work.device_id
where
    work_id lik concat('%',#{workId},'%')
```

##根据产品名称查询

```
where product_name like concat('%',#{productName},'%')
```

##根据工序查询

```
where process_id like concat('%',#{processId},'%')
```

##根据设备名称查询

```
where device_name like concat('%',#{deviceName},'%')
```

#生产计划管理

页面显示表格所需要的字段

    生产批号：      manufacture_sn
    订单：          order_id
    工艺：          technology_name
    投产数量：      launch_quantity
    开始日期：      begin_date
    结束日期：      end_date

因为工艺显示的是名字，但是数据库表格中只有工艺id，所以需要管理工艺表格，订单也是一样。

##批量删除

使用Mybatis的《foreach》标签


##查询全部对象

```
select 
    manufacture_sn,
    manufacture.order_id,
    manufacture.technology_id,
    order_name,
    technology_name,
    launch_quantity,
    begin_date,
    end_date
from
    manufacture
left join c_order on c_order.order_id = manufacture.order_id
left join technology on technology.technology_id = manufacture.technology_id
```

##根据生产批号查询对象

```
select 
    manufacture_sn,
    manufacture.order_id,
    manufacture.technology_id,
    order_name,
    technology_name,
    launch_quantity,
    begin_date,
    end_date
from
    manufacture
left join c_order on c_order.order_id = manufacture.order_id
left join technology on technology.technology_id = manufacture.technology_id
where 
    manufacture_sn like concat('%',#{manufactureSn},'%')
```


##根据订单编号查询对象

```
where 
    order_id like concat('%',#{orderId},'%')
```

##根据工艺查询对象

```
where 
    technology_id like concat('%',#{technologyId},'%')
```

#生产派工管理

页面显示表格所需要的字段


    生产派工编号：  task_id
    作业编号：      work_id
    生产批号：      manufacture_sn
    派工数量：      task_quantity
    派工工时：      working_hours


因为这些字段在数据库的派工task表格上都有，所以不需要管理任何表格了

##查询全部

```
select * from task
```
或者使用Mybatist的example

##根据生产派工编号查询对象

```
select * from task where task_id like concat('%',#{taskId},'%')
```

##根据生产批号查询对象

```
select * from task where manufacture_sn like concat('%',#{manufactureSn},'%')
```

##根据作业编号查询对象

```
select * from task where work_id like concat('%',#{workId},'%')
```

#明天任务：



	2018-12-29 18:35:32
kumika	实战Production---设备列表	# 实战Production---设备列表

##拓展和关联的区别是什么？



#设备检查

Mapping.XML使用了  拓展map： 增加对象DeviceCheckVo

设备例检编号：  device_check_id
设备编号：      device_id
设备名称：      device_name
例检人：        device_check_emp_name
例检时间：      device_check_date
例检结果：      device_check_result
例检故障编号：  device_check_fault_id


 device_check_emp_name====> device_check_emp_id,这是要和employee表格进行赋值，条件是id相同

device_name ====>  device_id  ，这要个device表格进行赋值，条件是id相同

**因为没有办法，关联这3个表格在一起，所以只有使用创建新的实体类DeviceCheckVo，创建新属性deviceCheckEmp和deviceName，完成把这些字段都包装到一个对象上**

```
  <resultMap id="BaseResultMap" type="Com.CB.Production.domain.DeviceCheck">
    <id column="device_check_id" jdbcType="VARCHAR" property="deviceCheckId" />
    <result column="device_id" jdbcType="VARCHAR" property="deviceId" />
    <result column="device_check_emp_id" jdbcType="VARCHAR" property="deviceCheckEmpId" />
    <result column="device_check_date" jdbcType="TIMESTAMP" property="deviceCheckDate" />
    <result column="device_check_result" jdbcType="VARCHAR" property="deviceCheckResult" />
    <result column="device_check_fault_id" jdbcType="VARCHAR" property="deviceCheckFaultId" />
  </resultMap>


  <resultMap id="AddResultMap" type="Com.CB.Production.domain.vo.DeviceCheckVo" extends="BaseResultMap">
    <result column="device_name" property="deviceName" jdbcType="VARCHAR" />
    <result column="device_check_emp" property="deviceCheckEmp" jdbcType="VARCHAR" />
  </resultMap>
```


##查询全部对象

`device_check_emp`这个字段是**不存在**的，只是为了强制(强行凑巧)获取员工名，赋值到DeviceVo的新属性deviceCheckEmp上。（新属性名称，字段都是随便你命名的）

`device_check_emp_id`  和`emp_id` 是没有任何关系的，但是因为要求赋值，所以使用关键字，强行**AS**

    emp_id as device_check_emp_id,
    emp_name as device_check_emp,

Sql:
```
select 
    device_check_id,
    device_check.device_id,
    device.device_name,
    emp_id as device_check_emp_id,
    emp_name as device_check_emp,
    device_check_date,
    device_check_result,
    device_check_fault_id
from
    device,
    deviceCheck,
    employee
where
    device_check.device_check_id = device.device_check_id
and
    device_check_emp_id = employee.emp_id
order  by device_check_id ASC
```


##根据设备例检编号查询对象


```
and 
    device_check_id like concat('%',#{deviceChcekId},'%')
```

like concat('%',#{},'%')

##根据设备名称查询对象


```
and
    device_name like concat('%',#{deviceName},'%')
```



#设备fault


Mapping.XML使用了  拓展map： 增加对象DeviceFaultVo


网页所要展示的字段：

故障编号：      device_fault_id
设备名称:       device_name  ===> 需要device表格
故障日期：      device_fault_date
故障原因：      device_fault_cause
维修方式：      device_fault_maintenance
故障描述:       device_fault_detail


创建新的实体类deviceFaultVo, 包含新属性 deviceName
```
  <resultMap id="AddResultMap" type="Com.CB.Production.domain.vo.DeviceFaultVo" extends="BaseResultMap">
    <result column="device_name" property="deviceName" jdbcType="VARCHAR" />
  </resultMap>
```

##查询全部

```
 <select id="find" parameterType="deviceFault" resultMap="AddResultMap">
select 
    device_fault_id,
    device_fault.device_id,
    device_name,
    device_fault_cause,
    device_fault_detail,
    device_fault_date,
    device_fault_maintenance
from
    device_fault,
    device
where
    device.device_id = device_fault.device_id

 </select>
```


##根据设备故障编号：

like concat('%',#{},'%')

```
and 
    device_fault_id like concat('%',#{deviceFaultId},'%')
```


##根据设备名称：


```
and
    device_name like concat('%',#{deviceName},'%')
```

#设备台账（list）


Mapping.xml使用了 拓展Map： 增加对象DeviceVo

页面显示表格所需要的字段：

    设备编号：      device_id
    设备名称：      device_name
    设备种类：      device_type_name
    设备状态：      device_status_id
    购买日期：      device_purchase_date
    购买价格：      device_purchase_price
    出厂日期：      device_manufacture_date
    使用年限：      device_service_life
    保管人：        deviceKeeper
    备注:           note


因为设备种类需要的是名称，就是device_type_name,但是数据库device表格上存在设备种类外键id，所以需要拓展ResultMap, 其中拓展的实体类是`DeviceVo` 
属性是：

            deviceKeeper，
            deviceTypeName，
            deviceIdd



拓展的ResultMap:
```
  <resultMap id="AddResultMap" type="Com.CB.Production.domain.vo.DeviceVo" extends="BaseResultMap">
    <result column="device_type_name" property="deviceTypeName" jdbcType="VARCHAR" />
    <result column="device_keeper" property="deviceKeeper" jdbcType="VARCHAR" />
  </resultMap>
```

##查询全部对象

因为device,device_type 有一个外键device_status_id, 此时是可以使用left/right join进行合并表格的。**但是，因为多了个employee员工表格，与device的2个表格是没有外键联系的，所以就没有办法进行3个表关联。**此时返回的对象是自己新建的实体类`DeviceVo`，里面新属性，完成接收别的表格传输过来的字段

网页上不能直接在数据库主表获取字段的：
设备种类：      device_type_name
保管人：        deviceKeeper

因为没有，所以要新建属性实现接收数据，创建实体类新属性device_keeper，进行硬接收字段（将emp_name  AS  device_keeper）。

```
<select id="find" parameterType="device" resultMap="AddResultMap">
select
          device_id,
          device_name,
          device_status_id,
          device_purchase_date,
          device_purchase_price,
          device_manufacture_date,
          device_service_life,
          device_keeper_id,
          emp_name as device_keeper,
          device.deivce_type_id,
          device_type_name,
          note
from
        device, 
        employee,
        device_type
where
        device.device_type_id = device_type.device_type_id
And
        device.device_keeper_id = employee.emp_id
order by device_id  ASC
 </select>
```

##根据设备编号查询对象

关键点:
    **where 后面跟着是条件，不是什么外键连接，条件是随便开的。**
在多个表格中:
    主表的字段包含多个外键，此时可以使用left/right。
    主表有部分副表的外键，不能和没有外键的副表使用left/right


```
select 
          device_id,
          device_name,
          device_status_id,
          device_purchase_date,
          device_purchase_price,
          device_manufacture_date,
          device_service_life,
          device_keeper_id,
          emp_name as device_keeper,
          device.deivce_type_id,
          device_type_name,
          note
from
    device,
    device_type,
    employee
where
    device_type.device_type_id = device.device_type_id
AND
    device_type.device_keeper_id = employee.emp_id
AND
    device_id like concat('%',#{deviceId},'%')
```


##根据设备名称查询对象


```
And
    device_name like concat('%',#{deviceName},'%')
```


##根据设备种类名称查询对象


```
And
    device_type_name like concat('%',#{deviceTypeName},'%')
```



#设备维修（保养）Maintain


Mapping.xml使用了 拓展Map： 增加对象DeviceMaintainVo

设备维修编号：      device_maintain_id 
故障编号：          device_fault_id
维修人：            device_maintain_emp ===>employee表格
维修日期：          device_maintain_date
维修结果：          device_maintain_result
维修费用：          device_maintain_cost
备注：              note


新实体类的1个新属性：
    
device_maintain_emp

利用device_maintain_emp_id 作为条件桥梁，强行赋值Name

##查询全部

```
select
    device_maintain_id,
    device_fault_id,
    device_maintain_emp_id,
    emp_name as device_maintain_emp,
    device_maintain_date,
    device_maintain_result,
    device_maintain_cost,
    note
from
    device_maintain,
    employee
where
    device_maintain_emp_id = employee.employee_id
```

##根据设备维修编号查询

```
and
    device_maintain_id like concat('%',#{deviceMaintainId},'%')
```

##根据故障编号查询

```
and
    device_fault_id like concat('%',#{deviceFaultId},'%')
```


#设备类型


Mapping.xml使用了 拓展Map： 增加对象DeviceTypeVo

设备种类编号：      device_type_id
设备种类名称：      device_type_name
型号：              device_type_model
规格：              device_type_spec
供应商:             device_type_supplier
生产商：            device_type_producer
台数:               device_type_quantity
保质期:             device_type_warranty


新的实体类:
**为什么需要这个`deviceTypeIdd`  ，在哪里的网页上需要？**
```
  <resultMap id="AddResultMap" type="Com.CB.Production.domain.vo.DeviceTypeVo" extends="BaseResultMap">
    <result column="device_type_idd" property="deviceTypeIdd" jdbcType="VARCHAR" />
  </resultMap>
```

##查询全部

```
  <select id="find" parameterType="deviceType" resultMap="AddResultMap">
    SELECT
    device_type_id,
    device_type_id as device_type_idd,
    device_type_name,
    device_type_model,
    device_type_spec,
    device_type_supplier,
    device_type_producer,
    device_type_quantity,
    device_type_warranty
    FROM
    device_type
    order by device_type_id ASC
  </select>
```



##根据设备种类编号查询

```
and
    device_type_id like concat('%',#{deviceTypeId},'%')
```


##根据设备种类名称查询

```
and
    device_Type_Name like concat('%',#{deviceTypeName},'%')
```


	2018-12-30 22:08:47
kumika	实战Production---质量列表	# 实战Production---质量列表




#最后质量检查类FCountCheckController

Mapper.xml 增加了拓展Map：FinalCountCheckVO

    成品计数质检编号 ： fCountCheckId
    订单编号            orderId
    检验项目            checkItem
    样本总数            sample
    抽检数              checkNumber
    不合格数            unqualify
    合格率              qualify
    检验时间            cdate
    实际测量数据        measureData
    检验人              empName
    检验结果            result
    备注                note


orderId，不是其他的字段，所以只需要employee

所以：新实体类的1个新属性
    empName
    
##查询全部

因为网页上的变量名称于字段的差不多，所以不需要AS，作别名。

```
select 
    f_count_check_id ,
    order_id,
    check_item,
    sample,
    check_number,
    unqualify,
    qualify,
    cdate,
    measure_data,
    final_count_check.emp_id,
    emp_name,
    result,
    final_count_check.note
from
    final_count_check,
    employee
where
    final_count_check.emp_id = employee.emp_id
```

##根据成品计量质检编号：

```
and
    final_count_check_id  like concat('%',#{finalCountCheckId},'%')
```

##根据订单编号：

```
and
    order_id  like concat('%',#{orderId},'%')
```



#最后测量检查类FMeasurementController

Mapper.xml 增加了拓展Map：FinalMeasureCheckVO

页面显示字段：

    成品计量质检编号：      fCountCheckId
    订单编号：              orderId
    检验项目：              checkItem
    检验时间：              cdate
    实际测量数据：          measureData
    检验人:                 empName
    检验结果:               result
    备注:                   note


orderId，不是其他的字段，所以只需要employee

所以：新实体类的1个新属性
    empName
```
  <resultMap id="AddResultMap" type="Com.CB.Production.domain.vo.FinalMeasuretCheckVo" extends="BaseResultMap">
    <result column="emp_name" property="empName" jdbcType="VARCHAR" />
  </resultMap>
```

##查询全部：

```
select 
      f_measure_check_id ,
      final_measuret_check.order_id,
      check_item,
      cdate,
      measure_data,
      final_measuret_check.emp_id,
      emp_name,
      result,
      final_measuret_check.note
from 
      final_measuret_check,
      employee
where
    final_measuret_check.emp_id = employee.emp_id
```

##根据成品计数质检编号：

```
and
    f_measure_check_id like concat('%',#{fMeasureCheckId},'%')
```

##订单编号：


```
and
    final_measuret_check.order_id like concat('%',#{orderId},'%')
```


#工序计数检查PCountCheckController

Mapper.xml 增加了拓展Map：ProcessCountCheckVo


检验人：  emp_name ==========>作为新实体类的新属性




##查询全部
```
select
    p_count_check_id,
    process_id,
    check_item,
    sample,
    check_number,
    unqualify,
    qualify,
    cdate,
    measure_data,
    process_count_check.emp_id,
    emp_name,
    result,
    note
from 
    employee,
    
where
    process_count_check.emp_id = employee.emp_id
```

##根据工序计量质检编号查询：

```
and
    process_count_check_id like concat('%',#{processCountCheckId},'%')
```


#工序测量检查


Mapper.xml 增加了拓展Map:  ProcessMeasureCheckVO

**检验人：  emp_name ==========>作为新实体类的新属性**




##查询全部

```
select 
    p_measure_check_id ,
    process_id,
    check_item,
    cdate,
    measure_data,
    process_measure_check.emp_id,
    emp_name,
    result,
    process_measure_check.note
from

where
    process_measure_check.emp_id  = employee.emp_id
```


##根据工序编号查询对象

```
and
     p_measure_check_id like concat('%',#{processMeasureCheckId},'%')
```
#不合格产品应用


Mapper.xml 增加了拓展Map:  UnqualifyApplyVO


新建实体类2个新属性：
    product_name,
    emp_name

```
  <resultMap id="AddResultMap" type="Com.CB.Production.domain.vo.UnqualifyApplyVO" extends="BaseResultMap">
    <result column="product_name" property="productName" jdbcType="VARCHAR" />
    <result column="emp_name" property="empName" jdbcType="VARCHAR" />
  </resultMap>
```


##查询全部：

```
  <!-- 查询所有记录 -->
  <select id="find" parameterType="unqualifyApply" resultMap="AddResultMap">
    SELECT
    unqualify_apply_id,
    unqualify_apply.product_id,
    unqualify_item,
    product_name,
    unqualify_apply.emp_id,
    emp_name,
    unqualify_count,
    assembly_date,
    apply_date,
    unqualify_apply.note
    FROM
    unqualify_apply,
    employee,
    product
    WHERE
    unqualify_apply.product_id = product.product_id
    AND unqualify_apply.emp_id = employee.emp_id
    ORDER BY unqualify_apply.apply_date
  </select>
```

##根据不合格编号查询

```
and
    unqualify_apply_id like concat('%',#{unqualifyApplyId},'%')
```

##根据产品名称查询

```
and
    product_name like concat('%',#{productName},'%')
```

	2018-12-30 23:05:30
kumika	实战Production---工艺监控列表	# 实战Production---工艺监控列表





#工艺计划

Mapper.xml    拓展map： TechnologyPlanVo

需要别的表格的字段：

工艺名称： technology_name  =====>technology表格

创建一个新实体类，具有新属性technologyName

##查询全部

因为technology_id 是表格technology 和technology_plan 的连接，是technology_plan的外键, 所以是可以使用left/righ进行关联的，虽然是拓展（这说明关联与Result Map是没有关系的）


```
select 
    technology_plan_id,
    technology_plan.technology_id,
    technology_name,
    batch_amount,
    start_plan,
    end_plan,
    commit_plan,
    technology_plan_start,
    technology_plan_end
from
    technology
left join techonolgy on technology.technology_id = technology_plan.technology_id
ORDER BY
    technology_plan_id ASC
```

##根据工艺计划编号查询

where条件是要加在order关键字之前的

```
where 
    technology_plan_id like concat('%',#{technologyPlanId},'%')
```


##根据工艺名称查询

where条件是要加在order关键字之前的

```
where 
    technology_name like concat('%',#{technologyName},'%')
```



#工艺需求

Mapper.xml    拓展map：TechnologyRequirementVo


1个新属性
        technology_name =====》technology表格
       

##查询全部

```
select
    technology_requirement_id,
    technology_requirement.technology_id,
    technology_name,
    requirement,
    add_time,
    revise_time
from
    technology_requirement
left join technology on technology.technology_id = technology_requirement.technology_id
ORDER BY
    technology_requirement_id ASC
```

##根据工艺要求编号查询

where条件是要加在order关键字之前的

```
where 
    technology_requirement_id like concat('%',#{technologyRequirementId},'%')
```


##根据工艺名称查询

where条件是要加在order关键字之前的

```
where 
    technology_name like concat('%',#{technologyName},'%')
```


#工序管理

网页全部都是使用主表的字段。


##根据工序编号查询

```
select * from process where process_id like concat('%',#{processId},'%')
```

##根据工艺计划编号查询：

```
select * from process where technology_plan_id like concat('%',#{technologyPlanId},'%')
```

#工艺管理


网页全部都是使用主表的字段。




##根据工艺编号查询

```
    SELECT
    *
    FROM
    technology
    WHERE
    technology_id LIKE CONCAT(
    '%',
    #{technologyId},'%' )
```


##根据工艺名称查询

```
    SELECT
    *
    FROM
    technology
    WHERE
    technology_name LIKE CONCAT(
    '%',
    #{technologyName},'%' )
```
	2018-12-31 11:30:12
kumika	实战production---系统列表	# 实战production---系统列表





#权限认证类permission


注意方法:  业务层上的：updateByRoleId






#角色控制Role

网页上需要的字段
        permission_name



##查询全部

```
    SELECT
    *
    FROM
    sys_role
```


##根据角色编号查询

```
    SELECT
    *
    FROM
    sys_role
    WHERE
    role_id LIKE CONCAT(
    '%',
    #{roleId},'%' )
```

##根据角色名称查询

```
    SELECT
    *
    FROM
    sys_role
    WHERE
    role_name LIKE CONCAT(
    '%',
    #{roleName},'%' )
```


#User控制


Mappper.xml  拓展Map：UserVO


页面上需要别的表格的字段：
    role_name
    

创建实体类UserVo，新属性role_name和role_id

```
  <resultMap id="UserVORM" type="Com.CB.Production.domain.vo.UserVO" extends="BaseResultMap">
    <result column="role_name" property="roleName" jdbcType="VARCHAR" />
    <result column="role_id" property="roleId" jdbcType="VARCHAR" />
  </resultMap>
```

使用的是  sys_user_role  sys_role,因为2个都有外键，所以 **需要关联2张表**

只有实体类的属性能和字段相匹配，管他是extend还是asscition，这是没有关系的东西。

    当你选取的字段在外键连接的副表上的时候，是要使用ass的，
    当你选取的字段和主表没有任何联系的时候，使用extend


##查询全部对象

关键理解点：
        3张表格，顺序是 1===》2===》3 的，其中**1和3 是没有外键相连接的**



```
select
    sys_user.id,
    username,
    password,
    locked,
    role_id,
    role_name
from 
    sys_user
left join sys_user_role on sys_user_id = sys_user.id
left join sys_role on role_id = sys_role_id
```


草 ，多出拼接，
首先SQL查询进行对象继承，对象拼接：
对象拼接原因：2个表之间没有外键，只能使用继承，完成把别表格的字段加入到返回对象的属性
role_id，role_name，是sys_user_role表格和sys_role表格的字段，现在要加入到返回对象，作为对象属性。
UserVO是返回对象，有了2个别的表格的属性。




##用户编号查询

```
where sys_user.id like concat('%',#{Id},'%')
```

##用户名称查询

```
where username like concat('%',#{userName},'%')
```

##角色名称查询

```
where role_name like concat('%',#{role_name},'%')
```



哇，这里的需要认真复习物料多表查询，还有用户查询，
	2018-12-31 12:12:42
kumika	实战production---物料列表	# 实战production---物料列表





#物料消耗


mapper.xml   链表： material,  work

网页需要字段：
    work_id  =======>work表格
    material_id ========>material表格

因为work_id  和 material_id 是外键，所以需要进行对3个表关联起来

```
  <resultMap id="BaseResultMap" type="Com.CB.Production.domain.vo.MaterialConsumeVo">
    <id column="consume_id" jdbcType="VARCHAR" property="consumeId" />
<!--
    <result column="work_id" jdbcType="VARCHAR" property="workId" />
    <result column="material_id" jdbcType="VARCHAR" property="materialId" />
-->
    <result column="consume_amount" jdbcType="INTEGER" property="consumeAmount" />
    <result column="consume_date" jdbcType="TIMESTAMP" property="consumeDate" />
    <result column="sender" jdbcType="VARCHAR" property="sender" />
    <result column="receiver" jdbcType="VARCHAR" property="receiver" />
    <result column="note" jdbcType="VARCHAR" property="note" />


    <association property="work" javaType="work">
      <id column="work_id" property="workId" jdbcType="VARCHAR" />
      <result column="process_number" property="processNumber" jdbcType="VARCHAR" />
      <result column="product_id" property="productId" jdbcType="VARCHAR" />
      <result column="process_id" property="processId" jdbcType="VARCHAR" />
      <result column="equipment_id" property="equipmentId" jdbcType="VARCHAR" />
      <result column="rating" property="rating" jdbcType="INTEGER" />
    </association>
    <association property="material" javaType="material">
      <id column="material_id" property="materialId" jdbcType="VARCHAR" />
      <result column="material_type" property="materialType" jdbcType="VARCHAR" />
      <result column="status" property="status" jdbcType="VARCHAR" />
      <result column="remaining" property="remaining" jdbcType="INTEGER" />
      <result column="note" property="note" jdbcType="VARCHAR" />
    </association>
  </resultMap>
```
##查询全部

要是关联表格，选取的字段应该来自副表

```
select
    consume_id,
    consume_amount,
    consume_date,
    sender,
    receiver,
    material_consume.note,
    material.material_id,
    work.work_id

from
    material_consume
left join work on consume.work_id = work.work_id
left join material on consume.material_id = material.material_id
```

##根据物料消耗编号：

like concat('%',#{},'%')

```
where
    consume_id like concat('%',#{consumeId},'%')
```


##根据作业编号：


```
where
    work_id like concat('%',#{workId},'%')
```

##根据物料编号：


```
where
    material_consume_id like concat('%',#{materialConsumeId},'%')
```

#物料接收

mapper.xml   链表：material

新属性：
        material_id
        
```
  <resultMap id="BaseResultMap" type="Com.CB.Production.domain.vo.MaterialReceiveVo">
    <id column="receive_id" jdbcType="VARCHAR" property="receiveId" />
   <!-- <result column="material_id" jdbcType="VARCHAR" property="materialId" />-->
    <result column="amount" jdbcType="INTEGER" property="amount" />
    <result column="receive_date" jdbcType="TIMESTAMP" property="receiveDate" />
    <result column="sender" jdbcType="VARCHAR" property="sender" />
    <result column="receiver" jdbcType="VARCHAR" property="receiver" />
    <result column="note" jdbcType="VARCHAR" property="note" />

    <association property="material" javaType="material">
      <id column="material_id" property="materialId" jdbcType="VARCHAR" />
      <result column="material_type" property="materialType" jdbcType="VARCHAR" />
      <result column="status" property="status" jdbcType="VARCHAR" />
      <result column="remaining" property="remaining" jdbcType="INTEGER" />
      <result column="note" property="note" jdbcType="VARCHAR" />
    </association>
  </resultMap>
```


##查询全部

```
  <select id="find" parameterType="MaterialReceive" resultMap="BaseResultMap">
    SELECT
    receive_id,
    amount,
    receive_date,
    sender,
    receiver,
    material_receive.note,
    material.material_id
    FROM
    material_receive
    LEFT JOIN material ON
    material.material_id=material_receive.material_id
    <!--  order by material_receive.receive_date -->
  </select>
```

##根据收入编号查询

```
where
    receive_id like concat('%',#{receiveId},'%')
```

##根据物料编号查询

```
where
   material_id like concat('%',#{materialId},'%')
```

#物料信息

页面全部都是主表的字段

##查询全部

```
select * from material 
```

##根据物料编号查询


```
where
    material_id like concat('%',#{materialId},'%')
```


##根据物料类型查询


```
where
    material_type like concat('%',#{materialType},'%')
```


	2018-12-31 16:46:34
kumika	实战production---员工列表	# 实战production---员工列表







#员工

mapper.xml  链表  department


##查询全部

```
select
    emp_id,
    emp_name,
    sex,
    id_code,
    birthday,
    join_date,
    STATUS,
    education,
    degree,
    major,
    graduate_school,
    education_form,
    department_name,
    employee.department_id
from 
    employee
left join department on employee.department_id = department.department_id
<if test="status!=null">
      and status=#{status}
</if>
```

##根据员工编号查询

```
where
    employee_id like concat('%',#{employeeId},'%')
```

##根据员工名称查询

```
where
    employee_Name like concat('%',#{employeeName},'%')
```


##根据部门名称查询

```
where
    department_name like concat('%',#{departmentName},'%')
```

#部门


网页全部使用表格上的字段


##查询全部

```
select * from department
```

##根据部门编号查询

```
where  department_id like concat('%',#{departmentId},'%')
```


##根据部门名称查询


```
where  department_name like concat('%',#{departmentName},'%')
```

	2018-12-31 17:27:00
kumika	实战Production---上传下载等功能	"# 实战Production---上传下载等功能

上传，下载，图片，session过期时间，验证码

下载，图片网上显示，session过期，验证码



#上传功能：


##JSP：

在order_list.jsp上的JavaScript的 `function order_edit()`上使用**JS的方法**，而且是Ajax的
```
	//加载文件上传插件
    initOrderEditFileUpload();
    //加载上传过的文件
    initUploadedFile();
```

common.js：
返回的类型**returnType: 'json'**
```
//加载文件上传插件
function initOrderEditFileUpload(){
	$("#orderEditFileUploader").uploadFile({
		url:"file/upload",
		maxFileCount: 5,                //上传文件个数（多个时修改此处
	    returnType: 'json',              //服务返回数据
	    allowedTypes: 'doc,docx,excel,sql,txt,ppt,pdf',  //允许上传的文件式
```

##控制层：

思路:

     *		因为是多文件上传，所以参数request 使用MultipartHttpServletRequest类
     * 		循环体iterator，方便点，不用向for循环体再写循环代码
     * 		1		使用iterator 获取上传来的文件名
     * 		2		因为页面使用Ajax， 所以创建String 变量json
     * 		3		while 循环 ，条件是iterator.hasNext()
     * 		4		创建String变量fileName, 从iterator获取文件名，赋值到fileName上,String fileName = iterator.next();
     * 		5		创建MultipartFile类对象multipartFile， 根据文件名fileName从request获取文件，赋值到multipartFile
     * 		6		使用FileService的上传方法，参数multipartFile，返回值是Map类型的变量XXX
     * 		7		将返回值XXX，根据自定义转换类JsonUtils转换成json，并且赋值到变量json上	
     * 		8		返回json	


代码：
```
@RequestMapping(value="/file/upload", method=RequestMethod.POST)
@ResponseBody
public String uploadFile(MultipartHttpServletRequest request){
    Iterator iterator = request.getFileNames();
    String json = null;
    while(iterator.hasNext()){
        String fileName = iterator.next();
        MultipartFile multipartFile = request.getFile(fileName);
        Map<String,Object> map = fileService.upload(multipartFile);
        json = JsonUtils.objectToJson(map);
    }
    return json;
}
```


JsonUtil类：自定义响应结构
```
    // 定义jackson对象
    private static final ObjectMapper MAPPER = new ObjectMapper();
    //将对象转换成json字符串。
    public static String objectToJson(Object data) {
    	try {
			String string = MAPPER.writeValueAsString(data);
			return string;
		} catch (JsonProcessingException e) {
			e.printStackTrace();
		}
    	return null;
    }
```



##业务层：
###FileServiceIMP:
思路：

     *      1       创建HashMap类型对象resultMap
     *      2       if判断,有3个条件，都为真时候可以进入
     *                  上传文件uploadFile不为null，
     *                  uploadFile的原文件名不为null
     *                  uploadFile的原文件名长度大于0
     *      3       创建String变量 fileName, 赋值上传文件uploadFile的原始文件名
     *      4       创建存放的文件路径 filePath  ， 随便哪个盘哪个文件，比如D:\\iB\\fileYY\\
     *      5       根据自定义工具类FileUtil，创建文件工具FileUtil对象 fu
     *      6       根据filePath，fileName作为2个参数，使用fu的方法，创建String类型的变量newName，作为新文件名
     *      7       根据newName, fileName作为参数，创建File类的对象file
     *      8       根据 file 作为参数，使用MultipartFile的方法，将内存中的文件写入磁盘
     *      9       上传成功后把文件的路径写回去，就是对resultMap进行 put操作， resultMap.put("url", "/file/" + newName);
     *      10      返回resultMap
     *      11      else 对resultMap进行put操作， resultMap.put("message", "文件异常");
     *      12      else 对resultMap进行put操作，resultMap.put("message", "文件上传发生异常");


代码：
```
public Map<String,Object> uploadFile(MultipartFile uploadFile){
    Map<String,Object> resultMap = new HashMap<>();
    try {
        if(uploadFile!= null && uploadFile.getOriginalFilename() != null &&  uploadFile.getOriginalFilename.length > 0){
        String fileName = uploadFile.getOriginalFilename();
        String filePath = "D:\\iB\\fileYY\\";
        FileUtil fu = new FileUtil();
        //这个新文件名是路径+文件名，目录下已经有同名文件,则文件重命名,增加文件序号
        String newName = fu.newFile(fileName,filePath);
        //在服务器上创建存放文件
        File  file = New File(newName);
        //上传文件数据传输到服务器的文件上，可以理解为内存文件写入到硬盘上
        uploadFile.transferTo(file);
        resultMap.put("error",0);
        retultMap.put("url" , "/fileYY/" + newName);
        return resultMap;
    }
    else{
            resultMap.put("error",1);
            retultMap.put("message", "文件异常");
            return resultMap;
    }
}catch(Exception e){
            resultMap.put("error",1);
            retultMap.put("message", "文件上传发生异常");
            return resultMap;
    }
}
```

**FileUtil类：**
```
	/* 目录下已经有同名文件,则文件重命名,增加文件序号 add by tony 20110712 */
	public String newFile(String sPath, String sFile){
		String newFileName = new String();
		String withoutExt = new String();
		File curFile = new File(sPath + "\\" + sFile);
		if (curFile.exists()) {
			for(int counter = 1; curFile.exists(); counter++){
				withoutExt = this.getNameWithoutExtension(curFile.getName());
				if(withoutExt.endsWith(counter-1 + ")")){
					withoutExt = withoutExt.substring(0,withoutExt.indexOf("("));		//idea
				}
                newFileName = withoutExt + "(" + counter + ")" + "." + getFileExt(curFile.getName());
                curFile = new File(sPath + "\\" + newFileName);
            }
		}else{
			newFileName = curFile.getName();
		}
		return newFileName;
	}
```



#上传文件删除


##JSP:

Common.js中

```
//ajax方法为调用服务器端删除方法删除服务器端的文件
	        $.ajax({
	            cache: false,
	            url: "file/delete",
	            dataType: "json",
	            data: {fileName:data.url},
```








##控制层:

思路：
根据获取的文件名，进行删除。后面返回的是字符串true，然后转换成json

```
	@RequestMapping(value="/file/delete")
	@ResponseBody
	public String handleFileDelete(@RequestParam String fileName) throws Exception{
		fileService.deleteFile(fileName);
		Map<String,Object> result = new HashMap<String,Object>();	
		result.put("data", "success");
		String json = JsonUtils.objectToJson(result);
		return json;
	}
```








##业务层：


思路：
在文件名的前面增加存放在服务器的路径，然后使用FileUtil的方法进行删除.
其实就还是使用文件名创建新的文件，覆盖了目标文件，然后再进行删除操作。

```
    @Override
    public boolean deleteFile(String fileName) {
        fileName = fileName.substring(fileName.lastIndexOf("/")+1);
        fileName = "D:\\iB\\fileYY\\"+fileName;
        FileUtil.deleteFile(fileName);
        return true;
    }
```



FileUtil类：
使用文件名创建新的文件，覆盖了目标文件，然后再进行删除操作。
```
  //删除给定的文件
  public static void deleteFile(String FileName) {
    File f2 = new File(FileName);
    f2.delete(); //del file
    f2 = null;
  }
```



#上传图片




##JSP

在Order_list.jsp上创建图片
```
TAOTAO.init({
    	"pics" : data.image,
    	});
```

调用全局变量TAOTAO，在common.js
```
TAOTAO = {
	// 编辑器参数
	kingEditorParams : {
		//指定上传文件参数名称
		filePostName  : "uploadFile",
		//指定上传文件请求的url。
		uploadJson : 'pic/upload',
		//上传类型，分别为image、flash、media、file
		dir : "image"
	}
```

##控制层

思路:
调用业务层的方法进行上传了，然后返回图片的地址，转换成json

    因为上传文件的参数是MultipartFileHttpServletRequest ,进行上传文件只能是一个个遍历上传而且对象为multipartFile类， 但是这里是MultipartFile，所以就不需要使用iterator了

代码：
```
	@RequestMapping("/pic/upload")
	public String pictureUpload(MultipartFile uploadFile) throws Exception{
		Map<String,Object> result = pictureService.uploadPicture(uploadFile);
		//为了保证功能的兼容性，需要把Result转换成json格式的字符串。
		String json = JsonUtils.objectToJson(result);
		return json;
	}
```




##业务层：


思路：
1   创建Map
2   if判断，有3个条件
3   获取原始文件名
4   获取文件存放路径
5   使用自定义工具类，生成新文件名NewName
5   原始文件名保留"."后面的字符串（保留文件格式），然后与NewName进行合并成一个新的文件名newName
6   根据newName 和 filePath 创建一个新文件newFile
7   把上传文件数据 transferTo 新文件newFile，完成上传过程
8   返回上传成功信息和图片的地址
9   else判断，当上传失败的时候返回失败信息
10  catch信息，上传失败的时候打印出信息

和上传文件的区别在于 **文件名的创建上**：

    图片是新建的，随机的
    上传文件是使用原始文件名的

代码：
```
public Map<String,Object> uploadImage(MultipartFile uploadFile){
    Map<String,Object> resultMap = new HashMap<>();
    
    try{
        if(uploadFile != null && uploadFile.getOriginalFilename != null && uploadFile.getOriginalFilename().length > 0){
            //获取上传文件的原文件名
            String OldName =  uploadFile.getOriginalFileName();
            //生成新文件名，使用自定义工具类
            String newName = IDUtils.genImageName();
            //使用新生成的文件名，舍弃原始文件名，只保留‘.jpg’这字符串，用来和新文件名组成新文件
            newName = newName + OldName.subString(OldName.lastIndexOf("."));
            String filePath = "D:\\iB\\IMA\\";
            //创建文件
            File newFile = new File(newName+filePath);
            //上传文件写入硬盘
            uploadFile.transferTo(newFile);
            
            //图片上传成功后，将图片的地址写回
            resultMap.put("error",0);
            resultMap.put("url","/pic/" + newName);
            return resultMap;
        }
        else{
            resultMap.put("error" , 1 );
            resultMap.put("message","文件异常");
            return resultMap;
        }
    }
    catch(Exception e){
            resultMap.put("error", 1);
            resultMap.put("message", "文件上传发生异常");
            return resultMap;
    }
}
```


###IDUtils类：

```
	/**
	 * 图片名生成
	 */
	public static String genImageName() {
		//取当前时间的长整形值包含毫秒
		long millis = System.currentTimeMillis();
		//long millis = System.nanoTime();
		//加上三位随机数
		Random random = new Random();
		int end3 = random.nextInt(999);
		//如果不足三位前面补0
		String str = millis + String.format("%03d", end3);
		
		return str;
	}
```




#上传图片删除：



##JSP：


Common.js

```
	$.ajax({
        cache: false,
        url: "pic/delete",
        dataType: "json",
        data: {picName:picName}
```





##控制层：

思路：
调用业务层的方法进行删除


代码：
```
	@RequestMapping("/pic/delete")
	public String pictureDelete(@RequestParam String picName) throws Exception{
		pictureService.deleteFile(picName);
		Map<String,Object> result = CollectionsFactory.newHashMap();
		result.put("data", "success");
		String json = JsonUtils.objectToJson(result);
		return json;
	}

```



##业务层：



```
    @Override
    public boolean deleteFile(String picName) {
        
        picName = picName.substring(picName.lastIndexOf("/")+1);

        picName = "D:\\iB\\IMA\\"+picName;

        FileUtil.deleteFile(picName);

        return true;
    }
```


###FileUtils类：

创建新的文件，覆盖原始文件，然后删除

```
  //删除给定的文件
  public static void deleteFile(String FileName) {
    File f2 = new File(FileName);
    f2.delete(); //del file
    f2 = null;
  }
```
"	2019-01-15 09:54:08
kumika	10个排序算法	#10个排序算法

插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序


 **所有的数据结构 都是 计算下标，然后数组元素进行交换，图片上的各种连接线，各种结构都只是辅助理解而已。**


[![20180202130611201.jpg](https://i.loli.net/2019/01/30/5c5120b709a0c.jpg)](https://i.loli.net/2019/01/30/5c5120b709a0c.jpg)

**排序效率（慢 -> 快）：冒泡排序** < **选择排序** < **插入排序** < **快速排序**

[![v2-136be4ed500266c113905f63d8d4ea36_r.jpg](https://i.loli.net/2019/01/24/5c49c11ff17c6.jpg)](https://i.loli.net/2019/01/24/5c49c11ff17c6.jpg)


关于时间复杂度：

平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。

线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序。

O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序。

线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。

关于稳定性：

稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。

不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。

名词解释：

n：数据规模

k：“桶”的个数

In-place：占用常数内存，不占用额外内存

Out-place：占用额外内存

稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同


[![140152c1b40emo0c54joff.jpg](https://i.loli.net/2019/01/25/5c4adf49e031a.jpg)](https://i.loli.net/2019/01/25/5c4adf49e031a.jpg)


    冒泡排序和选择排序用的不是很多，因为时间复杂度高，但是因为常数项少，小规模排序执行时间不一定比其他排序长。
    
    插入排序 虽然时间复杂度高，但是因为常数项比较小，通常用在大致排序完成后最后的调整阶段。比如Java中Array.sort()的底层实现便用了二分插入排序（长度小于32的Tim sort算法）。
    
    快速排序和归并排序是最常用的。堆排序的思想比较重要，涉及到优先队列的问题。
    
    基数排序 能够解决一些特定的问题。
    https://blog.csdn.net/weixin_38594819/article/details/79234174


#1  冒泡排序

输入一组乱序的数组，
输出一组有序的数组,是从小到大的顺序。

动图演示:
[![v2-b7d216a5b292cf3a5412bbc7fbb56a9e_b.gif](https://i.loli.net/2019/01/25/5c4adf4a0b74a.gif)](https://i.loli.net/2019/01/25/5c4adf4a0b74a.gif)

##算法步骤：

1   比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2   对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，3   这样在最后的元素应该会是最大的数；
针对所有的元素重复以上的步骤，除了最后一个；
重复步骤1~3，直到排序完成

**自己的小理解：**
遍历一遍全部的元素，一定有一个元素不需要比较了，所以第一个for循环就是计数几个不需要比较的元素。
第2个for循环的变量k就是比较值不能大于当前能比较的元素数（就是比较是一对一对的，当不能成一对的时候，就算完成一次数据冒泡）




什么时候最快：

当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。

什么时候最慢：

当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。


##代码实现：

个人理解的步骤：

     *  双循环 
     *  内循环是作为数组内2个元素的的比较，
     *  比较结束的要求是： 后面元素 大于 前面元素（判断条件语句就要是 后面元素 小于 前面元素）



代码：

```
    public static int[] bubbleSort(int[] array) {
        if (array.length == 0) {
            return array;
        }
       //减少的元素数量,是对比较范围的确定
        for (int i = 0; i < array.length;i++) {
            //第一次比较完毕后，下一次比较的时候就会减少一个元素的比较
            //比较大小的位置根据k 决定的，k最大范围是减少元素数量后的倒数2位，因为当k在最后一位的时候就无法比较
            for (int k =0; k < array.length - i - 1; k++) {
                if (array[k + 1] < array[k]) {
                    int temp = array[k + 1];
                    array[k + 1] = array[k];
                    array[k] = temp;
                }
            }
        }
        return array;
    }

```

进行验证：

```
    public static void main(String[] args) {
        int[] A = {10,9,8,7,6,5,4,3,2,1,0};
        int[] B = null;
        long startTime = System.currentTimeMillis();
        B = bubbleSort(A);
        long endTime = System.currentTimeMillis();
        for (int i =0;i < B.length;i++) {
            System.out.print(B[i]+",");

        }
        System.out.println("用时: "+ (endTime-startTime) +"毫秒");
        System.out.println(" ");
    }
```





# 2 选择排序


选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。**唯一的好处可能就是不占用额外的内存空间了吧。**


动图演示：
[![v2-44be35da53ae9ee564ce444542a43d10_b.gif](https://i.loli.net/2019/01/25/5c4ae32ea21b9.gif)](https://i.loli.net/2019/01/25/5c4ae32ea21b9.gif)


##算法步骤：

    1 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
    
    2 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
    
    重复第二步，直到所有元素均排序完毕。

**个人理解：**
冒泡是最小值从后面传到前面；
选择是遍历出最小值，然后放入前面位置，继续遍历最小值以此循环。




##代码实现

**个人理解的步骤：**

 *  步骤：
 *          2个循环
 *          内循环查询最小的元素值，然后保存它的下标，基准值是minIndex = 外循环的变量i值
 *          外循环执行 将 最小元素和 当前下标为 i 值的元素 交换

代码：
```
    public static int[] selecttionSort(int[] array) {
        if (array.length == 0) {
            return array;
        }
        for (int i= 0; i < array.length;i++) {
            int minIndex = i;
            for (int k = i ; k < array.length;k++) {
                if (array[k] < array[minIndex]) {//找到最小的值
                    minIndex = k;//将最小值的索引保存
                }
            }
            //将找到的最小值和i位置所在的值进行交换
            int temp = array[minIndex];
            array[minIndex] = array[i];
            array[i] = temp;
        }
        return array;
    }
```
代码验证：

```
        //选择排序
        int[] A = {120,9,38,72,63,35,4,3,23,321,34};
        int[] B = null;

        long startTime = System.currentTimeMillis();
        B = selecttionSort(A);
        long endTime = System.currentTimeMillis();

        for (int i =0;i < B.length;i++) {
            System.out.print(B[i]+",");

        }
        System.out.println("用时: "+ (endTime-startTime) +"毫秒");
        System.out.println(" ");
    }
```





# 3 插入排序


工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

动图演示：
[![插入排序.gif](https://i.loli.net/2019/01/26/5c4b3b24b1708.gif)](https://i.loli.net/2019/01/26/5c4b3b24b1708.gif)

过程：

1   从**1位置**（不是0位置）开始，比较与前面数的大小，如果小于前面的数，则交换位置，当大于前面的数，则停止，完成一次比较。
2   接着从**2位置**开始，重复这个过程。直到最后位置为止。
3   时间复杂度取决于数组的排序情况，当数组基本有序时候，复杂度很低，接近O（n）。当数组完全无序时，每个数都要经过多次移动，复杂度趋近于O（n²）。


##代码实现：

```
    public static int[] insertTionSort(int[] array) {
        if (array.length == 0) {
            return array;
        }
        int current;
        //为什么需要-1呢？
        //因为变量 i 是 从数组第1个元素到倒数第2个元素的范围，是交换对象
        for (int i=0;i< array.length - 1;i++) {
            //移动或者交换的基准点（被交换对象），是从数组的1位置开始的，不是0位置
            current = array[i + 1];
            //交换的对象
            int preIndex = i;
            //前面的判断是作用在第一次比较交换，后面的判断是进行判断是否需要移动或者停止这轮交换
            //当基准点大于交换对象的时候，就是停止本轮交换的时刻。
            while (preIndex >= 0 && current < array[preIndex]) {
                array[preIndex + 1] = array[preIndex];
                preIndex--;
            }
            //这就是冒泡排序最后的array[i] = temp，放在第三方的数据拿回来
            //就是将冒泡排序的交换3部曲使用判断分开了
            array[preIndex + 1] = current;
        }
        return array;
    }
```


代码验证：

```
        //插入排序
        int[] A = {120,9,38,72,63,35,4,3,23,321,34};
        int[] B = null;

        long startTime = System.currentTimeMillis();
        B = insertTionSort(A);
        long endTime = System.currentTimeMillis();

        for (int i =0;i < B.length;i++) {
            System.out.print(B[i]+",");

        }
        System.out.println("用时: "+ (endTime-startTime) +"毫秒");
        System.out.println(" ");
```




# 4 希尔排序

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

    1   插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率
    2   但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位


希尔排序的基本思想是：
先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。


**图片过程：**

[![140156o7nq6qd76zd66nzn.jpg](https://i.loli.net/2019/01/26/5c4c2f6625537.jpg)](https://i.loli.net/2019/01/26/5c4c2f6625537.jpg)


**过程：** 
1. 过程类似于插入排序，算是插入排序的一种优化。 
2. 首先，需要确定一个步长k，根据步长，把数组分为N/k部分，每一部分单独排序。 
3. 把步长缩短，继续排序，直到步长为1。 
4. 通过步长，减少了数组需要移动的次数，从而降低了复杂度。 
5. 所以复杂度的高低完全取决于步长的好坏，是一种特别不稳定的算法，也是一种实现简单分析困难的算法。

 


##**代码实现：**

```
    /**
     * 希尔排序
     * @param array
     * @return
     */
    public static int[] ShellSort(int[] array) {
        int len = array.length;
        int temp, gap = len / 2;
        while (gap > 0) {
            for (int i = gap; i < len; i++) {
                temp = array[i];
                int preIndex = i - gap;
                while (preIndex >= 0 && array[preIndex] > temp) {
                    array[preIndex + gap] = array[preIndex];
                    preIndex -= gap;
                }
                array[preIndex + gap] = temp;
            }
            gap /= 2;
        }
        return array;
    }
```


##代码验证：

```
        int[] A = {120,9,38,72,63,35,4,3,23,321,34};
        int[] B = null;

        long startTime = System.currentTimeMillis();
        B = ShellSort(A);
        long endTime = System.currentTimeMillis();

        for (int i =0;i < B.length;i++) {
            System.out.print(B[i]+",");

        }
        System.out.println("用时: "+ (endTime-startTime) +"毫秒");
        System.out.println(" ");
```


# 5 归并排序

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

**动图演示：**
[![v2-9541d116b9ad191437cb0f9acce7baf6_b.gif](https://i.loli.net/2019/01/26/5c4c7df3c8a91.gif)](https://i.loli.net/2019/01/26/5c4c7df3c8a91.gif)


**算法描述：**
把长度为n的输入序列分成两个长度为n/2的子序列；
对这两个子序列分别采用归并排序；
将两个排序好的子序列合并成一个最终的排序序列。

**过程：**

把数组分成两部分，分别比较大小，最后合并。
递归调用自己。


**重点理解：**
归并排序的优势很明显，它是稳定排序。同时相对于快排，它占用较多的空间。
递归的思想很重要，分治法的应用也很广泛，把大问题分解成小问题一步步解决。
递归过程要掌握，递归过程一定要有一个终止条件。
压栈的过程，空间的占用要理解。
同样有论文级别的算法可以把归并排序的空间省下来，知道就好。ORZ。。。 默认空间复杂度 O（n）。


**个人理解：**
代码实现需要2个部分，
一个部分是对数组进行分割，分成2组，
另外一个部分是进行比较大小和排序，使用第三方内存地址进行存储拿出来的数据。

比较排序的条件：
左数组赋值完，到右数组
右数组赋值完，到左数组
左数组 》 右数组， 此时右数组进行赋值
执行从左到右，从序号0开始

##**代码实现：**

实现步骤：
代码段1

 *              把原数组拆分成 2个数组，左右数组，以 mid = 数组的长度/2
 *              调用本身，参数是 左数组，0， mid           返回 数组 left
 *              调用本身，参数 右数组，mid， array.length  返回 数组 right
 *
 *              调用merge方法 ，参数是 递归本身（ left ） 和 递归本身（ right）


代码段2

 *          1  创建完整数组，长度是 2个数组的长度相加，恢复原来的数组长度
 *          2  创建1个循环 参数有 序号left = 0,  序号right = 0,  序号index = 0，index  <  总数组长度， 只有index++  index是表示要放入总数组的元素的下标
 *          3  循环内有4种情况
 *              第1种  判断序号left  >= 左数组的长度， 当大于的时候，说明左数组全部放入到总数组了，现在放右数组了
 *              第2种  判断序号right  >= 右数组的长度， 当大于的时候，说明右数组全部放入到总数组了，现在放左数组了
 *              第3种  当左边数组第一个元素的值  大于  右边数组第一个元素的值，整体数组元素从右边数组开始
 *              第4种  剩余情况，整体数组元素从左边数组开始，存放元素到整体数组上
 *          4   返回总数组

代码实现：
```
    /**
     * 归并排序
     * @param array
     * @return
     */
    public static int[] MergeSort(int[] array) {
        if (array.length < 2) return array;

        int mid = array.length / 2;
        int[] left = Arrays.copyOfRange(array, 0, mid);
        int[] right = Arrays.copyOfRange(array, mid, array.length);

        return merge(MergeSort(left), MergeSort(right));
    }

    /**
     *  归并排序----将2段排序好的数组结合成一个排序数组
     * @param left
     * @param right
     * @return
     */
    public static int[] merge(int[] left, int[] right) {
        int[] endNum = new int[left.length + right.length];
        //递归是2叉树的思想体现，这里体现了左右子树的分的作用
        //2个参数都是排列好的数组，只需要考虑边界问题
        for (int index = 0, i = 0,k = 0;index < endNum.length;index++) {
            if (i >= left.length)
                //当序号i 超越左数组序号范围最大值，右数组的第一个元素开始赋值到支付宝（endNum数组）
                endNum[index] = right[k++];
            else if (k >= right.length)
                //当序号k 超越右数组序号范围最大值，左数组的第一个元素开始赋值到支付宝（endNum数组）
                endNum[index] = left[i++];
            else if (left[i] > right[k])//个人认为的唯一的排序判断
                // 当左数组 》右数组，右数组赋值到支付宝（endNum数组）
                endNum[index] = right[k++];
            else
                //左数组从序号0开始，赋值到支付宝（endNum数组）上
                endNum[index] = left[i++];
        }
        return endNum;
    }
```

left[]

right[]

endNum[index] 是第三方，目的是存放每一次递归排列好的数据

##代码验证：

```
        int[] A = {120,9,38,72,63,35,4,3,23,321,34};
        int[] B = null;

        long startTime = System.currentTimeMillis();

        //归并排序
        B = MergeSort(A);

        long endTime = System.currentTimeMillis();

        for (int i =0;i < B.length;i++) {
            System.out.print(B[i]+",");

        }
        System.out.println("用时: "+ (endTime-startTime) +"毫秒");
        System.out.println(" ");
```


# 6  快速排序


**需要重点掌握：**

快速排序是一种很重要也很常用的排序，也有一些很重要的应用，比如说BFPRT算法，荷兰国旗问题。
快速排序如果每次都选到最大值，或者最小值，就会产生最坏的情况，使复杂度达到O（n²）级别。但是可以通过随机选择partition值，从数学期望上避免这种情况的发生。所以可以默认其复杂度为O（N * lg N）。
一般默认快速排序是非稳定的。但是有论文级别的方法，可以使其实现稳定（0-1 stable sort）。看看就好。。。

快速排序是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。

**基本思想：**
通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。


**动图演示：**
喜欢哪个就看哪个
[![v2-71c0f1c0ceb0e053c423426e7f343602_b.gif](https://i.loli.net/2019/01/28/5c4ec362ebd76.gif)](https://i.loli.net/2019/01/28/5c4ec362ebd76.gif)

P是基准值，L是左，R是右
[![](https://ae01.alicdn.com/kf/H362e8eece9fe4aa0a8cfbbc4c0f7f9400.gif)](https://ae01.alicdn.com/kf/H362e8eece9fe4aa0a8cfbbc4c0f7f9400.gif)

**算法描述（过程）：**


比基准值 大的，原地不动

120,9,38,72,63,35,4,3,23

基准值： 35

============================================

pivot进行了与end序号的交换
此时数组：120,9,38,72,63,23,4,3,35


start 0 ，end 8，i = 0， smallIndex = -1

120 》 35  不动，此时继续

-------------------
i = 1
9 《 35   ，经过了判断，此时smallIndex值增加1，为0

判断 i > smallIndex 为真，就把序号 i 和 序号smallIndex 的值进行调换

此时 i = 1，smallIndex = 0

-------------------------------

i = 2 ，
38 》 35 ，没经过判断，smallIndex不动，i继续增加

72，63 》 35 ，没经过判断，smallIndex不动，i增加到了5

-------------------------------

i = 5 ，23 《 35， 经过判断，smallIndex 增加1，此时smallIndex= 1,

判断 i > smallIndex 为真，就把序号 i 和 序号smallIndex 的值进行调换
array[smallIndex]=120，array[i] = 23,此时进行了跳跃交换

此时 i = 5, smallIndex = 1
i继续增加到6

--------------------------------------

i = 6 ， 4 《 35， 经过判断， small Index增加 1，此时smallIndex = 2，

判断 i  》 smallIndex 为真， 把i 和 smallIndex 的值进行调换
array[smallIndex]=38，array[i] = 4,此时进行了跳跃交换


此时 数组排序：  9, 23, 4, 72, 63, 120, 38, 3, 35
i = 6, smallIndex = 2
i继续增加到7

------------------------------------
i = 7，3 《 35，经过判断 ，smallIndex 增加1，smallIndex = 3，

判断 i  》 smallIndex 为真， 把i 和 smallIndex 的值进行调换
array[smallIndex]=72，array[i] = 3,此时进行了跳跃交换

此时 数组排序：  9, 23, 4, 3, 63, 120, 38, 72, 35
i = 7, smallIndex = 3
i继续增加到8

--------------------------------------

i = 8，35 = 35，经过判断 ，smallIndex 增加1，smallIndex = 4，

判断 i  》 smallIndex 为真， 把i 和 smallIndex 的值进行调换
array[smallIndex]=63，array[i] = 35,此时进行了跳跃交换

此时 数组排序：  9, 23, 4, 3, 35, 120, 38, 72, 63
i = 8, smallIndex = 4
i继续增加到9，不符合条件，返回smallIndex


======================================
自己的错误思考：
    认为一次遍历就可以完成全部排序，和移动一对固定的数据

实际情况：
    这个快速排序就是以小值的元素为中心（小值元素的移动/交换为优先级）。数组元素的交换 等于 数组元素的移动。
    完全实现排列好顺序是需要多次遍历的。
    每次一对数据交换都不一定是同一对元素。
   i                           P    
   S                           P
   1  12  33  3  54  16  2  6  4 
      S       i
   1  3  33  12  54  16  2  6  4 
         S               i      
   1  3  2   12  54  16 33  6  4 
   
理解的难点：
基准值P  只是和i 进行比较
小下标S  只是表示2个比较元素中小值的元素在数组的下标，同时下标S的增加一次也表示快速排序的移动一次
循环变量i  就是表示读取遍历数组的

以小值元素为移动（交换），用基准值与array[i]比较，推动下标的增加。
小元素在左段，大元素在右段，基准值在中间（交换元素的时候，在分段的最右边）


##代码实现：
分为3个部分：基准值判断， 分区操作， 元素交换

**快速排序的步骤：**

     * 快速排序  代码段1
     * 完整的快速排序  = 代码段1 + 代码段2 + 代码段3
     * 快速排序应该算是在冒泡排序基础上的递归分治法
     快速排序的步骤：

        代码段1  ： 调用分区操作方法---代码段2
            调用 排序方法，参数 array  0，array.length， 返回基准值smallIndex
            if  smallIndex  > 0     根据参数基准值smallIndex - 1，0 ，array ，调用自己形成递归
            if  smallIndex  < end   根据参数基准值smallIndex + 1，array.length ，array ，调用自己形成递归

        代码段2 ： 1个循环内2个if判断

            写排序方法
                 基准值 随机产生  (start + Math.random() * (end - start + 1));
                 创建 int smallIndex = start - 1 用于标记 2个元素比较小的那个
                 在数组中基准值为下标的元素和尾元素进行交换
                 for循环 i = start
                    if（array[i] <= array[end]）
                                smallIndex++;
                                if(i > smallIndex)
                                    将array[i] 和 array[smallIndex]进行交换元素
            return smallIndex

        代码段3

            写交换元素方法 参数是2个下标 和数组


代码实现：
```
    /**
     * 快速排序方法
     * @param array
     * @param start
     * @param end
     * @return
     */
    public static int[] QuickSort(int[] array, int start, int end) {

        if (array.length < 1 || start < 0 || end >= array.length || start > end) return null;
        //进行分区操作，返回基准值
        int smallIndex = partition(array,start,end);

        if (smallIndex > start)
            QuickSort(array, start, smallIndex - 1);

        if (smallIndex < end)
            QuickSort(array,smallIndex + 1,end);

        return array;
    }

    /**
     * 快速排序算法---partition----就是分区操作
     * @param array
     * @param start
     * @param end
     * @return
     */
    public  static int partition(int[] array, int start,int end) {
        //从数列中挑出一个元素，称为 “基准”（pivot）
        int pivot = (int) (start + Math.random() * (end - start + 1));
        //
        int smallIndex = start - 1;
        //根据基准数和 最后序号进行交换
        swap(array, pivot, end);
        //
        for (int i = start; i <= end; i++) {
            //从0开始与基准值进行比较，比基准值小，就不动，因为这个算法是从左到右的，不是2边同时判断的
            if (array[i] <= array[end]) {
                //发生交换的位置，同时也是记录基准值最后的位置。因为最后发生交换的位置是大概在中间位置的。
                smallIndex++;
                //判断 2个 交换对象 的位置，因为这算法要求输出是小的在左，大的在右
                if (i > smallIndex)
                    //进行交换元素
                    swap(array, i, smallIndex);
            }
        }
        return smallIndex;
    }

    /**
     * 交换数组内2个元素
     * @param array
     * @param i
     * @param k
     */
    public static void swap(int[] array, int i, int k) {
        int temp = array[i];
        array[i] = array[k];
        array[k] = temp;
    }
```


##代码验证：

```
        int[] A = {120,9,38,72,63,35,4,3,23};
        int[] B = null;

        long startTime = System.currentTimeMillis();

        //快速排序
        B = QuickSort(A,0,8);


        long endTime = System.currentTimeMillis();

        for (int i =0;i < B.length;i++) {
            System.out.print(B[i]+",");

        }
        System.out.println("用时: "+ (endTime-startTime) +"毫秒");
        System.out.println(" ");
```

=====================
###个人理解的最为关键的第二段代码：
自己写的理解注解
```
    /**
     *  快速排序  代码段2
     *  分区操作
     * @param array
     * @param start
     * @param end
     * @return
     */
    public static int partition(int[] array, int start, int end) {
        System.out.println("数组的元素是：");
        for (int i = 0; i < array.length;i++) {
            System.out.print("  "+array[i]);
        }
        System.out.println(" ");
        //随机产生基准值
        int pivot = (int) (start + Math.random() * (end - start + 1));

        System.out.println("随机的基准值是："+ pivot+"   基准值的数值元素是："+array[pivot]);

        //小下标，用于确认 2个交换元素中小的元素
        int smallIndex = start - 1;

        //基准值和最后一个元素进行交互，基准值作为尺子，在最后一位好操作
        // 这是为后面递归分区做的准备，
        // 同时也是算法的要求，小的在左，大的在右，
        swap(array, pivot, end);
        System.out.println("经过基准值的交换后，此时数组的元素是：");
        for (int i = 0; i < array.length;i++) {
            System.out.print("  "+array[i]);
        }

        System.out.println(" ");
        int u = 0;
        //对数组进行交换元素，判断根据是pivot的基准值，经过上行语句，现在基准值交换到end的位置上了
        for (int i = start; i <= end; i++) {
            System.out.println("变量i 增加 1，现在i的值："+i);
            //基准值 与数组第一个元素判断大小，同时也确定了小下标的位置
            //这个判断语句，根据下面的代码，其实这里有2重意思的 1个是判断基准值与元素的大小 另1个是作为小下标的
            if (array[i] <= array[end]) {
                //小下标原来是-1 ，-1就是准备状态，没有开始标注，
                // 现在增加后是0，也就是说小下标开始工作了，指认第一个元素是小值的元素（判断条件指认的）
                //也表示快速排序的移动，把小值的元素放进数组，数据的交换就是移动
                System.out.println("此时循环的i 的值："+ i);
                smallIndex++;
                System.out.println("smallIndex++， 此时循环的smallIndex 的值："+ smallIndex);
                //当循环变量 i > 小下标的时候，说明array[i] 的值  >  array[smallIndex],
                // i 和 smallIndex 是不同步的
                //这个 i  >  smallIndex 是快速排序的要求的，因为以小值元素为左边，大值元素为右边
                if (i > smallIndex) {
                    System.out.println("进入交换元素的判断");
                    System.out.println("i的值："+i+"    下标 i的数组元素值："+array[i]);
                    System.out.println("smallIndex的值："+smallIndex+"  smallIndex 下标 的数组元素"+array[smallIndex]);
                    swap(array, i, smallIndex);
                    u++;
                    System.out.println("进行了一次交换元素  交换数:"+u);
                    System.out.println("数组的元素是：");
                    for (int k = 0; k < array.length;k++) {
                        System.out.print("  "+array[k]);
                    }
                    System.out.println(" ");
                }
            }
        }
        System.out.println("此时数组的元素是：");
        for (int i = 0; i < array.length;i++) {
            System.out.print("  "+array[i]);
        }
        System.out.println(" ");
        System.out.println(" ==================  完成一次分区 ======================= 交换次数为: "+u);
        return smallIndex;
    }
```



# 7 堆排序

**堆排序（Heapsort）**是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质**：即子结点的键值或索引总是小于（或者大于）它的父节点。**

堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：
**大根堆**：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；

**小根堆：**每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；

[![20180308195555388.png](https://i.loli.net/2019/01/30/5c51769cdf814.png)](https://i.loli.net/2019/01/30/5c51769cdf814.png)

**上图，左侧是大根堆，右侧是小根堆**，这里必须要注意一点，只要求子节点与父节点的关系，两个节点的大小关系与其左右位置没有任何关系

**堆排序的平均时间复杂度为 Ο(nlogn)。**

--------------------------------------------------------




**动图演示：**

[![849589-20171015231308699-356134237.gif](https://i.loli.net/2019/01/30/5c516a7e840bf.gif)](https://i.loli.net/2019/01/30/5c516a7e840bf.gif)

[![](https://puui.qpic.cn/fans_admin/0/3_1231832914_1570210802723/0)](https://puui.qpic.cn/fans_admin/0/3_1231832914_1570210802723/0)
**过程：**






**重点：**

堆排序是一种复杂度很稳定的算法，没有最差或者最好，稳定的 n * lg N。
堆排序可以拓展到优先队列的实现，在贪心算法中经常用到。


上面图的结构 在实际代码中是没有的，只是图这样画有助于理解，实际代码是靠指针完成的（深坑）




##**代码实现：**

实现的步骤：
     学习算法： 先接收它的流程，在理解为什么这样写，自己500年也写不出这样的算法的，抄就完事了
     
**最大堆的流程：**

 **1. 根据输入的数组构建该数组的最大堆**
    为什么要先构建一个最大堆？直接使用交换不行吗？
    
    答： 
        就是直接使用了啊，只不过第1次是排成符合XX2叉树的数学排序公式计算后的序列，就是第1次是粗排，第2次是精细的排序。
        重新构建该数组内元素的排序，原来数组输入的排序现在进行重新排序，排成符合XXX2叉树的数学公式计算得出的排序，后面再进行最大堆排序就快速了，减少时间。
        相当于 一个瓷器不是我想要的形状， 放入到最大堆这个黑匣子中，匣子先打碎瓷器，然后捏了个大概形状，然后再使用黑匣子，捏了个仔仔细细的自己想要的形状。（放入代码中就是调用了2次最大堆的调整堆结构方法，该方法中也递归了本身方法）
        

 **2. 数组的头元素 与 末尾元素进行交换**
 **3. 数组的长度--**
 **4. 正式开始进行 最大堆的排序**

    此时的数组排序是符合XXX2叉树的数学公式计算得出的排序

 **5. 最后返回 完成排序的数组**


代码实现：

为什么调整结构方法里的判断条件语句要这么写？
因为数学公式这么要求的啊，背公式就完了

```
    //声明全局变量，用于记录数组array的长度
    static int len;

    /**
     *  堆排序算法
     * @param array
     * @return
     */
    public static int[] HeapSort(int[] array) {

        len = array.length;
        if (len < 1) return array;

        //1. 构建一个最大堆
        buildMaxHeap(array);

        //2. 循环将堆首位（最大值）与末位交换，然后再重新调整最大堆
        while (len > 0) {
            swap(array,0,len - 1);
            //再完成交换后，最大值就退出交换操作
            len--;
            //因为交换后，此时堆首位不是最大值，所以堆结构需要调整到符合规则的顺序
            adjustHeap(array, 0);
        }
        return array;
    }

    /**
     *  建立最大堆
     * @param array
     */
    public static void buildMaxHeap(int[] array) {
        //从最后一个非叶子节点开始向上构造最大堆
        for (int i = (len - 1) / 2; i >= 0; i--) {
            adjustHeap(array, i);
        }
    }

    /**
     * 调整堆结构，成为最大堆结构
     * @param array
     * @param i
     */
    public static void adjustHeap(int[] array, int i) {
        int maxIndex = i;
        //如果有左子树，而且左子树大于父节点，则将最大指针指向左子树
        //个人的理解：
        // 2倍的最大值下标值 与 数组的长度 相互比较， 比较它们的下标数值大小，所在的元素值大小
        if (i * 2 < len && array[i * 2] > array[maxIndex])
            maxIndex = i * 2;
        //如果有右子树，而且右子树大于父节点，则将最大指针指向右子树
        //个人理解：
        //2倍的最大值下标值 + 1 与 数组的长度 相互比较， 比较它们的下标数值大小，所在的元素值大小
        if (i * 2 + 1 < len && array[i * 2  + 1] > array[maxIndex])
            maxIndex = i * 2 + 1;
        //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置
        if (maxIndex != i) {
            swap(array, maxIndex, i);
            adjustHeap(array, maxIndex);
        }
    }

```



##代码验证：

```
        int[] A = {120,9,38,72,63,35,4,3,23};
        int[] B = null;

        long startTime = System.currentTimeMillis();

        //堆排序
        B = HeapSort(A);

        long endTime = System.currentTimeMillis();

        for (int i =0;i < B.length;i++) {
            System.out.print(B[i]+",");

        }
        System.out.println("用时: "+ (endTime-startTime) +"毫秒");
        System.out.println(" ");
```

**个人理解：**

使用完全二叉树的结构，对输入的数组进行排序，根据二叉树规则，多次调整结构，完成排序，输出要求的顺序。 其中关键有**3个部分**组成，

    建立堆排序（最大堆，最小堆），
    调整堆结构，
    堆首位（最大值OR最小值）与末位交换

**难点：**
    理解堆排序的过程，调整堆结构过程中的交换数据情况，判断发生交换的位置（利用完全二叉树特性）


**完全二叉树对左右子树存在节点的判断：**
一棵完全二叉树有 n个节点，则对任一节点i (1 <= i  <= n)适用

左子树存在节点条件： 
    
    2 * i  <= n，  所以编号 i 存在编号2 * i 的节点，作为左子树
        
右子树存在节点条件：
        
    2 * i + 1 <= n，   所以编号 i 存在编号2 * i + 1 的节点，作为右子树    

疑问：
最小堆的算法
非叶子结点 叶子结点   结点  是什么定义

##更新的个人理解
所有的数据结构 都是 计算下标，然后数组元素进行交换，图片上的各种连接线，各种结构都只是辅助理解而已。


这个最大堆，就是根据最大节点的下标 与 输入的下标 进行比较，然后进行交换元素


# 8 计数排序

桶排序（Bucket Sort）属于非比较排序，因此适用范围很窄，但是在特定问题上可以把时间复杂度做到 O（n）。
桶排序只是一个概念，一种非比较排序的思想。基数排序和计数排序都算桶排序的一种落地（实现）。

##**核心：**
计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 
作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数------适用于**明确范围的数字排序**



**动图演示：**
[![140203ojpphtzfs34zzxfd.gif](https://i.loli.net/2019/01/31/5c52fda922ca2.gif)](https://i.loli.net/2019/01/31/5c52fda922ca2.gif)



**算法过程：**

遍历一遍数组，得到最大值和最小值

max - min + 1  得到桶数组


**算法分析：**

当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。

##**代码实现：**



```
    public static int[] CountingSort(int[] array) {

        if (array.length == 0) return array;

        int bias, min = array[0], max = array[0];

        //找出输入数组A中的最大最小值
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) max = array[i];

            if (array[i] < min) min = array[i];
        }
        //目的是为了辅助数组的下标从0开始，不然就是min的值开始
        bias = 0 - min;

        //辅助计数数组B ，长度是根据输入数组A的最大值 - 最小值 + 1
        int[] bucket = new int[max - min + 1];

        //辅助数组B全部填充数值0
        Arrays.fill(bucket, 0);

        //记录每个数字出现的次数。辅助数组的下标  等于 输入数组的值
        for (int i = 0; i < array.length; i++) {
            // 因为辅助数组B的下标是从输入数组A的最小数值开始，到最大数值结束
            //比如输入数组最大值120，最小值3， 辅助数组的下标起始值就是3，终结值120，
            //但是，这里为了方便，辅助数组的下标起始值要从0开始，所以就要减去输入数组的最小值，
            //所以辅助数组的下标的最大值，则是输入数组最大值减去最小值
            bucket[array[i] + bias]++;
        }
        //index是作为输入数组的下标，i是辅助数组的下标
        int index = 0, i = 0;
        //辅助数组输出元素，就是从桶拿出元素
        while (index < array.length) {
            //判断辅助数组是否记录了元素
            if (bucket[i] != 0) {
                //根据辅助数组下标还原输入数组的值
                array[index] = i - bias;
                //输出了一个元素，辅助数组的该元素计数减一
                bucket[i]--;
                //i并没有更新，可以多次输出辅助数组的一个元素
                //index是输出数组的下标，需要更新
                index++;
            } else
                i++;
        }
        return array;
    }
```
**个人理解：**
代码实现分成了3个部分：

     输入数组A 输入 到桶（辅助数组B）里，
     桶（辅助数组B）记录数组A的元素出现次数，
     根据桶（辅助数组B）记录的次数，输出到数组C上，数组C的长度与数组A一致，
     最后返回数组C，完成排序。


大概率使用这个算法的范围： 大多数整数排序已经排序好的情况下。

##**代码验证：**

```
        int[] A = {120,9,38,72,63,35,4,3,23};
        int[] B = null;

        long startTime = System.currentTimeMillis();

        //计数排序
        B = CountingSort(A);

        long endTime = System.currentTimeMillis();

        for (int i =0;i < B.length;i++) {
            System.out.print(B[i]+",");

        }
        System.out.println("用时: "+ (endTime-startTime) +"毫秒");
        System.out.println(" ");
```


# 9 桶排序

ArrayList的初始化
list的长度和数组的长度
获取list的元素和获取数组的元素


桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。
**桶排序 (Bucket sort)的工作的原理：**
假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排

**图片演示：**
[![140203uuqs10xfx1fs70gg.jpg](https://i.loli.net/2019/02/02/5c554eb9ccda7.jpg)](https://i.loli.net/2019/02/02/5c554eb9ccda7.jpg)

再举另外图片例子
[![20161104140650130.gif](https://i.loli.net/2019/02/03/5c56986404b97.gif)](https://i.loli.net/2019/02/03/5c56986404b97.gif)


**原理：**
根据最大值最小值创建多个桶，确定各个桶之间的跨度，然后遍历原始数列，把各元素放到对应的桶中，先是每个桶内的元素各自排序，然后遍历输出所有的桶内的所有元素，输出结果即是排序好的数组。

桶排序有点像分治法，把一大堆数据分成若干个桶，每个桶内各自排序，最后再合并。

桶排序的一个要点就是如何确定桶的数量和桶与桶之间的跨度，在上面我看的程序员小灰的文章中他是创建与原始数组长度数量相等的桶，除了最后一个桶只包含一个最大值之外，其余各桶之间的区间跨度=(最大值-最小值)/(桶数量-1)。

桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。

1. 什么时候最快

当输入的数据可以均匀的分配到每一个桶中。

2. 什么时候最慢

当输入的数据被分配到了同一个桶中。

##**代码实现**

```
    public static ArrayList<Integer> BucketSort(ArrayList<Integer> array, int bucketSize) {
        //bucketSize是代表需要按 bucketSize个分桶，进行桶排序

        //人为设置一个BucketSize，作为每个桶所能放置多少个不同数值
        // （例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）

        ArrayList<Integer> resultArr = new ArrayList<>();

        if (array == null || array.size() < 2) return array;

        int max = array.get(0), min = array.get(0);

        //找到最大值和最小值
        for(int i =0; i < array.size(); i++) {
            if (array.get(i) > max) max = array.get(i);

            if (array.get(i) < min) min = array.get(i);
        }

        //桶数
        int buckCount = (max - min) /  bucketSize + 1;
        //存放桶的列表
        ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(buckCount);

        //对桶内元素进行填充 0
        for (int i = 0; i < buckCount; i++) {
            bucketArr.add(new ArrayList<Integer>());
        }

        //将每个元素放入桶
        for (int i = 0; i < array.size(); i++) {
            //桶的数量
            int num = (array.get(i) - min) / bucketSize;
            //将输入元素放入到数组上
            bucketArr.get(num).add(array.get(i));
        }

        //对每个桶进行排序
        for (int i = 0; i < buckCount; i++) {
            //当桶数 = 1 ，则减少桶内的元素数量
            if (buckCount == 1) bucketSize--;
            //使用递归，把每一个桶的元素数量分治到1，然后递归返回，只有1个元素数量的桶的值，赋值到temp数组上，完成排序
            ArrayList<Integer> temp = BucketSort(bucketArr.get(i), bucketSize);
            //根据temp数组上的元素，完成各个桶之间的排序合并，最后返回到输出数组上
            for (int k = 0; k < temp.size(); k++) {
                resultArr.add(temp.get(k));
            }
        }
        return resultArr;
    }
```

**代码验证：**

```
        ArrayList<Integer> AFF = new ArrayList<>();
        AFF.add(120);
        AFF.add(9);
        AFF.add(38);
        AFF.add(72);
        AFF.add(63);
        AFF.add(35);
        AFF.add(4);
        AFF.add(3);
        AFF.add(23);

        ArrayList<Integer> BFF = new ArrayList<>();

        long startTime = System.currentTimeMillis();


        //桶排序
        BFF = BucketSort(AFF,3);

        long endTime = System.currentTimeMillis();

        for (int i =0;i < BFF.size();i++) {
            System.out.print(BFF.get(i)+",");

        }
        System.out.println("用时: "+ (endTime-startTime) +"毫秒");
        System.out.println(" ");
```


# 10 基数排序

基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。
有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。
最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。
基数排序基于分别排序，分别收集，所以是稳定的。

2种算法：
第一类：最低位优先法，简称LSD法：先从最低位开始排序，再对次低位排序，直到对最高位排序后得到一个有序序列；


第二类：最高位优先法，简称MSD法：先从最高位开始排序，再逐个对各分组按次高位进行子排序，循环直到最低位。



**动图演示：**
[![140204ezq2fmi0pm2o9bb9.gif](https://i.loli.net/2019/02/03/5c56b1824c612.gif)](https://i.loli.net/2019/02/03/5c56b1824c612.gif)

基数排序已经不再是一种常规的排序方式，它更多地像一种排序方法的应用，基数排序必须依赖于另外的排序方法。基数排序的总体思路就是将待排序数据拆分成多个关键字进行排序，也就是说，基数排序的实质是多关键字排序。

**过程理解：**
首先需要理解一点：当个位排好顺序时，再对十位开始排序时，个位的相对位置不变。
什么叫相对位置？比如对23，26，58，93进行排序，个位排好后是23，93，26，58。
这时再对十位进行排序，23，26的相对位置是不会变的，排序结束为23，26，58，93。
这个思维过程有点像动态规划，把问题分为n个小步骤，每个下一步都会用到上一步的结果。




**理解重点：**
按照图片的显示看：共有2次排序，2个过程。
存储到临时数组的过程

从临时数组输出元素到目标数组的过程



输入数组遍历，就是第一次遍历，判断个位数，根据个位数的大小，存入到临时数组上，然后按照临时数组的下标按顺序输出到目标数组。

**此时，完成第一次排序**

------------------------------------------
第2次排序

目标数组遍历，就是第2次遍历，判断十位数大小，根据十位数的大小，存入到临时数组上，然后按照临时数组的下标按顺序输出到目标数组。

**别人的理解：**
基数排序是按照低位先排序，然后收集；
再按照高位排序，然后再收集；
依次类推，直到最高位。
有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。
最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。

##**代码实现：**

```
public static int[] RadixSort(int[] array) {
     if (array == null || array.length < 2)
        return array;
        // 1.先算出最大数的位数；
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < array.length; i++) {
            max = Math.max(max, array[i]);
    }
    int maxDigit = 0;
    while (max != 0) {
            max /= 10;
            maxDigit++;
    }
    int div = 1;
    //存放桶的列表
    ArrayList<ArrayList<Integer>> bucketList = new ArrayList<ArrayList<Integer>>();
    //对桶内元素进行填充 0
    for (int i = 0; i < 10; i++)
        bucketList.add(new ArrayList<Integer>());
        //2.进行maxDigit趟分配
        //将每个元素放入桶
    for (int i = 0; i < maxDigit; i++,div *= 10) {
            for (int j = 0; j < array.length; j++) {
                //桶的数量
                int num = (array[j] / div) % 10;
                //将输入元素放入到数组上
                bucketList.get(num).add(array[j]);
            }
        //3.收集
         //从临时数组上拿出元素，存储到array（输出数组）上
            int index = 0;
            for (int j = 0; j < bucketList.size(); j++) {
                for (int k = 0; k < bucketList.get(j).size(); k++)
                    array[index++] = bucketList.get(j).get(k);
                bucketList.get(j).clear();
            }
   }
   return array;
}
```

**代码验证：**

```
        int[] A = {120,9,38,72,63,35,4,3,23};
        int[] B = null;

        long startTime = System.currentTimeMillis();
        
        //基数排序
        B = RadixSort(A);

        long endTime = System.currentTimeMillis();

        for (int i =0;i < B.length;i++) {
            System.out.print(B[i] + ",");
        }
        System.out.println("用时: "+ (endTime-startTime) +"毫秒");
        System.out.println(" ");
```




#参考：

https://visualgo.net/en（全部的数据结构动图）

https://blog.csdn.net/hellozhxy/article/details/79911867
https://blog.csdn.net/weixin_38594819/article/details/79234174
https://zhuanlan.zhihu.com/p/53346876
https://zhuanlan.zhihu.com/p/34202846

快速排序：
https://blog.csdn.net/hrn1216/article/details/51526362
https://blog.csdn.net/nrsc272420199/article/details/82587933
https://www.cnblogs.com/xfcode/p/11490516.html

堆排序：
https://blog.csdn.net/u010452388/article/details/81283998
https://blog.csdn.net/u013384984/article/details/79496052
https://www.cnblogs.com/0zcl/p/6737944.html




计数排序：
https://www.cnblogs.com/protected/p/6603536.html



桶排序：
https://blog.csdn.net/zgcqflqinhao/article/details/83316453
https://www.cnblogs.com/protected/p/6603536.html


基数排序：
https://www.jianshu.com/p/47170b1ced23
https://www.cnblogs.com/protected/p/6603536.html
	2019-01-23 12:06:15
kumika	算法设计与分析	# 算法设计与分析

贪心算法
分治思想
动态规划



#参考：

https://blog.csdn.net/wenhui12345/article/details/80326500
	2019-01-30 12:13:05
kumika	工作	# 工作


很多人从大学毕业之后，开始在社会上拼搏时就会遇到一个问题：找到工作之后，发现自己不会工作。从校园到社会，中间好像有一道非常大的坎，我们怎么也跨不过去。甚至有些工作很多年的人，也过不去。
那这道坎是什么？是协作。
半年前我还在是一名普通本科应届生，那时候每天的日子要过的有多潇洒就有多潇洒。昨晚视频看多了，今早爬不起来，那就不去上课。这节课老师布置了很多作业，在要上交的最后一小时，找宿舍学霸抄就完事。每天想着最多的等等吃什么，晚上玩什么，周末约哪个妹子。无忧无虑，天天都在度假。
在学校虽然说我们主要的任务就是学习，而学习是一个把知识装进自己脑袋的过程，主要靠自己。况且到了大学很多人，玩的天性被彻底释放，脑子里就没有学习这个词，每天就玩。而玩也是已个体为出发点，约不到朋友一起玩，那我就自己玩游戏，自己耍手机，自己玩自己。协作就没有那么重要。
而且学校里一般不会教大家如何协作。但在工作环境中，协作就变得异常重要。比如像我是一名爬虫师，我不单单是要把爬虫程序写好，还要和后台的哥们定好数据格式，和算法组讨论好接口，写代码只是工作中的一部分，更多的时间是与各组的同事进行沟通。
在我工作的这半年里，我也犯过很多错误。

1 不靠谱
很多人对于「靠谱」的理解是：把事情做好，老板要满意。但像我这样才出社会，各方面能力和认知都还非常差的时候，对于一个需求，我是做不到让老板满意的程度。在工作中的靠谱，我们应该理解成：“凡事有交代，件件有着落，事事有回音。”
怎么理解这句话？
比如说我在最开始接触公司项目的时候，老板就给了我一个任务，由于网站改版了，叫我把这个网站的解析函数写好，然后再给一个预计完成时间。我那时候能力还非常弱，做事并不是很快，到了预定的时间我还是没有完成。那时候老板也忙，没有空管我们这组。我也没有及时跟老板汇报当前的进展，这就是不靠谱的行为。
靠谱不需要你有多大的能力，但是要能让你的协作伙伴，知道你的能力边界和行动进度，这才是叫靠谱。做到这一点，你才是一个合格的职场人。
而我在最开始工作的时候，完全就不是一个靠谱的人。后来我逐渐意识到这点，我现在每做完一件事或者发现某个程序问题，就会第一时间跟上级汇报，即使这个问题有可能是由于自己过错而导致的。

2 不适应新的环境
很多人习惯了大学里舒适的生活，想做什么就做什么，一点顾虑都没有。这个同学看不惯，大不了我不和他说话就是了。但在实际的工作中，协作的对象不仅仅是同事，还有供应商、资源方、用户、技术、媒体、政府等等。这些因素和你大学里的同学就不一样了，具有非常大的不确定性。
你不可能也不能够再像大学里一样，对于自己感到不适的事物，选择避而远之就是了。在工作中你有可能遇到技术突然奔溃、代码全部没掉、被愤怒的客户投诉、被老板破口大骂等等。面对这些情况，你能从容应对吗？
如果你现在还是一名大学生，如果你现在还是每天只懂吃喝玩乐，如果你现在每天还是过着舒适的生活。那你就需要认真的思考下，你有能力面对各种突发情况吗？
比如你是一个客服，用户打电话暴怒地骂你，你得能知道，这不是骂你的个人角色，而是在指责你公司的服务或者是产品。所以你就用你的职业角色平和应对，而不是用个人角色觉得对方怎么素质这么差，干脆跟他对骂。做到职业化，实际上，你就把自己的“价值输出”稳定下来了。
如果对于上所的情况，你都能从容应对，恭喜你，你具备了适应性，你拥有了自己的职业化能力，能把自己的职业角色和个人角色区别开来。能够以不变应万变，尽人事，听天命。

大家一直说，你只有有能力，不愁没有工作。但具体是指哪些能力？
1 靠谱的能力
2 职业化的能力
3 让合作者放心的能力
4 组织战役的能力
5 着眼未来协同资源的能力
6 吸引合作的能力

今天的文章所说的两点问题可以归纳为：靠谱的能力和职业化的能力。我自身也还在不断的修行中，对于后面四点能力，暂时无法触及。



	2019-02-03 14:45:14
kumika	HTTP协议	# HTTP协议

Http是一种Transfer（传输）协议。
在一次传输中，重要的过程包括：
**传输的建立、
请求的发起、
响应的回传。**
所以深入学习这三个过程就是关键所在。


看图解HTTP的 1  2  3  5  6

HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。












====================================================
# HTTP与TCP的区别总结：

HTTP是应用层协议，定义的是传输数据的内容的规范
HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP ；


TCP是底层通讯协议，定义的是数据传输和连接方式的规范
TCP/IP是协议，是Internet国际互联网络的基础，是网络中使用的基本的通信协议。


TCP/IP实际上是一组协议，它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整传输的两个基本的重要协议。通常说TCP/IP是Internet协议族，而不单单是TCP和IP。


#参考：
http://www.ruanyifeng.com/blog/2016/08/http.html


TCP/IP协议：
https://www.cnblogs.com/fengzanfeng/articles/1339347.html



HTTP和TCP的区别：
https://blog.csdn.net/chenqiurui1994/article/details/80040125
https://blog.csdn.net/u013485792/article/details/52100533


	2019-02-06 21:15:48
kumika	互联网协议入门 1	# 互联网协议入门 1 

##五层模型

互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。
**tcp/ip是四层，osi七层 ，这里是非主流的科普类型的5层**

**3个划分层次的区别：**
[![20180802094638614.png](https://i.loli.net/2019/02/08/5c5d25198ee2c.png)](https://i.loli.net/2019/02/08/5c5d25198ee2c.png)


用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。

如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。

[![bg2012052902.png](https://i.loli.net/2019/02/07/5c5b95eb037b2.png)](https://i.loli.net/2019/02/07/5c5b95eb037b2.png)

最底下的一层叫做"实体层"（Physical Layer），最上面的一层叫做"应用层"（Application Layer），中间的三层（自下而上）分别是"链接层"（Link Layer）、"网络层"（Network Layer）和"传输层"（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户




##层与协议

每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。

大家都遵守的规则，就叫做"协议"（protocol）。

互联网的每一层，都定义了很多协议。这些协议的总称，就叫做"互联网协议"（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。




# 1 物理层

最底下的一层开始

把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。

**这就叫做"实体层"，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号**。



# 2 链路层

## 定义

单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？

**这就是"链接层"的功能，它在"实体层"的上方，确定了0和1的分组方式。**

## 以太网协议

早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做"以太网"（Ethernet）的协议，占据了主导地位。

以太网规定，一组电信号构成一个数据包，叫做"帧"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。


[![bg2012052904.png](https://i.loli.net/2019/02/07/5c5b98e0588c3.png)](https://i.loli.net/2019/02/07/5c5b98e0588c3.png)


**"标头"**包含数据包的一些说明项，比如发送者、接受者、数据类型等等；
**"数据"**则是数据包的具体内容。

"标头"的长度，固定为18字节。
"数据"的长度，最短为46字节，最长为1500字节。

因此，整个"帧"最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。

----------------------------------------------------
**另外一种的描述**

head包含：（固定18个字节）

    发送者（源地址，6个字节）
    接收者（目标地址，6个字节）
    数据类型（6个字节）

data包含：（最短46字节，最长1500字节）

数据包的具体内容
head长度+data长度=最短64字节，最长1518字节，超过最大限制就分片发送。

## MAC地址

以太网数据包的"标头"，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？


以太网规定，连入网络的所有设备，都必须具有**"网卡"**接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。

[![bg2012052905.jpg](https://i.loli.net/2019/02/07/5c5b9a6853255.jpg)](https://i.loli.net/2019/02/07/5c5b9a6853255.jpg)

每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。

[![bg2012052906.png](https://i.loli.net/2019/02/07/5c5b9adb41a7b.png)](https://i.loli.net/2019/02/07/5c5b9adb41a7b.png)
[![20180802111038690.png](https://i.loli.net/2019/02/08/5c5d46cd4b33b.png)](https://i.loli.net/2019/02/08/5c5d46cd4b33b.png)
前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。


## 广播

定义地址只是第一步，后面还有更多的步骤。

首先，一块网卡怎么会知道另一块网卡的MAC地址？

回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，**以太网数据包必须知道接收方的MAC地址，然后才能发送。**


其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？

回答是以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。

[![bg2012052907.png](https://i.loli.net/2019/02/07/5c5b9b6562e81.png)](https://i.loli.net/2019/02/07/5c5b9b6562e81.png)


上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机**都会收到这个包。**
它们读取这个包的"标头"，找到接收方的MAC地址，然后与自身的MAC地址相比较，**如果两者相同，就接受这个包**，做进一步处理，**否则就丢弃这个包**。
这种发送方式就叫做"广播"（broadcasting）。

有了数据包的定义、网卡的MAC地址、广播的发送方式，"链接层"就可以在多台计算机之间传送数据了。



# 3 网络层


## 网络层的由来

互联网要是使用MAC地址发生数据，技术上可以实现，但是数据安全性就不高了，每一个人都可以接收到数据。

互联网是无数子网络共同组成的一个巨型网络，很难想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。


因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。**如果是同一个子网络，就采用广播方式发送，否则就采用"路由"方式发送。**（"路由"的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）

遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。

**这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做"网络地址"，简称"网址"。**

-----------------------------------------------------

"网络层"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。
**两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起**。

网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是**先处理网络地址，然后再处理MAC地址**。


## IP协议

规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。

目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。

[![bg2012052908.png](https://i.loli.net/2019/02/07/5c5ba62cf4236.png)](https://i.loli.net/2019/02/07/5c5ba62cf4236.png)

习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。

互联网上的每一台计算机，都会分配到一个IP地址。
这个地址分成两个部分，前一部分代表网络，后一部分代表主机。
比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。


但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。

那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？**这就要用到另一个参数"子网掩码"（subnet mask）。**

**所谓"子网掩码"，就是表示子网络特征的一个参数。**它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。

知道"子网掩码"，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。


比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？**两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。**

总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。

--------------------------------------------------------

个人理解子网掩码：
**就像是一个过滤筛子，2个地址能通过这个筛子，则说明2个地址是同一个子网。**
所谓“掩码”，就是掩去主机部分，保留网络部分


## IP数据包

根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。

但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？

回答是不需要，我们可以把IP数据包直接放进以太网数据包的"数据"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。

具体来说，IP数据包也分为"标头"和"数据"两个部分。

[![bg2012052909.png](https://i.loli.net/2019/02/07/5c5be76d83610.png)](https://i.loli.net/2019/02/07/5c5be76d83610.png)

"标头"部分主要包括版本、长度、IP地址等信息，"数据"部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。


[![bg2012052910.png](https://i.loli.net/2019/02/07/5c5be76d85332.png)](https://i.loli.net/2019/02/07/5c5be76d85332.png)

IP数据包的"标头"部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的"数据"部分，最长为65,515字节。前面说过，以太网数据包的"数据"部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。



## ARP协议

关于"网络层"，还有最后一点需要说明。

因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。
所以，我们需要一种机制，能够从IP地址得到MAC地址。
这里又可以分成两种情况。

**第一种情况：**
如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的"网关"（gateway），让网关去处理。

怎么处理的呢？

首先，通过IP地址区分，计算机运算判断出目标IP不在同一个子网络，目标IP就替换成了网关的IP了。网关的IP在计算机上配死了，可以轻松获取。
[![20180802145027656.png](https://i.loli.net/2019/02/08/5c5d4a67ce8b9.png)](https://i.loli.net/2019/02/08/5c5d4a67ce8b9.png)
**目标IP被替换：**
[![20180802153427356.png](https://i.loli.net/2019/02/08/5c5d4a77f0d75.png)](https://i.loli.net/2019/02/08/5c5d4a77f0d75.png)

这样网关就会把它的Mac地址返回给你，然后正常发包
[![20180802154017799.png](https://i.loli.net/2019/02/08/5c5d4acd88025.png)](https://i.loli.net/2019/02/08/5c5d4acd88025.png)
网关帮你去找飞哥，但对用户来说，我们根本就感觉不到网关的存在。

**第二种情况：**

如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。
ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个"广播"地址。
它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。

--------------------------------------------
个人理解：
ARP协议发出数据包，在查询对方的MAC地址这个字段栏中，填写的是FF，表示我不知道对方的MAC地址

总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。



# 4 传输层

## 传输层的由来

有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。

接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？

也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做"端口"（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。

"端口"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。

---------------------------------------------------------
**"传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。**
因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了。


## UDP协议

现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。

UDP数据包，也是由"标头"和"数据"两部分组成。

[![bg2012052911.png](https://i.loli.net/2019/02/07/5c5bf4ad062c9.png)](https://i.loli.net/2019/02/07/5c5bf4ad062c9.png)


"标头"部分主要定义了发出端口和接收端口，"数据"部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的"数据"部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：

[![bg2012052912.png](https://i.loli.net/2019/02/07/5c5bf4dfb1d58.png)](https://i.loli.net/2019/02/07/5c5bf4dfb1d58.png)


|以太网头|ip头|udp头|数据| 
| ----- | ----- | ------ |

UDP数据包非常简单，"标头"部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。


## TCP协议

UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。

为了解决这个问题，提高网络可靠性，**TCP协议**就诞生了。**这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。**

因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。

TCP数据包和UDP数据包一样，都是内嵌在IP数据包的"数据"部分。


|以太网头|ip头|tcp头|数据| 
|----|----|


TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。


# 5 应用层

应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。

**"应用层"的作用，就是规定应用程序的数据格式。**

举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。

这是最高的一层，直接面对用户。它的数据就放在TCP数据包的"数据"部分。因此，现在的以太网的数据包就变成下面这样。

[![bg2012052913.png](https://i.loli.net/2019/02/07/5c5bf5dca0770.png)](https://i.loli.net/2019/02/07/5c5bf5dca0770.png)


# 参考：
阮一峰：
http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html
http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html



TCP/IP：
http://microchipdeveloper.com/tcpip:detailed-tcpip-communication


DHCP在的层数：
https://www.zhihu.com/question/23337642
https://www.cnblogs.com/wajika/p/6537085.html


OSI的7层：
https://blog.csdn.net/taotongning/article/details/81352985
https://blog.csdn.net/zhangyi_1027/article/details/80022493

[![1099668-20170212153338135-125492424.jpg](https://i.loli.net/2019/02/08/5c5d4d45588f4.jpg)](https://i.loli.net/2019/02/08/5c5d4d45588f4.jpg)





	2019-02-07 10:16:30
kumika	互联网协议入门 2	# 互联网协议入门 2


对 入门1 的小结：

我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：

[![bg2012052913.png](https://i.loli.net/2019/02/07/5c5bf5dca0770.png)](https://i.loli.net/2019/02/07/5c5bf5dca0770.png)


发送这个包，需要知道两个地址：

    对方的MAC地址
    
    对方的IP地址


有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。

[![bg2012061101.jpg](https://i.loli.net/2019/02/07/5c5bf8f93b4f7.jpg)](https://i.loli.net/2019/02/07/5c5bf8f93b4f7.jpg)

上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），
于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。


1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：


| 场景| 数据包地址 |
| ----- | ----- | ----- |
| 同一个子网络| 对方的MAC地址，对方的IP地址|
| 非同一个子网络| 网关的MAC地址，对方的IP地址 |


发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。



# 1 用户的上网设置

## 静态IP地址

你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？

通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：


    本机的IP地址
    子网掩码
    网关的IP地址
    DNS的IP地址

下图是Windows系统的设置窗口。

[![bg2012061111.png](https://i.loli.net/2019/02/07/5c5bfc9ee73dc.png)](https://i.loli.net/2019/02/07/5c5bfc9ee73dc.png)

**自己的WIN10配置：**
[![神奇2.png](https://i.loli.net/2019/02/07/5c5bfc9f11b36.png)](https://i.loli.net/2019/02/07/5c5bfc9f11b36.png)
[![租期3.png](https://i.loli.net/2019/02/07/5c5bfc9f140d6.png)](https://i.loli.net/2019/02/07/5c5bfc9f140d6.png)

这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作"静态IP地址上网"。

但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用"动态IP地址上网"。


## 动态IP地址

所谓"动态IP地址"，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做**DHCP协议**。


这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做"DHCP服务器"。

新的计算机加入网络，必须向"DHCP服务器"发送一个"DHCP请求"数据包，申请IP地址和相关的网络参数。

前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？

DHCP协议做了一些巧妙的规定。


## DHCP协议

首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：

[![bg2012052913.png](https://i.loli.net/2019/02/07/5c5bf5dca0770.png)](https://i.loli.net/2019/02/07/5c5bf5dca0770.png)

（1）最前面的"以太网标头"，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。


（2）后面的"IP标头"，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。


（3）最后的"UDP标头"，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。


这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道"这个包是发给我的"，而其他计算机就可以丢弃这个包。

接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个"DHCP响应"数据包。这个响应包的结构也是类似的，**以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方）**，UDP标头的端口是67（发出方）和68（接收方），**分配给请求端的IP地址和本网络的具体参数则包含在Data部分**。

新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。


## 上网设置：小结

这个部分，需要记住的就是一点：不管是"静态IP地址"还是"动态IP地址"，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：

        * 本机的IP地址
    　　* 子网掩码
    　　* 网关的IP地址
    　　* DNS的IP地址


# 实例：访问网页

## 本机参数

假设用户设置好了自己的网络参数：

　　* 本机的IP地址：192.168.1.100
　　* 子网掩码：255.255.255.0
　　* 网关的IP地址：192.168.1.1
　　* DNS的IP地址：8.8.8.8

然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。

这意味着，浏览器要向Google发送一个网页请求的数据包。


##  DNS协议


我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。


**DNS协议**可以帮助我们，**将这个网址转换成IP地址**。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。

[![bg2012052913.png](https://i.loli.net/2019/02/07/5c5bf5dca0770.png)](https://i.loli.net/2019/02/07/5c5bf5dca0770.png)

然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。


## 子网掩码

接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。

已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；
然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。
这两个结果不相等，所以结论是，Google与本机不在同一个子网络。

因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。


## 应用层协议

浏览网页用的是HTTP协议，它的整个数据包构造是这样的

[![bg2012061106.png](https://i.loli.net/2019/02/07/5c5c02888c1ea.png)](https://i.loli.net/2019/02/07/5c5c02888c1ea.png)

HTTP部分的内容，类似于下面这样：

    GET / HTTP/1.1
    Host: www.google.com
    Connection: keep-alive
    User-Agent: Mozilla/5.0 (Windows NT 6.1) ......
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Encoding: gzip,deflate,sdch
    Accept-Language: zh-CN,zh;q=0.8
    Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3
    Cookie: ... ...

我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。


## TCP协议

TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。

TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。

-----------------------------------------------------
个人理解：
TCP的4次握手没有讲，是科普文。

## IP协议

然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。

IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。



## 以太网协议

最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。

发送到192.168.1.1，网关应该还会拆开包，根据子网掩码与操作发现不是在一个内网内，那么将会重新把这个包封装一下，接收方的为它的网关的MAC地址，就这样一层一层往上面找，最终到一个网关，网关根据子网掩码发现172.194.72.105（Google）和自己在一个内网内，然后将请求发给172.194.72.105（Google），这样就到达了目的地

以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。

[![bg2012061107.png](https://i.loli.net/2019/02/07/5c5c0409d53ee.png)](https://i.loli.net/2019/02/07/5c5c0409d53ee.png)

1. IP数据包长度为5000字节 ＝ 20字节IP标头 ＋ 4980字节的IP数据。
2. 由于以太数据区最长为1500字节，然后拆分如下：
①20字节IP标头+1480字节的IP数据=1500
②20字节IP标头+1480字节的IP数据=1500
③20字节IP标头+1480字节的IP数据=1500
④20字节IP标头+540字节的IP数据=560

## 服务器端响应

经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。

根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的"HTTP请求"，接着做出"HTTP响应"，再用TCP协议发回来。

本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。

这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。







# 参考：
阮一峰：
http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html
http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html


http://www.notedeep.com/note/36/page/280
	2019-02-07 17:18:24
kumika	TCP/IP 的DNS协议	"# TCP/IP 的DNS协议

如果说ARP协议是用来将IP地址转换为MAC地址，
那么DNS协议则是用来将域名转换为IP地址（也可以将IP地址转换为相应的域名地址）。


TCP/IP中使用的是IP地址和端口号来确定网络上某一台主机上的某一个程序，不免有人有疑问，为什么不用域名来直接进行通信呢？ 

    1. 因为IP地址是固定长度的，IPv4是32位，IPv6是128位，而域名是变长的，不便于计算机处理。 
    2. IP地址对于用户来说不方便记忆，但域名便于用户使用，例如www.baidu.com这是百度的域名。

总结一点就是**IP地址是面向主机的**，而**域名则是面向用户的**。



## hosts文件 

域名和IP的对应关系保存在一个叫hosts文件中。 
最初，通过互联网信息中心来管理这个文件，如果有一个新的计算机想接入网络，或者某个计算IP变更都需要到信息中心申请变更hosts文件。其他计算机也需要定期更新，才能上网。 
但是这样太麻烦了，就出现了DNS系统。



## DNS系统


1. 一个组织的系统管理机构, 维护系统内的每个主机的IP和主机名的对应关系
2. 如果新计算机接入网络，将这个信息注册到数据库中
3. 用户输入域名的时候，会自动查询DNS服务器，由DNS服务器检索数据库，得到对应的IP地址。

---------------------------------------------------------
我们可以通过命令查看自己的hosts文件。

Windows用户查看Hosts文件：

hosts文件，路径是固定的，存储路径：
`c:\windows\system32\drivers\etc\hosts`

Host文件的内容
[![NDS.jpg](https://i.loli.net/2019/02/09/5c5ec17ec8a2c.jpg)](https://i.loli.net/2019/02/09/5c5ec17ec8a2c.jpg)



## DNS域名结构
域名系统必须要保持唯一性。
**域名服务主要是基于UDP实现的**，服务器的端口号为53。 
关于域名的层次结构，如下图所示： 

[![20180529182740527.png](https://i.loli.net/2019/02/15/5c661d6816f88.png)](https://i.loli.net/2019/02/15/5c661d6816f88.png)

eg :我们熟悉的，www.baidu.com 
1. com: 顶级（一级）域名. 表示这是一个企业域名。同级的还有 “net”(网络提供商), “org”(⾮非盈利组织) 等。 
2. baidu: 二级域名，指公司名。 
3. www: 只是一种习惯用法。

个人理解：
www.baidu.com的子域是
www.pan.baidu.com,
www.1231.baidu.com
后面的是一级，从后到前看

|国家顶级域名|	中国:cn， 美国:us，英国uk…|
|----|-----|
 | 通用顶级域名|	com公司企业，edu教育机构，gov政府部门，int国际组织，mil军事部门 ，net网络，org非盈利组织…|



域名服务器
-----

域名是分层结构，域名服务器也是对应的层级结构。 
有了域名结构，还需要有一个东西去解析域名，域名需要由遍及全世界的域名服务器去解析，域名服务器实际上就是装有域名系统的主机。

由高向低进行层次划分，可分为以下几大类：


|分类	|作用|
|----|-----|
|根域名服务器|	最高层次的域名服务器，本地域名服务器解析不了的域名就会向其求助|
|顶级域名服务器| 负责管理在该顶级域名服务器下注册的二级域名|
|权限域名服务器|	负责一个区的域名解析工作|
|本地域名服务器	|当一个主机发出DNS查询请求时，这个查询请求首先发给本地域名服务器|
注：一个域名服务器所负责的范围，或者说有管理权限的范围，就称为区 
我们需要注意的是： 
1. 每个层的域名上都有自己的域名服务器，最顶层的是根域名服务器 
2. 每一级域名服务器都知道下级域名服务器的IP地址 
3. 为了容灾, 每一级至少设置两个或以上的域名服务器



## DNS的解析过程

1.在浏览器中输入www.qq.com域名，**操作系统会先检查自己本地的hosts文件**是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。

2.如果hosts里没有这个域名的映射，则**查找本地DNS解析器缓存**，是否有这个网址映射关系，如果有，直接返回，完成域名解析。


3.如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它**本地DNS服务器**，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。


4.如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此**网址映射关系**，则调用这个IP地址映射，完成**域名解析**，此解析不具有权威性。


5.如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置**（是否设置转发器）**进行查询，如果未用转发模式，本地DNS就把请求发至 **“根DNS服务器”**，**“根DNS服务器”**收到请求后会判断这个域名(.com)是谁来授权管理，并会**返回一个负责该顶级域名服务器的一个IP**。**本地DNS服务器**收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，**重复上面的动作**，进行查询，直至找到www.qq.com主机。

6.如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。

[![20140718112133000.png](https://i.loli.net/2019/02/15/5c6626ab3f97f.png)](https://i.loli.net/2019/02/15/5c6626ab3f97f.png)

[![1126944-20170315222838041-2095036367.jpg](https://i.loli.net/2019/02/15/5c662a622f683.jpg)](https://i.loli.net/2019/02/15/5c662a622f683.jpg)

##使用wireShaker解析

好多数据，暂时看不懂



# 参考：

https://www.cnblogs.com/perfy576/p/8667951.html
https://blog.csdn.net/baidu_37964071/article/details/80500825
https://blog.csdn.net/tianxuhong/article/details/74922454



递归与迭代查询的区别：
https://blog.csdn.net/yanbao4070/article/details/79892032
这2个区别在于回复客户的区别，递归是一问一答，准确的查询结果回复客户，迭代是不直接回复，查到再回复






"	2019-02-09 19:08:22
kumika	电商项目	# 电商项目



# 登陆
这次登陆是有security验证的

##前端API接口：
```
export function login(username, password) {
  return request({
    url: '/admin/login',
    method: 'post',
    data: {
      username,
      password
    }
  })
}
```

目的：

    SpringSecurity和JWT实现后台用户的登录和授权功能，同时改造Swagger-UI的配置使其可以自动记住登录令牌进行发送

JWT实现认证和授权的原理

用户调用登录接口，登录成功后获取到JWT的token；
之后用户每次调用接口都在http的header中添加一个叫Authorization的头，值为JWT的token；
后台程序通过对Authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权

描述JWT，画出JWT的组件，
描述SpringSecurity，画出springSecurity的组件
写流程

##后端

### UmsAdminController
```
    @ApiOperation(value = "登录以后返回token")
    @RequestMapping(value = "/login", method = RequestMethod.POST)
    @ResponseBody
    public Object login(@RequestBody UmsAdminLoginParam umsAdminLoginParam,BindingResult result) {
        String token = adminService.login(umsAdminLoginParam.getUsername(), umsAdminLoginParam.getPassword());

        if (token == null) {
            return new CommonResult().validateFailed("用户名或密码错误");
        }

        //返回令牌，放入Map中传输到前端
        Map<String, String> tokenMap = new HashMap<>();
        tokenMap.put("token", token);
        tokenMap.put("tokenHead", tokenHead);
        return new CommonResult().success(tokenMap);
    }
```

###servicerImpl
````
    @Override
    public String login(String username, String password) {
        //令牌
        String token = null;

        //密码需要客户端加密后传递，制作令牌
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(username, passwordEncoder.encodePassword(password, null));


        try {
            //security的证明接口authentication接口对象
            // 使用authenticationManager接口的验证方法，使得令牌成为证明接口（Authentication）的令牌
            Authentication authentication = authenticationManager.authenticate(authenticationToken);
            //获取security的上下文，设置认证（证明）对象
            SecurityContextHolder.getContext().setAuthentication(authentication);
            //用户信息接口对象UserDetails，使用接口userDetailService的方法，根据用户名锁定用户信息对象
            UserDetails userDetails = userDetailService.loadUserByUsername(username);
            //根据用户信息接口对象使用JWT工具，生成令牌
            token = jwtTokenUtil.generateToken(userDetails);
            //根据用户名修改登录时间
            updateLoginTimeByUsername(username);
            //添加登录记录
            insertLoginLog(username);
        } catch (AuthenticationException e) {
            LOGGER.warn("登陆异常：{}", e.getMessage());
        }

        return token;
    }
    
    
    
    /**
     * 根据用户名修改登录时间
     */
    private void updateLoginTimeByUsername(String username) {
        UmsAdmin record = new UmsAdmin();
        record.setLoginTime(new Date());
        UmsAdminExample example = new UmsAdminExample();
        example.createCriteria().andUsernameEqualTo(username);
        adminMapper.updateByExampleSelective(record, example);
    }

    /**
     * 添加登录记录
     * @param username
     */
    private void insertLoginLog(String username) {
        //获取管理员对象
        UmsAdmin admin = getAdminByUsername(username);
        UmsAdminLoginLog loginLog = new UmsAdminLoginLog();
        loginLog.setAdminId(admin.getId());
        loginLog.setCreateTime(new Date());
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        loginLog.setIp(request.getRemoteAddr());
        loginLogMapper.insert(loginLog);
    }
```
使用的都是springSecurity的接口方法，自动返回对象。




### JWT令牌工具
JwtTokenUtil是JwtToken生成的工具类
```
    private static final String CLAIM_KEY_USERNAME = "sub";

    private static final String CLAIM_KEY_CREATED = "created";
    
    
    /**
     * 根据用户信息生成token
     */
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());
        claims.put(CLAIM_KEY_CREATED, new Date());
        return generateToken(claims);
    }
    
    
    
    /**
     * 根据负责生成JWT的token
     */
    public String generateToken(Map<String, Object> claims) {
        return Jwts.builder()
                .setClaims(claims) // 自定义属性
                .setExpiration(generateExpirationDate())// 过期时间
                .signWith(SignatureAlgorithm.HS512, secret) // 签名算法以及密匙
                .compact();//紧密的，协议，可以看做builder.compact()
    }

    /**
     * 生成token的过期时间
     */
    private Date generateExpirationDate() {
        return new Date(System.currentTimeMillis() + expiration * 1000);
    }
```

#security的配置
```
     * 通过 {@link #authenticationManager()} 方法的默认实现尝试获取一个 {@link AuthenticationManager}.
     * 如果被复写, 应该使用{@link AuthenticationManagerBuilder} 来指定 {@link AuthenticationManager}.
     *
     * 例如, 可以使用以下配置在内存中进行注册公开内存的身份验证{@link UserDetailsService}:

//暂时使用基于内存的AuthenticationProvider
```

#开发难题
##难题1
在完全不知道使用什么技术工具的情况下，不知道配置什么文件
JWT  ，Spring security ， Swagger2API

答： 
直接看官方文件的例子。

#疑问

## 1 在AdminController中登陆方法

为什么这里要使用令牌?
```
        Map<String, String> tokenMap = new HashMap<>();
        tokenMap.put("token", token);
        tokenMap.put("tokenHead", tokenHead);
        return new CommonResult().success(tokenMap);
```

使用令牌是为了得到更多的用户信息





# 问题 2
在遇到问题的时候，大多直接看控制台出现的问题，然后穷举法，一个个排除，很慢，而且大多是框架的配置问题

比如这次的

很奇怪的类型转换错误
```
w.s.m.s.DefaultHandlerExceptionResolver : Failed to bind request element: org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.lang.Long'; nested exception is java.lang.NumberFormatException: For input string: "info"
```

出错是在GET 和POST的传输上问题，get传参是路径传参的，我写成了POST，导致路径上没有参数，post是把参数放入request里面进行传输的

引申下个问题，哪里进行调用这个info方法的？
前端的`SEV的SRC /API文件下的JS`，具体的前端网页调用就不是我们写的了

##具体的GET和POST区别
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

 

也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。

 

因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？

1. GET与POST都有自己的语义，不能随便混用。

2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

##参考：
https://blog.csdn.net/qq_24691413/article/details/83956755
get和post的区别：
https://www.cnblogs.com/logsharing/p/8448446.html

# 问题 3

shiro 和SpringSecurity区别


# 问题 4

令牌在这里的业务流程是怎么样的？

```
用户信息：com.macro.mall.config.SecurityConfig$$Lambda$9/1487879101@22a5cca
auth的userdetail信息：org.springframework.security.config.annotation.authentication.configurers.userdetails.DaoAuthenticationConfigurer@71139e77
password信息：org.springframework.security.config.annotation.authentication.configurers.userdetails.DaoAuthenticationConfigurer@4de91056
```

看源码。

UserDetailsService 接口：作用是在特定用户权限认证时，用于加载用户信息。 该接口只有一个方法，用于返回用户的信息：
`UserDetails loadUserByUsername(String username) throws UsernameNotFoundException`;
那么，它的框架里面默认的实现类有 `InMemoryUserDetailsManager`，`CachingUserDetailsService` 和 `JdbcDaoImpl`，一个用于从内存中拿到用户信息，一个用于从数据库中拿到用户信息。

我们自定义LightSwordUserDetailService实现了UserDetailsService接口，从我们自己定义的数据库表里面取得用户信息来认证鉴权

```
//AuthenticationManager使用我们的 lightSwordUserDetailService 来获取用户信息。认证鉴权信息的Bean，采用我们自定义的从数据库中获取用户信息的LightSwordUserDetailService类。
auth.userDetailsService(userDetailsService());

  @Override
  @Bean
  public UserDetailsService userDetailsService() { //覆盖写userDetailsService方法，具体的LightSwordUserDetailService实现类
        return new LightSwordUserDetailService();

    }
```

自定义LightSwordUserDetailService
从数据库中获取用户信息的操作是必不可少的，我们首先来实现UserDetailsService，这个接口需要我们实现一个方法：loadUserByUsername。即从数据库中取出用户名、密码以及权限相关的信息。最后返回一个UserDetails 实现类。

config类上重写
`userDetailsService()`方法是拿到一个
`LightSwordUserDetailService`的Bean，就是`LightSwordUserDetailService`类
这个`LightSwordUserDetailService`类返回的用户对象具有用户详细信息的属性（数据库查询用户返回信息数据）。
具体过程就是根据用户名，密码查询然后返回用户对象，
再根据id查询权限，
接着就是把权限和用户进行关联在一起，
最后返回这个权限和用户信息结合在一起的对象







学习工具，查看关键实现的功能的数据传输过程
 清楚整个流程的过程


# 问题 5 
 spring Security的基本配置
 
 
 
 
 POM.xml
```
 <dependency>
    <groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-security</artifactId>
</dependency>
```
 
1   Controler ---login方法

2   Service实现类里面调用
 
    userDetailsService.loadUserByUsername(username);

3   securityConfig

```
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/", "/home").permitAll()
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .loginPage("/login")
                .permitAll()
                .and()
            .logout()
                .permitAll();
    }

    @Bean
    @Override
    public UserDetailsService userDetailsService() {
        UserDetails user =
             User.withDefaultPasswordEncoder()
                .username("user")
                .password("password")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user);
    }
}
```
configure(HttpSecurity)方法定义了哪些URL路径应该被保护，哪些不应该被保护。

userDetailsService()方法，设置一个存储在内存中的用户，并使用单个用户。该用户被赋予“user”的用户名，“password”的密码，以及“USER”的角色。

总结为一句话：Spring Security提供了一个过滤器，可以拦截该请求并对用户进行身份验证。

4 路由控制类：MvcConfig.java
```
@Configuration
public class MvcConfig implements WebMvcConfigurer {

    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/home").setViewName("home");
        registry.addViewController("/").setViewName("home");
        registry.addViewController("/hello").setViewName("hello");
        registry.addViewController("/login").setViewName("login");
    }
```
以前的路由控制是直接在方法上面加注解指定路由，现在是统一在一个类中，有点类似于struts了，不过这也方便管理，addViewControllers()方法(在WebMvcConfigurer中覆盖相同名称的方法)添加了四个视图控制器。两个视图控制器引用名称为“home”的视图(在home.html中定义)，另一个引用名为“hello”的视图(在hello.html中定义)。第四个视图控制器引用另一个名为“login”的视图。这样的设置是没有验证的，直接跳转，而无需登录。


# 问题 6

config和`authenticationManager.authenticate(authenticationToken)`方法之间的关联是什么？

不知道。


# 问题 7

config（）中方法里的参数：AuthenticationManagerBuilder 类对象
来源？以及它的几个方法的意思？

方法


方法 4 :
使用userDetailsService()方法传入一个userDetailsService来实现自定义的身份验证。
```

//根据传入的自定义UserDetailsService添加身份验证。然后返回DaoAuthenticationConfigurer以允许自定义身份验证。
//此方法还确保UserDetailsService可用于getDefaultUserDetailsService（）方法。 请注意，其他UserDetailsService可能会覆盖此UserDetailsService作为默认值。
public <T extends UserDetailsService> DaoAuthenticationConfigurer<AuthenticationManagerBuilder, T> userDetailsService(
      T userDetailsService) throws Exception {
   this.defaultUserDetailsService = userDetailsService;
   return apply(new DaoAuthenticationConfigurer<>(
         userDetailsService));
}
```


#参考：

 springBoot和springsecurity结合
 ======================
https://blog.csdn.net/change_on/article/details/79521488
https://spring.io/guides/gs/securing-web/


从config的UserDetailsService（）的方法进入
跳到

DaoAuthenticationProvider类的方法
-----------------------------

```
UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication){
    UserDetails loadedUser;
    loadedUser = this.getUserDetailsService().loadUserByUsername(username);
    return loadedUser;
}
```
返回loadeUser，跳到

abstractUserDetailsAuthenticationProvider类的方法
---------------------------------------------

```
Authentication authenticate(Authentication authentication){
    ···
    private UserCache userCache = new NullUserCache();
    ···
    //如果从缓存中没有获取到UserDetails，那么它调用retrieveUser方法来获取用户信息UserDetails
    UserDetails user = this.userCache.getUserFromCache(username);
}
user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);
    ···
    //preAuthenticationChecks预检查,它的的内部类DefaultPreAuthenticationChecks中可以看到，它会检查上面提到的三个boolean方法，即检查账户未锁定、账户可用、账户未过期，如果上面的方法只要有一个返回false，就会抛出异常，那么认证就会失败。
     this.preAuthenticationChecks.check(user);
     //附加检查，是个抽象方法
     this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);
    ···
    this.postAuthenticationChecks.check(user);
    
    if (!cacheWasUsed) {
            this.userCache.putUserInCache(user);
        }
    Object principalToReturn = user;
    return this.createSuccessAuthentication(principalToReturn, authentication, user);
```

返回，跳到

ProviderManager类的方法
-------------------

```
Authentication authenticate(Authentication authentication){
    ···
    Authentication result = null;
    Iterator var6 = this.getProviders().iterator();
    ···
    AuthenticationProvider provider = (AuthenticationProvider)var6.next();
    //authenticate认证方法
    result = provider.authenticate(authentication);
    if (result != null) {
        this.copyDetails(authentication, result);
        break;
      }
    ···
    if (this.eraseCredentialsAfterAuthentication && result instanceof CredentialsContainer) {
    ((CredentialsContainer)result).eraseCredentials();
    }

    this.eventPublisher.publishAuthenticationSuccess(result);
    return result;
}
```
最后返回，跳回serviceIMPL，完成使得令牌成为证明接口（Authentication）的令牌（创建令牌）的过程。


流程图：
[![spring-securityx.png](https://i.loli.net/2019/04/27/5cc3d0ae9ee12.png)](https://i.loli.net/2019/04/27/5cc3d0ae9ee12.png)


看文章，然后和自己的对照一遍，然后自己写出流程

关键的点在于说出数据在哪个地方转换成了什么（只是在于包装成一个什么对象，Java里是没有创建的）

关键点：未认证----认证，这个过程中需要什么？
        
答：
过程需要参数用户名，查询账户里的内容：检查账户未锁定、账户可用、账户未过期，密码未过期。
然后工具自动查询这前3个方面的内容，只要有一样是false，就会认证未通过。
密码未过期就附加的工具自动查询判断



重点是学习这个工具是需要到什么程度
答： 程度是能顺利通过编译，能用就行

知道是怎么样的认证过程，认证条件

答: 认证的核心概念----对照用户信息。
    所以这里看的就是源码 的 对照的方法，过程（工具大部分都会自动封装好信息，然后只需要你提供参数就可以了），条件。


#参考文章：

https://blog.csdn.net/abcwanglinyong/article/details/80981389
https://blog.csdn.net/shenchaohao12321/article/details/87721655


	2019-02-16 10:48:20
kumika	电商项目--2	"# 电商项目--2

快速写完这个，就看面试和算法吧

注册，登陆 上传，下载， 
商品管理，订单管理，促销管理，内容管理，用户管理


注册项目没用到，所以自己有想法和概念


#商品
商品的数据库表格：
[![](https://ae01.alicdn.com/kf/H5f4193839d4746bc805a9c13dd46ef5ar.jpg)](https://ae01.alicdn.com/kf/H5f4193839d4746bc805a9c13dd46ef5ar.jpg)

[![](https://cy-pic.kuaizhan.com/g3/5a/81/ff0f-f2fb-4446-a22c-d518a76255a709)](https://cy-pic.kuaizhan.com/g3/5a/81/ff0f-f2fb-4446-a22c-d518a76255a709)

#商品列表


##查询全部的商品
就是分页查询商品列表

要求：
点击链接，跳转后自动查询商品列表，分页的。
输入参数：商品对象属性参数 ，当前页码数，页数


前端请求：

在index.vue上
```
  import {
    fetchList,
    updateDeleteStatus,
    updateNewStatus,
    updateRecommendStatus,
    updatePublishStatus
  } from '@/api/product'
```

在API的product上
```
export function fetchList(params) {
  return request({
    url:'/product/list',
    method:'get',
    params:params
  })
}
```

前端要传输的数据参数（就是前后端相互沟通好的参数，而且是默认值）：
```
  const defaultListQuery = {
    keyword: null,
    pageNum: 1,
    pageSize: 5,
    publishStatus: null,
    verifyStatus: null,
    productSn: null,
    productCategoryId: null,
    brandId: null
  };
```
参数赋值：
defaultListQuery赋值给listQuery
```
 listQuery: Object.assign({}, defaultListQuery),
 //一大串代码
  fetchList(this.listQuery).then(response => {····
 
```


后端代码：

PmsProductController：

参数：
**productQueryParam,  pageSize,  pageNum**
  
```
@ApiOperation("查询商品")
@RequestMapping(value = "/list", method = RequestMethod.GET)
@ResponseBody
//限制查询，只能查询拥有权限的read部分，这是Spring Security的注解
@PreAuthorize("hasAuthority('pms:product:read')")
 public Object getlist(PmsProductQueryParam productQueryParam,
                    @RequestParam(value = "pageSize",defaultValue = "5") Integer pageSize,
                    @RequestParam(value = "pageNum",defaultValue = "1") Integer pageNum) {
        List<PmsProduct> productList = productService.list(productQueryParam, pageSize, pageNum);
        return new CommonResult().pageSuccess(productList);
    }
```
其中参数productQueryParam是自己根据客户需求创建的产品参数：（就是前后端相互沟通好的参数）
```
import io.swagger.annotations.ApiModelProperty;
public class PmsProductQueryParam {

    @ApiModelProperty("上架状态")
    private Integer publishStatus;

    @ApiModelProperty("审核状态")
    private Integer verifyStatus;

    @ApiModelProperty("商品名称模糊关键字")
    private String keyword;

    @ApiModelProperty("商品货号")
    private String productSn;

    @ApiModelProperty("商品分类编号")
    private Long productCategoryId;

    @ApiModelProperty("商品品牌编号")
    private Long brandId;
    
    //getting 和setting
```


Service：
客户需求：  点击连接，完成查询全部商品，得到全部商品的信息
输入参数： 上架状态publishStatus，审核状态verifyStatus，关键字keyword，商品货号productSn，商品分类编号productCategoryId，商品品牌编号brandId
exmaple： 查询的是商品对象，所以使用PmsProductExample,同时又条件要求： 6个参数条件要求，所以example也要增加条件语句criteria，增加那和参数名一致的方法，
比如上架状态publishStatus就使用andPublishStatusEqualTo方法，审核状态verifyStatus使用andVerifyStatusEqualTo，
关键字keyword使用andNameLike（“%”+keyword+“%”）方法，
商品货号productSn使用andProductSnEqualTo，
商品分类编号productCategoryId使用andBrandIdEqualTo方法，
商品品牌编号brandId使用andProductCategoryIdEqualTo，
记得这些方法都是需要上面的输入参数的，这里没有写参数而已。

完整代码:
```
    /**
     * 分页查询商品
     */
      List<PmsProduct> list(PmsProductQueryParam productQueryParam, Integer pageSize, Integer pageNum);
```
Impl:
```
import com.github.pagehelper.PageHelper//MyBatis分页插件
    @Override
    public List<PmsProduct> list(PmsProductQueryParam productQueryParam, Integer pageSize, Integer pageNum) {
        PageHelper.startPage(pageNum, pageSize);

        PmsProductExample productExample = new PmsProductExample();
        PmsProductExample.Criteria criteria = productExample.createCriteria();
        criteria.andDeleteStatusEqualTo(0);

        //上架状态
        if (productQueryParam.getPublishStatus() != null) {
            criteria.andPublishStatusEqualTo(productQueryParam.getPublishStatus());
        }
        //审核状态
        if (productQueryParam.getVerifyStatus() != null) {
            criteria.andVerifyStatusEqualTo(productQueryParam.getVerifyStatus());
        }
        //商品名称模糊关键字
        if (!StringUtils.isEmpty(productQueryParam.getKeyword())) {
            criteria.andNameLike("%" + productQueryParam.getKeyword() + "%");
        }

        //商品货号
        if (!StringUtils.isEmpty(productQueryParam.getProductSn())) {
            criteria.andProductSnEqualTo(productQueryParam.getProductSn());
        }

        //商品分类编号
        if (productQueryParam.getBrandId() != null) {
            criteria.andBrandIdEqualTo(productQueryParam.getBrandId());
        }

        //商品品牌编号
        if (productQueryParam.getProductCategoryId() != null) {
            criteria.andProductCategoryIdEqualTo(productQueryParam.getProductCategoryId());
        }


        return productMapper.selectByExample(productExample);
    }
```



##商品的增删查操作

## 1 单一商品查询

需求:
勾选一个商品，点击编辑按钮，跳转到另外一个网页，把该商品信息从数据库读取出来。
[![商品编辑操作.jpg](https://i.loli.net/2019/07/23/5d35e8a41d86030165.jpg)](https://i.loli.net/2019/07/23/5d35e8a41d86030165.jpg)

点击这个编辑按钮，跳转到商品详细页面（不要问怎么跳转，前端的事情），此时前端发出获取该商品信息的请求
就是在创建商品信息页面的同时发出请求
```
    created(){
      if(this.isEdit){
        getProduct(this.$route.query.id).then(response=>{
          this.productParam=response.data;
        });
      }
    }
```


后端代码：
PmsProductController:
接收要查询的商品id，然后进行查询
```
    @ApiOperation("根据商品id获取商品编辑信息")
    @RequestMapping(value = "/updateInfo/{id}", method = RequestMethod.GET)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:product:read')")
    public Object getUpdateInfo(@PathVariable Long id) {
        PmsProductResult productResult = productService.getUpdateInfo(id);
        return new CommonResult().success(productResult);
    }
```


service:
接口：
```
/**
 * 根据商品编号获取更新信息
 */
    PmsProductResult getUpdateInfo(Long id);
}
```
实现类：
```
    public PmsProductResult getUpdateInfo(Long id) {
        return productDao.getUpdateInfo(id);
    }
```

Dao:

接口：
```
    /**
     * 获取商品编辑信息
     */
    PmsProductResult getUpdateInfo(@Param("id") Long id);
```


XML文件:
```
 <resultMap id="updateInfoMap" type="com.taobao.taobaoadmin.dto.Pms.PmsProductResult" extends="com.taobao.taobaoadmin.mapper.PmsProductMapper.ResultMapWithBLOBs">
        <result column="cateParentId" jdbcType="BIGINT" property="cateParentId" />
        <collection property="productLadderList" columnPrefix="ladder_" resultMap="com.taobao.taobaoadmin.mapper.PmsProductLadderMapper.BaseResultMap"/>
        <collection property="productFullReductionList" columnPrefix="full_" resultMap="com.taobao.taobaoadmin.mapper.PmsProductFullReductionMapper.BaseResultMap"/>
        <collection property="memberPriceList" columnPrefix="member_" resultMap="com.taobao.taobaoadmin.mapper.PmsMemberPriceMapper.BaseResultMap"/>
        <collection property="skuStockList" columnPrefix="sku_" resultMap="com.taobao.taobaoadmin.mapper.PmsSkuStockMapper.BaseResultMap"/>
        <collection property="productAttributeValueList" columnPrefix="attribute_" resultMap="com.taobao.taobaoadmin.mapper.PmsProductAttributeValueMapper.BaseResultMap"/>
</resultMap>


    <select id="getUpdateInfo" resultMap="updateInfoMap">
        SELECT  *,
                pc.parent_id as cateParentId,
                l.id as ladder_id, l.product_id as ladder_product_id, l.discount as ladder_discount, l.count as ladder_count, l.price as ladder_price,
                pf.id as full_id, pf.product_id as full_product_id, pf.full_price as full_full_price,pf.reduce_price as  full_reduce_price,
                m.id as member_id,m.product_id as member_product_id,m.member_level_id as member_member_level_id,m.member_price as member_member_price,m.member_level_name as member_member_level_name,
                s.id as sku_id,s.product_id as sku_product_id,s.price as sku_price,s.low_stock as sku_low_stock,s.pic as sku_pic,s.sale,s.sku_code as sku_sku_code,s.sp1 as sku_sp1,s.sp2 as sku_sp2,s.sp3 as sku_sp3,s.stock as sku_stock,
                a.id as attribute_id,a.product_id as attribute_product_id,a.product_attribute_id as attribute_product_attribute_id,a.value as attribute_value
        FROM pms_product p
        LEFT  JOIN pms_product_category pc on pc.id = p.product_category_id
        LEFT  JOIN pms_product_ladder l on p.id = l.product_id
        left  JOIN pms_product_full_reduction pf on pf.product_id = p.id
        LEFT  JOIN pms_member_price m on m.product_id = p.id
        LEFT  JOIN pms_sku_stock s ON s.product_id = p.id
        LEFT  JOIN pms_product_attribute_value a ON a.product_id = p.id
        WHERE p.id = #{id};
    </select>
```
其中MyBatis的Collecion是没有使用过的。
Collection标签property的各种`list变量`是原本映射来自对象`PmsProductParam`的属性，但是因为对象`PmsProductResult`是继承了`PmsProductResult`，所以也就是现在映射`PmsProductResult`的属性

    PmsProductResult(查询单个产品进行修改时返回的结果)《----继承----PmsProductParam(创建和修改商品时使用的参数)《----继承-----PmsProduct(商品基本参数对象)

查询这么多的属性，使用标签`columnPrefix`进行别名区分。columnPrefix是自动将前缀增加到SQL语句上，方便增删查操作。（自己个人理解： 当出现多个表查询时，方便区分所要的属性，不会重复，resultMap上的`columnPrefix`要和查询语句上的属性别名前缀一致）

**columnPrefix标签参考：**
https://blog.csdn.net/chris_mao/article/details/48863609
https://www.2cto.com/database/201604/501256.html

###6个表联合商品表查询
商品表 pms_product  p 

    左接    商品分类表 pms_product_category pc 
    连接条件    2个字段的id相同  pc.id = p.product_category_id
    左接    商品阶梯价格价格表 pms_product_ladder l 
    连接条件    2个字段的id相同 p.id = l.product_id
    左接    商品满减价格表   pms_product_full_reduction pf
    连接条件    2个字段的id相同 pf.product_id = p.id
    左接    商品会员价格表  pms_member_price   m
    连接条件    2个字段的id相同 m.product_id = p.id
    左接    商品sku库存表   pms_sku_stock   s
    连接条件    2个字段的id相同 s.product_id = p.id
    左接    商品参数及自定义规格属性表 pms_product_attribute_value a 
    连接条件    2个字段的id相同  a.product_id = p.id






## 2 商品增加

增加商品，是有多个功能组合成一个实现，上传图片是其中之一，

### 2.1上传图片：

参考：https://www.jianshu.com/p/6aebdca025fc

流程图：
[![上图.jpg](https://i.loli.net/2019/06/05/5cf7924d4fd7b94959.jpg)](https://i.loli.net/2019/06/05/5cf7924d4fd7b94959.jpg)

Web前端请求应用服务器，获取上传所需参数（如OSS的accessKeyId、policy、callback等参数）
应用服务器返回相关参数
Web前端直接向OSS服务发起上传文件请求
等上传完成后OSS服务会回调应用服务器的回调接口
应用服务器返回响应给OSS服务
OSS服务将应用服务器回调接口的内容返回给Web前端


####整合OSS实现文件上传
-----------

#####**在pom.xml中添加相关依赖**
```
		<!-- 阿里云OSS -->
		<dependency>
			<groupId>com.aliyun.oss</groupId>
			<artifactId>aliyun-sdk-oss</artifactId>
			<version>2.5.0</version>
		</dependency>
```

#####**修改SpringBoot配置文件**
注意：endpoint、accessKeyId、accessKeySecret、bucketName、callback、prefix都要改为你自己帐号OSS相关的，callback需要是公网可以访问的地址。

写在application.properties上
```
#===OSS start===
aliyun.oss.endpoint=oss-cn-shenzhen.aliyuncs.com
aliyun.oss.accessKeyId=LTAI65MAAZHXwAYS
aliyun.oss.accessKeySecret=FQEMBK6kko6OqLlCpYJDmuA2ygzRL0
aliyun.oss.bucketName=ima-oss
aliyun.oss.policy.expire=300
aliyun.oss.maxSize=10
aliyun.oss.callback=http://loc                                                                                                                                                                     alhost:8080/aliyun/oss/callback
aliyun.oss.dir.prefix=mall/images/
#===OSS end===
```

配置说明:

    endpoint: oss-cn-shenzhen.aliyuncs.com # oss对外服务的访问域名
    accessKeyId: test # 访问身份验证中用到用户标识
    accessKeySecret: test # 用户用于加密签名字符串和oss用来验证签名字符串的密钥
    bucketName: macro-oss # oss的存储空间
    policy:
      expire: 300 # 签名有效期(S)
    maxSize: 10 # 上传文件大小(M)
    callback: http://localhost:8080/aliyun/oss/callback # 文件上传成功后的回调地址
    dir:
      prefix: mall/images/ # 上传文件夹路径前缀



#####**添加OSS的相关Java配置**




用于配置OSS的连接客户端OSSClient

```
import com.aliyun.oss.OSSClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


@Configuration
public class OssConfig {
    @Value("${aliyun.oss.endpoint}")
    private String ALIYUN_OSS_ENDPOINT;
    @Value("${aliyun.oss.accessKeyId}")
    private String ALIYUN_OSS_ACCESSKEYID;
    @Value("${aliyun.oss.accessKeySecret}")
    private String ALIYUN_OSS_ACCESSKEYSECRET;
    @Bean
    public OSSClient ossClient(){
        return new OSSClient(ALIYUN_OSS_ENDPOINT,ALIYUN_OSS_ACCESSKEYID,ALIYUN_OSS_ACCESSKEYSECRET);
    }
}
```

#####**添加OSS上传策略封装对象OssPolicyResult**
前端直接上传文件时所需参数，从后端返回过来。

```
import io.swagger.annotations.ApiModelProperty;
/**
 * 获取OSS上传授权返回结果
 */
public class OssPolicyResult {
    @ApiModelProperty("访问身份验证中用到用户标识")
    private String accessKeyId;
    @ApiModelProperty("用户表单上传的策略,经过base64编码过的字符串")
    private String policy;
    @ApiModelProperty("对policy签名后的字符串")
    private String signature;
    @ApiModelProperty("上传文件夹路径前缀")
    private String dir;
    @ApiModelProperty("oss对外服务的访问域名")
    private String host;
    @ApiModelProperty("上传成功后的回调设置")
    private String callback;
    //省略了getter和setter
}
```

#####**添加OSS上传成功后的回调参数对象OssCallbackParam**

当OSS上传成功后，会根据该配置参数来回调对应接口。

```
import io.swagger.annotations.ApiModelProperty;

/**
 * oss上传成功后的回调参数
 */
public class OssCallbackParam {
    @ApiModelProperty("请求的回调地址")
    private String callbackUrl;
    @ApiModelProperty("回调是传入request中的参数")
    private String callbackBody;
    @ApiModelProperty("回调时传入参数的格式，比如表单提交形式")
    private String callbackBodyType;
    //省略getter和setter
}
```


#####**OSS上传成功后的回调结果对象OssCallbackResult**

回调接口中返回的数据对象，封装了上传文件的信息。

```
/**
 * oss上传文件的回调结果
 */
public class OssCallbackResult {
    @ApiModelProperty("文件名称")
    private String filename;
    @ApiModelProperty("文件大小")
    private String size;
    @ApiModelProperty("文件的mimeType")
    private String mineType;
    @ApiModelProperty("图片文件的宽")
    private String width;
    @ApiModelProperty("图片文件的高")
    private String height;
    //省略getter和setter
}
```


#####**OssController定义接口**

```
import com.taobao.taobaoadmin.dto.CommonResult;
import com.taobao.taobaoadmin.dto.OssCallbackResult;
import com.taobao.taobaoadmin.dto.OssPolicyResult;
import com.taobao.taobaoadmin.service.OssService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;

/**
 * Oss相关操作接口
 */
@Controller
@Api(tags = "OssController",description = "Oss管理")
@RequestMapping("/aliyun/oss")
public class OssController {
    @Autowired
    private OssService ossService;

    @ApiOperation(value = "oss上传签名生成")
    @RequestMapping(value = "/policy",method = RequestMethod.GET)
    @ResponseBody
    public Object policy() {
        OssPolicyResult result = ossService.policy();
        return new CommonResult().success(result);
    }

    @ApiOperation(value = "oss上传成功回调")
    @RequestMapping(value="callback",method = RequestMethod.POST)
    @ResponseBody
    public Object callback(HttpServletRequest request) {
        OssCallbackResult ossCallbackResult = ossService.callback(request);
        return new CommonResult().success(ossCallbackResult);
    }

}
```

#####**OSS业务接口OssService**

```
import com.taobao.taobaoadmin.dto.OssCallbackResult;
import com.taobao.taobaoadmin.dto.OssPolicyResult;
import javax.servlet.http.HttpServletRequest;

/**
 * oss上传管理Service
 */
public interface OssService {
   //oss上传策略生成
    OssPolicyResult policy();

    //oss上传成功回调
    OssCallbackResult callback(HttpServletRequest request);
}
```

#####实现类OssServiceImpl

```
import com.aliyun.oss.OSSClient;
import com.aliyun.oss.common.utils.BinaryUtil;
import com.aliyun.oss.model.MatchMode;
import com.aliyun.oss.model.PolicyConditions;
import com.taobao.taobaoadmin.dto.OssCallbackResult;
import com.taobao.taobaoadmin.dto.OssPolicyResult;
import com.taobao.taobaoadmin.service.OssService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.servlet.http.HttpServletRequest;
import java.text.SimpleDateFormat;
import java.util.Date;

@Service
public class OssServiceImpl implements OssService {

    private static final Logger LOGGER = LoggerFactory.getLogger(OssServiceImpl.class);

    @Value("${aliyun.oss.policy.expire}")
    private int ALIYUN_OSS_EXPIRE;
    @Value("${aliyun.oss.maxSize}")
    private int ALIYUN_OSS_MAX_SIZE;
    @Value("${aliyun.oss.callback}")
    private String ALIYUN_OSS_CALLBACK;
    @Value("${aliyun.oss.bucketName}")
    private String ALIYUN_OSS_BUCKET_NAME;
    @Value("${aliyun.oss.endpoint}")
    private String ALIYUN_OSS_ENDPOINT;
    @Value("${aliyun.oss.dir.prefix}")
    private String ALIYUN_OSS_DIR_PREFIX;


    @Autowired
    private OSSClient ossClient;


    /**
     * 签名生成
     *签名直传服务,响应客户端发送给应用服务器的GET消息(在Controller上看get或者POST)
     * @return
     */
    @Override
    public OssPolicyResult policy() {
        OssPolicyResult result = new OssPolicyResult();
        //存储目录
        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
        String dir = ALIYUN_OSS_DIR_PREFIX + sdf.format(new Date());

        //签名有效期
        long expireEndTime = System.currentTimeMillis() + ALIYUN_OSS_EXPIRE * 1000;
        Date expiration = new Date(expireEndTime);

        //文件大小
        long maxSize = ALIYUN_OSS_MAX_SIZE * 1024 * 1024;

        //提交节点
        String action = "http://" + ALIYUN_OSS_BUCKET_NAME + "." + ALIYUN_OSS_ENDPOINT;

        try {
            PolicyConditions policyCond = new PolicyConditions();
            policyCond.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, maxSize);
            policyCond.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);
            String postPolicy = ossClient.generatePostPolicy(expiration, policyCond);
            byte[] binaryData = postPolicy.getBytes("utf-8");
            String policy = BinaryUtil.toBase64String(binaryData);
            String signatrue = ossClient.calculatePostSignature(postPolicy);

            //访问身份验证中用到用户标识
            result.setAccessKeyId(ossClient.getCredentialsProvider().getCredentials().getAccessKeyId());
            //用户表单上传的策略，经过Base64编码过的字符串
            result.setPolicy(policy);
            //对policy签名后的字符串
            result.setSignature(signatrue);
            //上传文件夹路径前缀
            result.setDir(dir);
            //OSS对外服务的访问域名
            result.setHost(action);
        } catch (Exception e) {
            LOGGER.error("签名生成失败", e);
        }

        return result;
    }

    @Override
    public OssCallbackResult callback(HttpServletRequest request) {
        OssCallbackResult result = new OssCallbackResult();
        String filename = request.getParameter("filename");
        filename = "http://".concat(ALIYUN_OSS_BUCKET_NAME).concat(".").concat(ALIYUN_OSS_ENDPOINT).concat("/").concat(filename);

        result.setFilename(filename);
        result.setSize(request.getParameter("size"));
        result.setMineType(request.getParameter("mimeType"));
        result.setWidth(request.getParameter("width"));
        result.setHeight(request.getParameter("height"));

        return result;
    }
}
```

是参考使用阿里的API实现上传的，就是改变了一些变量的名字。
API参考：
https://help.aliyun.com/document_detail/91868.html?spm=a2c4g.11186623.2.15.2b9a6e28ifkhfH#concept-ahk-rfz-2fb



###2.2 增加产品请求

添加商品这个过程中会发出请求，
增加请求又分2步骤：

    第一步是向数据库查询数据请求
    第2步是向数据库插入数据请求

因为有些商品属性是需要先查询，然后让用户选择属性作为商品属性的，所以会出现先一个查询请求，然后接着一个插入请求。
下面就是商品的查询请求：

    查询品牌对象
    查询商品分类对象 
    查询商品属性类型对象
    查询商品关联

上面都是访问增加商品页面时候需要加载的对象，不是客户自己添加商品的属性，下面才是客户自己添加的属性内容

自己查看商品对象的属性，然后写前端发出的要求是什么

整理整个过程
插入Mybatis的SQL语句


####2.2.1查询请求
前端点击lia：  

点击链接，跳转增加商品链接

点击页面旁边的状态栏，引入模块，发出跳转连接
  

    component: () => import('@/views/pms/product/add')


跳转到Add.vue上，随后有引入模块，跳转到Product Detail.vue上

  

    import ProductDetail from './components/ProductDetail'


跳转到productdetail.vue上，引入模块，跳转到5个模块上，发出4个查询请求，InfoDetail这个是后面选择好ID查询时候才使用的。

      import ProductInfoDetail from './ProductInfoDetail';
      import ProductSaleDetail from './ProductSaleDetail';
      import ProductAttrDetail from './ProductAttrDetail';
      import ProductRelationDetail from './ProductRelationDetail';
      import {createProduct,getProduct,updateProduct} from '@/api/product';



#####2.2.1.1查询品牌对象和查询商品1级2级分类请求

从**ProductInfoDetail**模块上引入品牌模块,查询产品分类模块

      import {fetchListWithChildren} from '@/api/productCate'
      import {fetchList as fetchBrandList} from '@/api/brand'
      import {getProduct} from '@/api/product';

从API文件下的ProductCate模块,brand模块上分别发出**查询品牌对象请求**和**查询商品1级2级分类请求**

######2.2.1.1.1查询品牌对象请求

```
export function fetchList(params) {
  return request({
    url:'/brand/list',
    method:'get',
    params:params
  })
}
```

PmsBrandController：
keyWord，pageNum, pageSize这些参数在前端的表单上已经包装好，我们后端只是需要知道传入参数的名称，值是多少，就可以了。个人猜想是前后端需要沟通好才能写这参数。
```
@Controller
@Api(tags = "PmsBrandController", description = "商品品牌管理")
@RequestMapping("/brand")
public class PmsBrandController {

    @Autowired
    private PmsBrandService brandService;

    @ApiOperation(value = "根据品牌名称分页获取品牌列表")
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:brand:read')")
    public Object getList(@RequestParam(value = "keyword", required = false) String keyword,
                          @RequestParam(value = "pageNum", defaultValue = "1") Integer pageNum,
                          @RequestParam(value = "pageSize", defaultValue = "5") Integer pageSize) {
        return new CommonResult().pageSuccess(brandService.listBrand(keyword, pageNum, pageSize));
    }

}
```


Service
pageHelper是MyBatis的分页插件
客户的需求： 根据关键词keyword查询产品
输入参数：查询关键词keyword
criteria采用的方法：andNameLike("%"+ keyword +"%")
```
import com.github.pagehelper.PageHelper;
import com.taobao.taobaoadmin.mapper.PmsBrandMapper;
import com.taobao.taobaoadmin.model.PmsBrandExample;
import com.taobao.taobaoadmin.service.Pms.PmsBrandService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
@Service
public class PmsBrandServiceImpl implements PmsBrandService{

    @Autowired
    private PmsBrandMapper brandMapper;

    @Override
    public List listBrand(String keyword, Integer pageNum, Integer pageSize) {

        PageHelper.startPage(pageNum, pageSize);
        PmsBrandExample pmsBrandExample = new PmsBrandExample();
        pmsBrandExample.setOrderByClause("sort desc");
        PmsBrandExample.Criteria criteria = pmsBrandExample.createCriteria();

        if (!StringUtils.isEmpty(keyword)) {
            criteria.andNameLike("%" + keyword + "%");
        }

        return brandMapper.selectByExample(pmsBrandExample);
    }
}
```



######2.2.1.1.2查询商品1级2级分类请求
```
export function fetchListWithChildren() {
  return request({
    url:'/productCategory/list/withChildren',
    method:'get'
  })
```

PmsProductCategoryController：
查询全部的商品1级2级分类
```
@Controller
@Api(tags = "PmsProductCategoryController", description = "商品分类管理")
@RequestMapping("/productCategory")
public class PmsProductCategoryController {

    @Autowired
    private PmsProductCategoryService productCategoryService;

    @ApiOperation("查询所有一级分类及子分类")
    @RequestMapping(value = "/list/withChildren",method = RequestMethod.GET)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:productCategory:read')")
    public Object listWithChildren() {

        List<PmsProductCategoryWithChildrenItem> list = productCategoryService.listWithChildren();
        return new CommonResult().success(list);
    }
}
```

Service
客户需求： 查找产品，而且产品带有分类属性，分类属性有1级2级
输入： 没有参数
Dao： 使用自己写的SQL查询

```
@Service
public class PmsProductCategoryServiceImpl implements PmsProductCategoryService {

    @Autowired
    private PmsProductCategoryDao productCategoryDao;

    @Override
    public List<PmsProductCategoryWithChildrenItem> listWithChildren() {
        return productCategoryDao.listWithChildren();
    }
}
```


Dao：

创建带2级分类产品的分类对象`PmsProductCategoryWithChildrenItem`，继承`PmsProductCategory`类，它带有一个`PmsProductCategory`类型的属性：`children`
说明结果集：
创建一个结果集`listWithChildrenMap`，返回的类型是一个带2级分类产品的分类对象`PmsProductCategoryWithChildrenItem`，然后继承产品分类对象的结果集，同时`listWithChildrenMap`有Collection标签，Collection设置标签的属性：属性前缀`child_`和JavaBean的属性`children`


查询语句：
pms_product_category 是数据库中的产品分类表，用现实的话就是一张表复印2份，一份称为C1，另一份称为C2，然后使用`左连接`，连接2份表。C1是主表格，C2是副表格。
连接2份表格的连接条件是ON之后的**（副表条件在On之后）**
```
c1.id = c2.parent_id
```
主要筛选条件是where之后的**（主表条件在where之后）**
```
c1.parent_id = 0
```
**查询全部的产品1级和2级分类对象----查询条件：字段`parentId = 0` 的产品，而且它的子类的`parentid`与自己的`id`相同**


完整查询语句：
```
    <resultMap id="listWithChildrenMap"   type="com.taobao.taobaoadmin.dto.Pms.PmsProductCategoryWithChildrenItem"
               extends="com.taobao.taobaoadmin.mapper.PmsProductCategoryMapper.BaseResultMap">
               
<!--
        collection 为关联关系，是实现一对多的关键
　　　　1. property 为javabean中容器对应字段名
　　　　2. ofType 指定集合中元素的对象类型
　　　　3. select 使用另一个查询封装的结果
　　　　4. column 为数据库中的列名，与select配合使用
        columnPrefix是表示在Collection所包括的字段，在SQL书写的时候，这些字段自动添加上“XXX”的前缀，与其他字段名区别开
        这里是把全部字段都加上”child_“前缀。
-->           
<!--
column 对应数据库表的列名
property 属性对应javabean的属性名
-->   
        <collection property="children" resultMap="com.taobao.taobaoadmin.mapper.PmsProductCategoryMapper.BaseResultMap"
                    columnPrefix="child_"/>
    </resultMap>
    <select id="listWithChildren" resultMap="listWithChildrenMap">
        SELECT
            c1.id,
            c1.name,
            c2.id   as child_id,
            c2.name as child_name
        FROM
            pms_product_category c1
        left join  pms_product_category c2 ON  c1.id = c2.parent_id
        WHERE  c1.parent_id = 0
    </select>

```

前端发出请求：查询全部的产品对象而且是带有子类的产品分类对象（就是一个分类产品名称里带有另外一个分类产品名称）

**查询全部的产品1级和2级分类对象----查询条件：字段`parentId = 0` 的产品，而且它的子类的`parentid`与自己的`id`相同**



#####2.2.1.2查询获取全部商品专题和获取所有商品优选

从**ProductRelationDetail**模块上引入商品专题模块，引入商品优选模块

      import {fetchListAll as fetchSubjectList} from '@/api/subject'
      import {fetchList as fetchPrefrenceAreaList} from '@/api/prefrenceArea'


从API文件下的subject模块,prefrenceArea模块上分别发出**查询全部商品专题请求**和**查询所有商品优选请求**

######2.2.1.2.1获取所有商品优选
请求进来是没有一个参数的。
```
export function fetchList() {
  return request({
    url:'/prefrenceArea/listAll',
    method:'get',
  })
  }
```

CmsPreferenceAreaController：
请求进来是没有一个参数的。
```
@Controller
@Api(tags = "CmsPrefrenceAreaController", description = "商品优选管理")
@RequestMapping("/prefrenceArea")
public class CmsPreferenceAreaController {

    @Autowired
    private CmsPreferenceAreService preferenceAreService;

    @ApiOperation("获取所有商品优选")
    @RequestMapping(value = "/listAll", method = RequestMethod.GET)
    @ResponseBody
    public Object listAll() {

        List<CmsPrefrenceArea> preferenceAreaList = preferenceAreService.listAll();
        return new CommonResult().success(preferenceAreaList);
    }
}
```

Service

客户需求： 查询所有商品
输入： 没有参数的请求
example： 使用Mybatis的时候，自动创建的CmsPrefrenceAreaExample现在直接使用，不加入Criteria语句就是查询全部了。查询什么产品类就使用Mybatis自动创建的那个产品类

```
import com.taobao.taobaoadmin.mapper.CmsPrefrenceAreaMapper;
import com.taobao.taobaoadmin.model.CmsPrefrenceArea;
import com.taobao.taobaoadmin.model.CmsPrefrenceAreaExample;
import com.taobao.taobaoadmin.service.Cms.CmsPreferenceAreService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
@Service
public class CmsPreferenceAreServiceImpl implements CmsPreferenceAreService {

    @Autowired
    private CmsPrefrenceAreaMapper preferenceAreaMapper;

    @Override
    public List<CmsPrefrenceArea> listAll() {
        return preferenceAreaMapper.selectByExample(new CmsPrefrenceAreaExample());
    }
}
```



######2.2.1.2.2 查询获取全部商品专题
```
export function fetchListAll() {
  return request({
    url:'/subject/listAll',
    method:'get',
  })
}
```


CmsSubjectController：
```
@Controller
@Api(tags = "CmsSubjectController",description = "商品专题管理" )
@RequestMapping("/subject")
public class CmsSubjectController {
    @Autowired
    private CmsSubjectService subjectService;

    @ApiOperation("获取全部商品专题")
    @RequestMapping(value = "/listAll",method = RequestMethod.GET)
    @ResponseBody
    public Object listAll() {
        List<CmsSubject> subjectList = subjectService.listAll();
        return new CommonResult().success(subjectList);
    }
}
```

Service
客户需求： 查询所有商品专题
输入： 没有参数的请求
example： 查询产品是商品专题类，所以使用CmsSubjectExample

```
@Service
public class CmsSubjectServiceImpl implements CmsSubjectService {

    @Autowired
    private CmsSubjectMapper subjectMapper;

    @Override
    public List<CmsSubject> listAll() {
        return subjectMapper.selectByExample(new CmsSubjectExample());
    }
}
```




#####2.2.1.3查询商品属性分类和获取所有商品属性

从**ProductAttrDetail**模块上引入商品属性分类模块，引入商品属性模块,后面的就是下载了，那就是接上面2.1的上传图片内容了。

      import {fetchList as fetchProductAttrCateList} from '@/api/productAttrCate'
      import {fetchList as fetchProductAttrList} from '@/api/productAttr'
      import SingleUpload from '@/components/Upload/singleUpload'
      import MultiUpload from '@/components/Upload/multiUpload'
      import Tinymce from '@/components/Tinymce'


从API文件下的productAttriCate模块,productAttr模块上分别发出**查询分页获取所有商品属性分类请求**和**根据商品的分类查询商品的属性列表或参数列表请求**

######2.2.1.3.1查询分页获取所有商品属性分类请求
参数是分页的参数，前端沟通的。
```
export function fetchList(params) {
  return request({
    url:'/productAttribute/category/list',
    method:'get',
    params:params
  })
}
```
PmsProductAttributeCategoryController 
请求的参数是分页pageSize,pageNum，这是与前端沟通好的。
返回的是全部产品属性的分类对象
```
@Controller
@Api(tags = "PmsProductAttributeCategoryController", description = "商品属性分类管理")
@RequestMapping("/productAttribute/category")
public class PmsProductAttributeCategoryController {

    @Autowired
    private PmsProductAttributeCategoryService productAttributeCategoryService;


    @ApiOperation("分页获取所有商品属性分类")
    @RequestMapping(value="/list",method = RequestMethod.GET)
    @ResponseBody
    public Object getList(@RequestParam(defaultValue = "5") Integer pageSize, @RequestParam(defaultValue = "1") Integer pageNum) {
        List<PmsProductAttributeCategory> productAttributeCategoryList = productAttributeCategoryService.getList(pageSize, pageNum);
        return new CommonResult().pageSuccess(productAttributeCategoryList);
    }
}
```

Service
客户需求： 查询所有商品属性的分类对象
输入： 有分页参数的请求 pageSize，pageNum
example： 查询的是商品属性的分类对象，所以使用PmsProductAttributeCategoryExample


```
@Service
public class PmsProductAttributeCategoryServiceImpl implements PmsProductAttributeCategoryService {

    @Autowired
    private PmsProductAttributeCategoryMapper productAttributeCategoryMapper;


    @Override
    public List<PmsProductAttributeCategory> getList(Integer pageSize, Integer pageNum) {

        PageHelper.startPage(pageNum, pageSize);

        return productAttributeCategoryMapper.selectByExample(new PmsProductAttributeCategoryExample());
    }
}
```



######2.2.1.3.2根据商品的分类查询商品的属性列表请求或参数列表
客户要的效果就是 在创建商品过程中根据商品分类类型 查询分类的属性列表或者参数列表**（注意：这里的属性和参数的区别只是在数据库中商品属性表的字段type值的不同，并不是不同表格的字段之类）**

效果：
[![创建商品使用到了根据分类对象查询商品属性.jpg](https://i.loli.net/2019/07/23/5d35e0b3cf60765218.jpg)](https://i.loli.net/2019/07/23/5d35e0b3cf60765218.jpg)
选择商品分类，获取商品属性，然后返回到页面给客户进行编辑商品属性
比如：
服装--T恤商品的属性编辑
[![商品属性1.jpg](https://i.loli.net/2019/08/01/5d41faa9b996435974.jpg)](https://i.loli.net/2019/08/01/5d41faa9b996435974.jpg)
[![商品属性2.jpg](https://i.loli.net/2019/08/01/5d41faa9cbd4f35007.jpg)](https://i.loli.net/2019/08/01/5d41faa9cbd4f35007.jpg)

手机商品的属性编辑：
[![商品属性3.jpg](https://i.loli.net/2019/08/01/5d41faed2d8c282240.jpg)](https://i.loli.net/2019/08/01/5d41faed2d8c282240.jpg)
[![商品属性4.jpg](https://i.loli.net/2019/08/01/5d41faed208f043172.jpg)](https://i.loli.net/2019/08/01/5d41faed208f043172.jpg)

前端请求：
客户的想法：点击选择商品的分类，获取商品的属性，然后进行修改商品的属性

```      
<el-form-item label="属性类型：">
        <el-select v-model="value.productAttributeCategoryId"
                   placeholder="请选择属性类型"
                   @change="handleProductAttrChange">
    //一大串代码····               
      import {fetchList as fetchProductAttrList} from '@/api/productAttr'
    //一大串代码····
      handleProductAttrChange(value) {
        this.getProductAttrList(0, value);
        this.getProductAttrList(1, value);
      },
      //一大串代码····
      getProductAttrList(type, cid) {
        let param = {pageNum: 1, pageSize: 100, type: type};
        fetchProductAttrList(cid, param).then(response => {
```

商品属性的API代码：
```
export function fetchList(cid,params) {
  return request({
    url:'/productAttribute/list/'+cid,
    method:'get',
    params:params
  })
}
```

具体的请求参数名
```
 let param = {pageNum: 1, pageSize: 100, type: type};
        fetchProductAttrList(cid, param).then(response => {
```


后端：

PmsProductAttributeController 
请求参数有4个：商品分类cid，type，pageSize，pageNum，也是与前端沟通好的。
```
@Controller
@Api(tags = "PmsProductAttributeController", description = "商品属性管理")
@RequestMapping("/productAttribute")
public class PmsProductAttributeController {

    @Autowired
    private PmsProductAttributeService productAttributeService;

    /*
    *  @ApiImplicitParams是swagger2常用注解
    *
@ApiImplicitParams：用在请求的方法上，表示一组参数说明
    @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面
        name：参数名
        value：参数的汉字说明、解释
        required：参数是否必须传
        paramType：参数放在哪个地方
            · header --> 意思是：请求参数的获取：@RequestHeader
            · query --> 意思是：请求参数的获取：@RequestParam
            · path（用于restful接口）--> 请求参数的获取：@PathVariable
            · body（不常用）
            · form（不常用）
        dataType：参数类型，默认String，其它值dataType="Integer"
        defaultValue：参数的默认值
    * */

    @ApiOperation("根据分类查询属性列表或参数列表")
    @ApiImplicitParams({@ApiImplicitParam(name = "type",value="0表示属性，1表示参数",
                                          required = true,
                                          paramType = "query",
                                          dataType = "integer")})
    @RequestMapping(value = "/list/{cid}",method = RequestMethod.GET)
    @ResponseBody
    public Object getList(@PathVariable Long cid,
                          @RequestParam(value="type") Integer type,
                          @RequestParam(value="pageSize",defaultValue = "5") Integer pageSize,
                          @RequestParam(value="pageNum",defaultValue = "1") Integer pageNum) {
        List<PmsProductAttribute> productAttributeList = productAttributeService.getList(cid,type, pageSize, pageNum);

        return new CommonResult().pageSuccess(productAttributeList);
    }
}

```

Service
客户需求： 根据商品分类id和产品类型type查询所有的商品属性对象
输入： 有分页参数的请求 pageSize，pageNum, 商品类型type, 商品分类ID--cid
example： 查询的是商品属性对象，所以使用PmsProductAttributeExample,同时又条件要求： cid，type，所以example也要增加条件语句criteria，增加方法idEqualTo(),和方法andTypeEqualTo()

```
@Service
public class PmsProductAttributeServiceImpl implements PmsProductAttributeService {

    @Autowired
    private PmsProductAttributeMapper productAttributeMapper;
    
    @Override
    public List<PmsProductAttribute> getList(Long cid,Integer type , Integer pageSize, Integer pageNum) {

        PageHelper.startPage(pageNum, pageSize);
        PmsProductAttributeExample example = new PmsProductAttributeExample();
        example.setOrderByClause("sort desc");
        example.createCriteria().andProductAttributeCategoryIdEqualTo(cid).andTypeEqualTo(type);
        return productAttributeMapper.selectByExample(example);
    }
}
```




#####2.2.1.4查询会员等级

从ProductSaleDetail模块引入会员模块

    import {fetchList as fetchMemberLevelList} from '@/api/memberLevel'

从API文件下的memberLevel模块上发出**查询会员等级请求**

```
export function fetchList(params) {
  return request({
    url:'/memberLevel/list',
    method:'get',
    params:params
  })
}
```
请求参数params的具体参数名
```
    fetchMemberLevelList({defaultStatus: 0}).then(response => {
```

UmsMemberLevelController：
请求参数：defaultStatus,也是与前端沟通好的
```
@Controller
@Api(tags = "UmsMemberLevelController", description = "会员等级管理")
@RequestMapping("/memberLevel")
public class UmsMemberLevelController {

    @Autowired
    private UmsMemberLevelService memberLevelService;

    @RequestMapping(value = "/list",method = RequestMethod.GET)
    public Object list(@RequestParam("defaultStatus") Integer defaultStatus) {
        List<UmsMemberLevel> memberLevelList = memberLevelService.list(defaultStatus);

        return new CommonResult().pageSuccess(memberLevelList);
    }
}
```

Service 
客户需求： 查询会员等级
输入： defaultStatus 会员等级状态
example： 查询的是会员等级对象，所以使用UmsMemberLevelExample,同时有条件要求：会员等级状态defaultStatus，所以example也要增加条件语句criteria，增加方法andDefaultStatusEqualTo（）
```
@Service
public class UmsMemberLevelServiceImpl implements UmsMemberLevelService {

    @Autowired
    private UmsMemberLevelMapper memberLevelMapper;

    @Override
    public List<UmsMemberLevel> list(Integer defaultStatus) {

        UmsMemberLevelExample example = new UmsMemberLevelExample();
        example.createCriteria().andDefaultStatusEqualTo(defaultStatus);
        return memberLevelMapper.selectByExample(example);
    }
}
```



####2.2.2产品的创建请求
因为是在Product Detail.vue上引入

     import {createProduct,getProduct,updateProduct} from '@/api/product';

所以其实是使用 **创建，查询，更新** 3个操作的**（创建的第一反应就是插入数据，为什么老是没反应过来啊）**


这里就只说引入product模块的createProduct函数


从API文件下的product模块上发出**创建商品请求**

```
export function createProduct(data) {
  return request({
    url:'/product/create',
    method:'post',
    data:data
  })
}
```
具体的请求参数data
```
createProduct(this.productParam).then(response=>{
```
productParam在前端的定义：
```
  productParam: Object.assign({}, defaultProductParam),
```
defaultProductParam在前端的定义：
```
  const defaultProductParam = {
    albumPics: '',
    brandId: null,
    brandName: '',
    deleteStatus: 0,
    description: '',
    detailDesc: '',
    detailHtml: '',
    detailMobileHtml: '',
    detailTitle: '',
    feightTemplateId: 0,
    flashPromotionCount: 0,
    flashPromotionId: 0,
    flashPromotionPrice: 0,
    flashPromotionSort: 0,
    giftPoint: 0,
    giftGrowth: 0,
    keywords: '',
    lowStock: 0,
    name: '',
    newStatus: 0,
    note: '',
    originalPrice: 0,
    pic: '',
    //会员价格{memberLevelId: 0,memberPrice: 0,memberLevelName: null}
    memberPriceList: [],
    //商品满减
    productFullReductionList: [{fullPrice: 0, reducePrice: 0}],
    //商品阶梯价格
    productLadderList: [{count: 0,discount: 0,price: 0}],
    previewStatus: 0,
    price: 0,
    productAttributeCategoryId: null,
    //商品属性相关{productAttributeId: 0, value: ''}
    productAttributeValueList: [],
    //商品sku库存信息{lowStock: 0, pic: '', price: 0, sale: 0, skuCode: '', sp1: '', sp2: '', sp3: '', stock: 0}
    skuStockList: [],
    //商品相关专题{subjectId: 0}
    subjectProductRelationList: [],
    //商品相关优选{prefrenceAreaId: 0}
    prefrenceAreaProductRelationList: [],
    productCategoryId: null,
    productCategoryName: '',
    productSn: '',
    promotionEndTime: '',
    promotionPerLimit: 0,
    promotionPrice: null,
    promotionStartTime: '',
    promotionType: 0,
    publishStatus: 0,
    recommandStatus: 0,
    sale: 0,
    serviceIds: '',
    sort: 0,
    stock: 0,
    subTitle: '',
    unit: '',
    usePointLimit: 0,
    verifyStatus: 0,
    weight: 0
  };
```

#####2.2.2.1 后端代码


PmsProductController：
请求参数productParam在创建产品的时候它的属性其实不一定全部有值，所以创建一个随时可以修改使用的对象`PmsProductParam`，该对象继承产品对象`PmsProduct`。
作用就是传入的产品的属性存在与数据库不对应的属性的时候，这里可以创建对象创建属性接收传入的产品属性（该属性类型一定是数据库存在的属性）。简单就是可以接收意外的用户要求或者是产品属性。
```
@Controller
@Api(tags = "PmsProductController", description = "商品管理")
@RequestMapping("/product")
public class PmsProductController {

    @Autowired
    private PmsProductService productService;

    @ApiOperation("创建商品")
    @RequestMapping(value = "/create", method = RequestMethod.POST)
    @ResponseBody //把后台pojo转换json对象，返回到页面。
    @PreAuthorize("hasAuthority('pms:product:create')")//限制查询，只能查询拥有权限的create部分，这是Spring Security的注解
    //RequestBody ,接受前台json数据，把json数据自动封装javaBean。
    public Object create(@RequestBody PmsProductParam productParam, BindingResult bindingResult) {
        int count = productService.create(productParam);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
}
```


Service
这里是每一个产品自定义类属性都需要自己编写SQL
同时都是获取产品类属性对象和产品id随后插入数据库，所以在Service上有重复代码，所以利用反射写可以复用的代码（就是方法，获取参数就可以调用方法完成重复）
复用代码的参数：会员价格，阶梯价格，满减价格，添加sku库存信息，添加商品参数,添加自定义商品规格，关联专题，关联优选


以前是创建XX对象，然后把传入的参数一个个亲自setting进入XX对象中，然后创建一个集合List返回到Controller上

理解复用代码的意思
这段复用好像是利用反射产生对象，然后进行对象赋值的作用，但是目前不知道返回的对象是什么，


这个invoke居然找源码找到了invoke0方法去了，这是一个native方法,它在HotSpot JVM里调用JVM_InvokeMethod函数

输入
过程
输出

这里是我自己没有理解反射的基本概念，导致这段代码没有理解，就是Spring的DI，就是把创建对象这个操作交给程序（spring）。
首先我们根据反射得到Method类型的方法对象login（就是我们要调用的方法，现在根据反射成了一个对象）
我们给出输入参数：使用方法的对象XX，方法需要的参数name（或者是参数列表）
login使用调用invoke(XX,name)，这个过程完成了XX对象对login方法的使用，区别在于，不是我们人写代码完成`XX.login（name）；`这语句，而是由程序完成（AI的最简陋方法？！）写这句代码。



完整的Service代码：
```
@Service
public class PmsProductServiceImpL  implements PmsProductService{
    private static final Logger LOGGER = LoggerFactory.getLogger(PmsProductServiceImpL.class);

    @Autowired
    private PmsProductMapper productMapper;

    @Autowired
    private PmsMemberPriceDao memberPriceDao;

    @Autowired
    private PmsProductLadderDao productLadderDao;

    @Autowired
    private PmsProductFullReductionDao productFullReductionDao;

    @Autowired
    private PmsSkuStockDao skuStockDao;

    @Autowired
    private PmsProductAttributeValueDao productAttributeValueDao;

    @Autowired
    private CmsSubjectProductRelationDao subjectProductRelationDao;

    @Autowired
    private CmsPrefrenceAreaProductRelationDao prefrenceAreaProductRelationDao;

    @Autowired
    private PmsProductDao productDao;

    /**
     * 建立和插入关系表操作
     * @param dao  可以操作的dao
     * @param dataList  要插入的数据
     * @param productId  建立关系的id
     */
    private void relateAndInsertList(Object dao, List dataList, Long productId) {
        try {
            if (CollectionUtils.isEmpty(dataList)) return;

            //这里是有规划的，属性列表dataList的主要内容是客户填写的，我们这里只是需要写属性是归类于哪个产品id就可以了
            //这个循环是为了给产品的属性列表中的属性赋予产品ID，表面这个属性是哪个产品哪个ID的。
            for (Object item : dataList) {
                //Method method = ownerClass.getMethod(methodName, argsClass)：
                // 通过methodName和参数的argsClass（方法中的参数类型集合）数组得到要执行的Method。
                // 返回一个方法对象
                Method setId = item.getClass().getMethod("setId", Long.class);
                //method.invoke(owner, args)：执行该Method.invoke方法的参数是执行这个方法的对象owner，和参数数组args，
                //可以这么理解：owner对象中带有参数args的method方法。返回值是Object，也既是该方法的返回值。
                //这里就是根据”setId“获取到XX对象的所有setId方法，当args=null，说明调用的是所有setId方法中的无参数值方法，
                setId.invoke(item, (Long)null);
                //获取XX对象的所有setProductId方法
                Method setProductId = item.getClass().getMethod("setProductId", Long.class);
                //调用XX对象中的setProductId方法并且方法中参数值要带有productId，返回值是Object
                setProductId.invoke(item, productId);
            }
            //得到插入数据列表方法insertList
            Method insertList = dao.getClass().getMethod("insertList", List.class);
            //dao对象mapper进行插入操作----就是以前写的这句mapper.insertList(XXXList)
            insertList.invoke(dao, dataList);
        } catch (Exception e) {
            e.printStackTrace();
            LOGGER.warn("创建产品出错：{}", e.getMessage());
            throw new RuntimeException(e.getMessage());
        }
    }
    
        /**
     * 处理sku的编码，在sku编码后面加入当前日期和商品id
     * @param skuStockList
     * @param productId
     */
    private void handleSkuStockCode(List<PmsSkuStock> skuStockList, Long productId) {
        if (CollectionUtils.isEmpty(skuStockList)) return;

        for (int i = 0; i < skuStockList.size();i++) {
            //获取sku的编码
            PmsSkuStock skuStock = skuStockList.get(i);
            if (StringUtils.isEmpty(skuStock.getSkuCode())) {
                SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
                //对于处理时间短的服务或者启动频率高的要用单线程，相反用多线程
                //单线程操作字符串缓冲流同时有大量数据的时候，使用StringBuilder
                StringBuilder sd = new StringBuilder();
                //日期，获取当前日期
                sd.append(sdf.format(new Date()));
                //四位商品id，%04d是输出商品id不足4位数字则向左用0补齐4位数，d是10进制整型
                sd.append(String.format("%04d", productId));
                //3位索引id，%03d是输出索引id不足3位数字则向左用0补齐3位数，d是10进制整型
                sd.append(String.format("%03d", i + 1));
                skuStock.setSkuCode(sd.toString());
            }
        }
    }
        
    /**
     * 创建产品
     * @param productParam
     * @return
     */    
        @Override
    public int create(PmsProductParam productParam) {
        int count;

        //创建商品
        PmsProduct product = productParam;
        product.setId(null);
        productMapper.insertSelective(product);

        //根据促销类型设置价格：、阶梯价格、满减价格
        Long productId = product.getId();

        //会员价格
        relateAndInsertList(memberPriceDao, productParam.getMemberPriceList(), productId);

        //阶梯价格
        relateAndInsertList(productLadderDao, productParam.getProductLadderList(), productId);

        //满减价格
        relateAndInsertList(productFullReductionDao, productParam.getProductFullReductionList(), productId);

        //处理sku的编码，在sku编码后面加入当前日期和商品id
        handleSkuStockCode(productParam.getSkuStockList(), productId);

        //添加sku库存信息
        relateAndInsertList(skuStockDao, productParam.getSkuStockList(), productId);

        //添加商品参数,添加自定义商品规格
        relateAndInsertList(productAttributeValueDao, productParam.getProductAttributeValueList(), productId);

        //关联专题
        relateAndInsertList(subjectProductRelationDao, productParam.getSubjectProductRelationList(), productId);

        //关联优选
        relateAndInsertList(prefrenceAreaProductRelationDao, productParam.getPrefrenceAreaProductRelationList(), productId);

        count = 1;
        return count;
    }
}
```


Dao
直接写这几个Dao.xml的SQL语句

    注意使用foreach标签的时候，标签里面的属性是POJO的属性，SQL语句的是数据库表格上的字段，老是会头晕把这2个搞混了，或者foreacha标签里的POJO属性写成字段了。别头晕了。


会员价格Dao
PmsMemberPriceDao.xml
```
//插入会员价格
<mapper namespace="com.taobao.taobaoadmin.dao.pms.PmsMemberPriceDao">
    <!--批量新增回写主键支持-->
    <insert id="insertList">
        insert into pms_member_price (product_id,member_level_id,member_price,member_level_name) VALUES
        <foreach collection="list" item="item" separator="," index="index">
            (#{item.productId,jdbcType=BIGINT},
            #{item.memberLevelId,jdbcType=BIGINT},
            #{item.memberPrice,jdbcType=DECIMAL},
            #{item.memberLevelName,jdbcType=VARCHAR})
        </foreach>
    </insert>
</mapper>
```
阶梯价格Dao
PmsProductLadderDao.xml
```
<mapper namespace="com.taobao.taobaoadmin.dao.pms.PmsProductLadderDao">
    <insert id="insertList">
        insert into pms_product_ladder (product_id, count, discount, price) VALUES
        <foreach collection="list" item="item" separator="," index="index">
            (#{item.productId,jdbcType=BIGINT},
            #{item.count,jdbcType=INTEGER},
            #{item.discount,jdbcType=DECIMAL},
            #{item.price,jdbcType=DECIMAL})
        </foreach>
    </insert>
</mapper>
```

满减价格Dao
PmsProductFullReductionDao.xml
```
<mapper namespace="com.taobao.taobaoadmin.dao.pms.PmsProductFullReductionDao">
    <insert id="insertList">
        insert into pms_product_full_reduction (product_id,full_price,reduce_price) VALUES
        <foreach collection="list" item="item" separator="," index="index">
            (#{item.productId,jdbcType=BIGINT},
            #{item.fullPrice,jdbcType=DECIMAL},
            #{item.reducePrice,jdbcType=DECIMAL})
        </foreach>
    </insert>
</mapper>
```


增加sku库存信息
```
<mapper namespace="com.taobao.taobaoadmin.dao.pms.PmsSkuStockDao">

    <insert id="insertList">
        insert into pms_sku_stock (product_id,sku_code,price,stock,low_stock,sp1,sp2,sp3,pic,sale) VALUES
        <foreach collection="list" item="item" separator="," index="index">
            (#{item.productId,jdbcType=BIGINT},
            #{item.skuCode,jdbcType=VARCHAR},
            #{item.price,jdbcType=DECIMAL},
            #{item.stock,jdbcType=INTEGER},
            #{item.lowStock,jdbcType=INTEGER},
            #{item.sp1,jdbcType=VARCHAR},
            #{item.sp2,jdbcType=VARCHAR},
            #{item.sp3,jdbcType=VARCHAR},
            #{item.pic,jdbcType=VARCHAR},
            #{item.sale,jdbcType=INTEGER})
        </foreach>
    </insert>
</mapper>
```

添加商品参数,添加自定义商品规格
PmsProductAttributeValueDao.xml
```
<mapper namespace="com.taobao.taobaoadmin.dao.pms.PmsProductAttributeValueDao">
    <insert id="insertList">
          insert into pms_product_attribute_value (product_id,product_attribute_id,value) VALUES
          <foreach collection="list" item="item" separator="," index="index">
              (#{item.productId,jdbcType=BIGINT},
              #{item.productAttributeId,jdbcType=BIGINT},
              #{item.value,jdbcType=VARCHAR})
          </foreach>
    </insert>
</mapper>
```

关联专题

```
<mapper namespace="com.taobao.taobaoadmin.dao.CMS.CmsSubjectProductRelationDao">
    <insert id="insertList">
          insert into cms_subject_product_relation (subject_id, product_id) values
          <foreach collection="list" item="item" separator="," index="index">
              (#{item.subjectId,jdbcType=BIGINT}, #{item.productId,jdbcType=BIGINT})
          </foreach>
    </insert>
</mapper>
```

关联优选
CmsPrefrenceAreaProductRelationDao.xml
```
<mapper namespace="com.taobao.taobaoadmin.dao.CMS.CmsPrefrenceAreaProductRelationDao">
    <insert id="insertList">
        insert into cms_prefrence_area_product_relation (prefrence_area_id,product_id) values
        <foreach collection="list" item="item" separator="," index="index">
            (#{item.prefrenceAreaId,jdbcType=BIGINT},#{item.productId,jdbcType=BIGINT})
        </foreach>
    </insert>
</mapper>
```





反射定义：
方法的名称和参数列表才能唯一地决定某个方法
方法反射操作：method.invoke(对象，参数列表)
反射是框架底层的一些方法，比如以后看到的Spring的重要特性DI:控制反转就是这么一个原理，至于为什么使用反射，

    1.首先你能通过任意对象获取类类型即是所有的信息，这个作用以后才能体现；
    2.方法的反射的好处就是解耦，比如说a,b,c对象都要调用 print()方法，正常的想法就是要创建每个对象，并且a.print() b.print() c.print() ，但是使用反射的话，就 print()方法的对象.invoke(a,参数列表)想要用哪个对象就用哪个对象










#疑问：

##问题1：
为什么http://localhost:8883不能访问，但是http://localhost:8883/可以访问（会自动添加home）



##问题2 
在MyBatis中的字段别名有什么用
答：
    不会重复字段，导致数据覆盖。


##问题3

```
#===OSS start===
aliyun.oss.endpoint=oss-cn-shenzhen.aliyuncs.com
aliyun.oss.accessKeyId=test
aliyun.oss.accessKeySecret=test
aliyun.oss.bucketName=macro-oss
aliyun.oss.policy.expire=300
aliyun.oss.maxSize=10
aliyun.oss.callback=http://loc                                                                                                                                                                     alhost:8080/aliyun/oss/callback
aliyun.oss.dir.prefix=mall/images/
#===OSS end===
```


出现子用户没有权限的问题。
思路： 给子用户增加权限，在OSS上增加权限。


##问题4：

阿里的OSS跨域设置没有设置好，导致上传图片失败。所以这个跨域设置是什么？



答：
跨域资源共享（Cross-Origin Resource Sharing），简称 CORS，是 HTML5 提供的标准跨域解决方案，OSS 支持 CORS 标准来实现跨域访问。

跨域访问，或者说 JavaScript 的跨域访问问题，是浏览器出于安全考虑而设置的一个限制，即同源策略。举例说明，当 A，B 两个网站属于不同的域时，如果来自于 A 网站的页面中的 JavaScript 代码希望访问 B 网站的时候，浏览器会拒绝该访问。

然而，在实际应用中，经常会有跨域访问的需求。比如用户的网站 www.a.com，后端使用了 OSS，在网页中提供了使用 JavaScript 实现的上传功能，但是在该页面中，只能向 www.a.com 发送请求，向其他网站发送的请求都会被浏览器拒绝。这样会导致用户上传的数据必须从www.a.com 中转。如果设置了跨域访问的话，用户就可以直接上传到 OSS 而无需从 www.a.com 中转。


**使用情景：**

    使用CORS的主要应用就是在浏览器端使用Ajax直接访问OSS的数据，而无需走用户本身的应用服务器中转。无论上传或者下载。对于同时使用OSS和使用Ajax技术的网站来说，都建议使用CORS来实现与OSS的直接通信。



**参考：**
阿里文档：
https://help.aliyun.com/document_detail/31928.html?spm=5176.11065259.1996646101.searchclickresult.4d1a5607Pf3e9i



##问题 5
描述：
上传操作，使用阿里API，然后API中new出OSSClient对象，需要3个参数，但是因为这里用了springMVC，所以spirngMVC注入过程是怎么样的？

答：



##问题6

描述：
因为不清楚SpringMVC与前端进行数据参数交换的过程，与Strust2的堆栈交换是不一致的吗？那SpringMVC是怎么进行参数配对的？


答：
前端和后端数据的交换----转换成JSON类型进行交换----SPringMVC的XML写有JSON的jra包，所以spring就自动转换成JSon类型。
Spring 注解 
@RequestBody   接收前台的json数据，然后自动把JSON数据封装成JAVABEAN
@ResponseBody  把后台实体类POJO对象转换成JSON，返回到前台

使用注解2个都是自动把数据封装好，具体的要看Spring源码
但是POJO对象的属性名字要和前台表单提交的属性名字一致


strust2是不同于SpringMVC的。区别在于strust2会使用ModelDriven接口，使用值栈来，通过类属性Getting，Setting来实现接收OR设置请求对象参数，SpringMVC使用



SpringMVC 是于方法配对，注解适配器对RequestMapping标记的方法进行适配，将从浏览器种请求的数据（key/value或者表单信息）在方法种的形参会进行参数绑定。方法级别的拦截。

    {终极个人理解{SpringMVC的request与Controller怎么适配的----解析URL，根据URL通过XXX适配器，XXX映射器找到，然后匹配到controller}}

Strust2的堆栈配对完成数据交换，请求参数压入堆栈，同时请求参数实现实体类，返回堆栈进行属性配对，配对成功后，访问数据库。类级别的拦截。



SpringMVC的controller向jsp传递数据的五种方式：
https://ss0.baidu.com/73F1bjeh1BF3odCf/it/u=1567032756,2290023038&fm=85&s=1FA4D5043A621E8858A01098030050B0https://blog.csdn.net/qq_40646143/article/details/79536909

Request适配Controller参考：
https://www.cnblogs.com/fangjian0423/p/springMVC-request-mapping.html（SpringMVC的参数配对源码解析）
https://www.cnblogs.com/xjz1842/p/6385054.html
https://www.cnblogs.com/xjz1842/p/6392976.html
https://www.cnblogs.com/WuXuanKun/p/6203975.html
https://www.cnblogs.com/fsmly/p/10413163.html（controller的参数绑定）


#参考：

https://www.jianshu.com/p/6aebdca025fc（OSS上传参考）
https://github.com/macrozheng/mall-admin-web


https://www.jianshu.com/p/3d91982ce458
https://github.com/macrozheng/mall/blob/master/document/reference/mysql.md
https://www.cnblogs.com/orac/p/6726323.html（There is no getter for property named 'product_id'）



反射参考：https://blog.csdn.net/lixq05/article/details/78029653
"	2019-05-09 10:22:14
kumika	springMVC的参数绑定详解	# springMVC的参数绑定详解


springMVC是怎么匹配POJO类的

JSON的转换
springMVC.XML是使用了标签`<mvc:annotation-driven/>`，是启用注解驱动，注册RequestMappingHandlerMapping和RequestMappingHandlerAdapter（其他类也注册有，只是这2个重点说明）到spring工厂中实例化处理我们的请求。
RequestMappingHandlerAdapter类是请求处理的适配器，是处理哪个类哪个方法和相关数据类型转换器等工作的。
标签`<mvc:annotation-driven/>`可以增加别的转换器
```
<mvc:annotation-driven>
  <mvc:message-converters>
    <bean class="org.example.MyHttpMessageConverter"/>
    <bean class="org.example.MyOtherHttpMessageConverter"/>
  </mvc:message-converters>
</mvc:annotation-driven>
```

转换器初始化，请求发送，在进入目标方法前，注解@RequestBody会调用HttpMessageConverter的实现类读取请求参数，**然后将请求参数绑定到目标方法的参数中**。注解@Response则是返回请求前，调用HttpMessageConverter的实现类读取返回值，将返回值写入响应报文。
举例子：
@response的具体过程是

`RequestMappingHandlerAdapter`进行Handel的时候，会委托给HandleMessage（具体由子类`ServletInvocableHandlerMethod`处理）的invokeAndhandle方法进行处理，这方法又转接给`HandlerMethodReturnValuehandlerComposite`处理。`HandlerMethodReturnValueHandlerComposite`维护了一个`HandlerMethodReturnValueHandler`列表。`HandlerMethodReturnValueHandler`是一个对返回值进行处理的策略接口，这个接口非常重要。然后找到对应的`HandlerMethodReturnValueHandler`对结果值进行处理。最终找到`RequestResponseBodyMethodProcessor`这个Handler（由于使用了@ResponseBody注解）。转换器就在这个RequestResponseBodyMethodProcessor中实现。
转换器获取request的Accept信息，然后获取转换器中支持Accept的MediaType数据，判断转换器中支持的Accept信息是否兼容request的accept，最后根据class和mediaType进行转换，总结：根据Accept使用相对应的转换器。




此外，也可以加入特定的json依赖，使这个依赖成为默认的转换器。

https://www.cnblogs.com/fangjian0423/p/springMVC-request-param-analysis.html(是Controller参数绑定 ---有注解RequestBody的解读)
https://www.cnblogs.com/fangjian0423/p/3716067.html#top关于springMVC的自动JSON转换 ---有注解responseBody的解读
https://www.cnblogs.com/fangjian0423/p/springMVC-databind-typeconvert.html 类型转换和数据绑定[附带源码分析]
https://www.cnblogs.com/w-y-c-m/p/8443892.html（具体的参数绑定源码解析）

绑定参数:
[![根据请求格式进入到不同的转换流程.png](https://i.loli.net/2019/07/11/5d26be3f2658b34097.png)](https://i.loli.net/2019/07/11/5d26be3f2658b34097.png)
BeanWrapperImpl类：

[![beanWrapper下面从上往下依次接受这些接口以及实现类.png](https://i.loli.net/2019/06/28/5d150dafd5f2923396.png)](https://i.loli.net/2019/06/28/5d150dafd5f2923396.png)
Spring主控程序从BeanDefinition中获取Bean属性的配置信息PropertyValue，并使用属性编辑器对PropertyValue进行转换以得到Bean的属性值。对Bean的其他属性重复这样的步骤，就可以完成Bean所有属性的注入工作。BeanWrapperImpl在内部使用Spring的BeanUtils工具类对Bean进行反射操作，设置属性。


SpringMVC的处理request流程？!
简单类型参数：
int  id 
request的请求：/test?id=4396

request进入dispatcherServlet---->doDispatch---->数据参数绑定------->HandlerMethod----->HandlerApapter（确定HandlerAdapter的类型为RequestMappingHandlerAdapter）---->handle方法----》RequestMappingHandlerAdapter的invokeHandleMethod方法




根据request和response创建ServletWebRequest对象webRequest，webRequest为httpRequest包装后的类，添加了uri成员，标记请求uri以便方便分配。
根据handleMethod创建绑定数据工厂binderFactory，----》
根据handleMethod和binderFactory创建SpringMVC使用的model工厂modelFactory
同时也根据这2个参数handleMethod和binderFactory创建ServletInvocableHandlerMethod类requestMappingMethod对象

根据RequestContextUtils里的方法从request获取带有input_flash字样的attributes,然后增加到新创建的ModelAndViewContainer对象mavContainer上。mavContainer为ModelAndViewContainer类对象，用于绑定模块（POJO）和视图（view即网页）。
此时SpringMVC可以有条件（3个参数：webRequest, mavContainer, requestMappingMethod）创建ModelAndViewContainer了
同时requestMappingMethod根据2个参数webRequest和mavContainer使用invokeAndHanldle方法

进入invokeAndHanldle方法：
然后进入invokeForRequest方法，这个方法是从request中解析出handleMethod方法所需要的参数，然后通过反射调用Handlermethod中的method。
此时在invokeForRequest方法中解析是使用getMethodArgumentValues方法，需要3个参数：request, mavContainer, providedArgs（这个是不定参数Object...类型，也可以看作一维数组）

进入getMethodArgumentValues方法：
创建参数数组对象 parameters  这个数组对象此时没有值，

获取所有方法的参数，这个参数是String类型的参数名字，还是参数对象




Java大于1.8是采用反射获取参数名，小于1.8是读取Class文件获取参数名



https://www.cnblogs.com/w-y-c-m/p/8443892.html（参数绑定原理）
https://github.com/wycm/SpringMVC-Demo


https://www.cnblogs.com/leftthen/p/5229204.html（handleMethod和MethodParameter类的源码解析）

https://blog.csdn.net/z69183787/article/details/81117525（Spring查找参数解析到底层源码）
https://www.cnblogs.com/guangshan/p/4431800.html（完整解析springMVC的参数绑定，参数绑定的流程）
https://www.cnblogs.com/guangshan/p/4660564.html（反射获取一个参数名，对`MethodParameter[] parameters = getMethodParameters()`语句的解析）


https://blog.csdn.net/qq271859852/article/details/84963672（参数解析之MethodParameter类的属性和源码解析无注解的参数绑定---解析到Class文件）


https://cheng-xinwei.iteye.com/blog/2008507（有getNamedValueInfo(parameter);的解析）

https://blog.csdn.net/j080624/article/details/58041191（具体的参数绑定过程）
https://www.jianshu.com/p/28a7f335729f（源码查询过程，要认真看看是怎么查询过程的）

https://www.jianshu.com/p/f4653fe8c935（源码分析之 HandlerMethodArgumentResolver）

https://www.jianshu.com/p/6f841d81ed72（springMVC的请求流程）

https://www.cnblogs.com/guangshan/p/4431800.html（数据绑定，bind方法中applyPropertyValues(mpvs);方法把所有属性绑定到bean实体类中。）


https://blog.csdn.net/shenchaohao12321/article/details/86667511（Spring MVC设计原理----看WebDataBinder的源码解析）

https://blog.csdn.net/shenchaohao12321/article/details/80356890（DataBinder源码）

https://blog.csdn.net/gdutxiaoxu/article/details/68947735（反射详解）
https://blog.csdn.net/sinat_38259539/article/details/71799078（反射详解）


注解RequestParam的重要作用是当请求表单上属性名与Controller上的形参名不一致的时候使用，其他的作用都是派生出来的作用。

NamedValueInfo对象是根据MethodParameter类parameter对象作为参数，创建一个目标方法内有属性名，不知道属性值的对象


NameValueInfo对象的属性名和方法参数parameter对象的属性名对比，属性名一致后，NameValueInfo与WebRequest进行匹配，（就是request的值赋值给NameValueInfo）然后绑定赋值，随后返回


根据args数组对象，查询方法，然后调用method，返回一个返回值（类型不知道）


request参数是简单类型与参数是对象，哪里出现分配任务？


交给ServletModelAttributeMethodProcessor这个类，在初始化argumentResolvers的时候


HandlerMapping----》得到HandlerExecutionChain，返回dispatcher Servlet----》HandlerExecutionChain遍历handleAdapter找到合适的HandlerAdapter-----》handlerAdapter的实现类requestMappingHandlerAdapter----》初始化各类argumentResolvers，也就是初始化24个参数解析器，2个大类----基于注解的解析器和基于类型的参数解析器----》解析器进入HandlerMethodArgumentResolverComposite类加入参数解析---》后面就是进行参数绑定的情况了。

参数绑定：
根据NativeWebRequest类 request，mavContainer,方法参数列表 parameter ,绑定工厂 binderFactory 作为4个参数进入resolveArgument方法进行参数的绑定，参数名的赋值是在查询方法参数列表parameter的时候进行的，
根据参数parameter，创建一个NameValueInfo对象 nameValueInfo，这个对象存放的是参数名，是否必须，参数默认值。

参数赋值：（这个参数的值是从request获取的，赋值到nameValueinfo对象去，而parameter获取的是参数名的值，注意区分啊。）
```
//根据参数名解析出对象的值，就是根据方法的参数名来获取request中的参数
Object arg = resolveName(namedValueInfo.name, parameter, webRequest);
```
然后进入resolverName方法解析参数：
宗旨：根据方法的参数名来获取request中的参数。
[![10568892-38c80f56590d9808.png](https://i.loli.net/2019/07/06/5d2014b5dbf8313646.png)](https://i.loli.net/2019/07/06/5d2014b5dbf8313646.png)

实现HandlerMethodArgumentResolver接口，初始化SpringMVC默认的方法参数解析器（根据注解OR类型解析参数的解析器），参数解析器获取request的参数名，从webRequest获取参数的值，然后创建一个过渡对象NameValueInfo，用于装参数名，后端设置参数值的默认值，然后根据NameValueInfo对象内装的参数名，结合request获取参数值，最后返回Object对象arg。完成从request中获取参数值。




此时arg对象内装的是参数值，没有参数名。
比如：
```
http://localhost:8080/methodOne?fieldTwo=jack
```
此时arg装的参数值是`Jack`，参数名`fieldTwo`是没有的。
参数名和参数值的绑定是依靠WebDataBinder类的对象binder绑定器完成的，binder的作用之一是创建Bean（POJO对象OR简单类型对象），然后把传入参数值（String类型）转换成POJO类型OR简单类型对象

```
// 生成参数绑定器，第一个参数为request请求对象，第二个参数为需要绑定的目标对象，第三个参数为需要绑定的目标对象名
WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);

// 将参数转到预期类型，第一个参数为解析后的值，第二个参数为绑定Controller参数的类型，第三个参数为绑定的Controller参数
arg = binder.convertIfNecessary(arg, paramType, parameter);
```
最后arg对象的类型转换成了想要的类型。参数绑定的过程就是创建绑定器binder的过程。因为你得到了参数名，也有参数值，



说明nameValueInfo的作用，binder的作用，绑定过程是发生在哪一个作用中的？

现在是参数值在arg对象上，参数名在nameValueInfo和parameter上，并没有完成一次参数绑定，参数值和参数名都在各自的变量上，没有合并。

nameValueInfo还有一个功能就是设置参数默认值，设置后就执行BinderFactory语句了。

1 将参数类型和请求数据发送给`DataBinder`，
2 DataBinder将参数类型和请求数据再发给类型转换器`TypeConverter`，由类型转换器`TypeConverter`装配成一个bean，
3 类型转换器`TypeConverter`根据bean中的成员类型，在属性编辑器工厂`PropertyEditorRegistry`中查找已注册的属性编辑器`PropertyEditor`接口，
4 属性编辑器`PropertyEditor`接口将数据setter进bean中的成员，
5 `TypeConverter`将装配好的bean返回给DataBinder，
6 DataBinder将装配bean交给处理请求的方法

在参数绑定的过程TypeConverter和PropertyEditor是最核心的数据转化成对象（非序列化）的过程类型转换器TypeConverter负责将数据转化成一个bean，属性编辑器PropertyEditor负责将数据转化成一个成员字段





当参数是简单类型比如：int类型，进入BinderFactory创建Binder，然后发送给类型转换器TypeConverter，类型转换器TypeConverter根据参数类型，装配成一个Bean，在属性编辑注册工厂PropertyEditorRegistry查询合适的属性编辑器propertyEditor，然后PropertyEditor使用setAsText方法和setValue方法（这是Bean类的方法，底层方法），对参数值包装，包装成简单类型对象赋值给bean的属性，也就是此时属性值是对象了，不是String类型了 ，完成string---object，object----object的转化


个人理解：
页面发送请求
请求表单上的参数全部都是String类型，但是是包装好的（多个属性封装成一个对象比如User），不过值是String而已。
（现在很少直接使用属性编译器propertyEditor接口直接获取属性值，都是使用propertyEditor的继承者BeanWrapper接口设置属性值，更普遍的是使用包含了BeanWrapper的Binder或者是BeanFactory设置属性值，因为这里要学习源码，这里的propertyEditor就是原始的设置属性值方法了）
编译器工厂查询到适合参数类型的编译器进入到了该类型的编译器XXXpropertyEditor执行属性编译器方法的时候，重写setAsText()方法，设置属性的值setValue方法里会new一个参数类型对象（你配置好 的配置文件指示new参数类型对象，基本数据类型以包装类传入），把参数值（String类型）赋值给这个对象（POJO类OR基本数据类型包装类），完成数据类型转换，类型对象的属性获得了参数值，最后，propertyEditor返回对象是Bean。

关于propertyEditor和BeanWrapper的关系
[![BeanWrapper、DataBinder、ConversionService、Formatter之间的关系.png](https://i.loli.net/2019/07/11/5d26be04d3a9b84458.png)](https://i.loli.net/2019/07/11/5d26be04d3a9b84458.png)
BeanWrapper的使用方法
```
Foo foo = new Foo();
BeanWrapperImpl fooWrapper = new BeanWrapperImpl(foo);
fooWrapper.setPropertyValue("intProperty", "1");
Object intProperty = fooWrapper.getPropertyValue("intProperty");
```

property Editor是否创建一个Bean对象？
是的，先创建一个Bean对象，简单类型就创建简单类型对象，把参数值转换成类型对象，然后使用setValue设置值，就是setValue（简单类型.parse简单类型（参数值））。
POJO对象就创建POJO对象，在POJO属性编译器中写上对POJO对象属性的赋值，此时也要注意属性值类型的转换（String转换成属性类型对象），因为属性值类型是要与属性类型一致的，就是
```
    //①将字面值转换为属性类型对象  
    public void setAsText(String text){   
        if(text == null || text.indexOf(",") == -1){  
            throw new IllegalArgumentException("设置的字符串格式不正确");  
        }  
        String[] infos = text.split(",");  
        Car car = new Car();  
        car.setBrand(infos[0]);  
        car.setMaxSpeed(Integer.parseInt(infos[1]));  
        car.setPrice(Double.parseDouble(infos[2]));  
  
         //②调用父类的setValue()方法设置转换后的属性对象  
        setValue(car);   
    }  
```
setAsText负责将配置文件以字符串提供的字面值转换为Car对象。字面值采用逗号分隔的格式同时为brand、maxSpeed和price属性值提供设置值，setAsText()方法解析这个字面值并生成对应的Car对象。

简单说就是propertyEditor是简单类型转换是自带的，POJO对象则是自己需要什么POJO对象转换就自己配置什么，但是不能出现任意对象类型---转换---任意对象类型，同时也要自己写POJO属性编辑器，很繁琐。此时出现了BeanWrapper接口。


BeanWrapper是在已经拿到一个Bean对象的基础上，对这个Bean对象进行属性赋值。
书面语：

    要顺利地填充Bean属性，除了目标Bean实例和属性编辑器外，还需要获取Bean对应的BeanDefinition，它从Spring容器的BeanDefinitionRegistry中直接获取。Spring主控程序从BeanDefinition中获取Bean属性的配置信息PropertyValue，并使用属性编辑器对PropertyValue进行转换以得到Bean的属性值。对Bean的其他属性重复这样的步骤，就可以完成Bean所有属性的注入工作。


通常情况下，我们不在应用程序中直接使用BeanWrapper而是使用DataBinder 和BeanFactory。

借助Binder，从request获取参数值，完成参数转换，
在Binder内借助Bean wrapper接口，创建Bean对象并且把参数值赋值到Bean对象的属性上，完成参数绑定（就是创建对象，然后赋值----说成绑定卧槽，简直就是误导啊。）


PropertyEditor的缺点（为什么要换成Converter）
PropertyEditor被设计为只能String<——>Object之间转换，不能任意对象类型<——>任意类型，如我们常见的Long时间戳到Date类型的转换是办不到的；

（2、PropertyEditor是线程不安全的，也就是有状态的，因此每次使用时都需要创建一个，不可重用；

（3、PropertyEditor不是强类型的，setValue（Object）可以接受任意类型，因此需要我们自己判断类型是否兼容；




webDataBinder的具体作用
WebDataBinder与包含的对象的类型结构图
三角箭头代表继承关系，菱形箭头代表包含关系
[![WebDataBinder与包含的对象的类型结构图三角箭头代表继承关系，菱形箭头代表包含关系.jpg](https://i.loli.net/2019/07/09/5d24143e3a25f18360.jpg)](https://i.loli.net/2019/07/09/5d24143e3a25f18360.jpg)
WebDataBinder处理数据绑定时序图
[![WebDataBinder处理数据绑定时序图.jpg](https://i.loli.net/2019/07/09/5d2413e09bb4129165.jpg)](https://i.loli.net/2019/07/09/5d2413e09bb4129165.jpg)
1、数据绑定 
bind(PropertyValues pvs)方法，通过HandlerMethodResolver传入属性信息，然后通过AbstractNestablePropertyAccessor处理级联对象，并设置值到 target 中，如此完成数据绑定功能。 
2、数据转换。 
WebDataBinder处理类型转换时序图
[![WebDataBinder处理类型转换时序图.jpg](https://i.loli.net/2019/07/09/5d2414227061b53982.jpg)](https://i.loli.net/2019/07/09/5d2414227061b53982.jpg)
数据转换实际上都是通过TypeConverterDelegate 委托类型来处理的，该委托类型持有一个PropertyEditorRegistrySupport的引用（BeanWrapperImpl或者SimpleTypeConverter） 通过PropertyEditorRegistrySupport获得CustomEditor和ConversionService和DefaultEditor， 
生效顺序： 
1、CustomEditor，使用者注册的PropertyEditor。 
2、ConversionService 
3、DefaultEditor




对象绑定：
不同于简单基本类型绑定，对象绑定会交给ServletModelAttributeMethodProcessor这个类，在初始化argumentResolvers的时候。是会创建两个不同的ServletModelAttributeMethodProcessor对象的。

在RequestMappingHandlerAdapter的方法afterPropertiesSet（）中初始化了参数解析器，方法是getDefaultArgumentResolvers()，所以在getDefaultArgumentResolvers()中参数解析器根据 不同的类型参数增加解析器
```
resolvers.add(new ServletModelAttributeMethodProcessor(false));
resolvers.add(new ServletModelAttributeMethodProcessor(true));
```
这2个返回true和false有什么区别？
判断参数带有@ModelAttribute,带有返回true，没有返回false。
同时也判断参数是否是简单类型，是简单类型返回false，不是就返回true。
```
    //将请求绑定至目标binder的target对象，也就是刚刚创建的attribute对象。
    bindRequestParameters(binder, request);
    //如果有验证，则验证参数
    validateIfApplicable(binder, parameter);
```



https://www.iteye.com/topic/1123628（PropertyEditor详解）
https://blog.csdn.net/abc997995674/article/details/80384151（PropertyEditor应用）

http://shouce.jb51.net/spring/validation.html（BeanWrapper与propertyEditor的关系）

https://segmentfault.com/a/1190000008938863（BeanWrapper、DataBinder、ConversionService、Formatter的关系）
https://blog.csdn.net/alex_xfboy/article/details/88076245（SpringMVC流程同时也说了下BeanWrapper、DataBinder、ConversionService、Formatter的关系）

https://blog.csdn.net/shenchaohao12321/article/details/80295371（看自定义属性编辑器理解，理解参数值的类型，参数类型实体化，参数值与实体类赋值，完成类型转换）

https://www.cnblogs.com/guangshan/p/4431800.html（参数绑定，简单类型和POJO对象类型）

https://www.cnblogs.com/wewill/p/5676920.html（参数绑定流程---解析属性编辑器和类型编辑器）
https://blog.csdn.net/chengguotao/article/details/47009095（SpringMVC--数据进行类型转换）
https://my.oschina.net/chkui/blog/1975596（转换数据过程）

https://my.oschina.net/bieber/blog/395173（BeanWrapper的出现和PropertyEditor）
https://my.oschina.net/sugarZone/blog/705169#h3_1（属性编辑器讲解例子）
https://www.jianshu.com/p/f89a279141b9（BeanWrapper中使用属性编辑器PropertyEditor的过程）



https://my.oschina.net/kings0/blog/725415（WebDataBinder解析）
https://blog.csdn.net/yzx2015fd/article/details/54406591（webDataBinder的具体流程，数据转换，数据绑定） 

https://my.oschina.net/sugarZone/blog/706417（使用Converter类型转换的解析）
https://segmentfault.com/a/1190000014497947(Spring IOC Type Converter)

https://blog.csdn.net/zzc1684/article/details/84627069（3个Converter接口的例子）
https://my.oschina.net/kings0/blog/729437#h1_19（3个Converter接口的例子）
https://segmentfault.com/a/1190000009163158（不同格式的POST请求参数的数据类型转换过程）
https://segmentfault.com/a/1190000012555875（SpringMVC传递JSON数据的推荐方式）
https://www.cnblogs.com/jyyzzjl/p/5459335.html（IOC的实体例子）




	2019-07-11 12:24:44
kumika	springMVC的参数绑定详解	# springMVC的参数绑定详解


springMVC是怎么匹配POJO类的

JSON的转换
springMVC.XML是使用了标签`<mvc:annotation-driven/>`，是启用注解驱动，注册RequestMappingHandlerMapping和RequestMappingHandlerAdapter（其他类也注册有，只是这2个重点说明）到spring工厂中实例化处理我们的请求。
RequestMappingHandlerAdapter类是请求处理的适配器，是处理哪个类哪个方法和相关数据类型转换器等工作的。
标签`<mvc:annotation-driven/>`可以增加别的转换器
```
<mvc:annotation-driven>
  <mvc:message-converters>
    <bean class="org.example.MyHttpMessageConverter"/>
    <bean class="org.example.MyOtherHttpMessageConverter"/>
  </mvc:message-converters>
</mvc:annotation-driven>
```

转换器初始化，请求发送，在进入目标方法前，注解@RequestBody会调用HttpMessageConverter的实现类读取请求参数，**然后将请求参数绑定到目标方法的参数中**。注解@Response则是返回请求前，调用HttpMessageConverter的实现类读取返回值，将返回值写入响应报文。
举例子：
@response的具体过程是

`RequestMappingHandlerAdapter`进行Handel的时候，会委托给HandleMessage（具体由子类`ServletInvocableHandlerMethod`处理）的invokeAndhandle方法进行处理，这方法又转接给`HandlerMethodReturnValuehandlerComposite`处理。`HandlerMethodReturnValueHandlerComposite`维护了一个`HandlerMethodReturnValueHandler`列表。`HandlerMethodReturnValueHandler`是一个对返回值进行处理的策略接口，这个接口非常重要。然后找到对应的`HandlerMethodReturnValueHandler`对结果值进行处理。最终找到`RequestResponseBodyMethodProcessor`这个Handler（由于使用了@ResponseBody注解）。转换器就在这个RequestResponseBodyMethodProcessor中实现。
转换器获取request的Accept信息，然后获取转换器中支持Accept的MediaType数据，判断转换器中支持的Accept信息是否兼容request的accept，最后根据class和mediaType进行转换，总结：根据Accept使用相对应的转换器。




此外，也可以加入特定的json依赖，使这个依赖成为默认的转换器。

https://www.cnblogs.com/fangjian0423/p/springMVC-request-param-analysis.html(是Controller参数绑定 ---有注解RequestBody的解读)
https://www.cnblogs.com/fangjian0423/p/3716067.html#top关于springMVC的自动JSON转换 ---有注解responseBody的解读
https://www.cnblogs.com/fangjian0423/p/springMVC-databind-typeconvert.html 类型转换和数据绑定[附带源码分析]
https://www.cnblogs.com/w-y-c-m/p/8443892.html（具体的参数绑定源码解析）

绑定参数:

BeanWrapperImpl类：

[![beanWrapper下面从上往下依次接受这些接口以及实现类.png](https://i.loli.net/2019/06/28/5d150dafd5f2923396.png)](https://i.loli.net/2019/06/28/5d150dafd5f2923396.png)
Spring主控程序从BeanDefinition中获取Bean属性的配置信息PropertyValue，并使用属性编辑器对PropertyValue进行转换以得到Bean的属性值。对Bean的其他属性重复这样的步骤，就可以完成Bean所有属性的注入工作。BeanWrapperImpl在内部使用Spring的BeanUtils工具类对Bean进行反射操作，设置属性。


SpringMVC的处理request流程？!
简单类型参数：
int  id 
request的请求：/test?id=4396

request进入dispatcherServlet---->doDispatch---->数据参数绑定------->HandlerMethod----->HandlerApapter（确定HandlerAdapter的类型为RequestMappingHandlerAdapter）---->handle方法----》RequestMappingHandlerAdapter的invokeHandleMethod方法




根据request和response创建ServletWebRequest对象webRequest，webRequest为httpRequest包装后的类，添加了uri成员，标记请求uri以便方便分配。
根据handleMethod创建绑定数据工厂binderFactory，----》
根据handleMethod和binderFactory创建SpringMVC使用的model工厂modelFactory
同时也根据这2个参数handleMethod和binderFactory创建ServletInvocableHandlerMethod类requestMappingMethod对象

根据RequestContextUtils里的方法从request获取带有input_flash字样的attributes,然后增加到新创建的ModelAndViewContainer对象mavContainer上。mavContainer为ModelAndViewContainer类对象，用于绑定模块（POJO）和视图（view即网页）。
此时SpringMVC可以有条件（3个参数：webRequest, mavContainer, requestMappingMethod）创建ModelAndViewContainer了
同时requestMappingMethod根据2个参数webRequest和mavContainer使用invokeAndHanldle方法

进入invokeAndHanldle方法：
然后进入invokeForRequest方法，这个方法是从request中解析出handleMethod方法所需要的参数，然后通过反射调用Handlermethod中的method。
此时在invokeForRequest方法中解析是使用getMethodArgumentValues方法，需要3个参数：request, mavContainer, providedArgs（这个是不定参数Object...类型，也可以看作一维数组）

进入getMethodArgumentValues方法：
创建参数数组对象 parameters  这个数组对象此时没有值，

获取所有方法的参数，这个参数是String类型的参数名字，还是参数对象




Java大于1.8是采用反射获取参数名，小于1.8是读取Class文件获取参数名



https://www.cnblogs.com/w-y-c-m/p/8443892.html（参数绑定原理）
https://github.com/wycm/SpringMVC-Demo


https://www.cnblogs.com/leftthen/p/5229204.html（handleMethod和MethodParameter类的源码解析）

https://blog.csdn.net/z69183787/article/details/81117525（Spring查找参数解析到底层源码）
https://www.cnblogs.com/guangshan/p/4431800.html（完整解析springMVC的参数绑定，参数绑定的流程）
https://www.cnblogs.com/guangshan/p/4660564.html（反射获取一个参数名，对`MethodParameter[] parameters = getMethodParameters()`语句的解析）


https://blog.csdn.net/qq271859852/article/details/84963672（参数解析之MethodParameter类的属性和源码解析无注解的参数绑定---解析到Class文件）


https://cheng-xinwei.iteye.com/blog/2008507（有getNamedValueInfo(parameter);的解析）

https://blog.csdn.net/j080624/article/details/58041191（具体的参数绑定过程）
https://www.jianshu.com/p/28a7f335729f（源码查询过程，要认真看看是怎么查询过程的）

https://www.jianshu.com/p/f4653fe8c935（源码分析之 HandlerMethodArgumentResolver）

https://www.jianshu.com/p/6f841d81ed72（springMVC的请求流程）

https://www.cnblogs.com/guangshan/p/4431800.html（数据绑定，bind方法中applyPropertyValues(mpvs);方法把所有属性绑定到bean实体类中。）


https://blog.csdn.net/shenchaohao12321/article/details/86667511（Spring MVC设计原理----看WebDataBinder的源码解析）

https://blog.csdn.net/shenchaohao12321/article/details/80356890（DataBinder源码）

https://blog.csdn.net/gdutxiaoxu/article/details/68947735（反射详解）
https://blog.csdn.net/sinat_38259539/article/details/71799078（反射详解）


注解RequestParam的重要作用是当请求表单上属性名与Controller上的形参名不一致的时候使用，其他的作用都是派生出来的作用。

NamedValueInfo对象是根据MethodParameter类parameter对象作为参数，创建一个目标方法内有属性名，不知道属性值的对象


NameValueInfo对象的属性名和方法参数parameter对象的属性名对比，属性名一致后，NameValueInfo与WebRequest进行匹配，（就是request的值赋值给NameValueInfo）然后绑定赋值，随后返回


根据args数组对象，查询方法，然后调用method，返回一个返回值（类型不知道）


request参数是简单类型与参数是对象，哪里出现分配任务？


交给ServletModelAttributeMethodProcessor这个类，在初始化argumentResolvers的时候


HandlerMapping----》得到HandlerExecutionChain，返回dispatcher Servlet----》HandlerExecutionChain遍历handleAdapter找到合适的HandlerAdapter-----》handlerAdapter的实现类requestMappingHandlerAdapter----》初始化各类argumentResolvers，也就是初始化24个参数解析器，2个大类----基于注解的解析器和基于类型的参数解析器----》解析器进入HandlerMethodArgumentResolverComposite类加入参数解析---》后面就是进行参数绑定的情况了。

参数绑定：
根据NativeWebRequest类 request，mavContainer,方法参数列表 parameter ,绑定工厂 binderFactory 作为4个参数进入resolveArgument方法进行参数的绑定，参数名的赋值是在查询方法参数列表parameter的时候进行的，
根据参数parameter，创建一个NameValueInfo对象 nameValueInfo，这个对象存放的是参数名，是否必须，参数默认值。

参数赋值：（这个参数的值是从request获取的，赋值到nameValueinfo对象去，而parameter获取的是参数名的值，注意区分啊。）
```
//根据参数名解析出对象的值，就是根据方法的参数名来获取request中的参数
Object arg = resolveName(namedValueInfo.name, parameter, webRequest);
```
然后进入resolverName方法解析参数：
宗旨：根据方法的参数名来获取request中的参数。
[![10568892-38c80f56590d9808.png](https://i.loli.net/2019/07/06/5d2014b5dbf8313646.png)](https://i.loli.net/2019/07/06/5d2014b5dbf8313646.png)

实现HandlerMethodArgumentResolver接口，初始化SpringMVC默认的方法参数解析器（根据注解OR类型解析参数的解析器），参数解析器获取request的参数名，从webRequest获取参数的值，然后创建一个过渡对象NameValueInfo，用于装参数名，后端设置参数值的默认值，然后根据NameValueInfo对象内装的参数名，结合request获取参数值，最后返回Object对象arg。完成从request中获取参数值。




此时arg对象内装的是参数值，没有参数名。
比如：
```
http://localhost:8080/methodOne?fieldTwo=jack
```
此时arg装的参数值是`Jack`，参数名`fieldTwo`是没有的。
参数名和参数值的绑定是依靠WebDataBinder类的对象binder绑定器完成的，binder的作用之一是创建Bean（POJO对象OR简单类型对象），然后把传入参数值（String类型）转换成POJO类型OR简单类型对象

```
// 生成参数绑定器，第一个参数为request请求对象，第二个参数为需要绑定的目标对象，第三个参数为需要绑定的目标对象名
WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);

// 将参数转到预期类型，第一个参数为解析后的值，第二个参数为绑定Controller参数的类型，第三个参数为绑定的Controller参数
arg = binder.convertIfNecessary(arg, paramType, parameter);
```
最后arg对象的类型转换成了想要的类型。参数绑定的过程就是创建绑定器binder的过程。因为你得到了参数名，也有参数值，



说明nameValueInfo的作用，binder的作用，绑定过程是发生在哪一个作用中的？

现在是参数值在arg对象上，参数名在nameValueInfo和parameter上，并没有完成一次参数绑定，参数值和参数名都在各自的变量上，没有合并。

nameValueInfo还有一个功能就是设置参数默认值，设置后就执行BinderFactory语句了。

1 将参数类型和请求数据发送给`DataBinder`，
2 DataBinder将参数类型和请求数据再发给类型转换器`TypeConverter`，由类型转换器`TypeConverter`装配成一个bean，
3 类型转换器`TypeConverter`根据bean中的成员类型，在属性编辑器工厂`PropertyEditorRegistry`中查找已注册的属性编辑器`PropertyEditor`接口，
4 属性编辑器`PropertyEditor`接口将数据setter进bean中的成员，
5 `TypeConverter`将装配好的bean返回给DataBinder，
6 DataBinder将装配bean交给处理请求的方法

在参数绑定的过程TypeConverter和PropertyEditor是最核心的数据转化成对象（非序列化）的过程类型转换器TypeConverter负责将数据转化成一个bean，属性编辑器PropertyEditor负责将数据转化成一个成员字段





当参数是简单类型比如：int类型，进入BinderFactory创建Binder，然后发送给类型转换器TypeConverter，类型转换器TypeConverter根据参数类型，装配成一个Bean，在属性编辑注册工厂PropertyEditorRegistry查询合适的属性编辑器propertyEditor，然后PropertyEditor使用setAsText方法和setValue方法（这是Bean类的方法，底层方法），对参数值包装，包装成简单类型对象赋值给bean的属性，也就是此时属性值是对象了，不是String类型了 ，完成string---object，object----object的转化


个人理解：
页面发送请求
请求表单上的参数全部都是String类型，但是是包装好的（多个属性封装成一个对象比如User），不过值是String而已。
（现在很少直接使用属性编译器propertyEditor接口直接获取属性值，都是使用propertyEditor的继承者BeanWrapper接口设置属性值，更普遍的是使用包含了BeanWrapper的Binder或者是BeanFactory设置属性值，因为这里要学习源码，这里的propertyEditor就是原始的设置属性值方法了）
编译器工厂查询到适合参数类型的编译器进入到了该类型的编译器XXXpropertyEditor执行属性编译器方法的时候，重写setAsText()方法，设置属性的值setValue方法里会new一个参数类型对象（你配置好 的配置文件指示new参数类型对象，基本数据类型以包装类传入），把参数值（String类型）赋值给这个对象（POJO类OR基本数据类型包装类），完成数据类型转换，类型对象的属性获得了参数值，最后，propertyEditor返回对象是Bean。

关于propertyEditor和BeanWrapper的关系

BeanWrapper的使用方法
```
Foo foo = new Foo();
BeanWrapperImpl fooWrapper = new BeanWrapperImpl(foo);
fooWrapper.setPropertyValue("intProperty", "1");
Object intProperty = fooWrapper.getPropertyValue("intProperty");
```

property Editor是否创建一个Bean对象？
是的，先创建一个Bean对象，简单类型就创建简单类型对象，把参数值转换成类型对象，然后使用setValue设置值，就是setValue（简单类型.parse简单类型（参数值））。
POJO对象就创建POJO对象，在POJO属性编译器中写上对POJO对象属性的赋值，此时也要注意属性值类型的转换（String转换成属性类型对象），因为属性值类型是要与属性类型一致的，就是
```
    //①将字面值转换为属性类型对象  
    public void setAsText(String text){   
        if(text == null || text.indexOf(",") == -1){  
            throw new IllegalArgumentException("设置的字符串格式不正确");  
        }  
        String[] infos = text.split(",");  
        Car car = new Car();  
        car.setBrand(infos[0]);  
        car.setMaxSpeed(Integer.parseInt(infos[1]));  
        car.setPrice(Double.parseDouble(infos[2]));  
  
         //②调用父类的setValue()方法设置转换后的属性对象  
        setValue(car);   
    }  
```
setAsText负责将配置文件以字符串提供的字面值转换为Car对象。字面值采用逗号分隔的格式同时为brand、maxSpeed和price属性值提供设置值，setAsText()方法解析这个字面值并生成对应的Car对象。

简单说就是propertyEditor是简单类型转换是自带的，POJO对象则是自己需要什么POJO对象转换就自己配置什么，但是不能出现任意对象类型---转换---任意对象类型，同时也要自己写POJO属性编辑器，很繁琐。此时出现了BeanWrapper接口。


BeanWrapper是在已经拿到一个Bean对象的基础上，对这个Bean对象进行属性赋值。
书面语：

    要顺利地填充Bean属性，除了目标Bean实例和属性编辑器外，还需要获取Bean对应的BeanDefinition，它从Spring容器的BeanDefinitionRegistry中直接获取。Spring主控程序从BeanDefinition中获取Bean属性的配置信息PropertyValue，并使用属性编辑器对PropertyValue进行转换以得到Bean的属性值。对Bean的其他属性重复这样的步骤，就可以完成Bean所有属性的注入工作。


通常情况下，我们不在应用程序中直接使用BeanWrapper而是使用DataBinder 和BeanFactory。

借助Binder，从request获取参数值，完成参数转换，
在Binder内借助Bean wrapper接口，创建Bean对象并且把参数值赋值到Bean对象的属性上，完成参数绑定（就是创建对象，然后赋值----说成绑定卧槽，简直就是误导啊。）


PropertyEditor的缺点（为什么要换成Converter）
PropertyEditor被设计为只能String<——>Object之间转换，不能任意对象类型<——>任意类型，如我们常见的Long时间戳到Date类型的转换是办不到的；

（2、PropertyEditor是线程不安全的，也就是有状态的，因此每次使用时都需要创建一个，不可重用；

（3、PropertyEditor不是强类型的，setValue（Object）可以接受任意类型，因此需要我们自己判断类型是否兼容；




webDataBinder的具体作用
WebDataBinder与包含的对象的类型结构图
三角箭头代表继承关系，菱形箭头代表包含关系
[![WebDataBinder与包含的对象的类型结构图三角箭头代表继承关系，菱形箭头代表包含关系.jpg](https://i.loli.net/2019/07/09/5d24143e3a25f18360.jpg)](https://i.loli.net/2019/07/09/5d24143e3a25f18360.jpg)
WebDataBinder处理数据绑定时序图
[![WebDataBinder处理数据绑定时序图.jpg](https://i.loli.net/2019/07/09/5d2413e09bb4129165.jpg)](https://i.loli.net/2019/07/09/5d2413e09bb4129165.jpg)
1、数据绑定 
bind(PropertyValues pvs)方法，通过HandlerMethodResolver传入属性信息，然后通过AbstractNestablePropertyAccessor处理级联对象，并设置值到 target 中，如此完成数据绑定功能。 
2、数据转换。 
WebDataBinder处理类型转换时序图
[![WebDataBinder处理类型转换时序图.jpg](https://i.loli.net/2019/07/09/5d2414227061b53982.jpg)](https://i.loli.net/2019/07/09/5d2414227061b53982.jpg)
数据转换实际上都是通过TypeConverterDelegate 委托类型来处理的，该委托类型持有一个PropertyEditorRegistrySupport的引用（BeanWrapperImpl或者SimpleTypeConverter） 通过PropertyEditorRegistrySupport获得CustomEditor和ConversionService和DefaultEditor， 
生效顺序： 
1、CustomEditor，使用者注册的PropertyEditor。 
2、ConversionService 
3、DefaultEditor




对象绑定：
不同于简单基本类型绑定，对象绑定会交给ServletModelAttributeMethodProcessor这个类，在初始化argumentResolvers的时候。是会创建两个不同的ServletModelAttributeMethodProcessor对象的。

在RequestMappingHandlerAdapter的方法afterPropertiesSet（）中初始化了参数解析器，方法是getDefaultArgumentResolvers()，所以在getDefaultArgumentResolvers()中参数解析器根据 不同的类型参数增加解析器
```
resolvers.add(new ServletModelAttributeMethodProcessor(false));
resolvers.add(new ServletModelAttributeMethodProcessor(true));
```
这2个返回true和false有什么区别？
判断参数带有@ModelAttribute,带有返回true，没有返回false。
同时也判断参数是否是简单类型，是简单类型返回false，不是就返回true。
```
    //将请求绑定至目标binder的target对象，也就是刚刚创建的attribute对象。
    bindRequestParameters(binder, request);
    //如果有验证，则验证参数
    validateIfApplicable(binder, parameter);
```



https://www.iteye.com/topic/1123628（PropertyEditor详解）
https://blog.csdn.net/abc997995674/article/details/80384151（PropertyEditor应用）

http://shouce.jb51.net/spring/validation.html（BeanWrapper与propertyEditor的关系）

https://segmentfault.com/a/1190000008938863（BeanWrapper、DataBinder、ConversionService、Formatter的关系）
https://blog.csdn.net/alex_xfboy/article/details/88076245（SpringMVC流程同时也说了下BeanWrapper、DataBinder、ConversionService、Formatter的关系）

https://blog.csdn.net/shenchaohao12321/article/details/80295371（看自定义属性编辑器理解，理解参数值的类型，参数类型实体化，参数值与实体类赋值，完成类型转换）

https://www.cnblogs.com/guangshan/p/4431800.html（参数绑定，简单类型和POJO对象类型）

https://www.cnblogs.com/wewill/p/5676920.html（参数绑定流程---解析属性编辑器和类型编辑器）
https://blog.csdn.net/chengguotao/article/details/47009095（SpringMVC--数据进行类型转换）
https://my.oschina.net/chkui/blog/1975596（转换数据过程）

https://my.oschina.net/bieber/blog/395173（BeanWrapper的出现和PropertyEditor）
https://my.oschina.net/sugarZone/blog/705169#h3_1（属性编辑器讲解例子）
https://www.jianshu.com/p/f89a279141b9（BeanWrapper中使用属性编辑器PropertyEditor的过程）



https://my.oschina.net/kings0/blog/725415（WebDataBinder解析）
https://blog.csdn.net/yzx2015fd/article/details/54406591（webDataBinder的具体流程，数据转换，数据绑定） 

https://my.oschina.net/sugarZone/blog/706417（使用Converter类型转换的解析）
https://segmentfault.com/a/1190000014497947(Spring IOC Type Converter)

https://blog.csdn.net/zzc1684/article/details/84627069（3个Converter接口的例子）
https://my.oschina.net/kings0/blog/729437#h1_19（3个Converter接口的例子）
https://segmentfault.com/a/1190000009163158（不同格式的POST请求参数的数据类型转换过程）
https://segmentfault.com/a/1190000012555875（SpringMVC传递JSON数据的推荐方式）
https://www.cnblogs.com/jyyzzjl/p/5459335.html（IOC的实体例子）








	2019-07-11 12:28:13
kumika	电商项目--3	# 电商项目--3

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧

#商品管理

## 3 商品删除

删除是批量删除的。
效果：
[![删除操作.jpg](https://i.loli.net/2019/07/23/5d35e984f01c523319.jpg)](https://i.loli.net/2019/07/23/5d35e984f01c523319.jpg)


前端发出请求

script
```
  import {
    fetchList,
    updateDeleteStatus,
    updateNewStatus,
    updateRecommendStatus,
    updatePublishStatus
  } from '@/api/product'
```
在product的API接口上
```
export function updateDeleteStatus(params) {
  return request({
    url:'/product/update/deleteStatus',
    method:'post',
    params:params
  })
}
```

后端接收请求

批量删除请求的参数：（前后端沟通好的）
deleteStatus 删除状态  0 或者 1
删除产品id列表  ids 

PmsProductController
```
    @ApiOperation("批量修改删除状态")
    @RequestMapping(value = "/update/deleteStatus", method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:product:delete')")
    public Object updateDeleteStatus(@RequestParam("ids") List<Long> ids,
                                     @RequestParam("deleteStatus") Integer deleteStatus) {
        int count = productService.updateDeleteStatus(ids, deleteStatus);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service 
需求： 根据id单个或批量删除产品
输入的是  id列表ids
criteria采用的方法andIdIn(ids)

```
    @Override
    public int updateDeleteStatus(List<Long> ids, Integer deleteStatus) {

        PmsProduct record = new PmsProduct();
        record.setDeleteStatus(deleteStatus);
        PmsProductExample example = new PmsProductExample();
        example.createCriteria().andIdIn(ids);
        return productMapper.updateByExampleSelective(record,example);
    }

```

## 4 商品编辑

在前面的查询单一商品功能做好后，就可以做编辑商品功能了**（老是忘记，是先查询选好的商品，然后才能就这个商品进行修改编辑啊）**。


前端发出请求：
```
  import {createProduct,getProduct,updateProduct} from '@/api/product';
//····一大串代码····
      finishCommit(isEdit) {
        this.$confirm('是否要提交该产品', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          if(isEdit){
            updateProduct(this.$route.query.id,this.productParam).then(response=>{
              this.$message({
                type: 'success',
                message: '提交成功',
                duration:1000
              });
```

调用product的API
```
export function updateProduct(id,data) {
  return request({
    url:'/product/update/'+id,
    method:'post',
    data:data
  })
}
```


后端代码：

PmsProductController:

```
    @ApiOperation("更新商品")
    @RequestMapping(value = "/update/{id}",method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:product:update')")
    public Object update(@PathVariable Long id,
                         @RequestBody PmsProductParam productParam,
                         BindingResult bindingResult) {
        int count = productService.update(id, productParam);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service
更新商品，记得要先删除原来的数据，然后把新的数据插入到数据库中。
```
    @Override
    public int update(Long id, PmsProductParam productParam) {
        int count;
        //更新商品信息
        PmsProduct product = productParam;
        product.setId(id);
        productMapper.updateByPrimaryKeySelective(product);
        //会员价格
        PmsMemberPriceExample pmsMemberPriceExample = new PmsMemberPriceExample();
        pmsMemberPriceExample.createCriteria().andProductIdEqualTo(id);
        //删除原来的会员数据，然后重新插入会员数据
        memberPriceMapper.deleteByExample(pmsMemberPriceExample);
        //插入会员数据
        relateAndInsertList(memberPriceDao, productParam.getMemberPriceList(), id);

        //阶梯价格
        PmsProductLadderExample ladderExample = new PmsProductLadderExample();
        ladderExample.createCriteria().andProductIdEqualTo(id);
        //删除原来的阶梯价格数据，然后重新插入阶梯价格数据
        productLadderMapper.deleteByExample(ladderExample);
        //插入
        relateAndInsertList(productLadderDao, productParam.getProductLadderList(), id);

        //满减价格
        PmsProductFullReductionExample fullReductionExample = new PmsProductFullReductionExample();
        fullReductionExample.createCriteria().andProductIdEqualTo(id);
        //删除
        productFullReductionMapper.deleteByExample(fullReductionExample);
        //插入
        relateAndInsertList(productFullReductionDao, productParam.getProductFullReductionList(), id);

        //修改sku库存信息
        PmsSkuStockExample skuStockExample = new PmsSkuStockExample();
        skuStockExample.createCriteria().andProductIdEqualTo(id);
        //删除
        skuStockMapper.deleteByExample(skuStockExample);
        //处理sku的编码
        handleSkuStockCode(productParam.getSkuStockList(), id);
        //插入
        relateAndInsertList(skuStockDao,productParam.getSkuStockList(),id);

        //修改商品参数，添加自定义商品规格
        PmsProductAttributeValueExample productAttributeValueExample = new PmsProductAttributeValueExample();
        productAttributeValueExample.createCriteria().andProductIdEqualTo(id);
        //删除
        productAttributeValueMapper.deleteByExample(productAttributeValueExample);
        //插入
        relateAndInsertList(productAttributeValueDao, productParam.getProductAttributeValueList(), id);

        //关联专题
        CmsSubjectProductRelationExample subjectProductRelationExample = new CmsSubjectProductRelationExample();
        subjectProductRelationExample.createCriteria().andProductIdEqualTo(id);
        //删除
        subjectProductRelationMapper.deleteByExample(subjectProductRelationExample);
        //插入
        relateAndInsertList(subjectProductRelationDao, productParam.getSubjectProductRelationList(), id);


        //关联优选
        CmsPrefrenceAreaProductRelationExample prefrenceAreaExample = new CmsPrefrenceAreaProductRelationExample();
        prefrenceAreaExample.createCriteria().andProductIdEqualTo(id);
        //删除
        prefrenceAreaProductRelationMapper.deleteByExample(prefrenceAreaExample);
        //插入
        relateAndInsertList(prefrenceAreaProductRelationDao, productParam.getPrefrenceAreaProductRelationList(), id);

        count = 1;
        return count;
    }
```


## 5 批量更改状态操作

商品上下架，推荐，新品，删除商品，除了转移分类这个没有写


###批量商品上下架


PmsProductController:
```
    @ApiOperation("批量上下架")
    @RequestMapping(value = "/update/publishStatus",method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:product:update')")
    public Object updatePublishStatus(@RequestParam("ids")List<Long> ids,
                                      @RequestParam("publishStatus") Integer publishStatus) {
        int count = productService.updatePublishStatus(ids, publishStatus);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service:
```
    @Override
    public int updatePublishStatus(List<Long> ids, Integer publishStatus) {
        PmsProduct record = new PmsProduct();
        record.setPublishStatus(publishStatus);
        PmsProductExample example = new PmsProductExample();
        //使用方法andIdIn()
        example.createCriteria().andIdIn(ids);
        //当有参数为null的时候，使用XXXByExampleSelective
        return productMapper.updateByExampleSelective(record, example);
    }
```

###批量推荐商品

PmsProductController
```
    @ApiOperation("批量推荐商品")
    @RequestMapping(value = "/update/recommendStatus", method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:product:update')")
    public Object updateRecommendStatus(@RequestParam("ids") List<Long> ids,
                                        @RequestParam("recommendStatus") Integer recommendStatus) {
        int count = productService.updateRecommendStatus(ids, recommendStatus);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service
```
    @Override
    public int updateRecommendStatus(List<Long> ids, Integer recommendStatus) {
        PmsProduct record = new PmsProduct();
        record.setRecommandStatus(recommendStatus);
        PmsProductExample example = new PmsProductExample();
        //使用方法andIdIn()
        example.createCriteria().andIdIn(ids);
        //当有参数为null的时候，使用XXXByExampleSelective
        return productMapper.updateByExampleSelective(record, example);
    }
```


###批量设为新品


PmsProductController
```
    @ApiOperation("批量设为新品")
    @RequestMapping(value = "/update/newStatus", method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:product:update')")
    public Object updateNewStatus(@RequestParam("ids") List<Long> ids,
                                  @RequestParam("newStatus") Integer newStatus) {
        int count = productService.updateNewStatus(ids, newStatus);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service
```
    @Override
    public int updateNewStatus(List<Long> ids, Integer newStatus) {
        PmsProduct record = new PmsProduct();
        record.setNewStatus(newStatus);
        PmsProductExample example = new PmsProductExample();
        //使用方法andIdIn()
        example.createCriteria().andIdIn(ids);
        //当有参数为null的时候，使用XXXByExampleSelective
        return productMapper.updateByExampleSelective(record, example);
    }
```



###批量修改删除状态


PmsProductController
```
    @ApiOperation("批量修改删除状态")
    @RequestMapping(value = "/update/deleteStatus", method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:product:delete')")
    public Object updateDeleteStatus(@RequestParam("ids") List<Long> ids,
                                     @RequestParam("deleteStatus") Integer deleteStatus) {
        int count = productService.updateDeleteStatus(ids, deleteStatus);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service
```
    @Override
    public int updateDeleteStatus(List<Long> ids, Integer deleteStatus) {

        PmsProduct record = new PmsProduct();
        record.setDeleteStatus(deleteStatus);
        PmsProductExample example = new PmsProductExample();
        //使用方法andIdIn()
        example.createCriteria().andIdIn(ids);
        //当有参数为null的时候，使用XXXByExampleSelective
        return productMapper.updateByExampleSelective(record,example);
    }
```














	2019-07-18 20:22:10
kumika	电商项目--4	# 电商项目--4

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧

#商品分类
要实现7个功能 转移商品没有写
[![商品分类的实现8个功能.jpg](https://i.loli.net/2019/07/25/5d396596c96bf57864.jpg)](https://i.loli.net/2019/07/25/5d396596c96bf57864.jpg)


## 1 查询商品分类


查询全部商品分类
前端：
```
  import {fetchList,deleteProductCate,updateShowStatus,updateNavStatus} from '@/api/productCate'
  //默认值
    data() {
      return {
        list: null,
        total: null,
        listLoading: true,
        listQuery: {
          pageNum: 1,
          pageSize: 5
        },
        parentId: 0
      }
    },
```

点击商品分类，就跳转到这个页面，然后页面创建的时候发出请求
```
    created() {
      this.resetParentId();
      this.getList();
    },
    //-大串代码
    getList() {
        this.listLoading = true;
        fetchList(this.parentId, this.listQuery).then(response => {
          this.listLoading = false;
          this.list = response.data.list;
          this.total = response.data.total;
        });
      },
    
```

商品分类的API
```
export function fetchList(parentId,params) {
  return request({
    url:'/productCategory/list/'+parentId,
    method:'get',
    params:params
  })
}
```


后端代码：
PmsProductCategoryController:
```
    //PathVariable是绑定URI模板变量值，就是用来获得请求url中的动态参数的===》/list/{parentId}
    @ApiOperation("分页查询商品分类")
    @RequestMapping(value = "/list/{parentId}",method = RequestMethod.GET)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:productCategory:read')")
    public Object getList(@PathVariable Long parentId,
                          @RequestParam(value = "pageSize",defaultValue="5") Integer pageSize,
                          @RequestParam(value = "pageNum",defaultValue="1") Integer pageNum) {
        List<PmsProductCategory> productCategoryList = productCategoryService.getList(parentId, pageSize, pageNum);
        return new CommonResult().pageSuccess(productCategoryList);
    }
```

Service:
传入的参数是父类商品分类id = 0 ，就是全部的商品根分类id，这个值是默认的，也是和前端商量好的。
使用了andParentIdEqualTo（）方法
```
    @Override
    public List<PmsProductCategory> getList(Long parentId, Integer pageSize, Integer pageNum) {
        PageHelper.startPage(pageNum, pageSize);
        PmsProductCategoryExample example = new PmsProductCategoryExample();
        example.setOrderByClause("sort desc");
        example.createCriteria().andParentIdEqualTo(parentId);
        return productCategoryMapper.selectByExample(example);
    }
```


## 2 商品分类的编辑
对商品分类的编辑，首先就要获取目标商品分类
获取单一商品分类
点击编辑，前端发出请求
```
  import {fetchList, createProductCate, updateProductCate, getProductCate} from '@/api/productCate';
  import {fetchListWithAttr} from '@/api/productAttrCate';
  import {getProductAttrInfo} from '@/api/productAttr';
  import SingleUpload from '@/components/Upload/singleUpload';
 @click="handleUpdate(scope.$index, scope.row)">编辑
 //一大串代码····
 handleUpdate(index, row) {
 this.$router.push({path:'/pms/updateProductCate',query:{id:row.id}});
 },
```
同时页面创建的时候也会发出请求
```
      if (this.isEdit) {
        getProductCate(this.$route.query.id).then(response => {
          this.productCate = response.data;
        });
```
商品分类的API
```
export function getProductCate(id) {
  return request({
    url:'/productCategory/'+id,
    method:'get',
  })
}
```
从而得到URL：
```
/pms/updateProductCate?id=XXX
```
注意商品分类详细页面创建的的时候
会发出4个请求

    根据id获取商品分类请求
    根据id获取商品属性信息请求
    获取所选商品分类列表请求
    获取商品属性分类列表请求


后端代码：
###2.1先根据id获取商品分类请求
PmsProductCategoryController:
```
    @ApiOperation("根据id获取商品分类")
    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:productCategory:read')")
    public Object getItem(@PathVariable Long id) {
        PmsProductCategory productCategory = productCategoryService.getItem(id);
        return new CommonResult().success(productCategory);
    }
```

Service:
```
    @Override
    public PmsProductCategory getItem(Long id) {
        return productCategoryMapper.selectByPrimaryKey(id);
    }
```

###根据id获取商品属性信息请求
前端发出请求：
```
  import {getProductAttrInfo} from '@/api/productAttr';
  //一大串代码····
  getProductAttrInfo(this.$route.query.id).then(response => {
```
商品属性的API
```
export function getProductAttrInfo(productCategoryId) {
  return request({
    url:'/productAttribute/attrInfo/'+productCategoryId,
    method:'get'
  })
}
```


因为有特殊的属性，所以自己自定义创建一个类来接收请求参数
ProductAttrInfo类：
```
public class ProductAttrInfo {
    private Long attributeId;
    private Long attributeCategoryId;
    //getter和setter
}
```

PmsProductAttributeController 
```
    @ApiOperation("根据商品分类的id获取商品属性及属性分类")
    @RequestMapping(value = "/attrInfo/{productCategoryId}", method = RequestMethod.GET)
    @ResponseBody
    public Object getAttrInfo(@PathVariable Long productCategoryId) {

        List<ProductAttrInfo> productAttrInfoList = productAttributeService.getProductAttrInfo(productCategoryId);

        return new CommonResult().success(productAttrInfoList);
    }
```

Service 
接口就省略了，直接写实现类
```
//根据商品分类的id获取商品属性及属性分类
    @Override
    public List<ProductAttrInfo> getProductAttrInfo(Long productCategoryId) {
        return productAttributeDao.getProductAttrInfo(productCategoryId);
    }
```

Dao
自定义了一些属性，所以要自己写SQL语句，看实现的XML文件上数据库返回的类型resultType：`ProductAttrInfo`
PmsProductAttributeDao接口：
这是自定义商品属性Dao，下面是SQL的方法
```
List<ProductAttrInfo> getProductAttrInfo(@Param("id") Long productCategoryId);
```
Dao实现文件XML：
```
<mapper namespace="com.taobao.taobaoadmin.dao.pms.PmsProductAttributeDao">
    <select id="getProductAttrInfo" resultType="com.taobao.taobaoadmin.dto.Pms.ProductAttrInfo">
        SELECT
          pa.id AS  attributeId,
          pac.id AS attributeCategoryId
        FROM
          pms_product_category_attribute_relation AS pcar
          LEFT JOIN pms_product_attribute pa  ON pa.id = pcar.product_attribute_id
          LEFT JOIN pms_product_attribute_category pac  ON pa.product_attribute_category_id = pac.id
        WHERE
          pcar.product_category_id = #{id}
    </select>
</mapper>
```

根据商品分类id获取商品属性信息列表
使用了3个表
选择`pms_product_attribute`商品属性表的别名是PA
选择`pms_product_category_attribute_relation`产品的分类和属性的关系表，别名是PCAR，用于设置分类筛选条件（只支持一级分类）
选择`pms_product_attribute_category`产品属性分类表（不是关系表啊），别名Pac

商品属性表的id作为属性id
商品分类和属性关系表的id作为属性分类id

pcar左接 pa , 连接条件：pa.id 与pcar表里的产品属性id相同
拿到产品属性
pcar左接 pac, 连接条件：pa的产品属性分类id 与 pac.id相同
拿到产品属性分类
筛选条件：
pcar的产品分类id 与 输入的参数id相同
最后只拿
pa.id   和  pac.id 

左接表格含义， on 条件 
左接就是主表字段全查询，副表查询符合on条件的字段。
这里是使用分类和属性的关系表，作为主表，然后2次左接表格，实现了一次查询，得到请求要的全部的字段。不需要多次查询，这就是左接右接的意义。

###获取所选商品分类列表请求

就是进行一次查询商品分类，只不过其中的参数变成了：

    parentId=0，pageSize=100,pageNum=1


###获取商品属性分类列表请求


前端请求：

```
  import {fetchListWithAttr} from '@/api/productAttrCate';
  
  //一大串代码···
  //页面创建必调用函数：
   getProductCate(this.$route.query.id).then(response => 
   getProductAttrInfo(this.$route.query.id).then(response =>
  this.getSelectProductCateList();
  this.getProductAttrCateList();
  //一大串代码···
    getProductAttrCateList() {
        fetchListWithAttr().then(response => {
  
```
商品属性分类的API：
```
export function fetchListWithAttr() {
  return request({
    url:'/productAttribute/category/list/withAttr',
    method:'get'
  })
}
```

自定义的类，用于接收客户特别的请求参数
```
public class PmsProductAttributeCategoryItem extends PmsProductAttributeCategory {
    private List<PmsProductAttribute> productAttributeList;
    //getter 和setter
}
```


PmsProductAttributeCategoryController
```
    @ApiOperation("获取所有商品属性分类及其下属性")
    @RequestMapping(value = "/list/withAttr", method = RequestMethod.GET)
    @ResponseBody
    public Object getListWithAttr() {
        List<PmsProductAttributeCategoryItem> productAttributeCategoryResultList = productAttributeCategoryService.getListWithAttr();
        return new CommonResult().success(productAttributeCategoryResultList);
    }
```
Service
接口就不写了，直接写实现类
```
    @Override
    public List<PmsProductAttributeCategoryItem> getListWithAttr() {
        return productAttributeCategoryDao.getListWithAttr();
    }
```
Dao
PmsProductAttributeCategoryDao接口
 自定义商品属性分类Dao，下面是SQL的方法
```
    List<PmsProductAttributeCategoryItem> getListWithAttr();
```
Dao的实现XML文件：
```
<mapper namespace="com.taobao.taobaoadmin.dao.pms.PmsProductAttributeCategoryDao" >
    <resultMap id="getListWithAttrMap" type="com.taobao.taobaoadmin.dto.Pms.PmsProductAttributeCategoryItem" extends="com.taobao.taobaoadmin.mapper.PmsProductAttributeCategoryMapper.BaseResultMap">
        <collection property="productAttributeList" columnPrefix="attr_" resultMap="com.taobao.taobaoadmin.mapper.PmsProductAttributeMapper.BaseResultMap">

        </collection>
    </resultMap>
    <select id="getListWithAttr" resultMap="getListWithAttrMap">
        select
            pac.id,
            pac.name,
            pa.id as attr_id,
            pa.name as attr_name
        FROM
            pms_product_attribute_category pac
            LEFT JOIN pms_product_attribute pa ON pac.id = pa.product_attribute_category_id
        AND
            pa.type = 1;
    </select>
</mapper>
```

无参数，获取商品属性分类列表请求
使用了2个表
选择`pms_product_attribute`商品属性表的别名是PA
选择`pms_product_attribute_category`产品属性分类表（不是关系表啊），别名Pac


选择拿到
        pac表的name，id
        pa表的name，id

pac左接 pa , 连接条件：pa.id 与pac表里的产品属性分类id相同


筛选条件：
pa表的type字段 =  1
最后只拿
pa.id pa.name   和  pac.id  pac.name



### 2.2商品的更新
编辑之后，就是更新到数据库了

前端请求：
```
                updateProductCate(this.$route.query.id, this.productCate).then(response => {
                  this.$message({
                    message: '修改成功',
                    type: 'success',
                    duration: 1000
                  });
```
商品分类的API：
```
export function updateProductCate(id,data) {
  return request({
    url:'/productCategory/update/'+id,
    method:'post',
    data:data
  })
}
```


后端：
前端发送分类和属性关联的id，这是沟通好的。
创建自定义产品分类类型，接收客户的自定义参数
```
/**
 * 添加更新产品分类的参数
 */
public class PmsProductCategoryParam {
    @ApiModelProperty("父分类的编号")
    private Long parentId;

    @ApiModelProperty(value = "商品分类名称",required = true)
    @NotEmpty(message = "商品分类名称不能为空")
    private String name;

    @ApiModelProperty("分类单位")
    private String productUnit;

    @ApiModelProperty("是否在导航栏显示")
    @FlagValidator(value = {"0","1"},message = "状态只能为0或者1")
    private Integer navStatus;

    @ApiModelProperty("是否进行显示")
    @FlagValidator(value = {"0", "1"}, message = "状态只能为0或者1")
    private Integer showStatus;

    @ApiModelProperty
    @Min(value = 0, message = "排序最小0")
    private Integer sort;

    @ApiModelProperty("图标")
    private String icon;

    @ApiModelProperty("关键字")
    private String keywords;

    @ApiModelProperty
    private String description;

    @ApiModelProperty("产品相关筛选属性集合")
    private List<Long> productAttributeIdList;
    //getter和setter
}
```

PmsProductCategoryController:
这里的产品相关筛选属性集合，元素都是数字，现在我看不懂，可能这是前端完成的，元素要是文字就不好处理？
```
    @ApiOperation("更新/修改商品分类")
    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:productCategory:update')")
    public Object update(@PathVariable Long id,
                         @Validated
                         @RequestBody PmsProductCategoryParam productCategoryParam,
                         BindingResult result) {
        int count = productCategoryService.update(id, productCategoryParam);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service

更新分类对象的几个点：
数据库中所需要更新的表，是要与客户请求上的参数相匹配的，这时候要注意自己选取的是说明表。

创建商品分类对象，mybaits更新需要这个对象
这个对象获取传入参数数据

创建商品对象
创建对象目的：这个商品对象创建更新，是因为分类名称这个字段也是在商品信息表中，所以需要同步更新。
分类名称赋值给商品对象，然后商品对象进行更新


页面上的客户写的筛选条件----在数据库上就是分类和属性的关系表
所以这里要获取商品的属性列表，使用mybaits的example创建根据id查询语句，接着使用deleteByExample方法进行删除数据。

这里是先删除原来的属性与分类关系的数据，然后使用`insertRelationList（）`方法再插入客户传入的属性与分类关系数据

最后执行商品分类更新。

===================================================
2个私有方法的思路：
批量插入商品分类与筛选属性关系表
insertRelationList（）
关键在于理解筛选-----在数据库视角看这就是关联
**属性与属性之间的关联表格最好只是保存数字，不要文字。**
方法思路：
1   创建关联对象列表和关联对象
2   for循环遍历请求输入的属性列表，把请求参数内的所有筛选属性id和产品分类对象id遍历赋值到这个关联对象上，**2个不相干的属性，但是在一个对象上，这就形成关联了。**
3   这个关联对象增加到关联对象列表上
4   分类和属性关系Dao执行列表插入，完成更新

setCategoryLevel（）
判断输入的产品分类的父分类id是否为0
1   父分类id ==0的时候，产品分类对象的分类等级属性设置为最高级
2   父分类id ！= 0的时候，根据父分类id，获取父分类，获取父分类的等级数值，在此数值上+1，然后设置为产品分类的分类等级
3   当父分类id ！= 0，而且获取父分类为null的时候（此时应该是父分类被删除了的情况），直接设置产品分类的分类

完整代码：
```
    @Override
    public int update(Long id, PmsProductCategoryParam pmsproductCategoryParam) {

        //创建商品分类对象
        PmsProductCategory productCategory = new PmsProductCategory();
        //设置分类对象的id
        productCategory.setId(id);
        //传输请求参数到这个分类对象上
        BeanUtils.copyProperties(pmsproductCategoryParam,productCategory);
        //设置分类对象的分类级别
        setCategoryLevel(productCategory);

        //更新商品分类时更新商品中的分类名称
        //创建商品对象
        PmsProduct product = new PmsProduct();
        //从分类对象中获取商品名称，然后赋值给商品对象
        product.setProductCategoryName(productCategory.getName());
        //创建example，创建更新条件语句
        PmsProductExample example = new PmsProductExample();
        //根据传入的id，创建更新条件语句
        example.createCriteria().andProductCategoryIdEqualTo(id);
        //进行更新，参数：更新对象，更新条件
        productMapper.updateByExampleSelective(product, example);

        //同时更新筛选属性的信息，更新的是分类与属性关系 的表格------就是页面上的客户写的筛选条件
        //获取传入参数中的属性列表，判断是否为空，不为空进入判断。
        if (!CollectionUtils.isEmpty(pmsproductCategoryParam.getProductAttributeIdList())) {
            //创建example，根据传入的id创建删除条件语句
            PmsProductCategoryAttributeRelationExample relationExample = new PmsProductCategoryAttributeRelationExample();
            relationExample.createCriteria().andProductCategoryIdEqualTo(id);
            //执行删除属性
            productCategoryAttributeRelationMapper.deleteByExample(relationExample);
            //根据传入的id，再插入属性值
            insertRelationList(id, pmsproductCategoryParam.getProductAttributeIdList());
        } else {
            //获取传入参数中的属性列表，判断是否为空，为空，则进行删除属性
            PmsProductCategoryAttributeRelationExample relationExample = new PmsProductCategoryAttributeRelationExample();
            //创建删除条件语句
            relationExample.createCriteria().andProductCategoryIdEqualTo(id);
            //执行语句
            productCategoryAttributeRelationMapper.deleteByExample(relationExample);
        }
        //最后更新商品分类
        return productCategoryMapper.updateByPrimaryKeySelective(productCategory);
    }
    
    /**
     * 批量插入商品分类与筛选属性关系表
     *
     * @param productCategoryId      商品分类id
     * @param productAttributeIdList 相关商品筛选属性id集合
     */
    private void insertRelationList(Long productCategoryId, List<Long> productAttributeIdList) {
        //创建存放一个分类与属性关系类型的分类与属性关系列表对象
        List<PmsProductCategoryAttributeRelation> relationList = new ArrayList<>();
        //遍历商品筛选属性id集合
        for (Long productAttrId : productAttributeIdList) {
            //创建分类与属性关系类对象A
            PmsProductCategoryAttributeRelation relation = new PmsProductCategoryAttributeRelation();
            //遍历对象赋值到A对象上
            relation.setProductAttributeId(productAttrId);
            //产品分类id也赋值到对象A上
            relation.setProductCategoryId(productCategoryId);
            //A对象添加到分类与属性关系列表上
            relationList.add(relation);
        }
        //根据分类与属性关系列表进行更新
        productCategoryAttributeRelationDao.insertList(relationList);
    }

    /**
     * 根据分类的parentId设置分类的level
     */
    private void setCategoryLevel(PmsProductCategory productCategory) {
        //没有父分类时为一级分类
        if (productCategory.getParentId() == 0) {
            //设置分类等级为最高级
            productCategory.setLevel(0);
        } else {
            //有父分类时选择根据父分类level设置
            PmsProductCategory parentCategory = productCategoryMapper.selectByPrimaryKey(productCategory.getParentId());
            if (parentCategory != null) {
             //获取父类的分类等级，再此数值上+1，然后设置为自己的分类等级
             productCategory.setLevel(parentCategory.getLevel() + 1);
            } else {
                productCategory.setLevel(0);
            }
        }
    }
```

Dao
Dao的接口：
```
/**
 * 自定义商品分类和属性关系Dao
 */
public interface PmsProductCategoryAttributeRelationDao {
    void insertList(@Param("list") List<PmsProductCategoryAttributeRelation> relationList);
}
```
Dao实现.xml
```
<mapper namespace="com.taobao.taobaoadmin.dao.pms.PmsProductCategoryAttributeRelationDao">
    <!--批量新增回写主键支持-->
    <insert id="insertList">
        insert INTO  pms_product_category_attribute_relation (product_category_id,product_attribute_id)
        VALUES
        <foreach collection="list" separator="," item="item" index="index">
            (#{item.productCategoryId,jdbcType=BIGINT},
            #{item.productAttributeId,jdbcType=BIGINT})
        </foreach>
    </insert>
</mapper>
```



## 3 商品分类的删除
前端请求：

后端
PmsProductCategoryController：
```
    @ApiOperation("删除商品分类")
    @RequestMapping(value = "/delete/{id}", method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:productCategory:delete')")
    public Object delete(@PathVariable Long id) {
        int count = productCategoryService.delete(id);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service:
```
    @Override
    public int delete(Long id) {
        return productCategoryMapper.deleteByPrimaryKey(id);
    }
```




## 4 商品分类的增加

前端请求：
点击分类增加，跳转到分类详细页面，输入参数，点击提交，才是商品分类的增加

Vue的跳转代码：

增加按钮
```
      <el-button
        class="btn-add"
        @click="handleAddProductCate()"
        size="mini">
        添加
      </el-button>
      //一大串代码·····
      handleAddProductCate() {
        this.$router.push('/pms/addProductCate');
      },
```

跳转页面的配置
```
  import ProductCateDetail from './components/ProductCateDetail'
  export default {
    name: 'addProductCate',
    components: { ProductCateDetail }
  }
```
增加分类的提交按钮：
```
import {fetchList, createProductCate, updateProductCate, getProductCate} from '@/api/productCate';
    //一大串代码····
  updateProductCate(this.$route.query.id, this.productCate).then(response => {
                  this.$message({
                    message: '修改成功',
                    type: 'success',
                    duration: 1000
                  });
```
商品分类API：
```
export function createProductCate(data) {
  return request({
    url:'/productCategory/create',
    method:'post',
    data:data
  })
}
```

后端：

接收请求的参数:
        创建一个自定义的类（就是下面的类），前后端要沟通好。
```
/**
 * 添加更新产品分类的参数
 */
public class PmsProductCategoryParam {
    @ApiModelProperty("父分类的编号")
    private Long parentId;

    @ApiModelProperty(value = "商品分类名称",required = true)
    @NotEmpty(message = "商品分类名称不能为空")
    private String name;

    @ApiModelProperty("分类单位")
    private String productUnit;

    @ApiModelProperty("是否在导航栏显示")
    @FlagValidator(value = {"0","1"},message = "状态只能为0或者1")
    private Integer navStatus;

    @ApiModelProperty("是否进行显示")
    @FlagValidator(value = {"0", "1"}, message = "状态只能为0或者1")
    private Integer showStatus;

    @ApiModelProperty
    @Min(value = 0, message = "排序最小0")
    private Integer sort;

    @ApiModelProperty("图标")
    private String icon;

    @ApiModelProperty("关键字")
    private String keywords;

    @ApiModelProperty
    private String description;

    @ApiModelProperty("产品相关筛选属性集合")
    private List<Long> productAttributeIdList;
//getter  和   setter
```
        
PmsProductCategoryController:

```
    @ApiOperation("添加产品分类")
    @RequestMapping(value = "/create", method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:productCategory:create')")
    public Object create(@Validated
                         @RequestBody PmsProductCategoryParam productCategoryParam) {
        int count = productCategoryService.create(productCategoryParam);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service

思路：
1   创建一个分类对象
2   设置分类对象的分类级别
3   把输入参数的数据传输到这个分类对象上
4   当没有父分类的时候设置为1级分类（就是自己写一个私有方法setCategoryLevel）

私有方法setCategoryLevel思路：
判断分类对象是否有父级分类级别
    查看parentID，是0 ，属性Level就设置为父级分类级别
    不是0，就根据parentID查询分类对象的父类对象，然后获取父类对象的属性level值，设置自己的属性level值＋１

2个函数在修改分类的功能中已经写有了。
```
    @Override
    public int create(PmsProductCategoryParam pmsproductCategoryParam) {
        //创建商品分类对象
        PmsProductCategory productCategory = new PmsProductCategory();
        //分类对象设置分类级别，0是最高级别
        productCategory.setProductCount(0);
        //使用别的函数对分类对象传输数据
        BeanUtils.copyProperties(pmsproductCategoryParam,productCategory);

        //没有父分类时为一级分类
        setCategoryLevel(productCategory);
        int count = productCategoryMapper.insertSelective(productCategory);

        //创建筛选属性关联
        //获取属性列表
        List<Long> productAttributeIdList = pmsproductCategoryParam.getProductAttributeIdList();
        if (!CollectionUtils.isEmpty(productAttributeIdList)) {
            //对分类进行关联属性
            insertRelationList(productCategory.getId(), productAttributeIdList);
        }
        return count;
    }
        /**
     * 根据分类的parentId设置分类的level
     */
    private void setCategoryLevel(PmsProductCategory productCategory) {
        //没有父分类时为一级分类
        if (productCategory.getParentId() == 0) {
            productCategory.setLevel(0);
        } else {
            //有父分类时选择根据父分类level设置
            PmsProductCategory parentCategory = productCategoryMapper.selectByPrimaryKey(productCategory.getParentId());
            if (parentCategory != null) {
                productCategory.setLevel(parentCategory.getLevel() + 1);
            } else {
                productCategory.setLevel(0);
            }
        }
    }
```



#疑问

##问题1

[![商品分类的实现8个功能.jpg](https://i.loli.net/2019/07/25/5d396596c96bf57864.jpg)](https://i.loli.net/2019/07/25/5d396596c96bf57864.jpg)
点击查看下级，出现URL：
```
/pms/productCate?parentId=2
```
但是在后端上的mapping并没有直接接收的parentId啊？只有/list/{parentId}
DEBUG后发现数据进入的也是/list/{parentId}这个代码段。这个/list是摆设的吗？还是有PathVariable注解的原因？

看debug的过程，
```
/pms/productCate?parentId=2
```
被解析成了
```
http://localhost:8882/productCategory/list/2
```
这是哪个代码块解析的？


##问题2

在更新商品分类表过程中，在对分类名称的更新时候，也要对商品信息表中的分类名称进行更新，这是为什么？


##问题3

点击出标签，然后请求输入的是属性id，前端是怎么把id匹配到属性文字？

答：
    妈蛋，忘记了，前端传输都是map类型，也就是key---Value啊，知道id，当然知道文字了。
    但是，前端上，怎么获取key,怎么获取value，显示2层标签的结构怎么写，目前有代码也是看不懂的，因为这实在是分不清这该前端写还是后端写？
    
    

	2019-07-25 15:57:23
kumika	电商项目--5	# 电商项目--5

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧



#商品类型

[![商品类型.jpg](https://i.loli.net/2019/07/31/5d40f87733bc226644.jpg)](https://i.loli.net/2019/07/31/5d40f87733bc226644.jpg)
6个功能，
查询商品列表，查询属性列表，参数列表，商品类型的编辑，商品类型的删除，商品类型的添加



##商品类型查询

前端
页面创建时候就进行查询操作
```
 import {fetchList,createProductAttrCate,deleteProductAttrCate,updateProductAttrCate} from '@/api/productAttrCate'
 //一大串代码····
    created() {
      this.getList();
    },
    methods: {
      getList() {
        this.listLoading = true;
        fetchList(this.listQuery).then(response => {
          this.listLoading = false;
          this.list = response.data.list;
          this.total = response.data.total;
        });
      },
```
商品类型的API：
```
export function fetchList(cid,params) {
  return request({
    url:'/productAttribute/list/'+cid,
    method:'get',
    params:params
  })
}
```

后端

PmsProductAttributeCategoryController：
输入的参数：pageSize 和 pageNum
```
    @ApiOperation("分页获取所有商品属性分类")
    @RequestMapping(value="/list",method = RequestMethod.GET)
    @ResponseBody
    public Object getList(@RequestParam(defaultValue = "5") Integer pageSize, @RequestParam(defaultValue = "1") Integer pageNum) {
        List<PmsProductAttributeCategory> productAttributeCategoryList = productAttributeCategoryService.getList(pageSize, pageNum);
        return new CommonResult().pageSuccess(productAttributeCategoryList);
    }
    
    //这是别的页面发出的请求的Controller，暂时忘记是哪个的了，但是这也是查询啊
    @ApiOperation("获取所有商品属性分类及其下属性")
    @RequestMapping(value = "/list/withAttr", method = RequestMethod.GET)
    @ResponseBody
    public Object getListWithAttr() {
        List<PmsProductAttributeCategoryItem> productAttributeCategoryResultList = productAttributeCategoryService.getListWithAttr();
        return new CommonResult().success(productAttributeCategoryResultList);
    }
    
```

Service：
使用Mybaits的插件pageHelper进行处理页码问题，然后使用example进行查询
```
    @Override
    public List<PmsProductAttributeCategory> getList(Integer pageSize, Integer pageNum) {

        PageHelper.startPage(pageNum, pageSize);

        return productAttributeCategoryMapper.selectByExample(new PmsProductAttributeCategoryExample());
    }
    
    @Override
    public List<PmsProductAttributeCategoryItem> getListWithAttr() {
        return productAttributeCategoryDao.getListWithAttr();
    }
```


##查询属性列表和参数列表

前端：
其实在前面创建商品的时候已经把这个功能写了，这里只是重复一下客户的要求而已。
**都是查询数据库的商品属性表，属性和列表的区别只是字段type的0 和1 的区别**
属性列表：
[![属性.jpg](https://i.loli.net/2019/08/01/5d42081b052df93009.jpg)](https://i.loli.net/2019/08/01/5d42081b052df93009.jpg)

参数列表：
[![参数.jpg](https://i.loli.net/2019/08/01/5d42081b2681644721.jpg)](https://i.loli.net/2019/08/01/5d42081b2681644721.jpg)

后端：

PmsProductAttributeCategoryController

##商品类型的编辑


前端


后端：

PmsProductAttributeCategoryController
```
    @ApiOperation("修改商品属性分类")
    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object update(@PathVariable Long id, @RequestParam String name) {
        int count = productAttributeCategoryService.update(id, name);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service
```
    @Override
    public int update(Long id, String name) {
        PmsProductAttributeCategory productAttributeCategory = new PmsProductAttributeCategoryItem();
        //把输入的参数，赋值给新对象，然后更新这个对象到数据库中
        productAttributeCategory.setName(name);
        productAttributeCategory.setId(id);

        return productAttributeCategoryMapper.updateByPrimaryKeySelective(productAttributeCategory);
    }
```


##商品类型的增加

因为前端不知道怎么写的，获取不到商品属性名称，所以增加不了商品属性
后端的内容：
根据获取的名称，创建一个商品属性分类对象，把名称赋值给这个对象，然后对象插入到数据库中，完成增加操作。

##商品类型的删除

前端


后端：
PmsProductAttributeCategoryController
```
    @ApiOperation("删除单个商品属性分类")
    @RequestMapping(value = "/delete/{id}", method = RequestMethod.GET)
    @ResponseBody
    public Object delete(@PathVariable Long id) {
        int count = productAttributeCategoryService.delete(id);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```


Service
```
    @Override
    public int delete(Long id) {
        return productAttributeCategoryMapper.deleteByPrimaryKey(id);
    }
```


	2019-07-30 23:52:10
kumika	电商项目--6	# 电商项目--6

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧

#商品管理

实现的功能：
[![品牌管理.jpg](https://i.loli.net/2019/08/01/5d4288c3554c923708.jpg)](https://i.loli.net/2019/08/01/5d4288c3554c923708.jpg)
8个功能：

查询全部的商品品牌，批量更改品牌制作商的状态，批量更改品牌的显示状态，单一的更改品牌制造商状态，单一更改品牌的显示状态，品牌的编辑，品牌的删除，品牌的增加




##查询全部的商品品牌

关键字查询keyword是listQuery变量的属性，所以请求参数listQuery就包括了查询的关键字
```
 <el-input style="width: 203px" v-model="listQuery.keyword" placeholder="品牌名称/关键字">
```

前端：
```  
    import {fetchList, updateShowStatus, updateFactoryStatus, deleteBrand} from '@/api/brand'
    //大串代码····
    created() {
      this.getList();
    },
    //大串代码···
     fetchList(this.listQuery).then(response => {
```
品牌的API：
```
export function fetchList(params) {
  return request({
    url:'/brand/list',
    method:'get',
    params:params
  })
}
```


后端：
PmsBrandController
```
@Controller
@Api(tags = "PmsBrandController", description = "商品品牌管理")
@RequestMapping("/brand")
public class PmsBrandController {
    @ApiOperation(value = "根据品牌名称分页获取品牌列表")
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:brand:read')")
    public Object getList(@RequestParam(value = "keyword", required = false) String keyword,
                          @RequestParam(value = "pageNum", defaultValue = "1") Integer pageNum,
                          @RequestParam(value = "pageSize", defaultValue = "5") Integer pageSize) {
        return new CommonResult().pageSuccess(brandService.listBrand(keyword, pageNum, pageSize));
    }
}
```

Service
接口就不写了
```
    @Override
    public List listBrand(String keyword, Integer pageNum, Integer pageSize) {

        PageHelper.startPage(pageNum, pageSize);
        PmsBrandExample pmsBrandExample = new PmsBrandExample();
        pmsBrandExample.setOrderByClause("sort desc");
        PmsBrandExample.Criteria criteria = pmsBrandExample.createCriteria();

        if (!StringUtils.isEmpty(keyword)) {
            criteria.andNameLike("%" + keyword + "%");
        }

        return brandMapper.selectByExample(pmsBrandExample);
    }
```



##品牌的编辑

编辑----先获取对象，才能进行修改对象的属性。所以是**先查询，再进行更新操作。**

###查询单一品牌

前端：
```
  import {createBrand, getBrand, updateBrand} from '@/api/brand'
  //大串代码···
  created() {//页面创建的时候进行查询单一品牌操作
      if (this.isEdit) {
        getBrand(this.$route.query.id).then(response => {
          this.brand = response.data;
        });
      }else{
        this.brand = Object.assign({},defaultBrand);
      }
    },
```
品牌的API：
```
export function getBrand(id) {
  return request({
    url:'/brand/'+id,
    method:'get',
  })
}
```


后端：
PmsBrandController

```
    @ApiOperation("根据编号查询品牌信息")
    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:brand:read')")
    public Object getItem(@PathVariable("id") Long id) {
        return new CommonResult().success(brandService.getBrand(id));
    }
```


Service
```
    @Override
    public Object getBrand(Long id) {
        return brandMapper.selectByPrimaryKey(id);
    }
```


###品牌的更新

前端：
```
  import {createBrand, getBrand, updateBrand} from '@/api/brand'
  //大串代码···
 updateBrand(this.$route.query.id, this.brand).then(response => {
```
品牌的API：
```
export function updateBrand(id,data) {
  return request({
    url:'/brand/update/'+id,
    method:'post',
    data:data
  })
}
```

后端：

创建接收请求参数的自定义类：
```
/**
 * 品牌传递参数
 */
public class PmsBrandParam {
    @ApiModelProperty(value = "品牌名称",required = true)
    @NotEmpty(message = "名称不能为空")
    private String name;
    @ApiModelProperty(value = "品牌首字母")
    private String firstLetter;
    @ApiModelProperty(value = "排序字段")
    @Min(value = 0, message = "排序最小为0")
    private Integer sort;
    @ApiModelProperty(value = "是否为厂家制造商")
    @FlagValidator(value = {"0","1"}, message = "厂家状态不正确")
    private Integer factoryStatus;
    @ApiModelProperty(value = "是否进行显示")
    @FlagValidator(value = {"0","1"}, message = "显示状态不正确")
    private Integer showStatus;
    @ApiModelProperty(value = "品牌logo",required = true)
    @NotEmpty(message = "品牌logo不能为空")
    private String logo;
    @ApiModelProperty(value = "品牌大图")
    private String bigPic;
    @ApiModelProperty(value = "品牌故事")
    private String brandStory;
    //setter 和 getter    
}
```


PmsBrandController
```
    @ApiOperation("更新品牌")
    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:brand:update')")
    public Object update(@PathVariable("id") Long id,
                         @Validated
                         @RequestBody PmsBrandParam pmsBrandParam,
                         BindingResult result) {
        int count = brandService.updateBrand(id, pmsBrandParam);
        if (count == 1) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }

    }
```

Service

```
    @Override
    public int updateBrand(Long id, PmsBrandParam pmsBrandParam) {
        PmsBrand pmsBrand = new PmsBrand();
        BeanUtils.copyProperties(pmsBrandParam, pmsBrand);
        pmsBrand.setId(id);

        //如果创建时首字母为空，取名称的第一个为首字母
        if (StringUtils.isEmpty(pmsBrand.getFirstLetter())) {
            pmsBrand.setFirstLetter(pmsBrand.getName().substring(0,1));
        }
        //更新品牌时要更新商品中的品牌名称
        PmsProduct product = new PmsProduct();
        product.setBrandName(pmsBrand.getName());
        PmsProductExample example = new PmsProductExample();
        example.createCriteria().andBrandIdEqualTo(id);
        productMapper.updateByExampleSelective(product, example);
        return brandMapper.updateByPrimaryKeySelective(pmsBrand);
    }
```


##品牌的增加


前端
```
  import {createBrand, getBrand, updateBrand} from '@/api/brand'
  //大串代码···
  createBrand(this.brand).then(response => {
        this.$refs[formName].resetFields();
        this.brand = Object.assign({},defaultBrand);
                  this.$message({
                    message: '提交成功',
                    type: 'success',
                    duration:1000
                  });
    }
```
品牌的API
```
export function createBrand(data) {
  return request({
    url:'/brand/create',
    method:'post',
    data:data
  })
}
```



后端
PmsBrandController
接收请求参数的自定义类`PmsBrandParam`，再商品更新功能那写有，不重复贴上来了
```
    @ApiOperation("添加品牌")
    @RequestMapping(value = "/create", method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:brand:create')")
    public Object create(@Validated @RequestBody PmsBrandParam pmsBrand, BindingResult result) {
        int count = brandService.createBrand(pmsBrand);
        if (count == 1) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service
```
    @Override
    public int createBrand(PmsBrandParam pmsBrandParam) {
        PmsBrand pmsBrand = new PmsBrand();
        BeanUtils.copyProperties(pmsBrandParam, pmsBrand);

        //如果创建时首字母为空，取名称的第一个为首字母
        if (StringUtils.isEmpty(pmsBrand.getFirstLetter())) {
            pmsBrand.setFirstLetter(pmsBrand.getName().substring(0,1));
        }

        return brandMapper.insertSelective(pmsBrand);
    }
```





##品牌的删除


PmsBrandController
```
    @ApiOperation("删除品牌")
    @RequestMapping(value = "/delete/{id}", method = RequestMethod.GET)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:brand:delete')")
    public Object delete(@PathVariable("id") Long id) {
        int count = brandService.deleteBrand(id);
        if (count == 1) {
            return new CommonResult().success(null);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service 

```
    @Override
    public int deleteBrand(Long id) {
        return brandMapper.deleteByPrimaryKey(id);
    }
```

##品牌的批量删除
前端：

后端：
PmsBrandController
```
    @ApiOperation("批量删除品牌")
    @RequestMapping(value = "/delete/batch", method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:brand:delete')")
    public Object deleteBatch(@RequestParam("ids") List<Long> ids) {
        int count = brandService.deleteBrandBatch(ids);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service
```
    @Override
    public int deleteBrandBatch(List<Long> ids) {
        PmsBrandExample example = new PmsBrandExample();
        example.createCriteria().andIdIn(ids);
        return brandMapper.deleteByExample(example);
    }
```

##批量更新厂家制造商状态


前端：


后端

PmsBrandController

```
@ApiOperation("批量更新厂家制造商状态")
    @RequestMapping(value = "/update/factoryStatus",method =RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:brand:update')")
    public Object updateFactoryStatus(@RequestParam("ids")List<Long> ids,
                                      @RequestParam("factoryStatus") Integer factoryStatus) {
        int count = brandService.updateFactoryStatus(ids, factoryStatus);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service

```
    @Override
    public int updateFactoryStatus(List<Long> ids, Integer factoryStatus) {
        PmsBrand pmsBrand = new PmsBrand();
        pmsBrand.setFactoryStatus(factoryStatus);

        PmsBrandExample BrandExample = new PmsBrandExample();
        BrandExample.createCriteria().andIdIn(ids);
        return brandMapper.updateByExampleSelective(pmsBrand, BrandExample);
    }
```




##批量更新显示状态


前端：


后端：

PmsBrandController

```
    @ApiOperation("批量更新显示状态")
    @RequestMapping(value = "/update/showStatus", method = RequestMethod.POST)
    @ResponseBody
    @PreAuthorize("hasAuthority('pms:brand:update')")
    public Object updateShowStatus(@RequestParam("ids") List<Long> ids,
                                   @RequestParam("showStatus") Integer showStatus) {
        int count = brandService.updateShowStatus(ids, showStatus);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```


Service

```
    @Override
    public int updateShowStatus(List<Long> ids, Integer showStatus) {
        PmsBrand pmsBrand = new PmsBrand();
        pmsBrand.setShowStatus(showStatus);
        PmsBrandExample BrandExample = new PmsBrandExample();
        BrandExample.createCriteria().andIdIn(ids);
        return brandMapper.updateByExampleSelective(pmsBrand, BrandExample);
    }
```


	2019-08-01 14:25:38
kumika	电商项目--7	# 电商项目--7

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧



#订单管理

订单管理分为：
订单列表
订单设置
退货申请处理
退货原因设置

数据库结构：
[![](https://ae01.alicdn.com/kf/H4e1b79e39af04ca8a8f6dd0cf579cac6w.jpg)](https://ae01.alicdn.com/kf/H4e1b79e39af04ca8a8f6dd0cf579cac6w.jpg)

功能结构:
[![](https://ae01.alicdn.com/kf/H44fecfc013294a4da2b99fe89ac6edeei.jpg)](https://ae01.alicdn.com/kf/H44fecfc013294a4da2b99fe89ac6edeei.jpg)


#订单列表

[![](https://ae01.alicdn.com/kf/Hbcc1397d5cb949f6a33b9f74642e105ed.jpg)](https://ae01.alicdn.com/kf/Hbcc1397d5cb949f6a33b9f74642e105ed.jpg)


##多条件查询订单
前端：
点击订单列表，或者是 筛选搜索，网页发出搜索请求
```
  import {fetchList,closeOrder,deleteOrder} from '@/api/order'
```

订单的API：
```
export function fetchList(params) {
  return request({
    url:'/order/list',
    method:'get',
    params:params
  })
}
```

后端：
接收请求参数的自定义订单参数类：订单查询参数OmsOrderQueryParam
注意：
此属性`receiverKeyword`是要查询数据库订单表中2个字段，分别为`receiver_name`和`receiver_phone`。
这应该也是前后端沟通好的把，不然不会一个属性查询2个字段的。
```
/**
 * 订单查询参数
 */
@Getter
@Setter
public class OmsOrderQueryParam {
    @ApiModelProperty(value = "订单编号")
    private String orderSn;
    @ApiModelProperty(value = "收货人姓名/号码")
    private String receiverKeyword;
    @ApiModelProperty(value = "订单状态：0->待付款；1->待发货；2->已发货；3->已完成；4->已关闭；5->无效订单")
    private Integer status;
    @ApiModelProperty(value = "订单类型：0->正常订单；1->秒杀订单")
    private Integer orderType;
    @ApiModelProperty(value = "订单来源：0->PC订单；1->app订单")
    private Integer sourceType;
    @ApiModelProperty(value = "订单提交时间")
    private String createTime;
}
```


OmsOrderController

```
@Controller
@Api(value = "OmsOrderController", description = "订单管理")
@RequestMapping("/order")
public class OmsOrderController {

    @Autowired
    private OmsOrderService orderService;

    @ApiOperation("查询订单")
    @RequestMapping(value = "/list",method = RequestMethod.GET)
    @ResponseBody
    public Object list(OmsOrderQueryParam queryParam,
                       @RequestParam(value = "pageSize",defaultValue = "5") Integer pageSize,
                       @RequestParam(value = "pageNum",defaultValue = "1") Integer pageNum
                       ) {
        List<OmsOrder> orderList = orderService.list(queryParam, pageSize, pageNum);
        return new CommonResult().pageSuccess(orderList);
    }
}
```

Service
接口就不写了，直接写实现类
```
    @Override
    public List<OmsOrder> list(OmsOrderQueryParam queryParam, Integer pageSize, Integer pageNum) {
        PageHelper.startPage(pageNum, pageSize);
        return orderDao.getList(queryParam);
    }
```


Dao：
自定义查询Dao接口
OmsOrderDao
```

/**
 * 订单自定义查询Dao
 */
public interface OmsOrderDao {

    /**
     * 条件查询订单
     * @param queryParam
     * @return
     */
    List<OmsOrder> getList(@Param("queryParam") OmsOrderQueryParam queryParam);
}
```
OmsOrderDao.xml
一个表能查询完的，就不用别的表的resultMap了，当关联别的表格的时候就需要resultMap了。
查询订单，使用订单表就能查询完全了。
请求参数是有什么作用？
答：
    查询订单对象的全部字段，而且筛选条件的字段是接收类的属性，注意接收类的receiverKeyword属性，在数据库中是查询2个字段，`receiver_name`和`receiver_phone`（前后端沟通好的？！）
    
注意：
查看订单，一般都是要未删除状态的 就是delete_status = 0
```
delete_status        
int(1) not null default 0  comment 
'删除状态：0->未删除；1->已删除'
```

完整的Dao.xml
注解部分是查看订单详细内容的时候才添加。
```
<mapper namespace="com.taobao.taobaoadmin.dao.Oms.OmsOrderDao">
<!--    <resultMap id="orderDetailResultMap" type="com.taobao.taobaoadmin.dto.Oms.OmsOrderDetail" extends="com.taobao.taobaoadmin.mapper.OmsOrderMapper.BaseResultMap">
        <collection property="orderItemList" resultMap="com.taobao.taobaoadmin.mapper.OmsOrderItemMapper.BaseResultMap" columnPrefix="item_"/>
        <collection property="historyList" resultMap="com.taobao.taobaoadmin.mapper.OmsOrderOperateHistoryMapper.BaseResultMap" columnPrefix="history_"/>
    </resultMap>-->

    <select id="getList" resultMap="com.taobao.taobaoadmin.mapper.OmsOrderMapper.BaseResultMap">
        SELECT *
        FROM
        oms_order
        WHERE
        delete_status = 0
        <if test="queryParam.orderSn!=null and queryParam.orderSn!=''">
            AND order_sn = #{queryParam.orderSn}
        </if>

        <if test="queryParam.status!=null">
            AND `status` = #{queryParam.status}
        </if>

        <if test="queryParam.sourceType!=null">
            AND source_type = #{queryParam.sourceType}
        </if>

        <if test="queryParam.orderType!=null">
            AND order_type = #{queryParam.orderType}
        </if>

        <if test="queryParam.createTime!=null and queryParam.createTime!=''">
            AND create_time LIKE concat (#{queryParam.createTime},"%")
        </if>

        <if test="queryParam.receiverKeyword!=null and queryParam.receiverKeyword!=''">
            AND (
            receiver_name LIKE concat ("%",#{queryParam.receiverKeyword},"%")
            OR
            receiver_phone LIKE concat ("%",#{queryParam.receiverKeyword},"%")
            )
        </if>
    </select>
</mapper>
```

##编辑订单详细信息

###查看订单详情
客户要求：根据id查询订单的详细信息。
订单的不同状态：
（修改订单信息，跟踪订单，备注订单那几个按钮是已经写死在前端的，没有发送请求----作者没有完成功能，我现在学不到啊）
[![](https://ae01.alicdn.com/kf/H1159715f1bfb401188dae544b71b240d8.jpg)](https://ae01.alicdn.com/kf/H1159715f1bfb401188dae544b71b240d8.jpg)
[![](https://ae01.alicdn.com/kf/Heb7678b318aa4ff8bcee640708f08fa7Q.jpg)](https://ae01.alicdn.com/kf/Heb7678b318aa4ff8bcee640708f08fa7Q.jpg)
[![](https://ae01.alicdn.com/kf/Ha0b8ff3c7b4e45df9d8002327398ab32g.jpg)](https://ae01.alicdn.com/kf/Ha0b8ff3c7b4e45df9d8002327398ab32g.jpg)

页面要求显示的订单信息----注意数据库表中的字段，遗漏了就不行了啊。
[![](https://ae01.alicdn.com/kf/H73931efff2574641bcf0e071ae3a15fc0.jpg)](https://ae01.alicdn.com/kf/H73931efff2574641bcf0e071ae3a15fc0.jpg)
[![](https://ae01.alicdn.com/kf/H023300da3ea74e00bda1ddc06b705e2c4.jpg)](https://ae01.alicdn.com/kf/H023300da3ea74e00bda1ddc06b705e2c4.jpg)
[![](https://ae01.alicdn.com/kf/He63fb626418c49fab4233e73b8d55288Z.jpg)](https://ae01.alicdn.com/kf/He63fb626418c49fab4233e73b8d55288Z.jpg)

前端：
```
import {getOrderDetail,updateReceiverInfo,updateMoneyInfo,closeOrder,updateOrderNote,deleteOrder} from '@/api/order';
//大串代码···
      this.id = this.list = this.$route.query.id;
      getOrderDetail(this.id).then(response => {
        this.order = response.data;
      });
```

订单API
```
export function getOrderDetail(id) {
  return request({
    url:'/order/'+id,
    method:'get'
  });
}
```


后端：

OmsOrderController

```
    @ApiOperation("获取订单详情:订单信息、商品信息、操作记录")
    @RequestMapping(value = "/{id}",method = RequestMethod.GET)
    @ResponseBody
    public Object detail(@PathVariable Long id) {
        OmsOrderDetail orderDetailResult = orderService.detail(id);
        return new CommonResult().success(orderDetailResult);
    }
```



Service

```
    @Override
    public OmsOrderDetail detail(Long id) {
        return orderDao.getDetail(id);
    }
```

OmsOrderDao:
订单自定义查询Dao接口：
```
    /**
     * 获取订单详情
     */
    OmsOrderDetail getDetail(Long id);
```
Dao.xml
因为查询使用到了多张表格，所以是要加上resultMap的。
表格的关系图
[![](https://ae01.alicdn.com/kf/H4e1b79e39af04ca8a8f6dd0cf579cac6w.jpg)](https://ae01.alicdn.com/kf/H4e1b79e39af04ca8a8f6dd0cf579cac6w.jpg)
**注意右边的3个表，指向主表oms_order**。现在只是使用了2个表`oms_order_item`和`oms_order_operate_history`指向主表，其中主表连接副表的条件是传入参数---id。主表的id = 副表查询目标字段（或者外键）的id
这次主辅表格连接条件写法就是**主表与副表的外键id相同**

    oms_order.id = oms_order_item.id
    oms_order.id =oms_order_operate_history.id

请求参数和查询表格之间的关系
答：  就是根据id查询订单的详细信息

根据页面要求，所以是使用了3个表，其中2个副表，查询返回选择的属性中主表全部属性，副表就是下面自己的字段了

OmsOrderDao完整代码：
```
    <resultMap id="orderDetailResultMap" type="com.taobao.taobaoadmin.dto.Oms.OmsOrderDetail" extends="com.taobao.taobaoadmin.mapper.OmsOrderMapper.BaseResultMap">
        <collection property="orderItemList" resultMap="com.taobao.taobaoadmin.mapper.OmsOrderItemMapper.BaseResultMap" columnPrefix="item_"/>
        <collection property="historyList" resultMap="com.taobao.taobaoadmin.mapper.OmsOrderOperateHistoryMapper.BaseResultMap" columnPrefix="history_"/>
    </resultMap>


    <select id="getDetail" resultMap="orderDetailResultMap">
        SELECT o.*,
                oi.id as item_id,
                oi.product_id as item_product_id,
                oi.product_sn as item_product_sn,
                oi.product_pic as item_product_pic,
                oi.product_name as item_product_name,
                oi.product_brand as item_product_brand,
                oi.product_price as item_product_price,
                oi.product_quantity as item_product_quantity,
                oi.product_attr as item_product_attr,
                oi.sp1 as item_sp1,
                oi.sp2 as item_sp2,
                oi.sp3 as item_sp3,
                oh.id as history_id,
                oh.operate_man as history_operate_man,
                oh.create_time as history_create_time,
                oh.order_status as history_order_status,
                oh.note as history_note
        FROM
                oms_order as o
                LEFT  JOIN  oms_order_item as oi ON o.id = oi.order_id
                LEFT JOIN  oms_order_operate_history as oh ON o.id =  oh.order_id
        WHERE
              o.id = #{id}
        ORDER BY
              oi.id ASC,
              oh.create_time DESC
    </select>
```



###订单操作

目标：包括批量修改订单


客户对返回到页面上的订单列表进行操作，订单操作有3种状态，其中能完成的有2种，删除和发货，订单跟踪无法完成。
[![](https://ae01.alicdn.com/kf/Ha5cc3375b1764b4c8a5678c587b39eb7B.jpg)](https://ae01.alicdn.com/kf/Ha5cc3375b1764b4c8a5678c587b39eb7B.jpg)

订单有3个操作状态： 删除，跟踪（这要配合物流，没有办法完成），发货
订单表格中的操作状态字段：

    status = 4  删除订单
    status = 3  订单跟踪
    status = 2  订单跟踪
    status = 1  订单发货


####订单跟踪
也就是页面显示静态的数据了。


####批量和单一删除订单

前端：
这里单一订单删除和批量订单删除，使用了同一函数，所以我把2个删除订单的前端代码都放上来了。

```
      <el-select
        size="small"
        v-model="operateType" placeholder="批量操作">
        <el-option
          v-for="item in operateOptions"
          :key="item.value"
          :label="item.label"
          :value="item.value">
        </el-option>
      </el-select>
//大段代码···
<el-button
   size="mini"
   type="danger"
   @click="handleDeleteOrder(scope.$index, scope.row)"
      v-show="scope.row.status===4">删除订单
</el-button>
//大串代码···
  import {fetchList,closeOrder,deleteOrder} from '@/api/order'
  //大串代码····
  handleDeleteOrder(index, row){
        let ids=[];
        ids.push(row.id);
        //单一删除订单
        this.deleteOrder(ids);
      },
//大串代码···
else if(this.operateType===3){
          //批量删除订单
          let ids=[];
          for(let i=0;i<this.multipleSelection.length;i++){
            ids.push(this.multipleSelection[i].id);
          }
          this.deleteOrder(ids);
        }
```



订单的API：
```
export function deleteOrder(params) {
  return request({
    url:'/order/delete',
    method:'post',
    params:params
  })
}
```

后端：
OmsOrderController
现在删除有3种思路：

    第一种：直接删除数据库的数据
    第二种：先使用null，覆盖数据库中的数据，然后进行删除
    第三种：现在要写的这种单纯的覆盖，使用别的数据进行覆盖数据库中的数据。下次查询的时候因为查询条件与数据库中字段的数据不一致，使人出现没有查询出来的错觉，一种删除/不存在的错觉

完整的代码：
```
    @ApiOperation("单一和批量删除订单")
    @RequestMapping(value = "/delete",method = RequestMethod.POST)
    @ResponseBody
    public Object delete(@RequestParam("ids") List<Long> ids) {
        int count = orderService.delete(ids);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```


Service
接口就不写了，懒人一个嘛。
```
    @Override
    public int delete(List<Long> ids) {
        //创建新订单对象
        OmsOrder record = new OmsOrder();
        record.setDeleteStatus(1);
        //设置查询条件
        OmsOrderExample example = new OmsOrderExample();
        //Mybatis的查询准则方法：andDeleteStatusEqualTo---查询属性deleteStatus等于0的对象，后面还可以加条件
        //andIdIn----查询id在指定集合中的对象，后面还可以加条件，但是这里就没有必要了。
        //criteria (评判或作决定的) 标准，准则，原则
        example.createCriteria().andDeleteStatusEqualTo(0).andIdIn(ids);
        //执行更新方法
        return orderMapper.updateByExampleSelective(record, example);
    }
```

####订单发货

单一发货和批量发货合在一个函数上。

前端：
点击订单发货按钮，跳转到发货详细页面，然后点击提交，发出请求。
注意，这里前端，**我只注意到了发送请求的参数，并没有注意到返回需要的是什么参数。也就是只知道输入变量是多少个，但是并不知道返回的结果变量是多少个。**比如根据id查询全部的订单，返回的结果就不是一个变量了。
输入变量 -----CDUS---输出变量  我老是忘记**输出变量，这个是页面要求显示的，客户的最终需求**

```
  import {deliveryOrder} from '@/api/order'
  //大串代码···
   if(this.operateType===1){
          //批量发货
          let list=[];
          for(let i=0;i<this.multipleSelection.length;i++){
            if(this.multipleSelection[i].status===1){
              list.push(this.covertOrder(this.multipleSelection[i]));
            }
          }
          //跳转页面，跳转携带的参数是装订单id的列表list
          this.$router.push({path:'/oms/deliverOrderList',query:{list:list}})
```
跳转到的目标页面：
点击提交
```
    created(){
      this.list= this.$route.query.list;
    },
    //大串代码
    deliveryOrder(this.list).then(response=>{
```


订单的API：
```
export function deliveryOrder(data) {
  return request({
    url:'/order/update/delivery',
    method:'post',
    data:data
  });
}
```

后端：

发货请求：
输入参数：订单id，物流公司，物流单号
返回对象：没有，或者说返回1，表示成功更改数据库的数据
没有立即返回，是因为页面要显示的返回对象不是发货请求的返回对象，而是重新对全部订单进行查询，接着返回的对象

接收请求参数类：OmsOrderDeliveryParam
```
/**
 * 订单发货参数
 */
@Getter
@Setter
public class OmsOrderDeliveryParam {
    @ApiModelProperty("订单id")
    private Long orderId;

    @ApiModelProperty("物流公司")
    private String deliveryCompany;

    @ApiModelProperty("物流单号")
    private String deliverySn;

}
```

OmsOrderController

```
    @ApiOperation("批量发货")
    @RequestMapping(value = "/update/delivery",method = RequestMethod.POST)
    @ResponseBody
    public Object delivery(@RequestParam("ids") List<OmsOrderDeliveryParam> deliveryParams) {
        int count = orderService.delivery(deliveryParams);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service
这里就是单纯的先更新了订单对象的更新时间，发货公司···属性
然后进行一个记录操作，
使用lamdba这个语法糖（减少以前各种new对象，set属性代码），更新订单操作历史对象（没有就创建）
```
    @Override
    public int delivery(List<OmsOrderDeliveryParam> deliveryParamList) {
        //批量发货
        int count = orderDao.delivery(deliveryParamList);

        //增加操作记录
        //这里有lambda 的应用
        //方法stream()---将集合转换为流， deliveryParamList.stream()就是把List转换成流
        //map(T -> R)----将流中的每一个元素 T 映射为 R（类似类型转换），这里将omsOrderDeliveryParam映射为history
        //就是将omsOrderDeliveryParam类型，映射成OmsOrderOperateHistory类型，omsOrderDeliveryParam是接收网页请求类，
        //这里假如不使用lambda，就单单是一个OmsOrderOperateHistory类对象的赋值过程
        //映射，不是转换，映射是XX对象的XX属性赋值给YY对象的YY属性
        //因为输入参数deliveryParamList是一个集合，每一个元素都要赋值执行，所以才使用lambda表达式的map()方法，进行遍历赋值
        List<OmsOrderOperateHistory> operateHistoryList = deliveryParamList.stream()
                .map(omsOrderDeliveryParam -> {
                    OmsOrderOperateHistory history = new OmsOrderOperateHistory();
                    history.setOrderId(omsOrderDeliveryParam.getOrderId());
                    history.setCreateTime(new Date());
                    history.setOperateMan("后台管理员");
                    history.setOrderStatus(2);
                    history.setNote("完成发货");
                    return history;
                }).collect(Collectors.toList());//collect 收集数据,它的方法toList()把流中所有元素收集到一个 List中
        orderOperateHistoryDao.insertList(operateHistoryList);
        return count;
    }
```

OmsOrderDao

这里case when意思是：
        当case后面的id 与when 后面的orderId 相同，则输出字段deliverySn的值
        foreach的作用：当case  后面的id = 2时候，遍历集合list，
        匹配when后面orderId，输出对应字段的值，没有找到匹配的orderId的时候，就跳过。
        foreach的open，separate close 分别表示sql语句中集合的输入参数的开头，元素之间，结尾，
        如果有3个元素XYZ，在Sql语句中显示的就是（X,Y,Z）


客户点击发货，传入参数，更新订单表格的物流单号，发货公司，发货时间，订单状态字段。
个人感觉这里应该是页面要求显示什么字段，就更新什么字段。
```
    <update id="delivery">
            /*这里case when意思是：
        当case后面的id 与when 后面的orderId 相同，则输出字段deliverySn的值
        foreach的作用：当case  后面的id = 2时候，遍历集合list，
        匹配when后面orderId，输出对应字段的值，没有找到匹配的orderId的时候，就跳过。
        foreach的open，separate close 分别表示sql语句中集合的输入参数的开头，元素之间，结尾，
        如果有3个元素XYZ，在Sql语句中显示的就是（X,Y,Z）
        */
        UPDATE
              oms_order
        SET
        delivery_sn = CASE  id
        <foreach collection="list" item="item">
            WHEN #{item.orderId} THEN #{item.deliverySn}
        </foreach>
        END ,
        delivery_company = CASE  id
        <foreach collection="list" item="item">
            WHEN #{item.orderId} THEN #{item.deliveryCompany}
        </foreach>
        END ,
        delivery_time = CASE  id
        <foreach collection="list" item="item">
            WHEN #{item.orderId} THEN now()
        </foreach>
        END ,
        `status` = CASE  id
        <foreach collection="list" item="item">
            WHEN #{item.orderId} THEN 2
        </foreach>
        END
        WHERE
            id
        IN
        <foreach collection="list" item="item" separator="," open="(" close=")">
            #{item.orderId}
        </foreach>
        AND
          `status` = 1
    </update>
```


OmsOrderOperateHistoryDao
接口
```

/**
 * 订单操作记录自定义Dao
 */
public interface OmsOrderOperateHistoryDao {

    void insertList(@Param("list") List<OmsOrderOperateHistory> operateHistoryList);
}
```


OmsOrderOperateHistoryDao.xml
```
<mapper namespace="com.taobao.taobaoadmin.dao.Oms.OmsOrderOperateHistoryDao">
    <insert id="insertList">
        insert INTO oms_order_operate_history(order_id,operate_man,create_time,order_status,note)
        VALUES
          <foreach collection="list" separator="," item="item" index="index">
              (
                #{item.orderId},
                #{item.operateMan},
                #{item.createTime,jdbcType=TIMESTAMP},
                #{item.orderStatus},
                #{item.note}
              )
          </foreach>
    </insert>
</mapper>
```


####修改收货人信息
发送站内信，取消订单，备注订单 

前端：
这是在订单详细页面上的
```
 <el-button type="primary" @click="handleUpdateReceiverInfo">确 定</el-button>
 //大串代码···
   import {getOrderDetail,updateReceiverInfo,updateMoneyInfo,closeOrder,updateOrderNote,deleteOrder} from '@/api/order';
 //大串代码···
       handleUpdateReceiverInfo(){
        this.$confirm('是否要修改收货信息?', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          updateReceiverInfo(this.receiverInfo).then(response=>{
            this.receiverDialogVisible=false;
            this.$message({
              type: 'success',
              message: '修改成功!'
            });
            getOrderDetail(this.id).then(response => {
              this.order = response.data;
            });
          });
        });
      },
```
API:
```
export function updateReceiverInfo(data) {
  return request({
    url:'/order/update/receiverInfo',
    method:'post',
    data:data
  });
}
```

后端：
修改请求：对数据库进行更新，没有立即返回对象的要求。
输入参数： 订单修改收货人信息参数
返回对象： 1

创建接收类:
```
import lombok.Getter;
import lombok.Setter;

/**
 * 订单修改收货人信息参数
 */
@Getter
@Setter
public class OmsReceiverInfoParam {
    private Long orderId;
    private String receiverName;
    private String receiverPhone;
    private String receiverPostCode;
    private String receiverDetailAddress;
    private String receiverProvince;
    private String receiverCity;
    private String receiverRegion;
    private Integer status;
}
```

OmsOrderController

```

    @ApiOperation("修改收货人信息")
    @RequestMapping(value = "/update/receiverInfo",method = RequestMethod.POST)
    @ResponseBody
    public Object updateReceiverInfo(@RequestBody OmsReceiverInfoParam receiverInfoParam) {
        int count = orderService.updateReceiverInfo(receiverInfoParam);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }

```

Service
接口：
```
    /**
     * 修改订单收货人信息
     */
    @Transactional
    int updateReceiverInfo(OmsReceiverInfoParam receiverInfoParam);
```
执行实体类：
```
    @Override
    public int updateReceiverInfo(OmsReceiverInfoParam receiverInfoParam) {
        OmsOrder order = new OmsOrder();
        order.setId(receiverInfoParam.getOrderId());
        order.setReceiverName(receiverInfoParam.getReceiverName());
        order.setReceiverCity(receiverInfoParam.getReceiverCity());
        order.setReceiverDetailAddress(receiverInfoParam.getReceiverDetailAddress());
        order.setReceiverPhone(receiverInfoParam.getReceiverPhone());
        order.setReceiverPostCode(receiverInfoParam.getReceiverPostCode());
        order.setReceiverProvince(receiverInfoParam.getReceiverProvince());
        order.setReceiverRegion(receiverInfoParam.getReceiverRegion());
        order.setModifyTime(new Date());
        int count = orderMapper.updateByPrimaryKeySelective(order);


        //插入操作记录
        OmsOrderOperateHistory history = new OmsOrderOperateHistory();
        history.setId(receiverInfoParam.getOrderId());
        history.setCreateTime(new Date());
        history.setOperateMan("后台管理员");
        history.setOrderStatus(receiverInfoParam.getStatus());
        history.setNote("修改收货人信息");
        orderOperateHistoryMapper.insert(history);
        return count;
    }
```

####修改订单费用信息

前端：
```
<el-button type="primary" @click="handleUpdateMoneyInfo">确 定</el-button>
//大串代码···
  import {getOrderDetail,updateReceiverInfo,updateMoneyInfo,closeOrder,updateOrderNote,deleteOrder} from '@/api/order';
//大串代码···
      handleUpdateMoneyInfo(){
        this.$confirm('是否要修改费用信息?', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          updateMoneyInfo(this.moneyInfo).then(response=>{
            this.moneyDialogVisible=false;
            this.$message({
              type: 'success',
              message: '修改成功!'
            });
```

API:
```
export function updateMoneyInfo(data) {
  return request({
    url:'/order/update/moneyInfo',
    method:'post',
    data:data
  });
}
```


后端：

修改请求：
输入参数：修改订单费用信息参数
返回对象：1，因为不是立即返回的对象，请求没有要求立即返回


费用的接收类：
```
import lombok.Getter;
import lombok.Setter;
import java.math.BigDecimal;
/**
 * 修改订单费用信息参数
 */
@Getter
@Setter
public class OmsMoneyInfoParam {
    private Long orderId;
    private BigDecimal freightAmount;
    private BigDecimal discountAmount;
    private Integer status;
}
```


OmsOrderController
```
    @ApiOperation("修改订单费用信息")
    @RequestMapping(value = "/update/moneyInfo",method = RequestMethod.POST)
    @ResponseBody
    public Object updateMoneyInfo(@RequestBody OmsMoneyInfoParam moneyInfoParam) {
        int count = orderService.updateMoneyInfo(moneyInfoParam);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service
接口：
```
    /**
     * 修改订单费用信息
     */
    @Transactional
    int updateMoneyInfo(OmsMoneyInfoParam moneyInfoParam);
```
实现类：
```
    @Override
    public int updateMoneyInfo(OmsMoneyInfoParam moneyInfoParam) {
        OmsOrder order = new OmsOrder();
        order.setId(moneyInfoParam.getOrderId());
        order.setFreightAmount(moneyInfoParam.getFreightAmount());
        order.setDiscountAmount(moneyInfoParam.getDiscountAmount());
        order.setModifyTime(new Date());
        int count = orderMapper.updateByPrimaryKeySelective(order);

        //插入操作记录
        OmsOrderOperateHistory history = new OmsOrderOperateHistory();
        history.setOrderId(moneyInfoParam.getOrderId());
        history.setCreateTime(new Date());
        history.setOperateMan("后台管理员");
        history.setOrderStatus(moneyInfoParam.getStatus());
        history.setNote("修改费用信息" );
        orderOperateHistoryMapper.insert(history);
        return count;
    }
```



####备注订单 

前端：

```
 <el-button type="primary" @click="handleMarkOrder">确 定</el-button>
 //大串代码···
   import {getOrderDetail,updateReceiverInfo,updateMoneyInfo,closeOrder,updateOrderNote,deleteOrder} from '@/api/order';
 //大串代码···
       handleMarkOrder(){
        this.$confirm('是否要备注订单?', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          let params = new URLSearchParams();
          params.append("id",this.markInfo.id);
          params.append("note",this.markInfo.note);
          params.append("status",this.order.status);
          updateOrderNote(params).then(response=>{
            this.markOrderDialogVisible=false;
            this.$message({
              type: 'success',
              message: '订单备注成功!'
            });
            getOrderDetail(this.id).then(response => {
              this.order = response.data;
            });
          });
        });
      },
```
API：
```
export function updateOrderNote(params) {
  return request({
    url:'/order/update/note',
    method:'post',
    params:params
  })
}
```

后端：

更改请求：
输入参数： id,note ,stataus
返回对象：1，应该是和客户沟通好，要返回什么对象的，不然不会这么整齐的返回一个1


OmsOrderController
```
    @ApiOperation("备注订单")
    @RequestMapping(value = "/update/note",method = RequestMethod.POST)
    @ResponseBody
    public Object updateNote(@RequestParam("id")Long id,
                             @RequestParam("note")String note,
                             @RequestParam("status")Integer status) {
        int count = orderService.updateNote(id,note,status);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```
Service:
接口：
```
    /**
     * 修改订单备注
     */
    @Transactional
    int updateNote(Long id, String note, Integer status);
```
实现类：
```
    @Override
    public int updateNote(Long id, String note, Integer status) {
        OmsOrder order = new OmsOrder();
        order.setId(id);
        order.setNote(note);
        order.setModifyTime(new Date());
        int count = orderMapper.updateByPrimaryKeySelective(order);

        //插入操作记录
        OmsOrderOperateHistory history = new OmsOrderOperateHistory();
        history.setOrderId(id);
        history.setCreateTime(new Date());
        history.setOperateMan("后台管理员");
        history.setOrderStatus(status);
        history.setNote("修改备注信息：" + note);
        orderOperateHistoryMapper.insert(history);
        return count;
    }
```

####批量关闭订单
发送站内信，取消订单

前端：
[![](https://ae01.alicdn.com/kf/H1159715f1bfb401188dae544b71b240d8.jpg)](https://ae01.alicdn.com/kf/H1159715f1bfb401188dae544b71b240d8.jpg)
[![](https://ae01.alicdn.com/kf/Hdce7bbd0849d4f5bafafc3709cc68c86H.jpg)](https://ae01.alicdn.com/kf/Hdce7bbd0849d4f5bafafc3709cc68c86H.jpg)
订单有3个操作状态： 删除，跟踪（这要配合物流，没有办法完成），发货
订单表格中的操作状态字段：

    status = 4  删除订单
    status = 3  订单跟踪
    status = 2  订单跟踪
    status = 1  订单发货

status在123状态下是没有单一按钮进行关闭的，只能批量关闭。

```
 <el-button type="primary" @click="handleCloseOrderConfirm">确 定</el-button>
 //大串代码···
  import {fetchList,closeOrder,deleteOrder} from '@/api/order'
  //大串代码···
  
      handleCloseOrderConfirm() {
        if (this.closeOrder.content == null || this.closeOrder.content === '') {
          this.$message({
            message: '操作备注不能为空',
            type: 'warning',
            duration: 1000
          });
          return;
        }
        let params = new URLSearchParams();
        params.append('ids', this.closeOrder.orderIds);
        params.append('note', this.closeOrder.content);
        closeOrder(params).then(response=>{
          this.closeOrder.orderIds=[];
          this.closeOrder.dialogVisible=false;
          this.getList();
          this.$message({
            message: '修改成功',
            type: 'success',
            duration: 1000
          });
        });
      },
//大串代码···
else if(this.operateType===2){
          //关闭订单
          this.closeOrder.orderIds=[];
          for(let i=0;i<this.multipleSelection.length;i++){
            this.closeOrder.orderIds.push(this.multipleSelection[i].id);
          }
          this.closeOrder.dialogVisible=true;
}
```



后端：

重点理解dao的查询Sql

OmsOrderController
```
    @ApiOperation("批量关闭订单")
    @RequestMapping(value = "/update/close",method = RequestMethod.POST)
    @ResponseBody
    public Object close(@RequestParam("ids") List<Long> ids,
                        @RequestParam String note) {
        int count = orderService.close(ids, note);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service:
接口：
```
    /**
     * 批量关闭订单
     */
    @Transactional
    int close(List<Long> ids, String note);
```
实现类：
```
    @Override
    public int close(List<Long> ids, String note) {
        OmsOrder record = new OmsOrder();
        record.setStatus(4);
        OmsOrderExample example = new OmsOrderExample();
        example.createCriteria().andDeleteStatusEqualTo(0).andIdIn(ids);
        int count = orderMapper.updateByExampleSelective(record, example);


        //删除操作记录
        List<OmsOrderOperateHistory> historyList = ids.stream().map(orderId -> {
            OmsOrderOperateHistory history = new OmsOrderOperateHistory();
            history.setOrderId(orderId);
            history.setCreateTime(new Date());
            history.setOperateMan("后台管理员");
            history.setOrderStatus(4);
            history.setNote("订单关闭："+note);
            return history;
        }).collect(Collectors.toList());
        orderOperateHistoryDao.insertList(historyList);
        return count;
    }
```

Dao：
```
/**
 * 订单操作记录自定义Dao
 */
public interface OmsOrderOperateHistoryDao {

    int insertList(@Param("list") List<OmsOrderOperateHistory> orderOperateHistoryList);
}
```
XML :
```
<mapper namespace="com.taobao.taobaoadmin.dao.Oms.OmsOrderOperateHistoryDao">
    <insert id="insertList">
        insert INTO oms_order_operate_history(order_id,operate_man,create_time,order_status,note)
        VALUES
          <foreach collection="list" separator="," item="item" index="index">
              (
                #{item.orderId},
                #{item.operateMan},
                #{item.createTime,jdbcType=TIMESTAMP},
                #{item.orderStatus},
                #{item.note}
              )
          </foreach>
    </insert>
</mapper>
```


#疑问

##问题1

在 写删除订单的时候，为什么删除方法的参数使用的是@RequestParam("ids"),而不是@PathVariable

简单说：就是@RequestParam和@PathVariable的区别？

##问题2

@RequestParam和@RequestBody的区别？




##问题3

注解@Transactional什么情况下使用？


##问题4


myBatis的Sql语句问题，在看控制台提示的时候，有时候它给的提示的错误的语句并不是问题所在，而是**提示语句的上下文语句出现了错误**。








#参考：

mall数据库表结构概览：
https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247483835&idx=1&sn=895ae94d5a0bc5fbe5bed8aa715d92af&scene=21#wechat_redirect

订单模块数据库表解析1
https://mp.weixin.qq.com/s/OcZQpT3b9YjR8xAZHblHAw



	2019-08-02 18:04:52
kumika	电商项目--8	# 电商项目--8

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧



#订单管理

订单管理分为：
订单列表
订单设置
退货申请处理
退货原因设置


#订单设置

##查询设置属性

点击订单设置，查询全部的订单设置属性
```
  import {getOrderSetting,updateOrderSetting} from '@/api/orderSetting';
  //大串代码···
  created(){
      this.getDetail();
    },
//大串代码··
    getDetail(){
        getOrderSetting(1).then(response=>{
          this.orderSetting=response.data;
        })
      }
```

订单设置的API：
```
export function getOrderSetting(id) {
  return request({
    url:'/orderSetting/'+id,
    method:'get',
  })
}
```

后端：

查询请求：根据id查询订单设置对象，查询请求有立即返回对象。
输入参数：id
返回对象：OmsOrderSetting类对象---订单设置对象


OmsOrderSettingController

```
@Controller
@Api(value = "OmsOrderSettingController", description = "订单设置管理")
@RequestMapping("/orderSetting")
public class OmsOrderSettingController {

    @Autowired
    private OmsOrderSettingService orderSettingService;

    @ApiOperation("获取指定订单设置")
    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    @ResponseBody
    public Object getItem(@PathVariable Long id) {
        OmsOrderSetting orderSetting = orderSettingService.getItem(id);
        return new CommonResult().success(orderSetting);
    }

}
```


Service:
接口就不写了。
```
/**
 * 订单设置管理Service实现类
 */
@Service
public class OmsOrderSettingServiceIMPL implements OmsOrderSettingService {

    @Autowired
    private OmsOrderSettingMapper orderSettingMapper;

    @Override
    public OmsOrderSetting getItem(Long id) {
        return orderSettingMapper.selectByPrimaryKey(id);
    }
}
```


##更新订单设置属性

前端：
```
<el-button
          @click="confirm('orderSettingForm')"
          type="primary">提交</el-button>
//大串代码···
  import {getOrderSetting,updateOrderSetting} from '@/api/orderSetting';
  //大串代码···
confirm(formName){
        this.$refs[formName].validate((valid) => {
          if (valid) {
            this.$confirm('是否要提交修改?', '提示', {
              confirmButtonText: '确定',
              cancelButtonText: '取消',
              type: 'warning'
            }).then(() => {
  updateOrderSetting(1,this.orderSetting).then(response=>{
```

API：
```
export function updateOrderSetting(id,data) {
  return request({
    url:'/orderSetting/update/'+id,
    method:'post',
    data:data
  })
}
```


后端：

OmsOrderSettingController
```
    @ApiOperation("修改指定订单设置")
    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object update(@PathVariable Long id, @RequestBody OmsOrderSetting orderSetting) {
        int count = orderSettingService.update(id, orderSetting);
        if (count > 0) {
            return new CommonResult().success(count);
        } else {
            return new CommonResult().failed();
        }
    }
```

Service:
```
    @Override
    public int update(Long id, OmsOrderSetting orderSetting) {
        orderSetting.setId(id);
        return orderSettingMapper.updateByPrimaryKey(orderSetting);
    }
```

	2019-08-08 12:15:18
kumika	电商项目--9	# 电商项目--9

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧



#订单管理

订单管理分为：
订单列表
订单设置
退货申请处理
退货原因设置


#退货申请处理

##查询退货申请

前端：
```
        <el-button
          style="float:right"
          type="primary"
          @click="handleSearchList()"
          size="small">
          查询搜索
        </el-button>
//大串代码···
  import {fetchList,deleteApply} from '@/api/returnApply';
//大串代码···
    created(){
      this.getList();
    },
//大串代码···
      handleSearchList() {
        this.listQuery.pageNum = 1;
        this.getList();
      },
//大串代码···
      getList(){
        this.listLoading=true;
        fetchList(this.listQuery).then(response => {
          this.listLoading = false;
          this.list = response.data.list;
          this.total = response.data.total;
        });
      }
```
API：
```
export function fetchList(params) {
  return request({
    url:'/returnApply/list',
    method:'get',
    params:params
  })
}
```

后端：

接收参数：
```
/**
 * 订单退货申请查询参数
 */
@Getter
@Setter
public class OmsReturnApplyQueryParam {
    @ApiModelProperty("服务单号")
    private Long id;
    @ApiModelProperty("收货人姓名/号码")
    private String receiverKeyword;
    @ApiModelProperty("申请状态：0->待处理；1->退货中；2->已完成；3->已拒绝")
    private Integer status;
    @ApiModelProperty("申请时间")
    private String createTime;
    @ApiModelProperty("处理人员")
    private String handleMan;
    @ApiModelProperty("处理时间")
    private String handleTime;
}
```



OmsOrderReturnApplyController
```
/**
 * 订单退货申请管理
 */
@Controller
@Api(value = "OmsOrderReturnApplyController", description = "订单退货申请管理")
@RequestMapping("/returnApply")
public class OmsOrderReturnApplyController {

    @Autowired
    private OmsOrderReturnApplyService returnApplyService;

    @ApiOperation("分页查询退货申请")
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    @ResponseBody
    public Object list(OmsReturnApplyQueryParam queryParam,
                       @RequestParam(value = "pageSize", defaultValue = "5") Integer pageSize,
                       @RequestParam(value = "pageNum", defaultValue = "1") Integer pageNum) {
        List<OmsOrderReturnApply> returnApplyList = returnApplyService.list(queryParam, pageSize, pageNum);
        return new CommonResult().pageSuccess(returnApplyList);
    }
}
```

Service :
接口：
```
/**
 * 退货申请管理Service
 */
public interface OmsOrderReturnApplyService {
    /**
     * 分页查询申请
     */
    List<OmsOrderReturnApply> list(OmsReturnApplyQueryParam queryParam, Integer pageSize, Integer pageNum);
}
```
实现类：
```
    @Override
    public List<OmsOrderReturnApply> list(OmsReturnApplyQueryParam queryParam, Integer pageSize, Integer pageNum) {
        PageHelper.startPage(pageNum, pageSize);
        return orderReturnApplyDao.getList(queryParam);
    }
```

Dao:
接口：
```
/**
 * 订单退货申请自定义Dao
 */
public interface OmsOrderReturnApplyDao {
    /**
     * 查询申请列表
     */
    List<OmsOrderReturnApply> getList(@Param("queryParam") OmsReturnApplyQueryParam queryParam);
}
```
XML文件：
注意：使用的resultMap是OmsOrderReturnApplyMapper的BaseResultMap，不是随便哪个BaseResultMap
```
<select id="getList" resultMap="com.taobao.taobaoadmin.mapper.OmsOrderReturnApplyMapper.BaseResultMap">
        select
              id,
              create_time,
              member_username,
              product_real_price,
              product_name,
              status,
              handle_time
        from
              oms_order_return_apply
        WHERE
              1 = 1
              <if test="queryParam.id != null">
                  AND  id = #{queryParam.id}
              </if>
        <if test="queryParam.status != null">
            AND  status = #{queryParam.status}
        </if>
        <if test="queryParam.handleMan != null and queryParam.handleMan!=''">
            AND  handle_man = #{queryParam.handleMan}
        </if>
        <if test="queryParam.createTime != null and queryParam.createTime!=''">
            AND  create_time LIKE  CONCAT (#{queryParam.createTime},'%')
        </if>
        <if test="queryParam.handleTime != null and queryParam.handleTime!=''">
            AND  handle_time LIKE  CONCAT (#{queryParam.handleTime},'%')
        </if>
        <if test="queryParam.receiverKeyword != null and queryParam.receiverKeyword!=''">
            AND (
                return_name LIKE CONCAT ("%",#{queryParam.receiverKeyword},"%")
                OR
                return_phone LIKE CONCAT ("%",#{queryParam.receiverKeyword},"%")
            )
        </if>
    </select>
```

##批量删除
前端：
```
export function deleteApply(params) {
  return request({
    url:'/returnApply/delete',
    method:'post',
    params:params
  })
}
```


后端：

客户请求： 根据id集合删除申请对象
请求参数： id集合
返回对象： 1


OmsOrderReturnApplyController
```
    @ApiOperation("批量删除申请")
    @RequestMapping(value = "/delete", method = RequestMethod.POST)
    @ResponseBody
    public Object delete(@RequestParam("ids") List<Long> ids) {
        int count = returnApplyService.delete(ids);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```


Service:
```
    @Override
    public int delete(List<Long> ids) {
        OmsOrderReturnApplyExample example = new OmsOrderReturnApplyExample();
        example.createCriteria().andIdIn(ids).andStatusEqualTo(3);

        return returnApplyMapper.deleteByExample(example);
    }
```


##查看详细申请

前端：
```
export function getApplyDetail(id) {
  return request({
    url:'/returnApply/'+id,
    method:'get'
  })
}
```

后端：

客户请求： 根据id查询申请对象全部属性
请求参数： id
返回对象： 申请对象，是立即返回对象。


接收前端请求参数类：
这个类继承了OmsOrderReturnApply
```
/**
 * 申请信息封装
 */
public class OmsOrderReturnApplyResult extends OmsOrderReturnApply {
    @Getter
    @Setter
    private OmsCompanyAddress companyAddress;
}
```


OmsOrderReturnApplyController
```
    @ApiOperation("获取退货申请详情")
    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    @ResponseBody
    public Object getItem(@PathVariable Long id) {
        OmsOrderReturnApplyResult result = returnApplyService.getItem(id);
        return new CommonResult().success(result);
    }
```

Service
```
    @Override
    public OmsOrderReturnApplyResult getItem(Long id) {
        return orderReturnApplyDao.getDetail(id);
    }
```

Dao：
接口：
```
    /**
     * 获取申请详情
     */
    OmsOrderReturnApplyResult getDetail(@Param("id") Long id);
```
xml文件：

这个Map的类型是OmsOrderReturnApplyResult申请信息封装类，拓展OmsOrderReturnApplyMapper的baseResultMap
级联association，JavaBean属性是companyAddress，resultmap是OmsCompanyAddressMapper的baseResultMap，有columnPrefix

请求参数的大多数属性在申请表 `oms_order_return_apply`可以获取，但是因为你请求参数有companyAddress属性，这属性不在申请表 `oms_order_return_apply`上，在公司地址表`oms_company_address`上，所以使用级联association（级联--同等级联系？）

```
    <!--
            type：返回值的全限定类名，或类型别名。
            extends： 就是继承，让别的返回集合也可以用
            association与collection的区别：
            嵌套使用collection，就是你查询星球对象，星球对象里有海洋属性，但是海洋是一个对象也有一个表格，它也有属性而且你页面也要显示，像俄罗斯套娃。简单说就是一对多
            查询一个对象，这个对象里有一个别的表格的属性，此时使用association，就是一对一
    -->
    <resultMap id="returnApplyDetailResultMap"  type="com.taobao.taobaoadmin.dto.Oms.OmsOrderReturnApplyResult" extends="com.taobao.taobaoadmin.mapper.OmsOrderReturnApplyMapper.BaseResultMap">
            <!--
            association： 级联
            property: 映射JavaBean的属性，这里是OmsOrderReturnApplyResult对象的属性，就是客户要的数据
            resultMap: 返回集合
            columnPrefix：数据库的列名或者列标签的前缀。
            级联，返回集合是OmsCompanyAddressMapper的BaseResultMap，
            要是SQL语句有相同列名的情况区别在于前缀ca_，映射OmsOrderReturnApplyResult对象的属性companyAddress
        -->
        <association property="companyAddress"
                     resultMap="com.taobao.taobaoadmin.mapper.OmsCompanyAddressMapper.BaseResultMap"
                     columnPrefix="ca_"/>
    </resultMap>
    
    
    
    <select id="getDetail" resultMap="returnApplyDetailResultMap">
        SELECT
          ra.*,
          ca.id as ca_id,
          ca.address_name as ca_address_name,
          ca.`name` as ca_name,
          ca.phone as ca_phone,
          ca.province as ca_province,
          ca.city as ca_city,
          ca.region as ca_region,
          ca.detail_address as ca_detail_address
        FROM
          oms_order_return_apply as ra
          left join
          oms_company_address as ca ON  ra.company_address_id = ca.id
        WHERE
          ra.id=#{id}
    </select>
```


##更新申请对象


前端：
```
export function updateApplyStatus(id,data) {
  return request({
    url:'/returnApply/update/status/'+id,
    method:'post',
    data:data
  })
}
```


后端：

客户请求： 确认退货，拒绝退货，确认收货
请求参数： id  页面上的请求数据data
返回对象： 1


确认收货提交参数:
```
@Getter
@Setter
public class OmsUpdateStatusParam {
    @ApiModelProperty("服务单号")
    private Long id;
    @ApiModelProperty("收货地址关联id")
    private Long companyAddressId;
    @ApiModelProperty("确认退款金额")
    private BigDecimal returnAmount;
    @ApiModelProperty("处理备注")
    private String handleNote;
    @ApiModelProperty("处理人")
    private String handleMan;
    @ApiModelProperty("收货备注")
    private String receiveNote;
    @ApiModelProperty("收货人")
    private String receiveMan;
    @ApiModelProperty("申请状态：1->退货中；2->已完成；3->已拒绝")
    private Integer status;
}
```

OmsOrderReturnApplyController
```
    @ApiOperation("修改申请状态")
    @RequestMapping(value = "/update/status/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object updateStatus(@PathVariable Long id,
                               @RequestBody OmsUpdateStatusParam statusParam) {
        int count = returnApplyService.updateStatus(id, statusParam);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service
更新对象有3状态，4种情况

    申请状态： 
              0->待处理；
              1->退货中；
              2->已完成；
              3->已拒绝"，

所以有4种情况，


**更新操作大多数是对对象的属性赋值完毕，直接使用Mybatis的方法进行更新
查询，删除大多是进入DaoXML文件进行写SQL语句操作的。**

```
    @Override
    public int updateStatus(Long id, OmsUpdateStatusParam statusParam) {
        Integer status = statusParam.getStatus();
        OmsOrderReturnApply returnApply = new OmsOrderReturnApplyResult();
        if (status.equals(1)) {
            //确认退货
            returnApply.setId(id);
            returnApply.setStatus(1);
            returnApply.setReturnAmount(statusParam.getReturnAmount());
            returnApply.setCompanyAddressId(statusParam.getCompanyAddressId());
            returnApply.setHandleTime(new Date());
            returnApply.setHandleMan(statusParam.getHandleMan());
            returnApply.setHandleNote(statusParam.getHandleNote());
        } else if (status.equals(2)) {
            //完成退货
            returnApply.setId(id);
            returnApply.setStatus(2);
            returnApply.setReceiveTime(new Date());
            returnApply.setReceiveMan(statusParam.getReceiveMan());
            returnApply.setReceiveNote(statusParam.getReceiveNote());
        } else if (status.equals(3)) {
            returnApply.setId(id);
            returnApply.setStatus(3);
            returnApply.setHandleTime(new Date());
            returnApply.setHandleMan(statusParam.getHandleMan());
            returnApply.setHandleNote(statusParam.getHandleNote());
        } else {
            return 0;
        }
        return returnApplyMapper.updateByPrimaryKeySelective(returnApply);
    }
```






#疑问：

##问题1

pageSuccess和success的区别是什么？


##问题2

在myBatis中
```
 AND  handle_time LIKE  CONCAT (#{queryParam.handleTime},'%')
  AND (
                return_name LIKE CONCAT ("%",#{queryParam.receiverKeyword},"%")
                OR
                return_phone LIKE CONCAT ("%",#{queryParam.receiverKeyword},"%")
            )
```
其中""和‘’的使用区别是什么？


	2019-08-09 11:36:31
kumika	电商项目--10	# 电商项目--10

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧



#订单管理

订单管理分为：
订单列表
订单设置
退货申请处理
退货原因设置


#退货原因设置

##查询全部
前端：
```
export function fetchList(params) {
  return request({
    url:'/returnReason/list',
    method:'get',
    params:params
  })
}
```



后端：
客户要求：点击退货原因设置，就能看到全部的退货原因对象
请求参数；pageSize, pageNum
返回对象：原因列表对象，立即返回的列表对象

OmsOrderReturnReasonController



```
/**
 * 退货原因管理Controller
 */
@Controller
@Api(value = "OmsOrderReturnReasonController", description = "退货原因管理")
@RequestMapping("/returnReason")
public class OmsOrderReturnReasonController {

    @Autowired
    private OmsOrderReturnReasonService orderReturnReasonService;

    @ApiOperation("分页查询全部退货原因")
    @RequestMapping(value = "/list",method = RequestMethod.GET)
    @ResponseBody
    public Object list(@RequestParam(value = "pageSize",defaultValue = "5")Integer pageSize,
                       @RequestParam(value = "pageNum",defaultValue = "1")Integer pageNum) {
        List<OmsOrderReturnReason> returnReasonList = orderReturnReasonService.list(pageSize, pageNum);
        return new CommonResult().pageSuccess(returnReasonList);
    }
}
```

Service:

查询列表集合，只使用了降序排列列表

```
    @Override
    public List<OmsOrderReturnReason> list(Integer pageSize, Integer pageNum) {
        PageHelper.startPage(pageNum, pageSize);
        OmsOrderReturnReasonExample example = new OmsOrderReturnReasonExample();
        example.setOrderByClause("sort desc");

        return orderReturnReasonMapper.selectByExample(example);
    }
```
##查询单一


前端：
```
export function getReasonDetail(id) {
  return request({
    url:'/returnReason/'+id,
    method:'get'
  })
}
```




后端：
客户要求： 勾选任意单一原因对象，查看该对象的详细属性
请求参数； id
返回对象： 该id的对象，立即返回

OmsOrderReturnReasonController
```
    @ApiOperation("获取单个退货原因详情信息")
    @RequestMapping(value = "/{id}",method = RequestMethod.GET)
    @ResponseBody
    public Object getItem(@PathVariable Long id) {
        OmsOrderReturnReason returnReason = orderReturnReasonService.getItem(id);
        return new CommonResult().success(returnReason);
    }
```

Service:
根据id查询退货原因对象
```
    @Override
    public OmsOrderReturnReason getItem(Long id) {
        return orderReturnReasonMapper.selectByPrimaryKey(id);
    }
```


##更新原因对象

###编辑原因对象
前端：
```
export function updateReason(id,data) {
  return request({
    url:'/returnReason/update/'+id,
    method:'post',
    data:data
  })
}
```
客户想法：
    点击编辑按钮，出现详细更改内容，内容页面上点击确定，完成修改


后端：
客户要求：勾选对象，点击确定，完成修改
请求参数：id，原因设置对象属性
返回对象： 1，没有立即返回对象

OmsOrderReturnReasonController
```

    @ApiOperation("修改退货原因")
    @RequestMapping(value = "/update/{id}",method = RequestMethod.POST)
    @ResponseBody
    public Object update(@PathVariable Long id,
                         @RequestBody OmsOrderReturnReason returnReason) {
        int count = orderReturnReasonService.update(id, returnReason);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }

```



Serivce
```
    @Override
    public int update(Long id, OmsOrderReturnReason returnReason) {
        returnReason.setId(id);
        return orderReturnReasonMapper.updateByPrimaryKey(returnReason);
    }
```




###更改原因对象状态


前端：
```
export function updateStatus(params) {
  return request({
    url:'/returnReason/update/status',
    method:'post',
    params:params
  })
}
```

客户想法：
    点击按钮，直接更改状态


后端：
客户要求：  点击按钮，直接更改状态
请求参数： id ，原因对象的状态属性
返回对象： 1 ， 没有立即返回对象

OmsOrderReturnReasonController
```
    @ApiOperation("修改退货原因启用状态")
    @RequestMapping(value = "/update/status",method = RequestMethod.POST)
    @ResponseBody
    public Object updateStatus(@RequestParam("ids")List<Long> ids,
                               @RequestParam("status")Integer status) {
        int count = orderReturnReasonService.updateStatus(ids, status);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```


Service:
```
    @Override
    public int updateStatus(List<Long> ids, Integer status) {
        if (!status.equals(0) && !status.equals(1)) {
            return 0;
        }
        OmsOrderReturnReason record = new OmsOrderReturnReason();
        record.setStatus(status);
        OmsOrderReturnReasonExample example = new OmsOrderReturnReasonExample();
        example.createCriteria().andIdIn(ids);
        return orderReturnReasonMapper.updateByExampleSelective(record, example);
    }
```

##增加退货原因

前端：
```
export function addReason(data) {
  return request({
    url:'/returnReason/create',
    method:'post',
    data:data
  })
}
```


客户想法：
    点击按钮，增加退货原因对象


后端：
客户要求：增加退货原因对象
请求参数：退货原因对象
返回对象： 1，没有立即返回对象

OmsOrderReturnReasonController
```
    @ApiOperation("添加退货原因")
    @RequestMapping(value = "/create", method = RequestMethod.POST)
    @ResponseBody
    public Object create(@RequestBody OmsOrderReturnReason returnReason) {
        int count = orderReturnReasonService.create(returnReason);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service

```
    @Override
    public int create(OmsOrderReturnReason returnReason) {
        returnReason.setCreateTime(new Date());
        return orderReturnReasonMapper.insert(returnReason);
    }
```



##删除退货原因


前端：
```
export function deleteReason(params) {
  return request({
    url:'/returnReason/delete',
    method:'post',
    params:params
  })
}
```


客户想法：
    点击按钮，直接删除，或者是勾选多个原因对象，点击批量删除


后端：
客户要求： 能批量或者单一删除对象
请求参数： ids
返回对象： 1 ，没有立即返回对象

OmsOrderReturnReasonController
```
    @ApiOperation("批量删除退货原因")
    @RequestMapping(value = "/delete", method = RequestMethod.POST)
    @ResponseBody
    public Object delete(@RequestParam("ids") List<Long> ids) {
        int count = orderReturnReasonService.delete(ids);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service
```
    @Override
    public int delete(List<Long> ids) {
        OmsOrderReturnReasonExample example = new OmsOrderReturnReasonExample();
        example.createCriteria().andIdIn(ids);
        return orderReturnReasonMapper.deleteByExample(example);
    }
```

	2019-08-10 12:16:48
kumika	电商项目--11	# 电商项目--11

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧

#营销管理

秒杀活动列表
优惠劵列表
品牌推荐
新品推荐
人气推荐
专题推荐
广告列表


#秒杀活动列表

分为3个部分合成的结构，秒杀列表是一个部分，活动列表是一个部分,秒杀与活动关联作为一个对象，这也是一个部分。所以有3类Controller。



##秒杀列表


[![](https://ae01.alicdn.com/kf/Hfa4b368a7bb44a65a3e1e50eaae0b4e7T.jpg)](https://ae01.alicdn.com/kf/Hfa4b368a7bb44a65a3e1e50eaae0b4e7T.jpg)

###查询秒杀列表

前端：
```
export function fetchList(params) {
  return request({
    url: '/flashSession/list',
    method: 'get',
    params: params
  })
}
```

客户要求：点击秒杀时间段列表按钮，查询出全部的秒杀对象


后端：

请求效果： 点击按钮，跳转新的页面，出现全部的秒杀对象
输入参数:  null(就是这么霸气，不需要参数)
返回对象： 秒杀对象列表

SmsFlashPromotionSessionController

```
/**
 * 限时购场次管理Controller
 */
@Controller
@Api(value = "SmsFlashPromotionSessionController", description = "限时购场次管理")
@RequestMapping("/flashSession")
public class SmsFlashPromotionSessionController {
    @Autowired
    private SmsFlashPromotionSessionService flashPromotionSessionService;


    @ApiOperation("获取全部场次")
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    @ResponseBody
    public Object list() {
        List<SmsFlashPromotionSession> promotionSessionList = flashPromotionSessionService.list();
        return new CommonResult().success(promotionSessionList);
    }
}
```

Service
```
@Service
public class SmsFlashPromotionSessionServiceIMPL implements SmsFlashPromotionSessionService {

    @Autowired
    private SmsFlashPromotionSessionMapper promotionSessionMapper;
    
    //根据启用状态获取场次列表
    @Override
    public List<SmsFlashPromotionSession> list() {
        SmsFlashPromotionSessionExample example = new SmsFlashPromotionSessionExample();

        return promotionSessionMapper.selectByExample(example);
    }
}
```


###增加秒杀列表

前端：
```
export function createSession(data) {
  return request({
    url: '/flashSession/create',
    method: 'post',
    data: data
  })
}
```

客户要求： 点击增加按钮，跳转到秒杀对象详细属性页面，再点击确定，完成添加按钮。


后端：

请求效果： 完成增加秒杀对象
输入参数:  秒杀对象
返回对象： 1


SmsFlashPromotionSessionController

```
    @ApiOperation("添加场次")
    @RequestMapping(value = "/create", method = RequestMethod.POST)
    @ResponseBody
    public Object create(@RequestBody SmsFlashPromotionSession promotionSession) {
        int count = flashPromotionSessionService.create(promotionSession);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```


Service:

```
@Override
    public int create(SmsFlashPromotionSession promotionSession) {
        promotionSession.setCreateTime(new Date());
        return promotionSessionMapper.insert(promotionSession);
    }
```
###删除秒杀对象
前端：
```
export function deleteSession(id) {
  return request({
    url: '/flashSession/delete/' + id,
    method: 'post'
  })
}
```


客户要求：


后端：点击删除，完成删除秒杀对象（只能一个个删除，不能批量，能实现这个给批量功能，但是没有必要）

请求效果： 删除秒杀对象
输入参数:  秒杀对象
返回对象： 1 （这虽然是返回1，但是删除后是会跳转回查询页面，重新查询全部秒杀对象的，这功能的实现是前端技术）

SmsFlashPromotionSessionController

```
    @ApiOperation("删除场次")
    @RequestMapping(value = "/delete/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object delete(@PathVariable Long id) {
        int count = flashPromotionSessionService.delete(id);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service:

```
    @Override
    public int delete(Long id) {
        return promotionSessionMapper.deleteByPrimaryKey(id);
    }
```

###编辑秒杀列表
[![](https://ae01.alicdn.com/kf/H5f9a563d5d984ea1ac2ccf73c37f2e327.jpg)](https://ae01.alicdn.com/kf/H5f9a563d5d984ea1ac2ccf73c37f2e327.jpg)


修改对象，一般是创建一个新的该类对象，把输入参数赋值到这个对象上，然后使用Mybatis进行更新修改。
要是输入参数就是该类对象，则不需要再次创建一个新的对象，不需要赋值，直接使用MyBatis的方法进行更新修改。
使用Mybatis的updateByXXXX方法，这些方法有什么区别？


####直接更改启用状态

前端：
```
export function updateStatus(id, params) {
  return request({
    url: '/flashSession/update/status/' + id,
    method: 'post',
    params: params
  })
}
```

客户要求：直接点击启用按钮，可以修改属性，不需要点击编辑按钮


后端：

请求效果： 直接修改属性
输入参数:  id，status
返回对象： 1 

SmsFlashPromotionSessionController

```
    @ApiOperation("修改启用状态")
    @RequestMapping(value = "/update/status/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object updateStatus(@PathVariable Long id,Integer status) {
        int count = flashPromotionSessionService.updateStatus(id, status);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service

```
    @Override
    public int updateStatus(Long id, Integer status) {
        SmsFlashPromotionSession promotionSession = new SmsFlashPromotionSession();
        promotionSession.setId(id);
        promotionSession.setStatus(status);
        return promotionSessionMapper.updateByPrimaryKeySelective(promotionSession);
    }
```

####修改单一秒杀对象

前端：
```
export function updateSession(id, data) {
  return request({
    url: '/flashSession/update/' + id,
    method: 'post',
    data: data
  })
}
```

客户要求：修改包括启用属性在内的全部的秒杀对象属性，点击编辑按钮，完成修改对象


后端：

请求效果： 编辑按钮，完成修改
输入参数:  id，秒杀对象
返回对象： 1

SmsFlashPromotionSessionController


```
    @ApiOperation("修改场次")
    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object update(@PathVariable Long id,
                         @RequestBody SmsFlashPromotionSession promotionSession) {
        int count = flashPromotionSessionService.update(id, promotionSession);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service

```
    @Override
    public int update(Long id, SmsFlashPromotionSession promotionSession) {
        promotionSession.setId(id);
        return promotionSessionMapper.updateByPrimaryKey(promotionSession);
    }
```

###活动列表的设置商品

[![](https://ae01.alicdn.com/kf/H12f01e9edfaf4f23a7d1400a0a69c98cm.jpg)](https://ae01.alicdn.com/kf/H12f01e9edfaf4f23a7d1400a0a69c98cm.jpg)

不知道为什么放在秒杀的Controller上。？！

前端：
```
export function fetchSelectList(params) {
  return request({
    url: '/flashSession/selectList',
    method: 'get',
    params: params
  })
}
```

客户要求：点击设置商品按钮，跳转到新页面，显示全部的秒杀对象（主要要求），而且有显示商品列表的连接，点击链接跳转显示参加秒杀活动的商品（这是后面的限时购与商品关联的内容）


后端：

请求效果： 点击设置商品，跳转页面，查询全部秒杀对象 
输入参数:  活动对象的id
返回对象： 秒杀对象列表


接收类： 
从SmsFlashPromotionSession继承，有自己的属性productCount的SmsFlashPromotionSessionDetail类。
```
/**
 * 包含商品数量的场次信息
 */
public class SmsFlashPromotionSessionDetail extends SmsFlashPromotionSession {
    @Setter
    @Getter
    private Integer productCount;
}
```

查询限时秒杀对象，但是因为客户的要求里有计算商品数量，是属于商品与限时活动关联表格的值，不是属于数据库中的限时秒杀表格，所以自定义了一个属性是商品数量的XX类，这XX类继承了限时秒杀类。
给这个XX类赋值的时候，因为表格不同，查询返回的值可以分开赋值。
这样就完成发出一个请求，**返回的对象，包含了客户全部的要求。**

SmsFlashPromotionSessionController

```
    @ApiOperation("获取全部可选场次及其数量")
    @RequestMapping(value = "/selectList", method = RequestMethod.GET)
    @ResponseBody
    public Object selectList(Long flashPromotionId) {
        List<SmsFlashPromotionSessionDetail> promotionSessionList = flashPromotionSessionService.selectList(flashPromotionId);
        return new CommonResult().pageSuccess(promotionSessionList);
    }
```


Service:
接口：
```
    /**
     * 获取全部可选场次及其数量
     */
    List<SmsFlashPromotionSessionDetail> selectList(Long flashPromotionId);
```
实现类：
查询限时秒杀对象，但是因为客户的要求里有计算商品数量，是属于商品与限时活动关联表格的值，不是属于数据库中的限时秒杀表格，所以自定义了一个属性是商品数量的XX类，这XX类继承了限时秒杀类。
给这个XX类赋值的时候，因为表格不同，查询返回的值可以分开赋值。
这样就完成发出一个请求，**返回的对象，包含了客户全部的要求。**

```
    @Override
    public List<SmsFlashPromotionSessionDetail> selectList(Long flashPromotionId) {
        //根据输入参数id，使用example查询,
        // 而且应该是和前端沟通好的，查询的时候只查询status = 1 范围里的id
        SmsFlashPromotionSessionExample example = new SmsFlashPromotionSessionExample();
        example.createCriteria().andStatusEqualTo(1);
        List<SmsFlashPromotionSession> list = promotionSessionMapper.selectByExample(example);
        //因为客户要求页面上显示商品的数量
        //返回的限时购场次列表对象list，需要放到一个自定义的包含商品数量的场次信息的列表对象上
        //这个列表对象泛型是SmsFlashPromotionSessionDetail类，具有商品数量的属性，继承自SmsFlashPromotionSession类
        List<SmsFlashPromotionSessionDetail> result = new ArrayList<>();
        for (SmsFlashPromotionSession promotionSession : list) {
            SmsFlashPromotionSessionDetail detail = new SmsFlashPromotionSessionDetail();
            BeanUtils.copyProperties(promotionSession, detail);
            //查询商品的数量，使用限时购商品关联管理接口的方法来计算
            //此方法是根据活动id和场次id获取商品关系数量
            int count = relationService.getCount(flashPromotionId, promotionSession.getId());
            detail.setProductCount(count);
            result.add(detail);
        }
        return result;
    }
```

限时购商品关联管理Service
接口就不写了，怕麻烦。
根据活动id和场次id获取商品关系数量
SmsFlashPromotionProductRelationServiceIMPL
```
    @Autowired
    private SmsFlashPromotionProductRelationMapper relationMapper;

    @Override
    public int getCount(Long flashPromotionId, Long flashPromotionSessionId) {
        SmsFlashPromotionProductRelationExample example = new SmsFlashPromotionProductRelationExample();
        example.createCriteria()
                .andFlashPromotionIdEqualTo(flashPromotionId)
                .andFlashPromotionSessionIdEqualTo(flashPromotionSessionId);
        return relationMapper.countByExample(example);
    }
```




##活动列表


###查询全部的活动列表

前端：
```
export function fetchList(params) {
  return request({
    url:'/flash/list',
    method:'get',
    params:params
  })
}
```
客户要求：
点击活动列表或者条件搜索，查到相对应活动对象，返回到页面（条件搜索，就一定有keyword的了）

后端：

请求效果： 点击活动列表，查到全部的活动对象，返回到页面
输入参数:  pageSize,pageNum，keyword
返回对象： 活动对象集合


SmsFlashPromotionController
```
/**
 * 限时购活动管理Controller
 */
@Controller
@Api(value = "SmsFlashPromotionController", description = "限时购活动管理")
@RequestMapping("/flash")
public class SmsFlashPromotionController {

    @Autowired
    private SmsFlashPromotionService flashPromotionService;

    @ApiOperation("根据活动名称分页查询")
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    @ResponseBody
    public Object getItem(@RequestParam(value = "keyword", required = false) String keyword,
                          @RequestParam(value = "pageSize", defaultValue = "5") Integer pageSize,
                          @RequestParam(value = "pageNum", defaultValue = "1") Integer pageNum) {
        List<SmsFlashPromotion> flashPromotionList = flashPromotionService.list(keyword, pageNum, pageSize);

        return new CommonResult().pageSuccess(flashPromotionList);
    }
```

Service

```
    @Autowired
    private SmsFlashPromotionMapper flashPromotionMapper;

    @Override
    public List<SmsFlashPromotion> list(String keyword, Integer pageNum, Integer pageSize) {
        PageHelper.startPage(pageNum, pageSize);

        SmsFlashPromotionExample example = new SmsFlashPromotionExample();
        if (!StringUtils.isEmpty(keyword)) {
            example.createCriteria().andTitleLike("%" + keyword + "%");
        }
        return flashPromotionMapper.selectByExample(example);
    }
```



###编辑活动列表



####更改活动的上下线属性
前端：
```
export function updateStatus(id,params) {
  return request({
    url:'/flash/update/status/'+id,
    method:'post',
    params:params
  })
}
```

客户要求：在页面上直接修改活动的上下线属性


后端：

请求效果： 点击上下线，修改活动的上下线属性
输入参数:  id ， status
返回对象： 1


SmsFlashPromotionController

```
    @ApiOperation("修改上下线状态")
    @RequestMapping(value = "/update/status/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object updateStatus(@PathVariable Long id, Integer status) {
        int count = flashPromotionService.updateStatus(id, status);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```


Service

```
    @Override
    public int updateStatus(Long id, Integer status) {
        SmsFlashPromotion flashPromotion = new SmsFlashPromotion();
        flashPromotion.setId(id);
        flashPromotion.setStatus(status);

        return flashPromotionMapper.updateByPrimaryKeySelective(flashPromotion);
    }

```


####编辑单一活动对象


前端：
```
export function updateFlash(id,data) {
  return request({
    url:'/flash/update/'+id,
    method:'post',
    data:data
  })
}
```

客户要求：
点击编辑按钮，完成对单一活动对象的编辑

后端：

请求效果： 点击编辑按钮，完成对单一活动对象的编辑
输入参数:  活动对象，id
返回对象： 1（这个1，都是Mybaits的方法返回的）


SmsFlashPromotionController

```
    @ApiOperation("编辑活动信息")
    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object update(@PathVariable Long id, @RequestBody SmsFlashPromotion flashPromotion) {
        int count = flashPromotionService.update(id, flashPromotion);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```


Service

```
    @Override
    public int update(Long id, SmsFlashPromotion flashPromotion) {
        flashPromotion.setId(id);
        return flashPromotionMapper.updateByPrimaryKeySelective(flashPromotion);
    }
```


###增加活动列表
前端：
```
export function createFlash(data) {
  return request({
    url:'/flash/create',
    method:'post',
    data:data
  })
}
```

客户要求：
点击增加按钮，完成对单一活动对象的增加

后端：

请求效果： 点击增加按钮，完成对单一活动对象的增加
输入参数:  活动对象，
返回对象： 1（这个1，都是Mybaits的方法返回的）


SmsFlashPromotionController

```
    @ApiOperation("添加活动信息")
    @RequestMapping(value = "/create", method = RequestMethod.POST)
    @ResponseBody
    public Object update( @RequestBody SmsFlashPromotion flashPromotion) {
        int count = flashPromotionService.create(flashPromotion);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```


Serivce

```
    @Override
    public int create(SmsFlashPromotion flashPromotion) {
        flashPromotion.setCreateTime(new Date());
        return flashPromotionMapper.insert(flashPromotion);
    }
```


###删除活动列表


前端：
```
export function deleteFlash(id) {
  return request({
    url:'/flash/delete/'+id,
    method:'post'
  })
}
```

客户要求：
点击删除按钮，完成对单一活动对象的删除

后端：

请求效果： 点击删除按钮，完成对单一活动对象的删除
输入参数:  id
返回对象： 1（这个1，都是Mybaits的方法返回的）


SmsFlashPromotionController

```
    @ApiOperation("删除活动信息")
    @RequestMapping(value = "/delete/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object delete(@PathVariable Long id) {
        int count = flashPromotionService.delete(id);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```


Serivce

```
    @Override
    public int delete(Long id) {
        return flashPromotionMapper.deleteByPrimaryKey(id);
    }
```



##限时购与商品关联

[![](https://ae01.alicdn.com/kf/Hae92430b30ad4adabed3d21bbcfd1c66c.jpg)](https://ae01.alicdn.com/kf/Hae92430b30ad4adabed3d21bbcfd1c66c.jpg)
点击设置商品连接跳转到新的页面

[![](https://ae01.alicdn.com/kf/Hdcfe832f80ab4c13bed2339dfcf8267dd.jpg)](https://ae01.alicdn.com/kf/Hdcfe832f80ab4c13bed2339dfcf8267dd.jpg)


点击商品列表连接，跳转到新的页面，这是商品关联的页面：
[![](https://ae01.alicdn.com/kf/H3f479037265a492b93263623197b68efY.jpg)](https://ae01.alicdn.com/kf/H3f479037265a492b93263623197b68efY.jpg)



###查询全部限时购关联对象


前端：
```
export function fetchList(params) {
  return request({
    url:'/flashProductRelation/list',
    method:'get',
    params:params
  })
}
```

客户要求：
点击商品列表 跳转到新的页面，页面显示参与活动的秒杀对象，也有一个显示参与秒杀对象的商品的链接，**但是最主要的是查询秒杀对象。**

后端：

请求效果： 查询全部的秒杀对象，而且带有商品对象
输入参数:  活动对象id，秒杀对象id，PageSize,pageNum
返回对象： 秒杀对象列表，而且带有商品对象

个人理解：
因为秒杀对象并没有商品属性，所以需要自定义一个类，去接收这样的要求，就是2个对象合成一个对象。

接收类：
```
/**
 * 限时购及商品信息封装
 */
public class SmsFlashPromotionProduct extends SmsFlashPromotionProductRelation{
    @Getter
    @Setter
    private PmsProduct product;
}
```


SmsFlashPromotionProductRelationController

```
@Controller
@Api(value = "SmsFlashPromotionProductRelationController", description = "限时购和商品关系管理")
@RequestMapping("/flashProductRelation")
public class SmsFlashPromotionProductRelationController {

    @Autowired
    private SmsFlashPromotionProductRelationService relationService;

    @ApiOperation("分页查询不同场次关联及商品信息")
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    @ResponseBody
    public Object list(@RequestParam("flashPromotionId") Long flashPromotionId,
                       @RequestParam("flashPromotionSessionId") Long flashPromotionSessionId,
                       @RequestParam(value = "pageSize", defaultValue = "5") Integer pageSize,
                       @RequestParam(value = "pageNum", defaultValue = "1") Integer pageNum) {
        List<SmsFlashPromotionProduct> flashPromotionProductList = relationService.list(flashPromotionId, flashPromotionSessionId, pageSize, pageNum);
        return new CommonResult().pageSuccess(flashPromotionProductList);
    }
}
```

Service

```
    @Override
    public List<SmsFlashPromotionProduct> list(Long flashPromotionId, Long flashPromotionSessionId, Integer pageSize, Integer pageNum) {
        PageHelper.startPage(pageNum, pageSize);
        return relationDao.getList(flashPromotionId, flashPromotionSessionId);
    }
```



SmsFlashPromotionProductRelationDao:
接口：
```
/**
 * 限时购商品关联自定义Dao
 */
public interface SmsFlashPromotionProductRelationDao {
    /**
     * 获取限时购及相关商品信息
     */
    List<SmsFlashPromotionProduct> getList(@Param("flashPromotionId") Long flashPromotionId,
                                           @Param("flashPromotionSessionId") Long flashPromotionSessionId);
}
```
SmsFlashPromotionProductRelationDao.xml
```
<mapper namespace="com.taobao.taobaoadmin.dao.Sms.SmsFlashPromotionProductRelationDao">
    <resultMap id="flashProductMap" type="com.taobao.taobaoadmin.dto.Sms.SmsFlashPromotionProduct"
               extends="com.taobao.taobaoadmin.mapper.SmsFlashPromotionProductRelationMapper.BaseResultMap">
        <association property="product"
                     resultMap="com.taobao.taobaoadmin.mapper.PmsProductMapper.BaseResultMap"
                     columnPrefix="p_"/>
    </resultMap>



    <select id="getList" resultMap="flashProductMap">
        SELECT
              r.id,
              r.flash_promotion_price,
              r.flash_promotion_count,
              r.flash_promotion_limit,
              r.flash_promotion_id,
              r.flash_promotion_session_id,
              r.product_id,
              r.sort,
              p.id as p_id,
              p.`name` as p_name,
              p.product_sn as p_product_sn,
              p.price as p_price,
              p.stock as p_stock
        FROM
              sms_flash_promotion_product_relation as r
              LEFT JOIN pms_product as p ON  r.product_id = p.id
        WHERE
              r.flash_promotion_id = #{flashPromotionId}
              AND
              r.flash_promotion_session_id = #{flashPromotionSessionId}
        ORDER BY r.sort DESC
    </select>
    
</mapper>
```


###编辑限时购关联对象
前端：
```
export function updateFlashProductRelation(id,data) {
  return request({
    url:'/flashProductRelation/update/'+id,
    method:'post',
    data:data
  })
}
```

客户要求：点击编辑，能对参与秒杀活动的商品进行修改价格，数量等属性。


后端：

请求效果： 修改关联商品的价格，数量等属性
输入参数:  id， 秒杀活动与商品关联对象
返回对象： 1


SmsFlashPromotionProductRelationController

```
    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object update(@PathVariable Long id, @RequestBody SmsFlashPromotionProductRelation relation) {
        int count = relationService.update(id, relation);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }

```


Serivce

```
    @Override
    public int update(Long id, SmsFlashPromotionProductRelation relation) {
        relation.setId(id);
        return relationMapper.updateByPrimaryKeySelective(relation);
    }
```



###增加限时购关联对象
前端:
```
export function createFlashProductRelation(data) {
  return request({
    url:'/flashProductRelation/create',
    method:'post',
    data:data
  })
}
```

客户要求：
点击添加按钮，选择好商品，确认添加

后端：

请求效果： 添加商品关联尿素对象
输入参数:  商品关联秒杀对象
返回对象： 1


SmsFlashPromotionProductRelationController

```
    @ApiOperation("批量选择商品添加关联")
    @RequestMapping(value = "/create", method = RequestMethod.POST)
    @ResponseBody
    public Object create(@RequestBody List<SmsFlashPromotionProductRelation> relationList) {
        int count = relationService.create(relationList);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service
接口：
```
    /**
     * 批量添加关联
     */
    @Transactional
    int create(List<SmsFlashPromotionProductRelation> relationList);
```
实现类：
```
    @Override
    public int create(List<SmsFlashPromotionProductRelation> relationList) {
        for (SmsFlashPromotionProductRelation promotionProductRelation : relationList) {
            relationMapper.insert(promotionProductRelation);
        }
        return relationList.size();
    }
```

###删除限时购关联对象



前端:
```
export function deleteFlashProductRelation(id) {
  return request({
    url:'/flashProductRelation/delete/'+id,
    method:'post'
  })
}
```

客户要求：
点击删除按钮，删除商品关联，就是这个秒杀对象没有了这个商品

后端：

请求效果： 删除商品关联
输入参数:  id
返回对象： 1


SmsFlashPromotionProductRelationController

```
    @ApiOperation("删除关联")
    @RequestMapping(value = "/delete/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object delete(@PathVariable Long id) {
        int count = relationService.delete(id);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service

```
    @Override
    public int delete(Long id) {
        return relationMapper.deleteByPrimaryKey(id);
    }
```

	2019-08-11 17:13:50
kumika	电商项目--12	# 电商项目--12

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧

#营销管理

秒杀活动列表
优惠劵列表
品牌推荐
新品推荐
人气推荐
专题推荐
广告列表
[![](https://ae01.alicdn.com/kf/Hc752f86c3f3e444abbacf7dbf41f0b9c3.jpg)](https://ae01.alicdn.com/kf/Hc752f86c3f3e444abbacf7dbf41f0b9c3.jpg)

#优惠劵列表

[![](https://ae01.alicdn.com/kf/H832d4a25243f4df18ed1582500b14ed4v.jpg)](https://ae01.alicdn.com/kf/H832d4a25243f4df18ed1582500b14ed4v.jpg)



优惠劵的操作分为：
优惠券管理，和优惠券领取记录管理2个部分

[![](https://ae01.alicdn.com/kf/Hdb9f61e4131449dc83c705921aefeae1P.jpg)](https://ae01.alicdn.com/kf/Hdb9f61e4131449dc83c705921aefeae1P.jpg)

##优惠券管理

###查询全部优惠券

前端：
```
export function fetchList(params) {
  return request({
    url:'/coupon/list',
    method:'get',
    params:params
  })
}
```


客户要求： 点击优惠卷管理，无条件的搜索全部的优惠卷，搜索是带有数据库的字段name,type的。


后端：

请求效果： 查询全部的优惠卷
输入参数:  pageSize,pageNum,name,type  
返回对象： 优惠劵列表


SmsCouponController

```
@Controller
@Api(value = "SmsCouponController", description = "优惠券管理")
@RequestMapping("/coupon")
public class SmsCouponController {

    @Autowired
    private SmsCouponService couponService;

    @ApiOperation("根据优惠券名称和类型分页获取优惠券列表")
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    @ResponseBody
    public Object list(@RequestParam(value = "name", required = false) String name,
                       @RequestParam(value = "type", required = false) Integer type,
                       @RequestParam(value = "pageSize", defaultValue = "5") Integer pageSize,
                       @RequestParam(value = "pageNum", defaultValue = "1") Integer pageNum) {
        List<SmsCoupon> couponList = couponService.list(name, type, pageSize, pageNum);
        return new CommonResult().pageSuccess(couponList);
    }
}
```


Service
注意name和type的判断条件，应该是前端沟通好的
```
@Service
public class SmsCouponServiceIMPL implements SmsCouponService {

    @Autowired
    private SmsCouponMapper couponMapper;

    @Override
    public List<SmsCoupon> list(String name, Integer type, Integer pageSize, Integer pageNum) {
        PageHelper.startPage(pageNum, pageSize);

        SmsCouponExample example = new SmsCouponExample();
        SmsCouponExample.Criteria criteria = example.createCriteria();
        if (!StringUtils.isEmpty(name)) {
            criteria.andNameLike("%" + name + "%");
        }
        if (type != null) {
            criteria.andTypeEqualTo(type);
        }

        return couponMapper.selectByExample(example);
    }
}
```



###编辑单一优惠券

**又忘记了，编辑单一对象的时候，首先要获取这个对象，然后才能修改。**


####获取单一优惠劵
前端：
```
export function getCoupon(id) {
  return request({
    url:'/coupon/'+id,
    method:'get',
  })
}
```


客户要求： 
点击编辑按钮，跳转新页面，创建新页面的时候，根据id获取优惠劵对象
注意：编辑详细属性上有个模糊查询商品的功能，在增加优惠劵功能上详细写了。

后端：

请求效果：  根据id获取优惠劵对象
输入参数:   id
返回对象：  优惠劵对象


SmsCouponController
```
    @ApiOperation("获取单个优惠券的详细信息")
    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    @ResponseBody
    public Object getItem(@PathVariable Long id) {
        SmsCouponParam couponParam = couponService.getItem(id);
        return new CommonResult().success(couponParam);
    }
```

Service
```
    @Autowired
    private SmsCouponDao couponDao;


    @Override
    public SmsCouponParam getItem(Long id) {
        return couponDao.getItem(id);
    }
```

SmsCouponDao:
接口：
```
/**
 * 优惠券管理自定义查询Dao
 */
public interface SmsCouponDao {
    SmsCouponParam getItem(@Param("id") Long id);
}
```

XML文件：

[![](https://ae01.alicdn.com/kf/Hdb9f61e4131449dc83c705921aefeae1P.jpg)](https://ae01.alicdn.com/kf/Hdb9f61e4131449dc83c705921aefeae1P.jpg)

因为这个优惠劵对象是包含了商品关联对象，商品分类关联对象,所以需要2个表格。
[![](https://ae01.alicdn.com/kf/H16921852f7e740268c7392106f9357df0.jpg)](https://ae01.alicdn.com/kf/H16921852f7e740268c7392106f9357df0.jpg)

[![](https://ae01.alicdn.com/kf/Hab684b8f81194a96afbd191517189298h.jpg)](https://ae01.alicdn.com/kf/Hab684b8f81194a96afbd191517189298h.jpg)
`productRelationList`是商品关联对象列表，但是在`couponItemParam`对象中是一个属性，所以是一对多的情况，使用标签`Collection`。
同理`productCategoryRelationList`也是一对多的情况

```
<mapper namespace="com.taobao.taobaoadmin.dao.Sms.SmsCouponDao">
    <resultMap id="couponItemParam" type="com.taobao.taobaoadmin.dto.Sms.SmsCouponParam" extends="com.taobao.taobaoadmin.mapper.SmsCouponMapper.BaseResultMap">
        <collection property="productRelationList" columnPrefix="cpx_" resultMap="com.taobao.taobaoadmin.mapper.SmsCouponProductRelationMapper.BaseResultMap"></collection>
        <collection property="productCategoryRelationList" columnPrefix="cpcr_" resultMap="com.taobao.taobaoadmin.mapper.SmsCouponProductCategoryRelationMapper.BaseResultMap"></collection>
    </resultMap>


    <select id="getItem" resultMap="couponItemParam">
        SELECT
              c.*,
              /*优惠券绑定的商品*/
              cpr.id  as cpr_id,
              cpr.product_id  as cpr_product_id,
              cpr.product_name  as cpr_product_name,
              cpr.product_sn  as cpr_product_sn,
              /*优惠券绑定的商品分类*/
              cpcr.id  as cpcr_id,
              cpcr.product_category_id  as cpcr_product_category_id,
              cpcr.product_category_name  as cpcr_product_category_name,
              cpcr.parent_category_name  as cpcr_parent_category_name
        FROM
              sms_coupon c
              LEFT JOIN sms_coupon_product_relation cpr ON c.id = cpr.coupon_id
              LEFT JOIN sms_coupon_product_category_relation cpcr ON c.id = cpcr.coupon_id
        WHERE
              c.id = #{id}
    </select>
</mapper>
```



####更改单一优惠劵
前端：
```
export function updateCoupon(id,data) {
  return request({
    url:'/coupon/update/'+id,
    method:'post',
    data:data
  })
}
```


客户要求： 
点击编辑按钮，进行对优惠劵的属性进行修改，点击确定完成编辑


后端：

请求效果：  更改优惠劵对象
输入参数:   id，优惠劵拓展对象（包含了优惠劵绑定的商品分类对象）
返回对象：  1

接收类：
```
/**
 * 优惠券信息封装，包括绑定商品和绑定分类
 */
@Setter
@Getter
public class SmsCouponParam extends SmsCoupon {
    //优惠券绑定的商品
    private List<SmsCouponProductRelation> productRelationList;

    //优惠券绑定的商品分类
    private List<SmsCouponProductCategoryRelation> productCategoryRelationList;
}
```

SmsCouponController

```
    @ApiOperation("修改优惠券")
    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object update(@PathVariable Long id,
                       @RequestBody SmsCouponParam couponParam) {
        int count  = couponService.update(id, couponParam);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service
接口：
```
    /**
     * 根据优惠券id更新优惠券信息
     */
    @Transactional
    List<SmsCoupon> update(Long id, SmsCouponParam couponParam);
```
实现类：
[![](https://ae01.alicdn.com/kf/H16921852f7e740268c7392106f9357df0.jpg)](https://ae01.alicdn.com/kf/H16921852f7e740268c7392106f9357df0.jpg)

[![](https://ae01.alicdn.com/kf/Hab684b8f81194a96afbd191517189298h.jpg)](https://ae01.alicdn.com/kf/Hab684b8f81194a96afbd191517189298h.jpg)


```
    @Autowired
    private SmsCouponMapper couponMapper;

    @Autowired
    private SmsCouponProductRelationDao productRelationDao;

    @Autowired
    private SmsCouponProductRelationMapper productRelationMapper;


    @Autowired
    private SmsCouponProductCategoryRelationDao productCategoryRelationDao;

    @Autowired
    private SmsCouponProductCategoryRelationMapper productCategoryRelationMapper;
    
    @Override
    public int update(Long id, SmsCouponParam couponParam) {
        //赋值id，然后更新到数据库中，
        // 优惠券和商品关系还有优惠券和商品分类关系表的更新步骤是需要先删除，在插入
        couponParam.setId(id);
        int count = couponMapper.updateByPrimaryKey(couponParam);

        //删除后插入优惠券和商品关系表
        if (couponParam.getUseType().equals(2)) {
            //遍历优惠券和商品关系表列表，把商品关系对象与优惠劵关联起来（id赋值）
            for (SmsCouponProductRelation productRelation : couponParam.getProductRelationList()) {
                productRelation.setCouponId(couponParam.getId());
            }
            //根据id删除优惠券和商品关系表中的对象
            deleteProductRelation(id);
            //因为上面遍历优惠券和商品关系对象列表之后，优惠劵与商品建立新的关系对象，可以进行插入数据
            productRelationDao.insertList(couponParam.getProductRelationList());
        }
        //删除后插入优惠券和商品分类关系表
        if (couponParam.getUseType().equals(1)) {
            //遍历优惠券和商品分类关系表列表，把商品分类关系对象与优惠劵关联起来（id赋值）
            for (SmsCouponProductCategoryRelation productCategoryRelation : couponParam.getProductCategoryRelationList()) {
                productCategoryRelation.setCouponId(couponParam.getId());
            }
            //根据id删除优惠券和商品分类关系表中的对象
            deleteProductCategoryRelation(id);
            //因为上面遍历优惠券和商品分类关系对象列表之后，优惠劵与商品分类建立新的关系对象，可以进行插入数据
            productCategoryRelationDao.insertList(couponParam.getProductCategoryRelationList());
        }
        return count;
    }

    private void deleteProductCategoryRelation(Long id) {
        SmsCouponProductCategoryRelationExample example = new SmsCouponProductCategoryRelationExample();
        example.createCriteria().andCouponIdEqualTo(id);
        productCategoryRelationMapper.deleteByExample(example);
    }

    private void deleteProductRelation(Long id) {
        SmsCouponProductRelationExample example = new SmsCouponProductRelationExample();
        example.createCriteria().andCouponIdEqualTo(id);
        productRelationMapper.deleteByExample(example);
    }
```


优惠券和产品关系自定义Dao：
SmsCouponProductRelationDao接口：
```
/**
 * 优惠券和产品关系自定义Dao
 */
public interface SmsCouponProductRelationDao {
    void insertList(@Param("list") List<SmsCouponProductRelation> productRelationList);
}
```

XML 文件：

```
<mapper namespace="com.taobao.taobaoadmin.dao.Sms.SmsCouponProductRelationDao">
    <insert id="insertList">
        INSERT 
               sms_coupon_product_relation(product_id,product_name,product_sn,coupon_id)
        VALUES 
               <foreach collection="list" item="item" separator="," index="index">
                   (
                   #{item.productId,jdbcType=BIGINT},
                   #{item.productName,jdbcType=VARCHAR},
                   #{item.productSn,jdbcType=VARCHAR},
                   #{item.couponId,jdbcType=INTEGER}
                   )
               </foreach>
    </insert>
</mapper>
```


优惠券和商品分类关系自定义Dao：
SmsCouponProductCategoryRelationDao接口:
```
/**
 * 优惠券和商品分类关系自定义Dao
 */
public interface SmsCouponProductCategoryRelationDao {
    void insertList(@Param("list") List<SmsCouponProductCategoryRelation> productCategoryRelationList);
}

```
XML实现文件：
```
<mapper namespace="com.taobao.taobaoadmin.dao.Sms.SmsCouponProductCategoryRelationDao">
    <insert id="insertList">
        INSERT 
               sms_counpon_product_category_relation (product_category_id,product_cateogry_name,parent_category_name,coupon_id)
        VALUES 
               <foreach collection="list" index="index" separator="," item="item">
                   (
                   #{item.productCategoryId,jdbcType=BIGINT},
                   #{item.productCategoryName,jdbcType=VARCHAR},
                   #{item.parentCategoryName,jdbcType=VARCHAR},
                   #{item.couponId,jdbcType=BIGINT}
                   )
               </foreach>
    </insert>
</mapper>
```

###增加优惠券

前端：
```
export function createCoupon(data) {
  return request({
    url:'/coupon/create',
    method:'post',
    data:data
  })
}
```

客户要求： 
        点击添加按钮，跳转到新页面填写属性，然后点击确定完成添加

后端：

请求效果：  增加优惠劵信息的封装
输入参数:   优惠劵信息封装（有产品和产品分类）
返回对象：  1

接收类：
```
/**
 * 优惠券信息封装，包括绑定商品和绑定分类
 */
@Setter
@Getter
public class SmsCouponParam extends SmsCoupon {
    //优惠券绑定的商品
    private List<SmsCouponProductRelation> productRelationList;

    //优惠券绑定的商品分类
    private List<SmsCouponProductCategoryRelation> productCategoryRelationList;
}
```


SmsCouponController

```
    @ApiOperation("添加优惠券")
    @RequestMapping(value = "/create", method = RequestMethod.POST)
    @ResponseBody
    public Object add(@RequestBody SmsCouponParam couponParam) {
        int count = couponService.create(couponParam);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service
接口：
```
    /**
     * 添加优惠券
     */
    @Transactional
    int create(SmsCouponParam couponParam);
```

实现类：
```
    @Override
    public int create(SmsCouponParam couponParam) {
        couponParam.setCount(couponParam.getPublishCount());
        couponParam.setUseCount(0);
        couponParam.setCount(0);
        //插入优惠劵表
        int count = couponMapper.insert(couponParam);

        //插入优惠券和商品关系表
        if (couponParam.getUseType().equals(2)) {
            for (SmsCouponProductRelation productRelation : couponParam.getProductRelationList()) {
                productRelation.setCouponId(couponParam.getId());
            }
            productRelationDao.insertList(couponParam.getProductRelationList());
        }
        //插入优惠券和商品分类关系表
        if (couponParam.getUseType().equals(1)) {
            for (SmsCouponProductCategoryRelation productCategoryRelation : couponParam.getProductCategoryRelationList()) {
                productCategoryRelation.setCouponId(couponParam.getId());
            }
            productCategoryRelationDao.insertList(couponParam.getProductCategoryRelationList());
        }
        return count;
    }
```


####模糊查询商品功能：
前端：
```
export function fetchSimpleList(params) {
  return request({
    url:'/product/simpleList',
    method:'get',
    params:params
  })
}
```

客户要求： 
在文本框上输入，商品名称或者商品货号（关键词keyword），就会进行模糊查询

后端：

请求效果： 根据关键词keyword，进行模糊查询
输入参数:  关键词
返回对象： 商品对象列表
[![](https://ae01.alicdn.com/kf/Hd388f5f1c1e4449884ed595841141b77y.jpg)](https://ae01.alicdn.com/kf/Hd388f5f1c1e4449884ed595841141b77y.jpg)

[![](https://ae01.alicdn.com/kf/Hd4d2d723947d453fbab735d7d1e31f2fS.jpg)](https://ae01.alicdn.com/kf/Hd4d2d723947d453fbab735d7d1e31f2fS.jpg)

PmsProductController
```
    @ApiOperation("根据商品名称或货号模糊查询")
    @RequestMapping(value = "/simpleList", method = RequestMethod.POST)
    @ResponseBody
    public Object getList(String keyword) {
        List<PmsProduct> productList = productService.list(keyword);
        return new CommonResult().success(productList);
    }
```


Service：
模糊查询的条件是怎么写的？
商品货号：productSn    myBatis的方法：andProductSnLike
商品名称：name         myBatis的方法：andNameLike
```
    @Override
    public List<PmsProduct> list(String keyword) {
        PmsProductExample productExample = new PmsProductExample();
        PmsProductExample.Criteria criteria = productExample.createCriteria();
        criteria.andDeleteStatusEqualTo(0);
        if (!StringUtils.isEmpty(keyword)) {
            criteria.andNameLike("%"+keyword+"%");
            productExample
                    .or()
                    .andDeleteStatusEqualTo(0)
                    .andProductSnLike("%" + keyword + "%");
        }
        return productMapper.selectByExample(productExample);
    }
```

###删除优惠券

前端：
```
export function deleteCoupon(id) {
  return request({
    url:'/coupon/delete/'+id,
    method:'post',
  })
}
```


客户要求： 

点击删除按钮，完成删除优惠劵对象

注意：
        因为你增加优惠劵的时候，是关联有别的表，所以删除的时候，也要把别的表上的数据进行删除。
        
        
        
        
        **也就是删除优惠劵，删除商品关联，删除商品分类关联**，需要根据id进行3次执行删除语句。

后端：

请求效果： 删除优惠劵对象
输入参数:  id 
返回对象： 1


SmsCouponController

```
    @ApiOperation("删除优惠劵")
    @RequestMapping(value = "/delete/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object delete(@PathVariable Long id) {
        int count = couponService.delete(id);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service

```
    @Override
    public int delete(Long id) {
        //删除优惠券
        int count = couponMapper.deleteByPrimaryKey(id);
        //删除商品关联
        deleteProductRelation(id);
        //删除商品分类关联
        deleteProductCategoryRelation(id);
        return count;
    }
```


##优惠券领取记录管理


前端：
```
export function fetchList(params) {
  return request({
    url:'/couponHistory/list',
    method:'get',
    params:params
  })
}
```


客户要求： 

点击优惠劵的查看按钮，查询优惠劵历史对象


后端：

请求效果： 查询优惠劵历史对象
输入参数:  优惠劵id（couponId），使用状态（useStatus），订单编号（orderId），pageSize,
返回对象： 1

SmsCouponHistoryController
```
/**
 * 优惠券领取记录管理Controller
 * Created by macro on 2018/11/6.
 */
@Controller
@Api(tags = "SmsCouponHistoryController",description = "优惠券领取记录管理")
@RequestMapping("/couponHistory")
public class SmsCouponHistoryController {
    @Autowired
    private SmsCouponHistoryService historyService;
    @ApiOperation("根据优惠券id，使用状态，订单编号分页获取领取记录")
    @RequestMapping(value = "/list",method = RequestMethod.GET)
    @ResponseBody
    public Object list(@RequestParam(value = "couponId",required = false) Long couponId,
                       @RequestParam(value = "useStatus",required = false) Integer useStatus,
                       @RequestParam(value = "orderSn",required = false) String orderSn,
                       @RequestParam(value = "pageSize", defaultValue = "5") Integer pageSize,
                       @RequestParam(value = "pageNum", defaultValue = "1") Integer pageNum){
        List<SmsCouponHistory> historyList = historyService.list(couponId,useStatus,orderSn,pageSize,pageNum);
        return new CommonResult().pageSuccess(historyList);
    }
}
```

Service:
这么多参数判断，应该是和数据库的字段约束有关，这些参数哪些不能为null
```
@Service
public class SmsCouponHistoryServiceIMPL implements SmsCouponHistoryService {

    @Autowired
    private SmsCouponHistoryMapper historyMapper;


    @Override
    public List<SmsCouponHistory> list(Long couponId, Integer useStatus, String orderSn, Integer pageSize, Integer pageNum) {
        PageHelper.startPage(pageNum, pageSize);


        SmsCouponHistoryExample example = new SmsCouponHistoryExample();
        SmsCouponHistoryExample.Criteria criteria = example.createCriteria();
        if (couponId != null) {
            criteria.andCouponIdEqualTo(couponId);
        }
        if (useStatus != null) {
            criteria.andUseStatusEqualTo(useStatus);
        }
        if (!StringUtils.isEmpty(orderSn)) {
            criteria.andOrderSnEqualTo(orderSn);
        }
        return historyMapper.selectByExample(example);
    }
}
```



#疑问：
##问题1 

根据商品号码和商品名称，模糊查询的条件是怎么写的


##问题2

为什么模糊查询商品名称用  criteria.andNameLike("%"+keyword+"%");
模糊查询商品货号使用
            productExample
                    .or()
                    .andDeleteStatusEqualTo(0)
                    .andProductSnLike("%" + keyword + "%");


#参考：
https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247483835&idx=1&sn=895ae94d5a0bc5fbe5bed8aa715d92af&scene=21#wechat_redirect

	2019-08-14 08:42:34
kumika	电商项目--13	# 电商项目--13

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧

#营销管理

秒杀活动列表
优惠劵列表
品牌推荐
新品推荐
人气推荐
专题推荐
广告列表




#品牌推荐


##分页查询品牌推荐

前端：
```
export function fetchList(params) {
  return request({
    url:'/home/brand/list',
    method:'get',
    params:params
  })
}
```



客户要求： 点击品牌推荐，条件搜索的关键词：recommendStatus和brandName，关键词可以为null，查询品牌推荐。

点击选择品牌按钮，选择品牌，完成增加品牌推荐
后端：

请求效果： 关键词都为null，查询全部的品牌推荐
输入参数:  推荐状态，品牌名称，pageSize,pageNum
返回对象： 品牌推荐列表


SmsHomeBrandController

```
@Controller
@Api(value = "SmsHomeBrandController", description = "首页品牌管理")
@RequestMapping("/home/brand")
public class SmsHomeBrandController {

    @Autowired
    private SmsHomeBrandService homeBrandService;
    
    
    @ApiOperation("分页查询推荐品牌")
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    @ResponseBody
    public Object list(@RequestParam(value = "brandName",required = false)String brandName,
                       @RequestParam(value = "recommendStatus",required = false)Integer recommendStatus,
                       @RequestParam(value = "pageSize",defaultValue = "5")Integer pageSize,
                       @RequestParam(value = "pageNum",defaultValue = "1")Integer pageNum) {
        List<SmsHomeBrand> homeBrandList = homeBrandService.list(brandName, recommendStatus, pageNum, pageSize);

        return new CommonResult().pageSuccess(homeBrandList);
    }
}
```

Serivce

```
/**
 * 首页品牌管理Service实现类
 */
@Service
public class SmsHomeBrandServiceIMPL implements SmsHomeBrandService {


    @Autowired
    private SmsHomeBrandMapper homeBrandMapper;
    
    @Override
    public List<SmsHomeBrand> list(String brandName, Integer recommendStatus, Integer pageNum, Integer pageSize) {
        PageHelper.offsetPage(pageNum, pageSize);

        SmsHomeBrandExample example = new SmsHomeBrandExample();
        SmsHomeBrandExample.Criteria criteria = example.createCriteria();

        if (!StringUtils.isEmpty(brandName)) {
            criteria.andBrandNameLike("%" + brandName+"%");
        }
        if (recommendStatus != null) {
            criteria.andRecommendStatusEqualTo(recommendStatus);
        }
        example.setOrderByClause("sort desc");
        return homeBrandMapper.selectByExample(example);
    }
}
```


##添加首页推荐品牌


前端：
```
export function createHomeBrand(data) {
  return request({
    url:'/home/brand/create',
    method:'post',
    data:data
  })
}
```



客户要求： 点击选择品牌按钮，选择品牌，完成增加品牌推荐


后端：

请求效果： 添加品牌推荐对象
输入参数:  推荐对象
返回对象： 1



SmsHomeBrandController

```
    @ApiOperation("添加首页推荐品牌")
    @RequestMapping(value = "/create", method = RequestMethod.POST)
    @ResponseBody
    public Object create(@RequestBody List<SmsHomeBrand> homeBrandList) {
        int count = homeBrandService.create(homeBrandList);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service
这里对首页品牌设置的属性，应该是根据数据库表上的字段约束或者属性设定来设置的

SmsHomeBrand类这是什么类？
首页品牌类，它的属性用于记录哪些是在首页的。
```
    @Override
    public int create(List<SmsHomeBrand> homeBrandList) {
        //这里对首页品牌设置的属性，应该是根据数据库表上的字段约束，
        // 或者属性设定来设置的
        for (SmsHomeBrand homeBrand : homeBrandList) {
            //推荐状态设置为1
            homeBrand.setRecommendStatus(1);
            //排序为0
            homeBrand.setSort(0);
            homeBrandMapper.insert(homeBrand);
        }
        return homeBrandList.size();
    }
```

##修改品牌排序

前端：
```
export function updateHomeBrandSort(params) {
  return request({
    url:'/home/brand/update/sort/'+params.id,
    method:'post',
    params:params
  })
}
```



客户要求： 直接点击按钮，修改对象排序属性


后端：

请求效果： 点击按钮，修改对象排序属性
输入参数:  id  ，排序（sort）
返回对象： 1


SmsHomeBrandController

```
    @ApiOperation("修改品牌排序")
    @RequestMapping(value = "/update/sort/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object create(@PathVariable Long id,Integer sort) {
        int count = homeBrandService.updateSort(id, sort);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```


Service

```
    @Override
    public int updateSort(Long id, Integer sort) {
        //创建一个新SmsHomeBrand对象，把参数赋值进对象，进行更新
        SmsHomeBrand homeBrand = new SmsHomeBrand();
        homeBrand.setId(id);
        homeBrand.setSort(sort);

        return homeBrandMapper.updateByPrimaryKeySelective(homeBrand);
    }
```


##批量修改推荐状态

前端：
```
export function updateRecommendStatus(data) {
  return request({
    url:'/home/brand/update/recommendStatus',
    method:'post',
    data:data
  })
}
```



客户要求： 批量修改对象推荐属性


后端：

请求效果： 批量修改对象推荐属性
输入参数:  ids  ，推荐属性recommendStatus
返回对象： 1


SmsHomeBrandController

```
    @ApiOperation("批量修改推荐状态")
    @RequestMapping(value = "/update/recommendStatus", method = RequestMethod.POST)
    @ResponseBody
    public Object updateRecommendStatus(@RequestParam("ids")List<Long>ids,
                                        @RequestParam Integer recommendStatus) {
        int count = homeBrandService.updateRecommendStatus(ids, recommendStatus);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```


Service
批量修改推荐状态
```
    @Override
    public int updateRecommendStatus(List<Long> ids, Integer recommendStatus) {
        //参数一个是对象的属性，一个是SQL语句的条件，的时候，使用XXXByExampleSelective
        SmsHomeBrand record = new SmsHomeBrand();
        record.setRecommendStatus(recommendStatus);

        SmsHomeBrandExample example = new SmsHomeBrandExample();
        example.createCriteria().andIdIn(ids);
        return homeBrandMapper.updateByExampleSelective(record, example);
    }
```






##批量删除

前端：
```
export function deleteHomeBrand(data) {
  return request({
    url:'/home/brand/delete',
    method:'post',
    data:data
  })
}
```



客户要求： 批量删除对象


后端：

请求效果： 批量删除对象
输入参数:  ids  
返回对象： 1


SmsHomeBrandController

```
    @ApiOperation("批量删除推荐品牌")
    @RequestMapping(value = "/delete", method = RequestMethod.POST)
    @ResponseBody
    public Object delete(@RequestParam("ids")List<Long>ids) {
        int count = homeBrandService.delete(ids);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```


Service
批量删除
```
    @Override
    public int delete(List<Long> ids) {
        SmsHomeBrandExample example = new SmsHomeBrandExample();
        example.createCriteria().andIdIn(ids);
        return homeBrandMapper.deleteByExample(example);
    }
```




	2019-08-14 15:53:23
kumika	电商项目--14	# 电商项目--14

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧

#营销管理

秒杀活动列表
优惠劵列表
品牌推荐
新品推荐
人气推荐
专题推荐
广告列表

    “理解”的意思是，从教科书的一大段话中、从老师的板书里提炼出最重要的内容，想清楚它从哪里来、它的机制（原理）是什么、它是怎么工作的、能用来解决哪些问题。

#新品推荐

**专题推荐，人气推荐，新品推荐，品牌推荐，广告列表这几个都是一个套路代码，只是对象变了而已（变量名改变）**

##分页查询推荐

前端：
```
export function fetchList(params) {
  return request({
    url:'/home/newProduct/list',
    method:'get',
    params:params
  })
}
```


客户要求： 
点击新品推荐，查询全部的新品

后端：

请求效果： 查询全部的新品
输入参数:  产品名称，推荐状态，pageSize，pageNum
返回对象： 新品对象列表


后端：
SmsHomeAdvertiseController

```
@Controller
@Api(value = "SmsHomeNewProductController", description = "首页新品管理")
@RequestMapping("/home/newProduct")
public class SmsHomeNewProductController {

    @Autowired
    private SmsHomeNewProductService homeNewProductService;
    
    
    @ApiOperation("分页查询推荐")
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    @ResponseBody
    public Object list(@RequestParam(value = "productName",required = false)String productName,
                       @RequestParam(value = "recommendStatus",required = false)Integer recommendStatus,
                       @RequestParam(value = "pageSize",defaultValue = "5")Integer pageSize,
                       @RequestParam(value = "pageNum",defaultValue = "1")Integer pageNum) {
        List<SmsHomeNewProduct> homeNewProductList = homeNewProductService.list(productName, recommendStatus, pageNum, pageSize);

        return new CommonResult().pageSuccess(homeNewProductList);
    }
}
```

Service

```
/**
 * 首页新品推荐管理Service实现类
 */
@Service
public class SmsHomeNewProductServiceIMPL implements SmsHomeNewProductService {

    @Autowired
    private SmsHomeNewProductMapper newProductMapper;

    @Override
    public List<SmsHomeNewProduct> list(String productName, Integer recommendStatus, Integer pageNum, Integer pageSize) {
        PageHelper.startPage(pageNum, pageSize);


        SmsHomeNewProductExample example = new SmsHomeNewProductExample();
        SmsHomeNewProductExample.Criteria criteria = example.createCriteria();

        if (!StringUtils.isEmpty(productName)) {
            criteria.andProductNameLike("%" + productName + "%");
        }

        if (recommendStatus != null) {
            criteria.andRecommendStatusEqualTo(recommendStatus);
        }
        example.setOrderByClause("sort desc");
        return newProductMapper.selectByExample(example);
    }
}
```

##修改推荐排序

前端：
```
export function updateNewProductSort(params) {
  return request({
    url:'/home/newProduct/update/sort/'+params.id,
    method:'post',
    params:params
  })
}
```


客户要求： 
点击修改推荐排序，完成对商品的首页排序

后端：

请求效果： 对商品的首页排序
输入参数:  id，客户输入的排序值sort
返回对象： 1


后端：
SmsHomeAdvertiseController
```
    @ApiOperation("修改推荐排序")
    @RequestMapping(value = "/update/sort/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object create(@PathVariable Long id,Integer sort) {
        int count = homeNewProductService.updateSort(id, sort);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service
```
    @Override
    public int updateSort(Long id, Integer sort) {
        SmsHomeNewProduct product = new SmsHomeNewProduct();
        product.setSort(sort);
        product.setId(id);
        //更新对象的部分属性值，使用此方法。newProductMapper.updateByPrimaryKeySelective(product);
        return newProductMapper.updateByPrimaryKeySelective(product);
    }
```


##批量修改推荐状态

前端：
```
export function updateRecommendStatus(data) {
  return request({
    url:'/home/newProduct/update/recommendStatus',
    method:'post',
    data:data
  })
}
```


客户要求： 
批量更改商品的推荐状态

后端：

请求效果： 批量更改商品的推荐状态
输入参数:  id的列表ids，推荐状态（1还是0）
返回对象： 1


后端：
SmsHomeAdvertiseController
```
    @ApiOperation("批量修改推荐状态")
    @RequestMapping(value = "/update/recommendStatus", method = RequestMethod.POST)
    @ResponseBody
    public Object updateRecommendStatus(@RequestParam("ids")List<Long>ids,
                                        @RequestParam Integer recommendStatus) {
        int count = homeNewProductService.updateRecommendStatus(ids, recommendStatus);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }

```

Service
```
    @Override
    public int updateRecommendStatus(List<Long> ids, Integer recommendStatus) {
        SmsHomeNewProduct product = new SmsHomeNewProduct();
        product.setRecommendStatus(recommendStatus);

        SmsHomeNewProductExample example = new SmsHomeNewProductExample();
        example.createCriteria().andIdIn(ids);
        return newProductMapper.updateByExampleSelective(product, example);
    }
```


##批量删除推荐

前端：
```
export function deleteNewProduct(data) {
  return request({
    url:'/home/newProduct/delete',
    method:'post',
    data:data
  })
}
```


客户要求： 
批量删除商品（在首页推荐表上的值，不是商品表上的值）

后端：

请求效果： 批量删除商品（不推荐了）
输入参数:  ids
返回对象： 1


后端：
SmsHomeAdvertiseController
```
    @ApiOperation("批量删除推荐")
    @RequestMapping(value = "/delete", method = RequestMethod.POST)
    @ResponseBody
    public Object delete(@RequestParam("ids")List<Long>ids) {
        int count = homeNewProductService.delete(ids);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service
```
    @Override
    public int delete(List<Long> ids) {
        SmsHomeNewProductExample example = new SmsHomeNewProductExample();
        example.createCriteria().andIdIn(ids);
        return newProductMapper.deleteByExample(example);
    }
```

##添加首页推荐品牌

前端：
```
export function createNewProduct(data) {
  return request({
    url:'/home/newProduct/create',
    method:'post',
    data:data
  })
}
```


客户要求： 
点击增加商品，填写相关属性，完成增加商品推荐

后端：

请求效果： 增加商品推荐
输入参数:  填写的商品列表
返回对象： 


后端：
SmsHomeAdvertiseController
```
    @ApiOperation("添加首页推荐品牌")
    @RequestMapping(value = "/create", method = RequestMethod.POST)
    @ResponseBody
    public Object create(@RequestBody List<SmsHomeNewProduct> homeNewProductList) {
        int count = homeNewProductService.create(homeNewProductList);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
```

Service
```
    //首页推荐，是一个表，打包过来的商品列表自然是要一个个插入
    @Override
    public int create(List<SmsHomeNewProduct> homeNewProductList) {
        for (SmsHomeNewProduct product : homeNewProductList) {
            product.setRecommendStatus(1);
            product.setSort(0);
            newProductMapper.insert(product);
        }
        return homeNewProductList.size();
    }
```

#广告列表
这里写广告列表的条件查询广告对象，因为有一个转换时间格式的写法。

前端：
[![](https://ae01.alicdn.com/kf/H2e7b89d2a050473daf5dd6ec01b452adA.jpg)](https://ae01.alicdn.com/kf/H2e7b89d2a050473daf5dd6ec01b452adA.jpg)

数据库：
[![](https://ae01.alicdn.com/kf/Hd0d73c7593dc44e7abf8a0a625aa9d5dy.jpg)](https://ae01.alicdn.com/kf/Hd0d73c7593dc44e7abf8a0a625aa9d5dy.jpg)

中间好像多了时分秒，就是转换的结果，**重要的是为什么要转换，**，因为Mybatis的时间查询格式不是输入时间的格式。

```
            //输入的时间格式是：2019-08-14
            //SQL语句查询时间的格式：Wed Aug 14 00:00:00 CST 2019
            
    转换 过程：
    日期后面增加小时分秒： 2019-08-14 00:00:00
    转换方法：SimpleDateFormat.parse()
    转换工具：SimpleDateFormat sdf
    设置转换格式：SimpleDateFormat（"yyyy-MM-dd HH:mm:ss"）
    
    查询时间，是查询范围：
    头：start = sdf.parse(startStr)
    尾：end = sdf.parse(endStr)
    
最后转换成功：
    start：Wed Aug 14 00:00:00 CST 2019
    end:   Wed Aug 14 23:59:59 CST 2019
```

完整的时间转换代码：
```
    @Override
    public List<SmsHomeAdvertise> list(String name, Integer type, String endTime, Integer pageNum, Integer pageSize) {
        PageHelper.startPage(pageNum, pageSize);

        SmsHomeAdvertiseExample example = new SmsHomeAdvertiseExample();
        SmsHomeAdvertiseExample.Criteria criteria = example.createCriteria();
        if (!StringUtils.isEmpty(name)) {
            criteria.andNameLike("%" + name + "%");
        }
        if (type != null) {
            criteria.andTypeEqualTo(type);
        }
        if (!StringUtils.isEmpty(endTime)) {
            //因为时间的格式不对，所以需要转换格式
            //输入的时间格式是：
            //SQL语句查询时间的格式（或者是数据库存储的时间格式）：
            String startStr = endTime + " 00:00:00";
            String endStr = endTime + " 23:59:59";
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

            Date start = null;
            try {
                start = sdf.parse(startStr);
            } catch (ParseException e) {
                e.printStackTrace();
            }

            Date end = null;
            try {
                end = sdf.parse(endStr);
            } catch (ParseException e) {
                e.printStackTrace();
            }

            if (start != null && end != null) {
                criteria.andEndTimeBetween(start, end);
            }
        }
        example.setOrderByClause("sort desc");
        return advertiseMapper.selectByExample(example);
    }
```	2019-08-14 19:51:48
kumika	电商项目--15	# 电商项目--15

商品管理，订单管理，促销管理，内容管理，用户管理，快速写完这些，就看面试和算法吧


#用户管理


写项目没有给实现，但是又有代码的，关键是前端是没有的（不想给吗，这作者）

##后台用户角色管理

Controller:
```
/**
 * 后台用户角色管理
 */
@Controller
@Api(value = "UmsRoleController",description = "后台用户角色管理")
@RequestMapping("/role")
public class UmsRoleController {

    @Autowired
    private UmsRoleService roleService;


    @ApiOperation("获取所有角色")
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    @ResponseBody
    public Object list() {
        List<UmsRole> roleList = roleService.list();
        return new CommonResult().success(roleList);
    }


    @ApiOperation("添加角色")
    @RequestMapping(value = "/create", method = RequestMethod.POST)
    @ResponseBody
    public Object create(@RequestBody UmsRole role) {
        int count = roleService.create(role);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }



    @ApiOperation("获取相应角色权限")
    @RequestMapping(value = "/permission/{roleId}", method = RequestMethod.GET)
    @ResponseBody
    public Object getPermissionList(@PathVariable Long roleId) {
        List<UmsPermission> permissionList = roleService.getPermissionList(roleId);
        return new CommonResult().success(permissionList);
    }

    @ApiOperation("修改角色权限")
    @RequestMapping(value = "/permission/update", method = RequestMethod.GET)
    @ResponseBody
    public Object updatePermissionList(@PathVariable Long roleId,
                                       @RequestParam("permissionIds") List<Long> permissionIds) {

        int count = roleService.updatePermission(roleId, permissionIds);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }

    @ApiOperation("修改角色")
    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)
    @ResponseBody
    public Object update(@PathVariable Long id,@RequestBody UmsRole role) {
        int count = roleService.update(id,role);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }

    @ApiOperation("批量删除角色")
    @RequestMapping(value = "/delete}", method = RequestMethod.POST)
    @ResponseBody
    public Object delete(@RequestParam List<Long> ids) {
        int count = roleService.delete(ids);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }
}

```

Service
```

@Service
public class UmsRoleServiceIMPL implements UmsRoleService {

    @Autowired
    private UmsRoleMapper roleMapper;

    @Autowired
    private UmsRolePermissionRelationDao rolePermissionRelationDao;

    @Autowired
    private UmsRolePermissionRelationMapper rolePermissionRelationMapper;

    @Override
    public List<UmsRole> list() {
        return roleMapper.selectByExample(new UmsRoleExample());
    }

    @Override
    public int create(UmsRole role) {
        role.setCreateTime(new Date());
        role.setStatus(1);
        role.setAdminCount(0);
        role.setSort(0);

        return roleMapper.insert(role);
    }

    @Override
    public List<UmsPermission> getPermissionList(Long roleId) {
        return rolePermissionRelationDao.getPermissionList(roleId);
    }

    @Override
    public int updatePermission(Long roleId, List<Long> permissionIds) {
        //先删除原有关系
        UmsRolePermissionRelationExample example = new UmsRolePermissionRelationExample();
        example.createCriteria().andRoleIdEqualTo(roleId);
        rolePermissionRelationMapper.deleteByExample(example);

        //批量插入新关系
        List<UmsRolePermissionRelation> relationList = new ArrayList<>();
        for (Long permissionId : permissionIds) {
            UmsRolePermissionRelation relation = new UmsRolePermissionRelation();
            relation.setRoleId(roleId);
            relation.setPermissionId(permissionId);
            relationList.add(relation);
        }
        return rolePermissionRelationDao.insertList(relationList);
    }

    @Override
    public int update(Long id, UmsRole role) {
        role.setId(id);
        return roleMapper.updateByPrimaryKey(role);
    }

    @Override
    public int delete(List<Long> ids) {
        UmsRoleExample example = new UmsRoleExample();
        example.createCriteria().andIdIn(ids);
        return roleMapper.deleteByExample(example);
    }
}
```
Dao:
接口：
```
/**
 * 后台用户角色管理自定义Dao
 */
public interface UmsRolePermissionRelationDao {
    /**
     * 根据角色获取权限
     */
    List<UmsPermission> getPermissionList(@Param("roleId") Long roleId);

    /**
     * 批量插入角色和权限关系
     */
    int insertList(@Param("list") List<UmsRolePermissionRelation> relationList);
}
```
XML文件：
```
<mapper namespace="com.taobao.taobaoadmin.dao.Ums.UmsRolePermissionRelationDao">
    <select id="getPermissionList" resultMap="com.taobao.taobaoadmin.mapper.UmsRoleMapper.BaseResultMap">
        SELECT
              p.*
        FROM
              ums_role_permission_relation r
              left JOIN  ums_permission p ON  r.permission_id = p.id
        WHERE
              r.role_id = #{roleId}
    </select>

    <!--批量新增回写主键支持-->
    <insert id="insertList">
        INSERT  INTO ums_permission_relation (role_id,permission_id)
        VALUES
              <foreach collection="list" item="item" separator="," index="index">
                  (
                  #{item.roleId,jdbcType=BIGINT},
                  #{item.permissionId,jdbcType=BIGINT}
                  )
              </foreach>
    </insert>
</mapper>
```



##后台用户权限管理


接收类：
```
public class UmsPermissionNode extends UmsPermission {
    @Getter
    @Setter
    private List<UmsPermissionNode> children;
}
```



Controller:
```
/**
 * 后台用户权限管理
 */
@Controller
@Api(value = "UmsPermissionController", description = "后台用户权限管理")
@RequestMapping("/permission")
public class UmsPermissionController {

    @Autowired
    private UmsPermissionService permissionService;

    @ApiOperation("获取所有权限列表")
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    @ResponseBody
    public Object list() {
        List<UmsPermission> permissionList = permissionService.list();
        return new CommonResult().success(permissionList);
    }

    @ApiOperation("添加权限")
    @RequestMapping(value = "/create", method = RequestMethod.POST)
    @ResponseBody
    public Object create(@RequestBody UmsPermission permission) {
        int count = permissionService.create(permission);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }

    @ApiOperation("修改权限")
    @RequestMapping(value = "/update", method = RequestMethod.POST)
    @ResponseBody
    public Object update(@PathVariable Long id, @RequestBody UmsPermission permission) {
        int count = permissionService.update(id,permission);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }

    @ApiOperation("根据id批量删除权限")
    @RequestMapping(value = "/delete", method = RequestMethod.POST)
    @ResponseBody
    public Object update(@RequestParam("ids")List<Long> ids) {
        int count = permissionService.delete(ids);
        if (count > 0) {
            return new CommonResult().success(count);
        }
        return new CommonResult().failed();
    }

    @ApiOperation("以层级结构返回所有权限")
    @RequestMapping(value = "/treeList", method = RequestMethod.GET)
    @ResponseBody
    public Object treeList() {
        List<UmsPermissionNode> permissionNodeList = permissionService.treeList();
        return new CommonResult().success(permissionNodeList);
    }
}
```

Service
```
@Service
public class UmsPermissionServiceIMPL implements UmsPermissionService{

    @Autowired
    private UmsPermissionMapper permissionMapper;


    @Override
    public List<UmsPermission> list() {
        UmsPermissionExample example = new UmsPermissionExample();
        return permissionMapper.selectByExample(example);
    }

    @Override
    public int create(UmsPermission permission) {
        permission.setStatus(1);
        permission.setCreateTime(new Date());
        permission.setSort(0);
        return permissionMapper.insert(permission);
    }

    @Override
    public int update(Long id, UmsPermission permission) {
        permission.setId(id);
        return permissionMapper.updateByPrimaryKey(permission);
    }

    @Override
    public int delete(List<Long> ids) {
        UmsPermissionExample example = new UmsPermissionExample();
        example.createCriteria().andIdIn(ids);
        return permissionMapper.deleteByExample(example);
    }

    @Override
    public List<UmsPermissionNode> treeList() {
        List<UmsPermission> permissionList = permissionMapper.selectByExample(new UmsPermissionExample());
        //0L （零L） 不是  OL（欧L）
        List<UmsPermissionNode> result = permissionList.stream()
                .filter(permission -> permission.getPid().equals(0L))
                .map(permission -> covert(permission, permissionList)).collect(Collectors.toList());
        return result;
    }

    /**
     * 将权限转换为带有子级的权限对象
     * 当找不到子级权限的时候map操作不会再递归调用covert
     */
    private UmsPermissionNode covert(UmsPermission permission, List<UmsPermission> permissionList) {
        UmsPermissionNode node = new UmsPermissionNode();
        BeanUtils.copyProperties(permission, node);
        List<UmsPermissionNode> children = permissionList.stream()
                .filter(subPermission -> subPermission.getPid().equals(permission.getId()))
                .map(subPermission -> covert(subPermission, permissionList)).collect(Collectors.toList());
        node.setChildren(children);
        return node;
    }
}
```

	2019-08-16 22:00:20
kumika	面试大概注意的知识	"# 面试大概注意的知识    

网上看到的大牛对自己学习的心路历程,贴在这里作为对自己的激励吧：
```
整个暑假吧，认认真真推到了统计机器学习的大部分公式，数据结构的算法，leecode也刷了150道，剑指offer刷了3遍。深度学习所有能想到的知识点都去推导一遍。网络，系统知识等都去看了看。智力题，概率题，场景题，也都复习。晚上睡不着的时候就回顾面试，看看哪里做得不对。。看别人的面经。遇到不会就百度，牛客上问。。。
```



https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486163&idx=1&sn=3f395ec8287050ac719d9237eb8107aa&chksm=ebd635ffdca1bce9f444940afeb0d86f6d83bcb2acde382057609225cba6faedf010222d1bfc&scene=21#wechat_redirect


https://segmentfault.com/a/1190000016773721（几道常见的秋招面试题）


https://blog.csdn.net/qq_18298439/article/details/80939968（全面的面试题）
https://www.cnblogs.com/lyldaisy/p/10952180.html
https://blog.csdn.net/weixin_44626952/article/details/90260021（面试题目）
https://blog.csdn.net/IbelieveSmile/article/details/81334205

https://segmentfault.com/a/1190000015373033（Java面试前需要了解的东西）


https://www.cnblogs.com/carsonwuu/p/10065679.html（面试=笔试的题目的，刷哪个都一样）

https://blog.csdn.net/jackfrued/article/details/44921941(上，有答案的)
https://blog.csdn.net/jackfrued/article/details/44931161(下，有答案的)


https://blog.csdn.net/IbelieveSmile/article/details/81334205

2019的面试宝典：
https://blog.csdn.net/weixin_38405770/article/details/86657613
https://blog.csdn.net/qq_41701956/article/details/90381294
https://zhuanlan.zhihu.com/p/83341908
https://www.cnblogs.com/carsonwuu/p/10065679.html
https://blog.csdn.net/bushanyantanzhe/article/details/79858961（1--2年的面试题目）









笔试：
https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484273&idx=1&sn=1eb9112e1ab1004b3040a66b76ad5646&chksm=ebd74270dca0cb663beb878ae31e39c3cc14bc56f1db62f426f5b4cb34b9a804a0bf7cbd9a27#rd


班科的求职之路：
https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484273&idx=1&sn=1eb9112e1ab1004b3040a66b76ad5646&chksm=ebd74270dca0cb663beb878ae31e39c3cc14bc56f1db62f426f5b4cb34b9a804a0bf7cbd9a27#rd

##项目
项目的要点是什么，怎么实现的

我想要的基本技术：
    上传，下载 ，缓存登录， shiro的登录，再回头看看那些项目有什么技术点把
    
    上面完成后看JavaSE的基础，还有下面的算法
MyBatis-generator代码生成器技术

后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。


# JavaArithmetic

Java练习算法代码(排序，数据结构，小算法，LeetCode练习题)


## 一、sort文件夹是排序算法

八大排序算法

- 冒泡排序
- 选择排序
- 插入排序
- 归并排序
- 快速排序
- 基数排序(桶排序)
- 希尔排序
- 堆排序


## 三、basic文件夹是基础相关

Java简单的算法题，目前有20道

递归知识～

## 四、datastructure

2018年9月25日更新，_old文件夹的是之前的(..


## 五、LeetCode

一些LeetCode的题目.


- No1：找出数组中能够组成sum的两个数的数组下标
	- 解法：使用Map来存储，如果发现`target-arr[i]`如果在Map中有数据，那返回下标即可
- No3：求出数组能组成最大不重复元素的间隔
	- 解法：使用滑动窗口的思想，不停往前移动，每次移动一次时计算max值，最终返回的一定是符合条件的最大值
- No7：反转整数
    - 解法：其实就是运用数学方法：`int pop = x % 10;x /= 10;rev = rev * 10 + pop;`。同时因为`res*10`可能会发生溢出，可以使用Math方法来判断一下：`if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;`
- No17： 9宫格，例如：输入123能够组合成哪些字母
	- 解法：将123..使用数组的方式来装载(类似于查表)，将输入的字符串123(digits)，从index开始，使用String s来记录每次可能得到的组合值。如果`index==digits.length`，说明已经是一种情况了。
- No19：删除链表第n个元素，tips：删除链表元素最好使用一个dummyHead，这样就不用担心删除的是链表头了。使用方式：`dummyHead.next = head`
	- 解法1：计算出链表的长度，`int k = length-n`，k的坐标就是要删除的位置了
	- 解法2：使用两个指针fast和slow，先让fast先走`n-1`个位置，然后两个指针同时走(直到fast==null)，最后，slow的下一个节点就是要删除的节点。
- No20：检验字符串`[]{]}{]{}(`这样的字符串是否有效(对齐)
	- 解法：使用Stack来存储`[{(`这些字符，如果是不是这些字符的话，则出栈，判断是否与`[{(`相匹配。
		- 可能遇到的边界问题：一、出栈时需要判断Stack是否有元素。二、所有元素进出栈完毕后，需要判断Stack是否为null
- No24：两两交换链表的节点
	- 解法：使用`p=dummyHead`，`while(p.next != null && p.next.next != null )`，找出接下来的三个节点，分别为node1,node2,next。做法很简单：node2指向node1，node1指向next，p指向node2,node1的位置由p取代
- No47：数字全排列(回溯法)
	-  解法：使用一个数组记录已经"走过"的数字，从`index=0`开始，当`index==nums.length`说明已经出现一个结果了。每次遍历一个数字时，判断是否已经"走过"，如果没有"走过"则设置为"走过"，并add到我们的结果中。回溯完了之后需要清除状态！
- No51：八皇后问题(回溯法)
	- 解决：其实与全排列的问题是一样的，解法也是一样的。只不过八皇后问题需要针对具体的条件来判断而已。规律就是这三个条件：`col[i] && !dia1[index + i] && !dia2[index - i + n - 1]`
- No75：给出只有`[0,1,2]`的数组，这个数组是乱序的，想要将其结果变成是`[0,1,2]`有序
	- 解决1：可能首先想到的是排序算法，排序算法的话时间复杂度最低控制在O(nlogn)
	- 解决2：因为只有3个元素，其实我们可以创建出一个三个元素的数组，记录每个数字出现的频率，然后根据`0,1,2`的频率放回到数组里边去，这样就是有序的了。这个时间复杂度和空间复杂度都为O(n)
	- 解决3：使用三路快排的思想，可以不用开辟多于的空间。具体实现就是0放在最左侧，1在中间，2在最右侧。
- No77：求解C(n,k)的组合(回溯法)
	- 解法：从1开始，只要`result.size()==k`则是一种组合，递归完记得要清除状态
- No79：在n*m的“地图”中，是否存在有对应的路径找到对应的答案(回溯)
	- 解法：使用一个二维数组来代表上下移动(遍历这个数组，即可实现)`int d[][] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};`使用一个visited数组来代表这个“位置”是否已经被走过了。如果没有被走过，并且是当前的结果路径之一，则继续上下左右移动。直到当前的结果长度与index相等(递归出口) 。回溯完需要清除状态值
- No96-144-145：遍历树
	- 解法1：使用递归的话就很容易前中后遍历数了。
	- 解法2：使用Stack来实现无递归的方式来遍历，要注意使用Stack时，什么时候push进去！因为跟递归的时候是相反的
- No102：层序遍历树
	- 解法：使用队列的方式(linkedList)就很容易实现了
- No104：树的最大深度
	- 解法：使用递归的方式，其实就一行代码` return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));`
- No112：树根节点到叶节点的"和"路径是否存在
	- 解法：递归的出口就是-->叶子节点的值是否等于sum，递归调用`return hasPathSum(root.left, sum - root.val)|| hasPathSum(root.right, sum - root.val);`
- No113：求出树根节点到叶节点的"和"路径
	- 解法：相对于leetcode 112，它只是要求出对应的路径。我们可以使用一个list来记录路径，每次进入之前就add进去，递归完了之后就remove掉。其实就相当于回溯法
- No167：找出数组中能够组成sum的两个数的数组下标，此时这个数组是有序的。
	- 跟第一题不同的是，此时的数组是有序的。
	- 解法1：使用二分的方式来搜索，找出对应的下标(此时的时间复杂度是O(nlogn)
	- 解法2：使用滑动窗口的方式来搜索，因为l值是小的，r值是大的。如果l+r < target，l这边++即可！
- No200：寻找"陆地"的个数，在n*m的数组中寻找出"陆地"(深度遍历)
	- 解法：使用一个二维数组来实现移动`d[][] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};`，使用`visited[][]`来记录已经走过的位置。
- No203：在链表删除的节点
	- 解法1：使用dummyHead就不用再做其余的处理了
	- 解法2：使用递归的方式：`head.next = removeElements4(head.next, val);`，最后`head.val == val ? head.next : head;`
- No206：反转链表
	- 解法1：循环的方式；使用一个pre节点，找到next节点。`cur.next= pre; pre = cur; cur = next`
	- 解法2：递归的方式；`ListNode rhead = reverseList2(head.next); head.next.next = head; head.next = null; return rhead;`
- No209：给出一个数组，给出一个target，求出数组的元素+起来的和>target的最短间隔
	- 解法：跟No3不同的是，No3着重于不重复元素的间隔，而这里着重于比较target的值。使用一个sum来维护，每次
- No219：给出一个数组，在k的范围内，判断有没有重复的元素
	- 解法：使用HashSet来维护，如果在add之前发现已经重复了，返回true。当map的大小大于k+1,那就减去最左边的元素`if(record.size() == k + 1) record.remove(nums[i-k]);`
- No220：在距离当前位置为k的范围内，是否存在一个点的值与当前位置值的差的绝对值小于等于t。
	- 解法：在上一题中，主要是判断是否有重复值，而此道的条件是有无绝对值小于的等于t(在k范围内)。其实就是判断条件变化了，绝对值问题我们可以使用treeSet的ceiling方法：`if (record.ceiling((long) nums[i] - (long) t) != null &&record.ceiling((long) nums[i] - (long) t) <= (long) nums[i] + (long) t)`
- No226：反转树
	- 解法：使用递归，得到左边，得到右边。左右两边交换
- No237：在链表删除元素为value的节点
	- 解法：找到给定值的节点，将找到的节点的下一个节点的值赋值给当前节点，删除掉下一个节点
- No253：在二叉树找出p和q节点的最小公共祖先
	- 解法：p q 都在root左边`if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);`...右边也是差不多的，如果在同一侧，直接返回root
- No257：求出二叉树的路径
	- 解法：当遍历到叶子节点时，此时加入根节点。否则递归求出左子树和右子树的路径
- No260：给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素
	- 解法：其实如果是恰好有一个元素只出现一次的话，我们可以直接异或就搞掂了。现在是两个元素只出现一次，解决其实也一样：对这些数据进行异或，得出一个sum-->`sum ^= nums[i];`，使用`sum &= -sum;`得出两个数异或结果的最右边的一个1，其他的为零，这样进行&操作就可以将两个不同的数分到不同的两组去。于是使用`int[] res = new int[2];`根据==0来区分两个组来异或，最后得出的结果就是res的值了！
- No283：将数组的0移到最后，其余的元素顺序不发生改变
	- 解法1：使用一个新数组装载非0元素，将nums剩余的位置放置为0：`for(int i = nonZeroElements.size() ; i < nums.length ; i ++) nums[i] = 0;`
	- 解法2：nums中, [0...k)的元素均为非0元素，只要遍历到的元素不为0，k++。
	- 解法3：使用交换的方式`for(int i = 0 ; i < nums.length ; i ++) if(nums[i] != 0) if(k != i)swap(nums, k++, i); else k ++;`
- No347：求Top K 频率出现最高的元素
	- 解法：使用HashMap来记录每个元素出现的频率，然后使用小顶堆将其比较，如果当前pop出来的堆顶比当前遍历到的元素频率要小，则出队，换当前元素进去(注意，要维护当前堆只有k个元素的)
- No349：求两个数组的交集，只出现一次
	- 解法：将其中一个数组遍历，使用hashSet来存储。再将第二个数组遍历，判断当前元素是否存在HashSet中，如果存在则是其中一个结果
- No350：求两个数组的交集，这次要求有多少个相同的，交集的结果也得有多少个
	- 解法：使用HashMap来计算频率，在遍历第二个数组的时候，根据频率来add到结果集中
- No437：树根节点到其余树节点的"和"路径有多少条？
	- 解法：这跟之前那个有点区别，这不是规定到叶子节点上了，而是每个节点上都行！`return findPath(root, sum)+ pathSum(root.left, sum) + pathSum(root.right, sum);`
- No447：求出三个点距离的组合
	- 解法使用hashMap来存储起来合适的距离。求和的时候使用`res += record.get(dis) * (record.get(dis) - 1);`即可！
- No454：求出四个数组的元素能够组成0的组合
	- 解法：计算C和D的sum，放入Map，如果sum重复的话，value加1(开辟空间来减少时间复杂度)。遍历AB的时候，算出具体的个数就可以了：`if(map.containsKey(-A[i]-B[j])) res += map.get(-A[i]-B[j]);`
- No804：唯一摩尔斯密码词
	- 解法：查表(将密码定义成表，查出对应的摩斯密码)，放入set集合即可





像四种八类基本类型，类型转换，方法重载和重写，接口和抽象类，线程状态和创建方式,多线程！反射,常见的算法如冒泡快排（要会手撕代码！）及各种排序的时间复杂度对比,自定义注解（之前去携程问了springmvc注解实现细节，其实在se阶段，贺老师已经讲了注解了，当然后面lzl刘老师也带我们看了源码！）（常见的垃圾回收算法也有讲，尽量熟记一下吧），这些真的很重要，几乎是面试必考或必问的，多看看hashmap，Arraylist和linkedlist的源码，了解它们的底层实现细节和扩容机制。这一阶段可以刷一下牛客上的题，夯实基础。

HTTP，servlet生命周期，cookie，session， 请求转发和重定向，数据库语句


动态代理，spring的ioc，di，aop，事务（五种隔离级别，七种传播行为），springmvc的请求处理流程及常见的注解及注解的实现细节，springboot的常用注解。


shiro认证授权，面试官可能会问后台shiro怎么做的，设计了几张表等

集合、hashmap、多线程、设计模式、springioc、aop、redis数据类型、sql语句、sql优化、数据库索引、linux常用命令（查看日志）

hashmap的原理一定要搞懂，比如底层数据结构，底层原码，如何解决hash冲突

 springioc，aop原理。mysql的索引实现，sql语句优化。

https://www.cnblogs.com/wsg25/p/9615100.html（数据库的3大范式，行的内容都要和主键有关，列的内容具有原子性，列的内容都要和主键有关）


集合的hashmap那些
"	2019-08-18 16:00:42
kumika	项目复习	#项目复习
项目的要点是什么，怎么实现的，例如使用什么技术、担当什么角色、达成了什么样的成果。

我想要的基本技术：
    上传，下载 ，缓存登录，注册 shiro的登录，再回头看看那些项目有什么技术点把
    
    上面完成后看JavaSE的基础，还有下面的算法


#登录：

##JWT的结构：

![JTW的结构.jpg](https://i.loli.net/2019/08/27/pYA1X79sbGPiIHD.png)

实际例子：
解码之前的JWT：
![没转码前的JWT.jpg](https://i.loli.net/2019/08/27/9rSicUZjfKynBEX.jpg)
解码之后：
![hp.jpg](https://i.loli.net/2019/08/27/2mKZHM7tVBRxr5q.jpg)
![s.jpg](https://i.loli.net/2019/08/27/fAHoBvhZPc4z8Ft.jpg)




为什么使用JWT？作用是什么？JWT的使用场景？
答：
使用JWT可以
**解决单一使用security时每次访问资源都需要用户信息进行登录的效率问题和安全问题**，解决redis session共享方式的跨域问题（这里我并没有使用到redis所以不知道）

作用是：
确保发送者发送的信息是没有经过伪造的。

在身份鉴定的实现中，传统方法是在服务端存储一个session，给客户端返回一个cookie，而使用JWT之后，当用户使用它的认证信息登陆系统之后，会返回给用户一个JWT，用户只需要本地保存该token（通常使用local storage，也可以使用cookie）即可。 当用户希望访问一个受保护的路由或者资源的时候，通常应该在`Authorization`头部使用`Bearer模式`添加JWT，其内容看起来是下面这样：`Authorization: Bearer <token>`

因为用户的状态在服务端的内存中是不存储的，所以这是一种无状态的认证机制。服务端的保护路由将会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为。由于JWT是自包含的，因此减少了需要查询数据库的需要。 JWT的这些特性使得我们可以完全依赖其无状态的特性提供数据API服务，甚至是创建一个下载流服务。因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域资源共享问题（CORS）。

**JWT的使用场景：**
-------------

[![](https://ae01.alicdn.com/kf/Hb72743d455bf4212b0ff2595ad0197b1y.png)](https://ae01.alicdn.com/kf/Hb72743d455bf4212b0ff2595ad0197b1y.png)

身份认证在这种场景下，一旦用户完成了登陆，在接下来的每个请求中包含JWT，可以用来验证用户身份以及对路由，服务和资源的访问权限进行验证。由于它的开销非常小，可以轻松的在不同域名的系统中传递，所有目前在单点登录（SSO）中比较广泛的使用了该技术。
信息交换在通信的双方之间使用JWT对数据进行编码是一种非常安全的方式，由于它的信息是经过签名的，可以确保发送者发送的信息是没有经过伪造的。


一次性验证

比如用户注册后需要发一封邮件让其激活账户，通常邮件中需要有一个链接，这个链接需要具备以下的特性：能够标识用户，该链接具有时效性（通常只允许几小时之内激活），不能被篡改以激活其他可能的账户…这种场景就和 jwt 的特性非常贴近，jwt 的 payload 中固定的参数：iss 签发者和 exp 过期时间正是为其做准备的。

restful api 的无状态认证

使用 jwt 来做 restful api 的身份认证也是值得推崇的一种使用方案。客户端和服务端共享 secret；过期时间由服务端校验，客户端定时刷新；签名信息不可被修改…spring security oauth jwt 提供了一套完整的 jwt 认证体系，以笔者的经验来看：使用 oauth2 或 jwt 来做 restful api 的认证都没有大问题，oauth2 功能更多，支持的场景更丰富，后者实现简单。




#搭建思路

搭建springboot工程
导入springSecurity跟jwt的依赖
用户的实体类
dao层
service层（真正开发时再写，这里就直接调用dao层操作数据库）
实现UserDetailsService接口
实现UserDetails接口
验证用户登录信息的拦截器
验证用户权限的拦截器
springSecurity配置
认证的Controller以及测试的controller
测试

实际上的思路：
###搭建springboot工程
###导入springSecurity跟jwt的依赖
###用户的实体类
###添加JWT token工具类
###添加UserRepository接口
###添加UserDetailsServiceImpl类
###添加JWTUser类
###配置拦截器`JWTAuthenticationFilter`和`JWTAuthorizationFilter`

使用`JWTAuthenticationFilter`去进行用户账号的验证，使用`JWTAuthorizationFilter`去进行用户权限的验证

JWTAuthenticationFilter

    JWTAuthenticationFilter继承于UsernamePasswordAuthenticationFilter
    该拦截器用于获取用户登录的信息，只需创建一个token并调用authenticationManager.authenticate()让spring-security去进行验证就可以了，不用自己查数据库再对比密码了，这一步交给spring去操作。
    这个操作有点像是shiro的subject.login(new UsernamePasswordToken())，验证的事情交给框架。
    献上这一部分的代码。

JWTAuthorizationFilter

    验证成功当然就是进行鉴权了，每一次需要权限的请求都需要检查该用户是否有该权限去操作该资源，当然这也是框架帮我们做的，那么我们需要做什么呢？很简单，只要告诉spring-security该用户是否已登录，是什么角色，拥有什么权限就可以了。
    JWTAuthenticationFilter继承于BasicAuthenticationFilter
    确保过滤器的顺序，JWTAuthorizationFilter在JWTAuthenticationFilter后面就没问题了


###配置SpringSecurity
需要开启一下注解`@EnableWebSecurity`然后再继承一下`WebSecurityConfigurerAdapter`就可以啦，springboot就是


###AuthController注册登录控制器


-------------------------------------------------------------

搭建springboot工程
###导入springSecurity跟jwt的依赖
###添加JWT token的工具类
目的：
    用于生成和解析JWT token的工具类
###添加SpringSecurity的配置类
目的：
    配置SpringSecurity，同时将JWT整合在一起（RestfulAccessDeniedHandler，RestAuthenticationEntryPoint，JwtAuthenticationTokenFilter）。
###添加RestfulAccessDeniedHandler
目的:
    当访问接口没有权限时，自定义的返回结果
###添加RestAuthenticationEntryPoint
目的：
    当未登录或者token失效访问接口时，自定义的返回结果
###添加AdminUserDetails
目的：
    继承UserDetails ，SpringSecurity需要的用户详情
###添加JwtAuthenticationTokenFilter
目的：
    在用户名和密码校验前添加的过滤器，如果请求中有jwt的token且有效，会取出token中的用户名，然后调用SpringSecurity的API进行登录操作。


-------------------------------
登录注册功能实现（注册前端根本没给啊）
###添加UmsAdminController类
目的：
    实现了后台用户登录、注册及获取权限的接口
###添加UmsAdminService接口
###添加UmsAdminServiceImpl类
    UmsAdminService实现类
###修改Swagger的配置
目的：
    通过修改配置实现调用接口自带Authorization头，这样就可以访问需要登录的接口了。
给PmsBrandController接口中的方法添加访问权限

搞清楚2个搭建配置就看CommentResult那个

串联自己项目的JWT，看看Swagger怎么用，看commentResult怎么回事，就完成这部分了。

这些都是工具，怎么用而已

CommonResult是springBoot的一个特点，工具的一个特点。

fishNoWantGuai
443fish
JWT的搭建思路
springBoot搭建
JWT的依赖
JWT的工具类
SpringSecurity配置类
JWT令牌配置类
JWT的过滤器
增加User Details类
Controller
service和实现类


#使用Swagger

这个Swagger是作为说明书的一个存在。可以在线实现功能，帮助客户了解功能。


##在SpringMVC整合：
1    添加maven依赖
2    定义一个swagger配置类，具体内容可参考网上demo
3    在spring配置文件中将写的config类添加一个bean
4    在controller中接口处添加swagger注解和相应参数
5    Swagger UI配置


##在SpringBoot整合：
1    添加maven依赖
2    创建swagger2配置类，该类和springmvc中的不太一样，具体可参考swagger官网。配置中通过@Configuration注解，让Spring来加载该类配置。再通过@EnableSwagger2注解来启用Swagger2。
3    和springmvc一样，在controller接口中编写swagger相关的注解来标识接口信息。
4     完成上述代码添加上，启动Spring Boot程序，访问：http://localhost:8080/swagger- ui.html。（项目不是用端口8080的，就改成当前项目使用的端口）

当前项目：
1    添加maven依赖
2    添加Swagger-UI的配置类
3    在controller中接口处添加swagger注解和相应参数
4    启动Spring Boot程序，访问：http://localhost:8080/swagger- ui.html。
还是和上面一样的设置。


#参考：
JWT结构的参考：
http://www.leftso.com/blog/220.html
http://www.leftso.com/blog/221.html

基于SpringSecurity和JWT的用户访问认证和授权
http://www.demodashi.com/demo/14559.html
这个也是一样的SpringSecurity和JWT整合
https://www.cnblogs.com/demodashi/p/10492856.html

**详细解释SpringSecurity和JWT**（重点对比）
https://blog.csdn.net/ech13an/article/details/80779973

https://www.cnblogs.com/JacZhu/p/9779975.html


Swagger的整合到mall上
https://www.jianshu.com/p/9a2dfaf3cfca
https://www.jianshu.com/p/7cfd173d1853

mall的整合
https://www.jianshu.com/p/686dca8202b5
https://www.jianshu.com/p/153803eec3dc

深入理解JWT的使用场景和优劣
https://mp.weixin.qq.com/s?__biz=MzI0NzEyODIyOA==&mid=2247483918&idx=1&sn=12683bae55f2ab1a8281ab398472362f&chksm=e9b58bc5dec202d385d1c1d861f7e0ff495296ed9387b32a8d01ae195eae03688e5aeebe6396&mpshare=1&scene=23&srcid=0505snLrWQ4JjwVW94oSMJaK#rd
深入理解JWT的使用场景和优劣（和上面的一致）
https://blog.csdn.net/qq_28165595/article/details/80214994

初步理解JWT并实践使用
https://blog.csdn.net/qq_40081976/article/details/79046825


Java容器的总结：
http://direct.superbed.cn/static/images/2019/08/27/5d64e767451253d178b57e74.png


**父母不能帮我
朋友不能帮我
亲戚不能帮我
同学不能帮我
自己帮自己。**
tcpip没讲、中间件没讲、nginx没讲、postman没讲

postMan讲解：
http://chromecj.com/utilities/2018-06/1460.html
http://chromecj.com/utilities/2018-06/1461.html
http://chromecj.com/utilities/2018-06/1469.html


JWT 实现的目的是什么
springSecurity 实现的目的是什么

我为什么要用JWT+ springSecurity
作者想要实现的功能是什么？











你这明显是跳槽太少了，很多东西必须要问的。 
我最少问两点: 
1.最基本的福利，六险一金都按什么标准交，有啥额外的补贴之类的没。 
2.团队招了你这个人，领导或者整个团队对你的定位是什么，希望你承担哪些工作，3个月，1年之后对你的期望是什么。 
3.团队的工作强度怎样？在整个公司内focus在哪个area？做的是不是最核心的东西？ 
这三个是最基本的。你什么都不问，他把你忽悠进去了，万一让你做的不是你期望的怎么办？


接收自己：
https://www.zhihu.com/question/316204212


学习---帝哥的解释

我想说说，什么是学习。学习，就是把未知的东西，转化成已知的东西。即，未知信息通过你的五感传入你的大脑，你的大脑通过工作，把这些信息转化成大脑可以理解的信息。正常的学习过程：五感发现问题：比如眼睛看到了1+1=？大脑转化信息：通过老师的教学，你首先认识了“1”、“+”、“=”这些信息元，然后搞明白了这些信息元以这样的组合方式放在一起是什么意思，然后你又搞清楚了怎样去处理这个问题，最终你把那个问号擦掉、用笔写上了“2”；大脑对信息的重组和整合：大脑会把上面的过程重新重组和整合一遍，然后把整理好的信息保存在大脑里。当下次你又看到同一个问题的时候，你就不再需要重新来一遍上面的过程了，你只需要直接调用这个整理好的信息，直接就可以解决问题。所以，学习的过程的几个核心要点是：怎么发现问题、怎么转化信息、怎么重组与整合信息。罗振宇和他的罗辑思维是在做什么呢？他是把发现问题、转化信息和重组与整合信息全部做完，然后把最终整理好的信息直接拿给你看。这个，不叫学习，更像是“展览”。罗振宇盖了个博物馆，你进去参观，仅此而已。你参观完你就能也盖一个一模一样的博物馆了吗？当然不行。学习的精髓，过程，也就是发现问题、信息转化和信息重组与整合，而不是一个结果。结果，只是学习完成的结果而不是学习本身。你妈把食物都嚼碎然后吐给你吃，你会因为消化系统无法正常发育而衰竭死亡；你把所有不会做的题目都让学霸给你讲一遍，你永远只会感叹“原来是这样”而你并不能在下次做难题时想到应该那样做；你天天去五星级餐厅吃饭，你只会感叹“真好吃”而你并不会变成大厨。同样的，你天天看罗辑思维，你变不成罗振宇。觉得天天看罗辑思维就能变成学霸就能变成博学多识之士的人，就和想减肥于是买了个甩脂机天天站在上面抖的人一样，本质就是一个字：懒 ——— 懒成狗了。你在学校没好好学习，妄图想靠“别人替你走路你就能游遍天下”，我只能说，你真能成功，算上帝瞎了眼。天龙八部里扫地僧说过一句话：旁人只能指点，不可代劳。这是至理名言。你如果不喜欢罗振宇和罗辑思维，不看就好了，有时间，自己摆正心态踏踏实实地读两本书，才是正途。

最后再啰嗦两句：“信息由五感传入大脑、大脑转化信息而后重组和整合信息” 和 “把大脑重组和整合好的信息掉出来并发送至五感最终表达出来”，这两个过程不是简单的逆向关系，而是一个相互促进的关系。比如，你学一个东西，你觉得你学会了，但是当你把你觉得你已经学会的这个东西用你的笔或者嘴巴写出来、说出来给别人讲的时候，有时候你会卡住、有时候你会发现其实自己并不是真的学会了。然后你就需要重新学习一次。这样长期下去；你会越来越厉害。这就是所谓的费曼学习法。所以啊，罗振宇一直做罗辑思维，他个人的学（财）识（富）是会越来越多的，但是呢，你还是你，不会有什么本质的变化。

作者：二律背反
链接：https://www.zhihu.com/question/67169545/answer/807120993
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	2019-08-19 20:42:54
kumika	项目复习2	#项目复习2
项目的要点是什么，怎么实现的

我想要的基本技术：
    上传，下载 ，缓存登录，注册 shiro的登录，再回头看看那些项目有什么技术点把
    
    上面完成后看JavaSE的基础，还有下面的算法


#OSS的上传
具体的代码在电商项目-2上写有。这里复习思路。
理解代码，配置是组件，OSS的配置思路

##上传的流程：



###开通OSS服务
-------

###创建存储空间
------

    1   点击网页右上角控制台按钮进入控制台
    2   选择我的云产品中的对象存储OSS
    3   点击左侧存储空间的加号新建存储空间
    4   新建存储空间并设置读写权限为公共读，存储类型是标准类型

###跨域资源共享（CORS）的设置
---------------

由于浏览器处于安全考虑，不允许跨域资源访问，所以我们要设置OSS的跨域资源共享。


选择一个存储空间，打开其基础设置
点击跨越设置的设置按钮
[![](https://ae01.alicdn.com/kf/H000d4b6e5faa462e910f50bf36d1b8bca.png)](https://ae01.alicdn.com/kf/H000d4b6e5faa462e910f50bf36d1b8bca.png)
点击创建规则
进行跨域规则设置
[![](https://ae01.alicdn.com/kf/Hba8bd387ac084a40af8e424132675ffeO.png)](https://ae01.alicdn.com/kf/Hba8bd387ac084a40af8e424132675ffeO.png)



#服务端签名后前端直传的相关说明

流程示例图

[![](https://ae01.alicdn.com/kf/H82d39fd32f674bbab5c387d8f9eeded1o.png)](https://ae01.alicdn.com/kf/H82d39fd32f674bbab5c387d8f9eeded1o.png)

##流程介绍

 1.   客户发出Web前端请求应用服务器，获取上传所需参数（如OSS的accessKeyId、policy、callback等参数）
 2.   应用服务器返回响应，回应请求，返回相关参数
 3.   客户直接向OSS服务发起上传文件请求（发送文件了）
 4.   等上传完成后OSS服务回调应用服务器的回调接口（上传文件已经在服务器上了，现在是要回显上传文件，此时阿里云自带的OSS服务就调用回调接口，发送回显操作请求给应用服务器）
 5.   应用服务器返回响应给OSS服务（应用服务器响应请求，返回上传文件数据给OSS服务）
 6.   Oss服务将应用服务器回调接口的内容返回给Web前端（上传文件数据返回到前端回显）

#整合OSS实现文件上传

使用了别的应用程序服务，一定会有 连接该应用程序服务的配置， 自己本地程序匹配该应用程序服务的配置，把自己需求、应用程序服务、本地程序这3个联系起来的对象。

    就好像有一条河，两岸分别是应用程序服务和本地程序，我要建立一座桥把两岸联系起来，而这座桥就是需要自己写的代码了（这里就是那3个回调对象和封装对象，Controller和service），两岸的桥墩是配置（已经帮你写好的）。

当需要学习新的工具的时候要想到**相互渗透**

##在pom.xml中添加相关依赖


##修改SpringBoot配置文件

修改application.properties文件，增加OSS服务的设置（交给SpringBoot进行读取OSS服务）


##添加OSS的相关Java配置

用于配置OSS服务连接客户端OSSClient（就是本地代码与OSS交接数据的配置，具体调用在Service的实现类上，这里作为铺垫）


##添加OSS上传策略封装对象OssPolicyResult

前端直接上传文件时所需参数，从后端返回过来。获取OSS上传文件授权返回结果。


##添加OSS上传成功后的回调参数对象OssCallbackParam

当OSS上传成功后，会根据该配置参数来回调对应接口。

##OSS上传成功后的回调结果对象OssCallbackResult

回调接口中返回的数据对象，封装了上传文件的信息。

##添加OSS业务接口OssService

##添加OSS业务接口OssService的实现类OssServiceImpl

这里使用的是签名直传服务

桥路面就是这里的代码了。具体实现还是要复制粘贴，现在我是没有这个能力自己写的。
但是大概思路：

    创建目录
    创建签名有效期
    文件大小
    产生签名（这个签名包含了文件存储在OSS服务器的路径，这个路径是前面修改application.properties文件里的数据）
    
产生签名：（在阿里的帮助中心上写有的代码，直接COPY过来了）
    创建PolicyConditions对象---policyCond
    policyCond使用增加条件方法addConditionItem，给签名对象policyCond增加上传目录，允许上传的文件大小限制
    给policyConds添加过期时间并json序列化（格式iso8601:"yyyy-MM-dd‘T‘HH:mm:ss.fff‘Z‘"），最后生成postPolicy
    生成签名后的字符串signatrue
    根据postPolicy生成的字节数组binaryData
    根据binaryData生成签名policy
    
    最后给返回对象增加用户标识，上传的签名，签名后的字符串，上传文件的路径，OSS对外服务的访问域名。
    

总结：
    **使用OSS的上传，并不是创建文件，把客户的数据放进文件的过程，而是创建一个签名和存放目录过程，数据传输不知道被谁执行了。**
    回调也是在帮助中心上有代码，直接COPY过来就可以了。    

##添加OssController定义接口

Oss的接口管理




#参考：

https://www.jianshu.com/p/6aebdca025fc


前后端分离，解决跨域问题
https://www.jianshu.com/p/524a006a38c8

OSS的上传下载：
https://www.jianshu.com/p/978e206ab8fd
http://www.bubuko.com/infodetail-2074695.html（需要看的部分代码的注解）


https://juejin.im/post/5cff9944e51d4577555508a9#heading-8（作者参考）


跨域规则（这里没有意识到有这个跨域的问题，导致浪费很多时间）
https://help.aliyun.com/document_detail/91868.html?spm=a2c4g.11186623.2.15.2f1a7eaewqVIBn#h2-url-2

直传存在的坑：
https://blog.csdn.net/AloneAsFoam/article/details/77880475

无聊看一些论坛和网址突然悟到的东西：

我喜欢编程吗？

为什么在学习编程的过程中会出现阻碍自己学习的幻想？

喜欢赞美，但是赞美来的条件是什么？谁先谁后（联动周琦，韦神等）？


1   美国工业科技外流是二战后全球体制形成，美国利益竞争导致的
2   第3次工业科技已经下半场（从能源革命看现在还是处于第2次工业革命，目前工业革命的定义还是有差异，这是自己的判断。）
3   既然已经是下半场，中国从美国得到的科技是不能够把美国拉下第一科技国的宝座的，因为我们人太多了，必须保持一定的就业，不能出现美国铁锈带（可能出现，但是会控制）
4   城镇化---现在确定是不会出现从未到过美国而且想象中的美国那样的城镇化，中国是没有那么多资源的，不会像美国那样的生活。
5   现在中国就是经济滞胀，就是美国70年代出现的经济滞胀，所以会持续10年以上的经济危机舆论（房子看日本就行了，买不买是看个人能力的，这个时候只有中产以上才能玩投机，我们这样的底层就出卖劳动力就OK了。）
6   现在政府在农村做的就是防范突然经济崩溃导致失业潮，以及在走出经济滞胀后，产业升级后淘汰的人口流向地。
7   L型经济，为什么不说V型经济？L型的平直经济代表的是什么，就是滞胀啊，就是目前没有办法向上发展，维持平衡的经济。同时经济就是信心，这点很重要也很没有用。
8   什么时候走出L型经济？这是要看全球工业链中在中国下面的国家发展的怎么样，这个过程是非常漫长的，日本用了13年，不知道中国要用多少年，所以现在就是发展自己能力的时期，不能靠别人，只能靠自己的智力，因为我没有智囊团。
总结： 全球工业链，我们向上攀升，但是不能承接本国大部分的人口，所以出现城镇化的政策。
   **经济滞胀是重点。**
留给我们这些底层人还有多少时间呢？就是这段滞胀的时间，充实自己，提示自己的能力，不被产业升级淘汰。

	2019-09-07 12:22:42
kumika	项目复习3	#项目复习3
项目的要点是什么，怎么实现的

我想要的基本技术：
    上传，下载 ，缓存登录，注册 shiro的登录，再回头看看那些项目有什么技术点把
    
    上面完成后看JavaSE的基础，jdk集合类的一些源码一定要熟悉，spring 多线程同步异步死锁 java内存模型 

1.熟悉java c python
2.熟悉基本的数据结构，能编写基本的排序查询算法
3.熟悉操作系统和计算机组成原理，熟悉基本的linux指令
4.熟悉http协议 了解tcp/ip协议

-----------------------------------------------

快速写完这个，就看面试和算法还有Java基础（集合、线程、并发包、包装类和基本数据类型、接口、继承、抽象类、多态），git 使用，ssm、springboot（能解释 IOC、AOP。有实际项目更佳），MySQL 基本操作、懂一点点基本的 sql 优化（比如不要使用 select *）


redis, nginx, elasticsearch, shiro，springSecurity 这些都是中间件


参考：https://www.jianshu.com/p/3d91982ce458
http://how2j.cn/k/tmall_springboot/tmall_springboot-1795/1795.html#




现在是看这个mall项目我使用了什么技术，有哪些技术是初级技术的亮点。

技术（别人造的框架轮子）：
SpringBoot
SpringSecurity
MyBatis
MyBatisGenerator
PageHelper
Oss
JWT
Lombok


mall项目是一套电商系统，包括前台商城系统及后台管理系统，基于SpringBoot+MyBatis实现。 前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。 后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。


发现自己比较喜欢的模块，然后复盘。


#实现类：
不是有那个什么反射实现吗？那个可以作为亮点。
数据库的级联是一对一，嵌套是一对多。

负责商品推荐，商品搜索，商品展示，商品管理模块


创建商品，因为商品的属性是有来自不同表格的，所以可能需要多行代码完成一个属性值的填充。

先说原来的填充方法，然后再说现在项目用的。

##原来的填充方法（2种情况）：

商品的属性都是商品对象的属性，不是一个类的情况：

    创建 商品对象
    获取页面表单传入的属性值，然后赋值给商品属性，
    商品对象存入数据库，完成创建商品。

商品的属性是另外一类对象的情况：

    创建 商品对象
    获取页面表单传入的属性值，创建商品属性类的对象，然后赋值给这个对象，
    商品属性对象存入数据库，
    此时表单剩余的数据，都赋值给商品对象，
    商品对象存入数据库，完成创建商品。

##现在项目使用的方法：
使用反射，交给程序进行调用自己给定的方法名，然后进行调用该方法。

    创建一个 建立和插入 作用的方法，数据传入进来，输入参数就完成建立和插入操作。
    
    需要参数： 商品属性的Mapper或者Dao，表单数据列表dataList，商品id
    
    遍历dataList，使用根据方法名反射获取该方法名的Method方法对象，然后执行该方法名的方法对象的invoke方法，这里使用setId和setProductId这2个方法名完成反射获取方法对象，并且调用setId（）和setProduct()方法，完成反射调用对象，并且赋值。
    （这里的大概意思：根据反射，交给程序XXX方法名，程序就根据方法名去调用该方法，不需要我们new这个对象，然后再setXXX方法名）
    
    同样也是可以反射Mapper或者Dao的方法，使方法自动调用Mapper或者Dao的方法，这里调用的是插入insertList方法（就是使用insertList这个方法名）




卧槽发现都是一个模板的
springboot vue 商城
https://www.jianshu.com/p/a1f9cc5cbc3a


#面试要点

https://www.jianshu.com/p/c6112808c50f


#github

桌面上那个图标-----这是操作本地仓库的应用。
页面上那个github---这是操作云盘上仓库的应用。

##这里就写桌面上的应用

增加本地仓库（文件已经有.git后缀之类的文件成为仓库）
[![](https://ae01.alicdn.com/kf/H317578219075457b90b1ef70684936b53.jpg)](https://ae01.alicdn.com/kf/H317578219075457b90b1ef70684936b53.jpg)

创建本地仓库

[![](https://ae01.alicdn.com/kf/Heb1f767101c641cb894a589a769313ef6.jpg)](https://ae01.alicdn.com/kf/Heb1f767101c641cb894a589a769313ef6.jpg)

从云服务器上克隆仓库下来

[![](https://ae01.alicdn.com/kf/H439b987137f34b23aac7318d51099516v.jpg)](https://ae01.alicdn.com/kf/H439b987137f34b23aac7318d51099516v.jpg)

##想要与云服务器的仓库同步的操作：

提交
[![](https://ae01.alicdn.com/kf/H646fe0251dbe4518b4bcb4ac8ba5af9cG.jpg)](https://ae01.alicdn.com/kf/H646fe0251dbe4518b4bcb4ac8ba5af9cG.jpg)

同步（提交之后没有同步，按了同步按钮之后才是同步）
[![](https://ae01.alicdn.com/kf/Ha3fe3528250748619aa88399932249e5O.jpg)](https://ae01.alicdn.com/kf/Ha3fe3528250748619aa88399932249e5O.jpg)

	2019-09-11 13:25:11
kumika	复习项目--安全控制Shiro	# 复习项目--安全控制Shiro

这个项目来自SSMToProductionxixi


#shiro配置

一定要实现的配置：
---------


 **1. 添加jar包
 2. 配置web.xml（配置shiro过滤器，shiro和spring整合在一起了）
 3. 配置spring--shiro.xml**

缓存是在spring--shiro.xml里面配置的。


spring--shiro.xml这里面重点在**Realm，这是shiro这个大机器黑匣子所能给你操作的控制台。**

给你控制的是用户的验证`AuthenticationInfo`，用户的授权`AuthorizationInfo`


##验证

得到令牌token，然后根据方法`getPrincipal（）`拿到用户名
根据用户名，查询用户，返回用户对象
返回的用户对象，把它全部的属性赋值给新创建的用户身份信息对象

有关权限对象
根据用户id ，查询用户的权限，返回用户权限对象
返回的用户权限对象，把它全部的属性赋值给用户身份信息对象

将用户身份信息对象，用户密码，当前realm的名字，这3个参数创建一个简易验证信息对象`simpleAuthenticationInfo`

最后返回`simpleAuthenticationInfo`，完成验证。


这里我没有理清楚的就是有关权限的。
现在是根据用户名，查询数据库，返回的对象不为null，则是登录正确，根据返回对象给出的用户id，进行查询用户权限，返回用户使用权限对象。

其实就是一次次进行查询，才能获取用户的权限，用户全部的角色，**没有一次性全部查询到的情况，这个是对设计数据库的表格有非常高要求的**（有也不知道啊）。

当前情况就是你登录正确了，你想要权限列表/对象，好，根据你返回的对象id，再进行一次查询，对权限表进行查询，返回权限列表/对象，放入到`simpleAuthenticationInfo`，返回到页面再根据前端进行判断是否能进入某个网页。

拓展：
你想查看用户的角色，也是登录正确后，根据用户id，对用户角色表格进行查询，返回用户角色列表/对象，，放入到`simpleAuthenticationInfo`，返回到页面，根据前端的判断进行显示。



##授权

输入参考：PrincipalCollection principals

从`principals`获取主身份信息对象`ActiveUser`

根据对象`ActiveUser`，获取用户id

根据用户id，查询用户权限列表/对象，返回权限列表/对象`permissions`

`permissions`增加到`SimpleAuthorizationInfo`对象中

最后返回`SimpleAuthorizationInfo`对象，完成授权。


#总结：

验证，授权，这2个都是需要先获取正确的用户对象，再根据用户对象的信息，进行查询别的需求。
像权限，用户角色，都是需要用户id，才能查询到的。
返回的对象，增加到`SimpleAuthorizationInfo`对象，或者是`simpleAuthenticationInfo`对象

最后返回`SimpleAuthorizationInfo`对象，或者是`simpleAuthenticationInfo`对象，完成验证或者授权


#参考：

https://www.cnblogs.com/zhouguanglin/archive/2018/02/27/8477807.html

https://www.cnblogs.com/learnhow/p/5694876.html


这个项目的权限数据库
mall项目里面的


#数据库的表格

##制造管理的数据库
[![production-SSM.jpg](https://i.loli.net/2018/12/16/5c16524dd92a0.jpg)](https://i.loli.net/2018/12/16/5c16524dd92a0.jpg)

[![sys的外键联系.jpg](https://i.loli.net/2018/12/27/5c249ac3e3584.jpg)](https://i.loli.net/2018/12/27/5c249ac3e3584.jpg)

因为数据库表格设计的很简单，没有外键的存在，所以表格与表格之间的联系只能是数值一样才能查询，物理产品上的意思一致才可以查询

Realm使用的方法

授权：

查询菜单



     permissionsList = sysService.findMenuListByUserId(activeUser.getUserid());

        3张表，系统认证《======》系统用户权限《===》系统用户，表格之间是靠相同字段名进行连接查询的（不是靠外键），**都是使用in关键字** 进行查询（毕竟是id池子筛选）
        1   根据用户id，在系统用户表中查询系统角色id
        2   根据系统角色id，在系统用户权限表格中查询系统权限id
        3   根据系统权限id，在系统认证表中查询权限对象，筛选条件是type关键字为memu
        

验证：

查询用户对象

    sysUser = sysService.getSysUserByName(username);
    使用Criteria，增加查询条件完成查询---criteria.andUsernameEqualTo(username);

查询用户权限角色

    sysRole = roleService.findRoleByUserId(sysUser.getId());
    使用Criteria，增加查询条件完成查询---criteria.andSysUserIdEqualTo(userid);

查询菜单对象

    menus = sysService.findMenuListByUserId(sysUser.getId());



##mall的数据库

商品的数据库表格：
[![](https://ae01.alicdn.com/kf/H5f4193839d4746bc805a9c13dd46ef5ar.jpg)](https://ae01.alicdn.com/kf/H5f4193839d4746bc805a9c13dd46ef5ar.jpg)

	2019-09-18 12:11:21
kumika	Java基础复习--数据类型，基本语法	"#Java基础复习--数据类型，基本语法
基本的纲要
[![](https://ae01.alicdn.com/kf/Hc3df6c7d724e4b6286ec467d0f7ea31e1.jpg)](https://ae01.alicdn.com/kf/Hc3df6c7d724e4b6286ec467d0f7ea31e1.jpg)



#java的基础知识

#数据类型

##基本数据类型

8种类型，分4种整型，2种浮点类型 单一表示Unicode字符的char字符型，Boolean布尔类型

###整型

4种整型：

 1. Long
 2. Int
 3. Byte
 4. short

###浮点类型

 1. float
 2. double

##引用类型

任意对象，数组，类，接口


##区别

基本类型的变量是存放在栈区（栈区指内存里的栈内存）
[![](https://ae01.alicdn.com/kf/H4584759fb36f4fc98dc2fcf7410557e72.png)](https://ae01.alicdn.com/kf/H4584759fb36f4fc98dc2fcf7410557e72.png)


引用类型的值是同时保存在栈内存和堆内存的对象
[![](https://ae01.alicdn.com/kf/Hea6932c5c7d0452ba237e488f2ad5355u.png)](https://ae01.alicdn.com/kf/Hea6932c5c7d0452ba237e488f2ad5355u.png)


##对象引用

2个对象变量A,B
person  A = {}；//A保存了一个空对象的实例（地址）
person  B = A //A和B都指向了这个空对象。

A.name = "faker"；
B.age  = 23;

A.equals(B)

他们之间的关系：
[![](https://ae01.alicdn.com/kf/Hcd4e07b487d849bfadfeccfafbc9c02bv.png)](https://ae01.alicdn.com/kf/Hcd4e07b487d849bfadfeccfafbc9c02bv.png)
**引用类型的赋值其实是对象保存栈区地址指针的赋值，因此2个变量对象指向同一个对象，任何操作都会相互影响(Java是值传递)。**

###值传递和引用传递

值传递和引用传递，引出这个问题的是因为：
在参数赋值的时候，方法的参数类型上出现赋值问题
这是什么赋值问题？

    方法参数是形参，基本类型和对象（引用类型）作为形参是有区别的。

什么区别？

    基本类型的变量在创建的时候，栈内存传递的是数据本身的副本，也就是传递值（传递复制品）。引用类型的变量（对象）在创建的时候，栈内存传递的是该对象在堆内存的地址，也就是传递的是地址。


那为什么引用类型能改变数据内容，不是传递的是地址吗？

    因为规定了如果在函数中没有改变这个变量副本的地址，而是改变了地址中的值，那么在函数内的改变会影响到传入的参数。


图片解释：
左边2个框框都是在栈内存，右边框框是在堆内存

[![](https://ae01.alicdn.com/kf/H069ba8c098cf4f5f8ccaf4757da9f463F.jpg)](https://ae01.alicdn.com/kf/H069ba8c098cf4f5f8ccaf4757da9f463F.jpg)
[![](https://ae01.alicdn.com/kf/H4655522251324f19bfb428dfb725f437G.jpg)](https://ae01.alicdn.com/kf/H4655522251324f19bfb428dfb725f437G.jpg)
这个num都是在栈内存上的。
[![](https://ae01.alicdn.com/kf/H96321246b1a644bbbac08c39580fb0e9k.jpg)](https://ae01.alicdn.com/kf/H96321246b1a644bbbac08c39580fb0e9k.jpg)

这个`值传递	引用传递`问题其实是解决当方法参数有基本类型与引用类型，并且调用方法结束后还使用该基本类型变量的时候，出现的赋值问题。要清楚哪个类型是能改变





#基本语法

##基本运算

算术运算符
+，—，*，/，%余，++自加，--自减

关系运算符
<， >， >=， <=，== ，!=
逻辑运算符
非！，与&，或|，^异或,&& 与,|| 或

赋值运算符
= ，+=，-=，*=，/=

字符串连接运算符
+

##基本语句
###if语句
if
if ····else
if ····else if
if ····else if····else if ···else


###Switch语句
Switch(){
    case XXX :
                ····
    case XXX :
                ····
    default：
                ····
}
也可以加break语句


###循环语句

for

while

do····while


##函数（方法）
###函数定义
```
 1 public class TestMethod{
 2     public static void main(String args[]){
 3         m();
 4         m1(3);
 5         m2(2,3);
 6         int i = m3(4,5);
 7         System.out.println(i);
 8     }
 9     //以下定义的都是静态方法，静态方法可以在main()方法里面直接调用
10     public static void m(){
11             System.out.println("Hello!");
12             System.out.println("李相赫");
13         }
14         
15     public static void m1(int i){
16             if(i==5){
17                     return;
18                 }
19             System.out.println(i);
20         }
21         
22     public static void m2(int i,int j){
23             System.out.println(i+j);
24         }
25         
26     public static int m3(int i,int j){
27             return i+j;
28         }
29 }
```
方法执行到return语句后，这个方法的执行就结束了，**方法可以有返回值，但可以不用这个返回值**。方法首先要定义，然后才能调用。


###函数重载
在JAVA中，可以在同一个类中存在多个函数，函数名称相同但参数列表不同。这就是函数的重载（overlording）。

**重载的特征：**

    函数名和返回值类型完全一致。
    
    参数的数量不同、或数量相同而类型和次序不同，以方便JVM区分到底调用哪个函数。

```
public class TestOverLoad {

    void max(int a, int b) {
        System.out.println(a > b ? a : b);
    }

    /*
     * int max(int a, int b) { 
     *         return a > b ? a : b; 
     * }
     */

    void max(float a, float b) {
        System.out.println(a > b ? a : b);
    }
}
```
或者
```
int max(int a, int b) {
    System.out.println("调用的int max(int a, int b)方法");
    return a > b ? a : b;
}
     
int max(short a, short b) {
    System.out.println("调用的int max(short a, short b)方法");
    return a > b ? a : b;
}
```


重写Overriding

“重载”不同于“重写”

“重写（覆盖）”概念存在于继承关系中，子类可继承父类中的方法而不需要单独编辑，这提供便捷化。但有的时侯，子类不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。

父类中存在一个函数，子类中也存在一个同名函数，在了类中对函数重新编辑，做得更具体化。

重写的规则：

1、在子类中可以根据需要对从父类中继承来的方法进行重写。

2、重写的方法和被重写的方法必须具有相同方法名称、参数列表和返回类型。

3、重写方法不能使用比被重写的方法更严格的访问权限。


###函数调用
函数调用
```
public class Demo03{
    int age;
    public static void main(String []args){
        System.out.println(Demo04.name);//静态调用静态1
        Demo04.eat();

        Demo04 d = new Demo04();//静态调用静态2
        System.out.println(d.name);
        d.eat();

        Demo03 d1 = new Demo03();//静态调用非静态
        d1.method();
        System.out.println(d1.age);
    }
    public void method(){
        System.out.println("first method");
    }

}
public class Demo04{
    static String name = "张三";

    public static void eat(){
        System.out.println("肉夹馍");
    }
}

```




###递归函数

递归：**在一个方法内部对自身的调用就称为递归**

递归方法执行在内存中执行的过程如下图所示：
重点在继续执行的判断条件
[![](https://ae01.alicdn.com/kf/Haecd7f140b5f4769b3d9360d2e1e078aR.png)](https://ae01.alicdn.com/kf/Haecd7f140b5f4769b3d9360d2e1e078aR.png)

例子：
使用递归计算第5个斐波那契数列数
```
/*计算第5个斐波那契数列数*/
/*
斐波那契数列特点：f(1)=1,f(2)=1,f(3)=f(1)+f(2),f(4)=(f2)+(f3)……依次类推。
即后一个数都是等于前两个数的和，这样的数列就是斐波那契数列。
*/
/*
使用递归调用的方法计算
*/
public class Fab{
    public static void main(String args[]){
        System.out.println(f(5));
    }
    
    public static int f(int n){
            if(n==1||n==2){
                    return 1;
                }else{
                        return f(n-1)+f(n-2);
                    }
        }
}
```
整个在内存中执行过程如下图所示
[![](https://ae01.alicdn.com/kf/Habdbe761c8b940d6993346a1eba818fbN.png)](https://ae01.alicdn.com/kf/Habdbe761c8b940d6993346a1eba818fbN.png)

###程序的执行过程

[![](https://ae01.alicdn.com/kf/H4205ec3439f848b88d16297ef40a954fi.png)](https://ae01.alicdn.com/kf/H4205ec3439f848b88d16297ef40a954fi.png)



##数组

###创建
一维数组的声明方式有2种：

格式一：数组元素类型  数组名[ ];  即type var[ ];
格式二：数组元素类型[ ] 数组名; 即type[ ] var;
格式二声明数组的方法与C#上声明一维数组的方法一样。
例如：
       
       int a1[ ];   int[ ] a2;
       double b[ ];
       person[ ] p1;  String s1[ ];

注意：**JAVA语言中声明数组时不能指定其长度(数组中的元素个数)**

       如：int a[5]; 这样声明一维数组是非法的。


**创建数组对象：**
　JAVA中使用关键字new创建数组对象。

　格式为：数组名 = new 数组元素的类型[数组元素的个数]
例如：
[![](https://ae01.alicdn.com/kf/H2cc65d6ecb194e6f9ed033581a8055d6b.png)](https://ae01.alicdn.com/kf/H2cc65d6ecb194e6f9ed033581a8055d6b.png)
[![](https://ae01.alicdn.com/kf/H82a6c907dc334a5db492b53270bc27e4J.png)](https://ae01.alicdn.com/kf/H82a6c907dc334a5db492b53270bc27e4J.png)


动态的初始化
```
public class Test{
    public static void main(String args[ ]){
    int a[ ];  //定义数组，即声明一个int类型的数组a[ ]
    a=new int[3];  //给数组元素分配内存空间。
    a[0]=3; a[1]=9; a[2]=8;  //给数组元素赋值。
    Date days[ ];
    days=new Date[3];
    days[0]=new Date(1, 4, 2004);
    days[1]=new Date(2, 4, 2004);
    days[2]=new Date(3, 4, 2004);
    } 
}

class Date{
    int year, month, day;
    Date(int y, int m, int d){
        year = y ;
        month = m ;
        day = d ;
    }
}
```
数组的内存分配情况：
[![](https://ae01.alicdn.com/kf/H95afd28a3e364dffb1dcdf7a30000b3e3.png)](https://ae01.alicdn.com/kf/H95afd28a3e364dffb1dcdf7a30000b3e3.png)

###遍历
for循环
```
//遍历数组
public class ThroughTheArray{
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] arr = {12,4,1,66,54,6,74,-3};//静态创建一个数组
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + ",");
		}
	}
}
```
增强for循环foreach
```
//遍历数组
public class ThroughTheArray {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] arr = {12,4,1,66,54,6,74,-3};//静态创建一个数组
		for (int i : arr) {
			System.out.print(i + ",");
		}
	}
}
```
利用jdk自带的方法  --> java.util.Arrays.toString()
```
//遍历数组
public class ThroughTheArray {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] arr = {12,4,1,66,54,6,74,-3};//静态创建一个数组
		System.out.println(java.util.Arrays.toString(arr));
	}
}
```

###多维数组

 1. 一维数组：一维数组就是一行，一行小格。
 2. 二维数组：二维数组就是一行加一列组成的一个平面分成的小格，有行有列。
 3. 三维数组：三维数组就是一个立方体。

人类对最多认识到三维空间

理解JAVA中的各个维度的数组模型
[![](https://ae01.alicdn.com/kf/Hec13f3392ec243eea20b53d11251f7a81.png)](https://ae01.alicdn.com/kf/Hec13f3392ec243eea20b53d11251f7a81.png)

##异常
###异常分类
运行时异常

    Exception

它规定的异常是程序本身可以处理的异常。异常和错误的区别是，异常是可以被处理的，而错误是没法处理的。

编译时异常

    error

Error是错误，对于所有的编译时期的错误以及系统错误都是通过Error抛出的。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。


###异常处理

Java异常处理的五个关键字：try、catch、finally、throw、throws

#参考：

https://www.cnblogs.com/xdp-gacl/tag/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/default.html?page=2（总体知识框架参考的对象）


https://www.cnblogs.com/bobo-site/p/9306049.html（基本类型的堆栈）

https://mp.weixin.qq.com/s?__biz=MzAwNTM0ODY1Mg==&mid=2457116077&idx=1&sn=ea9c69e95fede0f7410d6b6f1889ae9e&chksm=8c9e31eebbe9b8f887e779de89e829abb37fefc3f792ffd69bec8fd5d441834e2beeaa8dff67&token=313878124&lang=zh_CN#rd（这是值传递与引用传递的区别）
"	2019-09-20 11:51:46
kumika	Java基础复习--面对对象	#Java基础复习--面对对象


#面对对象
面向对象的思维是，当我碰到这个问题域的时候，碰到这个程序的时候，我首先应该把这个问题里有哪些对象，对象与对象之间有什么关系抽象出来。

我实现这件事我第一步应该干什么，第二步应该干什么,那就是面向过程的思维了.

##类和对象

###属性和方法

```
/**
 * 一类事物封装到JAVA里面首先得写class，定义这个类，类名是什么可以自己取。
 * 这里把类名叫做Dog
 */
public class Dog {
    /**
     * 接下来就是写这个狗这个类的属性或者叫成员变量，
     * 比如说狗这个类的毛的颜色，怎么定义这个属性呢，
     * 首先得定义毛的一个类型,如使用int来定义毛的颜色类型
     */
    int furcolor; //定义属性：毛的颜色
    float height; //定义属性：狗的高度
    float weight; //定义属性：狗的体重
    
    /**
     * 狗的颜色，高度，体重这些属性定义完了，接下来要定义的就是方法了。
     * 如写一个CatchMouse（）方法，捉老鼠的方法。
     * CatchMouse这个方法里面有一个对象类型的参数，捉哪一只老鼠，这个对象参数是属于Mouse这个类的
     * @param m
     */
    void CatchMouse(Mouse m){
            //在方法体内写捉老鼠这个过程，怎么捉，跑着捉，走着捉
            System.out.println("我捉到老鼠了，汪汪！，老鼠要尖叫了！");
            /**
             * 老鼠尖叫一声，表示被狗咬到了，咬到了能不叫吗，很自然而然地想到，
             * 尖叫（scream()）这个方法是属于Mouse这个类里面的某一个方法。
             * 老鼠自己调用它，让它自己尖叫。这就是面向对象的思维。
             */
            m.scream();
    }
    
    public static void main(String[] args) {
        Dog  d = new Dog();//首先用new关键字创建一只狗
        Mouse m=new Mouse();//造出一只老鼠。
        d.CatchMouse(m);//然后用这只狗去抓老鼠，让狗调用CatchMouse()方法去捉某只老鼠。
    }
}
```


###封装

```
/**
 * 封装的老鼠类
 */
public class Mouse {
    /**
     * 老鼠自己有一个发出尖叫的方法
     * 当被狗咬到时就会发出尖叫
     */
    public void scream() {
        System.out.println("我被狗咬到了，好痛啊！");
    }

}
```

##构造方法
构造方法是用来创建一个新的对象的，与new组合在一起用，使用new+构造方法创建一个新的对象。
你new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法。

###定义

构造方法比较特殊，构造方法的名字必须和类的名字完全一模一样，包括大小写，并且没有返回值。如原来定义的一个person类，在类里面声明了两个成员变量id与age，这时候你可以再为这个person类定义一个它的构造方法person(int n，int i)，这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写。

```
public class Person {
    int id;  //在person这类里面定义两个成员变量id和age,
    int age=20;  //给成员变量age赋了初值为20

    /**这里就是person这个类的一个构造方法
     * 构造方法的规则很简单，和类名要完全一样，一点都不能错，包括大小写。
     * 并且没有返回值，不能写void在它前面修饰
     * @param _id
     * @param _age
     */
    public Person(int _id,int _age ) {
        id = _id;
        age = _age;
    }
}
```

构造方法写好后就和new组合在一起使用，new的作用是构建一个新对象，创造一个新对象，所以new的时候实际当中调用的是构造方法。只有调用了这个构造方法才能构造出一个新的对象。例如：
```
 public static void main(String[] args) {
     Person tom = new Person(1, 25); // 调用person这个构造方法创建一个新的对象，并给这个对象的成员变量赋初始值
}
```

[![](https://ae01.alicdn.com/kf/Hc021094f92de4fb5b00ede5a0feafc53U.png)](https://ae01.alicdn.com/kf/Hc021094f92de4fb5b00ede5a0feafc53U.png)

下面是在main方法里面调用person构造方法时的内存分析情况：
[![](https://ae01.alicdn.com/kf/H050c416c77cb40fd97e7e0336c3039c3m.png)](https://ae01.alicdn.com/kf/H050c416c77cb40fd97e7e0336c3039c3m.png)
[![](https://ae01.alicdn.com/kf/He70da7356ded47cbae8049231214b15cT.png)](https://ae01.alicdn.com/kf/He70da7356ded47cbae8049231214b15cT.png)

**当方法调用完成之后，栈里面为它分配的空间全部都要消失，即把这个方法调用时分配给它的内存空间释放出来**，所以这个构造方法person调用完成之后，栈内存里面分配的两小块内存_id和_age自动消失了。这样就把它们所占的空间让了出来，让其他的方法去占用。**而new出来的对象则永远留在了堆内存里面。**


###重载

同一个类中的2个或2个以上的方法可以一同一个名字，只是它们的参数不同即可，在这种情况下，该方法就被称为重载，这个过程称为方法重载。

**构造方法可以重载.**

###this关键字

this一般出现在方法里面，当这个方法还没有调用的时候，this指的是谁并不知道。但是实际当中，你如果new了一个对象出来，那么this指的就是当前这个对象。
对哪个对象调用方法，this指的就是调用方法的这个对象（你对哪个对象调用这个方法，this指的就是谁）。
如果再new一个对象，这个对象他也有自己的this，他自己的this就当然指的是他自己了。

个人理解：
        作为方法参数的this，指的是调用/包括这个方法的对象
        在方法内部语句的this，指的是该方法对象
        在方法return位置的this，指的是调用该方法的对象
        在类内部的this，指的是该类对象

###super关键字

在JAVA类中**使用super来引用父类的成分，用this来引用当前对象**，如果一个类从另外一个类继承，我们new这个子类的实例对象的时候，这个子类对象里面会有一个父类对象。怎么去引用里面的父类对象呢？使用super来引用，this指的是当前对象的引用，super是当前对象里面的父对象的引用。

```
/**
 * 父类
 * @author gacl
 *
 */
class FatherClass {
    public int value;
    public void f() {
        value=100;
        System.out.println("父类的value属性值="+value);
    }
}

/**
 * 子类ChildClass从父类FatherClass继承
 * @author gacl
 *
 */
class ChildClass extends FatherClass {
    /**
     * 子类除了继承父类所具有的valu属性外，自己又另外声明了一个value属性，
     * 也就是说，此时的子类拥有两个value属性。
     */
    public int value;
    /**
     * 在子类ChildClass里面重写了从父类继承下来的f()方法里面的实现，即重写了f()方法的方法体。
     */
    public void f() {
        super.f();//使用super作为父类对象的引用对象来调用父类对象里面的f()方法
        value=200;//这个value是子类自己定义的那个valu，不是从父类继承下来的那个value
        System.out.println("子类的value属性值="+value);
        System.out.println(value);//打印出来的是子类自定义的那个value的值，这个值是200
        /**
         * 打印出来的是父类里面的value值，由于子类在重写从父类继承下来的f()方法时，
         * 第一句话“super.f();”是让父类对象的引用对象调用父类对象的f()方法，
         * 即相当于是这个父类对象自己调用f()方法去改变自己的value属性的值，由0变了100。
         * 所以这里打印出来的value值是100。
         */
        System.out.println(super.value);
    }
}

/**
 * 测试类
 * @author gacl
 *
 */
public class TestInherit {
    public static void main(String[] args) {
        ChildClass cc = new ChildClass();
        cc.f();
    }
}
```
运行结果：
[![](https://ae01.alicdn.com/kf/He0697c21b6ab4f6997795f6a5d451eeen.png)](https://ae01.alicdn.com/kf/He0697c21b6ab4f6997795f6a5d451eeen.png)

**画内存分析图了解程序执行的整个过程:**
分析任何程序都是从main方法的第一句开始分析的，所以首先分析main方法里面的第一句话:

    ChlidClass cc = new ChlidClass();

程序执行到这里时，首先在栈空间里面会产生一个变量cc，cc里面的值是什么这不好说，总而言之，通过这个值我们可以找到new出来的ChlidClass对象。
由于子类ChlidClass是从父类FatherClass继承下来的，所以当我们new一个子类对象的时候，这个子类对象里面会包含有一个父类对象，而这个父类对象拥有他自身的属性value。
这个value成员变量在FatherClass类里面声明的时候并没有对他进行初始化，所以系统默认给它初始化为0，成员变量（在类里面声明）在声明时可以不给它初始化，编译器会自动给这个成员变量初始化，但局部变量（在方法里面声明）在声明时一定要给它初始化，因为编译器不会自动给局部变量初始化，任何变量在使用之前必须对它进行初始化。

子类在继承父类value属性的同时，自己也单独定义了一个value属性，所以当我们new出一个子类对象的时候，这个对象会有两个value属性，一个是从父类继承下来的value，另一个是自己的value。在子类里定义的成员变量value在声明时也没有给它初始化，所以编译器默认给它初始化为0。因此，执行完第一句话以后，系统内存的布局如下图所示：
[![](https://ae01.alicdn.com/kf/Hc90256e2424f4fbba961ba779084bdab2.png)](https://ae01.alicdn.com/kf/Hc90256e2424f4fbba961ba779084bdab2.png)

接下来执行第二句话：

    cc.f();

当new一个对象出来的时候，这个对象会产生一个this的引用，这个this引用指向对象自身。如果new出来的对象是一个子类对象的话，那么这个子类对象里面还会有一个super引用，这个super指向当前对象里面的父对象。所以相当于程序里面有一个this，this指向对象自己，还有一个super，super指向当前对象里面的父对象。

　　这里调用重写之后的f()方法，方法体内的第一句话：“super.f();”是让这个子类对象里面的父对象自己调用自己的f()方法去改变自己value属性的值，父对象通过指向他的引用super来调用自己的f()方法，所以执行完这一句以后，父对象里面的value的值变成了100。接着执行“value=200；”这里的vaule是子类对象自己声明的value，不是从父类继承下来的那个value。所以这句话执行完毕后，子类对象自己本身的value值变成了200。此时的内存布局如下图所示：
[![](https://ae01.alicdn.com/kf/H718e958e95ad467eb2027dc3cc79aecaR.png)](https://ae01.alicdn.com/kf/H718e958e95ad467eb2027dc3cc79aecaR.png)

方法体内的最后三句话都是执行打印value值的命令，前两句打印出来的是子类对象自己的那个value值，因此打印出来的结果为200，最后一句话打印的是这个子类对象里面的父类对象自己的value值，打印出来的结果为100。

　　到此，整个内存分析就结束了，最终内存显示的结果如上面所示。
　　
##继承

 - 子类拥有父类非 private 的属性、方法。
 - 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
 - 子类可以用自己的方式实现父类的方法。
 - Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C
   类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。
 - 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。


**继承关键字:**

    extends 关键字
    implements 关键字

###实现

公共父类：
```
public class Animal { 
    private String name;  
    private int id; 
    public Animal(String myName, int myid) { 
        name = myName; 
        id = myid;
    } 
    public void eat(){ 
        System.out.println(name+"正在吃"); 
    }
    public void sleep(){
        System.out.println(name+"正在睡");
    }
    public void introduction() { 
        System.out.println("大家好！我是"         + id + "号" + name + "."); 
    } 
}
```

企鹅类：
```
public class Penguin extends Animal { 
    public Penguin(String myName, int myid) { 
        super(myName, myid); 
    } 
}
```
老鼠类：
```
public class Mouse extends Animal { 
    public Mouse(String myName, int myid) { 
        super(myName, myid); 
    } 
}
```


###重写父类方法
方法的重写要遵循“两同两小一大”规则：

    “两同”即方法名相同、形参列表相同
    “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或更像等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
    “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或者相等。


例子：
父类：
```
public class Bird {
    //Bird 类的fly（）方法
    public void fly()
    {
        System.out.println("我在天空可劲的飞啊");
    }
}
```
子类：
```
public class Ostrich {
    // 重写Bird类的fly（）方法
    public void fly() {
        System.out.println("我能在地上可劲跑");
 
    }
 
    public static void main(String[] args) {
        // 创建Ostrich对象
        Ostrich os = new Ostrich();
        // 执行Ostrich对象的fly（）方法，将输出“我在地上可劲的跑”
        os.fly();
    }
}
```
结果输出：
我能在地上可劲跑



###抽象类
例子：
```
/**
 * 父类Animal
 * 在class的前面加上abstract，即声明成这样：abstract class Animal
 * 这样Animal类就成了一个抽象类了
 */
abstract class Animal {

    public String name;

    public Animal(String name) {
        this.name = name;
    }
    
    /**
     * 抽象方法
     * 这里只有方法的定义，没有方法的实现。
     */
    public abstract void enjoy(); 
    
}
```
Java语言规定，当一个类里面有抽象方法的时候，这个类必须被声明为抽象类。

　　子类继承父类时，如果这个父类里面有抽象方法，并且子类觉得可以去实现父类的所有抽象方法，那么子类必须去实现父类的所有抽象方法，如：
　　
```
/**
 * 子类Dog继承抽象类Animal，并且实现了抽象方法enjoy
 * @author gacl
 *
 */
class Dog extends Animal {
    /**
     * Dog类添加自己特有的属性
     */
    public String furColor;

    public Dog(String n, String c) {
        super(n);//调用父类Animal的构造方法
        this.furColor = c;
    }

    @Override
    public void enjoy() {
        System.out.println("狗叫....");
    }

}
```

这个父类里面的抽象方法，子类如果觉得实现不了，那么把就子类也声明成一个抽象类，如：
```
/**
 * 这里的子类Cat从抽象类Animal继承下来，自然也继承了Animal类里面声明的抽象方法enjoy()，
 * 但子类Cat觉得自己去实现这个enjoy()方法也不合适，因此它把它自己也声明成一个抽象的类，
 * 那么，谁去实现这个抽象的enjoy方法，谁继承了子类，那谁就去实现这个抽象方法enjoy()。
 * @author gacl
 *
 */
abstract class Cat extends Animal {

    /**
     * Cat添加自己独有的属性
     */
    public String eyeColor;

    public Cat(String n, String c) {
        super(n);//调用父类Animal的构造方法
        this.eyeColor = c;
    }
}
```
这里的子类Cat从抽象类Animal继承下来，自然也继承了Animal类里面声明的抽象方法enjoy()，但子类Cat觉得自己去实现这个enjoy()方法也不合适，因此它把它自己也声明成一个抽象的类，那么，谁去实现这个抽象的enjoy方法，谁继承了子类，那谁就去实现这个抽象方法enjoy()。如：

```
/**
 * 子类BlueCat继承抽象类Cat，并且实现了从父类Cat继承下来的抽象方法enjoy
 * @author gacl
 *
 */
class BlueCat extends Cat {

    public BlueCat(String n, String c) {
        super(n, c);
    }

    /**
     * 实现了抽象方法enjoy
     */
    @Override
    public void enjoy() {
        System.out.println("蓝猫叫...");
    }
    
}
```


###接口
接口的本质——接口是一种特殊的抽象类，这种抽象类里面只包含常量和方法的定义，而没有变量和方法的实现。
```
/**
 * java中定义接口
 */
public interface JavaInterfaces {

}
```


接口(interface)是一种特殊的抽象类，在这种抽象类里面，所有的方法都是抽象方法，并且这个抽象类的属性（即成员变量）都是声明成“public static final 类型 属性名”这样的，默认也是声明成“public static final”即里面的成员变量都是公共的、静态的，不能改变的。


```
package javastudy.summary;

/**
 * 这里定义了接口：Painter。 在Painter接口里面定义了paint()和eat()这两个抽象方法。
 * 
 * @author gacl
 * 
 */
interface Painter {
    public void eat();

    public void paint();
}

/**
 * 这里定义了两个接口：Singer 在Singer接口里面定义了sing()和sleep()这两个抽象方法。
 * 
 * @author gacl
 * 
 */
interface Singer {
    public void sing();

    public void sleep();
}

/**
 * 类Student实现了Singer这个接口
 * 
 * @author gacl
 * 
 */
class Student implements Singer {

    private String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    /**
     * 实现接口中定义的sing方法
     */
    @Override
    public void sing() {
        System.out.println("student is singing");
    }

    /**
     * 实现接口中定义的sleep方法
     */
    @Override
    public void sleep() {
        System.out.println("student is sleeping");
    }

    public void study() {
        System.out.println("Studying...");
    }

}

/**
 * Teacher这个类实现了两个接口：Singer和Painter。 这里Teacher这个类通过实现两个不相关的接口而实现了多重继承。
 * 
 * @author gacl
 * 
 */
class Teacher implements Singer, Painter {

    private String name;

    public Teacher(String name) {
        this.name = name;
    }

    /**
     * 在Teacher类里面重写了这两个接口里面的抽象方法，
     * 通过重写抽象方法实现了这两个接口里面的抽象方法。
     */
    @Override
    public void eat() {
        System.out.println("teacher is eating");
    }

    public String getName() {
        return name;
    }

    @Override
    public void paint() {
        System.out.println("teacher is painting");
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public void sing() {
        System.out.println("teacher is singing");
    }

    @Override
    public void sleep() {
        System.out.println("teacher is sleeping");
    }

    public void teach() {
        System.out.println("teaching...");
    }
}

public class TestInterfaces {

    public static void main(String[] args) {
        /**
         * 这里定义了一个接口类型的变量s1
         */
        Singer s1 = new Student("le");
        s1.sing();
        s1.sleep();
        Singer s2 = new Teacher("steven");
        s2.sing();
        s2.sleep();
        Painter p1 = (Painter)s2;
        p1.paint();
        p1.eat();
    }
}
```
这里验证了两个规则，**“一个类可以实现多个无关的接口”**，Teacher类既实现了Singer接口，同时也实现了Painter接口，而Singer接口和Painter接口是无关系的两个接口。**“多个无关的类可以实现同一接口”**，Student类和Teacher类都实现了Singer接口，而Student类和Teacher类并不是关系很密切的两个类，可以说是无关的两个类。



接口更进一步的特性

```
package javastudy.summary;

/**
 * 把“值钱的东西”这个类定义成一个接口Valuable。在接口里面定义了一个抽象方法getMoney()
 * @author gacl
 *
 */
interface Valuable {
    public double getMoney();
}

/**
 * 把“应该受到保护的东西”这个类定义成一个接口Protectable。
 * 在接口里面定义了一个抽象方法beProtected();
 * @author gacl
 *
 */
interface Protectable {
    public void beProteced();
}

/**
 * 这里是接口与接口之间的继承，接口A继承了接口Protectable，
 * 因此自然而然地继承了接口Protectable里面的抽象方法beProtected()。
 * 因此某一类去实现接口A时，除了要实现接口A里面定义的抽象方法m()以外，
 * 还要实现接口A从它的父接口继承下来的抽象方法beProtected()。
 * 只有把这两个抽象方法都实现了才算是实现了接口A。
 * @author gacl
 *
 */
interface A extends Protectable {
    void m();
}

/**
 * 这里定义了一个抽象类Animal。
 * @author gacl
 *
 */
abstract class Animal {
    private String name;
    /**
     * 在Animal类里面声明了一个抽象方法enjoy()
     */
    abstract void enjoy();
}

/**
 * 这里是为了实现了我们原来的语义：
 * “金丝猴是一种动物”同时“他也是一种值钱的东西”同时“他也是应该受到保护的东西”。而定义的一个类GoldenMonKey。
 * 为了实现上面的语义，这里把“值钱的东西”这个类定义成了一个接口Valuable，
 * 把“应该受到保护的东西”这个类也定义成了一个接口Protectable。这样就可以实现多继承了。
 * GoldenMonKey类首先从Animal类继承，然后GoldenMonKey类再去实现Valuable接口和Protectable接口，
 * 这样就可以实现GoldenMonKey类同时从Animal类，Valuable类，Protectable类继承了，即实现了多重继承，
 * 实现了原来的语义。
 * @author gacl
 *
 */
class GoldenMonKey extends Animal implements Valuable,Protectable {

    /**
     * 在GoldenMoKey类里面重写了接口Protectable里面的beProtected()这个抽象方法，
     * 实现了接口Protectable。
     */
    @Override
    public void beProteced() {
        System.out.println("live in the Room");
    }

    /**
     * 在GoldenMoKey类里面重写了接口Valuable里面的getMoney()这个抽象方法，实现了接口Valuable。
     */
    @Override
    public double getMoney() {
        return 10000;
    }

    /**
     * 这里重写了从抽象类Animal继承下来的抽象方法enjoy()。
     * 实现了这抽象方法，不过这里是空实现，空实现也是一种实现。
     */
    @Override
    void enjoy() {
        
    }
    
    public static void test() {
        /**
         * 实际当中在内存里面我们new的是金丝猴，在金丝猴里面有很多的方法，
         * 但是接口的引用对象v能看到的就只有在接口Valuable里面声明的getMoney()方法，
         * 因此可以使用v.getMoney()来调用方法。而别的方法v都看不到，自然也调用不到了。
         */
        Valuable v = new GoldenMonKey();
        System.out.println(v.getMoney());
        /**
         * 把v强制转换成p，相当于换了一个窗口，通过这个窗口只能看得到接口Protectable里面的beProtected()方法
         */
        Protectable p = (Protectable)v;
        p.beProteced();
    } 
}

/**
 * 这里让Hen类去实现接口A，接口A又是从接口Protectable继承而来，接口A自己又定义了一个抽象方法m()，
 * 所以此时相当于接口A里面有两个抽象方法：m()和beProtected()。
 * 因此Hen类要去实现接口A，就要重写A里面的两个抽象方法，实现了这两个抽象方法后才算是实现了接口A。
 * @author gacl
 *
 */
class Hen implements A {

    @Override
    public void beProteced() {
        
    }

    @Override
    public void m() {
        
    }
    
}

/**
 * java中定义接口
 */
public class JavaInterfacesTest {

    public static void main(String[] args) {
        GoldenMonKey.test();
    }
}
```



接口总结：接口和接口之间可以相互继承，类和类之间可以相互继承，类和接口之间，只能是类来实现接口。


##多态

动态绑定，也叫多态


###实现与应用

```
package javastudy.summary;

class Animal {
    /**
     * 声明一个私有的成员变量name。
     */
    private String name;

    /**
     * 在Animal类自定义的构造方法
     * @param name
     */
    Animal(String name) {
        this.name = name;
    }

    /**
     * 在Animal类里面自定义一个方法enjoy
     */
    public void enjoy() {
        System.out.println("动物的叫声……");
    }
}

/**
 * 子类Cat从父类Animal继承下来，Cat类拥有了Animal类所有的属性和方法。
 * @author gacl
 *
 */
class Cat extends Animal {
    /**
     * 在子类Cat里面定义自己的私有成员变量
     */
    private String eyesColor;

    /**
     * 在子类Cat里面定义Cat类的构造方法
     * @param n
     * @param c
     */
    Cat(String n, String c) {
        /**
         * 在构造方法的实现里面首先使用super调用父类Animal的构造方法Animal(String name)。
         * 把子类对象里面的父类对象先造出来。
         */
        super(n);
        eyesColor = c;
    }

    /**
     * 子类Cat对从父类Animal继承下来的enjoy方法不满意，在这里重写了enjoy方法。
     */
    public void enjoy() {
        System.out.println("我养的猫高兴地叫了一声……");
    }
}

/**
 * 子类Dog从父类Animal继承下来，Dog类拥有了Animal类所有的属性和方法。
 * @author gacl
 *
 */
class Dog extends Animal {
    /**
     * 在子类Dog里面定义自己的私有成员变量
     */
    private String furColor;

    /**
     * 在子类Dog里面定义Dog类的构造方法
     * @param n
     * @param c
     */
    Dog(String n, String c) {
        /**
         * 在构造方法的实现里面首先使用super调用父类Animal的构造方法Animal(String name)。
         * 把子类对象里面的父类对象先造出来。
         */
        super(n);
        furColor = c;
    }

    /**
     * 子类Dog对从父类Animal继承下来的enjoy方法不满意，在这里重写了enjoy方法。
     */
    public void enjoy() {
        System.out.println("我养的狗高兴地叫了一声……");
    }
}

/**
 * 子类Bird从父类Animal继承下来，Bird类拥有Animal类所有的属性和方法
 * @author gacl
 *
 */
class Bird extends Animal {
    /**
     * 在子类Bird里面定义Bird类的构造方法
     */
    Bird() {
        /**
         * 在构造方法的实现里面首先使用super调用父类Animal的构造方法Animal(String name)。
         * 把子类对象里面的父类对象先造出来。
         */
        super("bird");
    }

    /**
     * 子类Bird对从父类Animal继承下来的enjoy方法不满意，在这里重写了enjoy方法。
     */
    public void enjoy() {
        System.out.println("我养的鸟高兴地叫了一声……");
    }
}

/**
 * 定义一个类Lady(女士)
 * @author gacl
 *
 */
class Lady {
    /**
     * 定义Lady类的私有成员变量name和pet
     */
    private String name;
    private Animal pet;

    /**
     * 在Lady类里面定义自己的构造方法Lady()，
     * 这个构造方法有两个参数，分别为String类型的name和Animal类型的pet，
     * 这里的第二个参数设置成Animal类型可以给我们的程序带来最大的灵活性，
     * 因为作为养宠物来说，可以养猫，养狗，养鸟，只要是你喜欢的都可以养，
     * 因此把它设置为父类对象的引用最为灵活。
     * 因为这个Animal类型的参数是父类对象的引用类型，因此当我们传参数的时候，
     * 可以把这个父类的子类对象传过去，即传Dog、Cat和Bird等都可以。
     * @param name
     * @param pet
     */
    Lady(String name, Animal pet) {
        this.name = name;
        this.pet = pet;
    }

    /**
     * 在Lady类里面自定义一个方法myPetEnjoy()
     * 方法体内是让Lady对象养的宠物自己调用自己的enjoy()方法发出自己的叫声。
     */
    public void myPetEnjoy() {
        pet.enjoy();
    }
}

public class TestPolymoph {
    public static void main(String args[]) {
        /**
         * 在堆内存里面new了一只蓝猫对象出来，这个蓝猫对象里面包含有一个父类对象Animal。
         */
        Cat c = new Cat("Catname", "blue");
        /**
         * 在堆内存里面new了一只黑狗对象出来，这个黑狗对象里面包含有一个父类对象Animal。
         */
        Dog d = new Dog("Dogname", "black");
        /**
         * 在堆内存里面new了一只小鸟对象出来，这个小鸟对象里面包含有一个父类对象Animal。
         */
        Bird b = new Bird();

        /**
         * 在堆内存里面new出来3个小姑娘，名字分别是l1，l2，l3。
         * l1养了一只宠物是c(Cat)，l2养了一只宠物是d(Dog)，l3养了一只宠物是b(Bird)。
         * 注意：调用Lady类的构造方法时，传递过来的c，d，b是当成Animal来传递的，
         * 因此使用c，d，b这三个引用对象只能访问父类Animal里面的enjoy()方法。
         */
        Lady l1 = new Lady("l1", c);
        Lady l2 = new Lady("l2", d);
        Lady l3 = new Lady("l3", b);
        /**
         * 这三个小姑娘都调用myPetEnjoy()方法使自己养的宠物高兴地叫起来。
         */
        l1.myPetEnjoy();
        l2.myPetEnjoy();
        l3.myPetEnjoy();
    }
}
```
运行结果：

    我养的猫高兴地叫了一声
    我养的狗高兴地叫了一声
    我养的鸟高兴地叫了一声


**内存图理解动态绑定（多态）**
首先从main方法的第一句话开始分析：

    Cat c = new Cat("Catname","blue");

当Cat(String n,String c)构造方法调用结束后，真真正正在堆内存里面new出了一只Cat，这只Cat里面包含有父类对象Animal，这个Animal对象有自己的属性name，name属性的值为调用父类构造方法时传递过来的字符串Catname。除此之外，这只Cat还有自己的私有成员变量eyesColor，eyesColor属性的属性值为调用子类构造方法时传递过来的字符串blue。所以执行完这句话以后，内存中的布局是栈内存里面有一个引用c，c指向堆内存里面new出来的一只Cat，而这只Cat对象里面又包含有父类对象Animal，Animal对象有自己的属性name，属性值为Catname，Cat除了拥有从Animal类继承下来的name属性外，还拥有一个自己私有的属性eyesColor，属性值为blue。这就是执行完第一句话以后整个内存布局的情况如下图所示：

[![](https://ae01.alicdn.com/kf/Hba26121d6e054bb9890cdab366ad77714.png)](https://ae01.alicdn.com/kf/Hba26121d6e054bb9890cdab366ad77714.png)

接着看这句话：

    Lady l1 = new Lady(“l1”,c);


[![](https://ae01.alicdn.com/kf/Hf425ca3e75d44260b7c65658eeced670c.png)](https://ae01.alicdn.com/kf/Hf425ca3e75d44260b7c65658eeced670c.png)

主要理解：
        在Cat对象里面的animal类对象的方法，在经过cat类重写后，animal类方法的地址就指向cat类方法的地址（方法的地址被改变了），这样才能**实现动态绑定，实现父类指向子类对象，使程序的可扩展性达到了最好**


**动态绑定（多态）这种机制能帮助我们做到这一点——让程序的可扩展性达到极致。因此动态绑定是面向对象的核心，如果没有动态绑定，那么面向对象绝对不可能发展得像现在这么流行，所以动态绑定是面向对象核心中的核心。**

####总结动态绑定（多态）：
-----------

动态绑定是指在“执行期间”（而非编译期间）判断所引用的实际对象类型，根据其实际的类型调用其相应的方法。所以实际当中找要调用的方法时是动态的去找的，new的是谁就找谁的方法，这就叫动态绑定。动态绑定帮助我们的程序的可扩展性达到了极致。

多态的存在有三个必要的条件：

 1. 要有继承（两个类之间存在继承关系，子类继承父类）
 2. 要有重写（在子类里面重写从父类继承下来的方法）
 3. 父类引用指向子类对象

　　这三个条件一旦满足，当你调用父类里面被重写的方法的时候，实际当中new的是哪个子类对象，就调用子类对象的方法（这个方法是从父类继承下来后重写后的方法）。

###类型转换

**父类引用指向子类对象的时候，它看到的只是作为父类的那部分所拥有的属性和方法，至于作为子类的那部分它没有看到。**

```
package javastudy.summary;

/**
 * 父类Animal
 * @author gacl
 *
 */
class Animal {

    public String name;

    public Animal(String name) {
        this.name = name;
    }
}

/**
 * 子类Cat继承Animal
 * @author gacl
 *
 */
class Cat extends Animal {

    /**
     * Cat添加自己独有的属性
     */
    public String eyeColor;

    public Cat(String n, String c) {
        super(n);//调用父类Animal的构造方法
        this.eyeColor = c;
    }
}

/**
 * 子类Dog继承Animal
 * @author gacl
 *
 */
class Dog extends Animal {
    /**
     * Dog类添加自己特有的属性
     */
    public String furColor;

    public Dog(String n, String c) {
        super(n);//调用父类Animal的构造方法
        this.furColor = c;
    }

}

/**
 * 下面是这三个类的测试程序
 * @author gacl
 *
 */
public class TestClassCast {

    /**
     * @param args
     */
    public static void main(String[] args) {

        Animal a = new Animal("name");
        Cat c = new Cat("catname","blue");
        Dog d = new Dog("dogname", "black");
        /**
         * a instanceof Animal这句话的意思是a是一只动物吗？
         * a是Animal这个类里面的是一个实例对象，所以a当然是一只动物，其结果为true。
         */
        System.out.println(String.format("a instanceof Animal的结果是%s",a instanceof Animal));//true
        /**
         * c是Cat类的实例对象的引用，即c代表的就是这个实例对象，
         * 所以“c是一只动物”打印出来的结果也是true。
         * d也一样，所以“d是一只动物”打印出来的结果也是true。
         */
        System.out.println(String.format("c instanceof Animal的结果是%s",c instanceof Animal));//true
        System.out.println(String.format("d instanceof Animal的结果是%s",d instanceof Animal));//true
        /**
         * 这里判断说“动物是一只猫”，不符合逻辑，所以打印出来的结果是false。
         */
        System.out.println(String.format("a instanceof Cat的结果是%s",a instanceof Cat));
        /**
         * 这句话比较有意思了，a本身是Animal类的实例对象的引用，
         * 但现在这个引用不指向Animal类的实例对象了，而是指向了Dog这个类的一个实例对象了，
         * 这里也就是父类对象的引用指向了子类的一个实例对象。
         */
        a = new Dog("bigyellow", "yellow");
        System.out.println(a.name);//bigyellow
        /**
         * 这里的furColor属性是子类在继承父类的基础上新增加的一个属性，是父类没有的。
         * 因此这里使用父类的引用对象a去访问子类对象里面新增加的成员变量是不允许的，
         * 因为在编译器眼里，你a就是Animal类对象的一个引用对象，你只能去访问Animal类对象里面所具有的name属性，
         * 除了Animal类里面的属性可以访问以外，其它类里面的成员变量a都没办法访问。
         * 这里furColor属性是Dog类里面的属性，因此你一个Animal类的引用是无法去访问Dog类里面的成员变量的，
         * 尽管你a指向的是子类Dog的一个实例对象，但因为子类Dog从父类Animal继承下来，
         * 所以new出一个子类对象的时候，这个子类对象里面会包含有一个父类对象，
         * 因此这个a指向的正是这个子类对象里面的父类对象，因此尽管a是指向Dog类对象的一个引用，
         * 但是在编译器眼里你a就是只是一个Animal类的引用对象，你a就是只能访问Animal类里面所具有的成员变量，
         * 别的你都访问不了。
         * 因此一个父类(基类)对象的引用是不可以访问其子类对象新增加的成员(属性和方法)的。
         */
        //System.out.println(a.furColor);
        System.out.println(String.format("a指向了Dog，a instanceof Animal的结果是%s",a instanceof Animal));//true
        /**
         * 这里判断说“a是一只Dog”是true。
         * 因为instanceof探索的是实际当中你整个对象到底是什么东西，
         * 并不是根据你的引用把对象看出什么样来判断的。
         */
        System.out.println(String.format("a instanceof Dog的结果是%s",a instanceof Dog));//true
        /**
         * 这里使用强制转换，把指向Animal类的引用对象a转型成指向Dog类对象的引用，
         * 这样转型后的引用对象d1就可以直接访问Dog类对象里面的新增的成员了。
         */
        Dog d1 = (Dog)a;
        System.out.println(d1.furColor);//yellow
    }

}
```

##关键字

###public/private/protected

[![](https://ae01.alicdn.com/kf/H28215b1142e64a998e7eb451998dc765u.jpg)](https://ae01.alicdn.com/kf/H28215b1142e64a998e7eb451998dc765u.jpg)

访问的权限：

    private 在本类
    
    protect 在本类   同一个包    继承类
    
    public  在本类   同一个包    继承类    其他类


###final

 - 修饰变量

凡是对成员变量或者局部变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。

final修饰基本数据类型的变量时，必须赋予初始值且不能被改变，修饰引用变量时，该引用变量不能再指向其他对象

 - 修饰方法

final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。

 - 修饰类

使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。

###static

[![](https://ae01.alicdn.com/kf/Hff1c068095db4f90bad8f6a20a3bb3afD.png)](https://ae01.alicdn.com/kf/Hff1c068095db4f90bad8f6a20a3bb3afD.png)
	2019-09-21 19:32:03
kumika	Java基础复习--集合类	"#Java基础复习--集合类



#集合类

 1. 集合类存放于java.util包中。
 2. 集合类存放的都是对象的引用，而非对象本身，出于表达上的便利，我们称集合中的对象就是指集合中对象的引用（reference)。
 3. 集合类型主要有3种：set(集）、list(列表）和map(映射)。
 4. 集合接口分为：Collection和Map，list、set实现了Collection接口

##Collection接口

List特点：
        
        元素有序；元素可以重复；元素都有索引（角标）。
List里存放的对象是有序的，同时也是可以重复的。
        List关注的是索引，拥有一系列和索引相关的方法，查询速度快， **因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所以插入和删除数据速度慢。**


Set特点：

    元素无序；元素不可以重复； 

Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。


Map特点：

    键值对；键不可以重复；值可以重复； 
    

Map集合中存储的是键值对，**键不能重复，值可以重复。**
根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。


###Iterator迭代器

Iterator是一个接口，作用是   **取**  集合中的元素，是一个**Collection系通用的取出元素的方法**。

**List系和Set系的对象里都有这个Iterator对象**。
比如arrayList的源码：
[![](https://ae01.alicdn.com/kf/He7d32f52860b4a3a82ea767aa4c0ce4fq.jpg)](https://ae01.alicdn.com/kf/He7d32f52860b4a3a82ea767aa4c0ce4fq.jpg)

Iterator重要的3个方法：

 - **hasNext()**

如果仍有元素可以迭代，则返回True

 - **next()**

返回迭代的下一个元素

 - **remove()**

从迭代器指向的collection中移除迭代器返回的最后一个元素

例子
```
    public static void main(String[] args) {
        Collection coo = new ArrayList();

        coo.add("adb");
        coo.add("adb2");
        coo.add("adb3");
        coo.add("adb4");
        coo.add("adb5");

        for (Iterator it = coo.iterator(); it.hasNext();) {
            System.out.println(it.next());
        }
    }
```


###List接口
总的特点：

**有序集合，允许相同元素和null**


####ArrayList

**非同步，允许相同元素和null，实现了动态大小的数组，遍历效率高，用的多**

```
//例子
    ArrayList<Integer> arrayList = new ArrayList<>();
    arrayList.add(1);
    arrayList.add(2);
    arrayList.add(1);
    arrayList.add(3);
    arrayList.add(2);
    arrayList.add(3);
 
    arrayList = new ArrayList<>(new HashSet<>(arrayList));
 
    for (int i=0;i<arrayList.size();i++){
        printlns("arrayList ["+ i +"] = "+arrayList.get(i));
    }
```
运行结果

    arrayList [0] = 1
    arrayList [1] = 2
    arrayList [2] = 3


####LinkedList

**非同步，允许相同元素和null，遍历效率低插入和删除效率高**

这个例子是和ArrayList比较插入数据时间
```
  public static void addTest(){

        //批量插入，每次都向首位插入数据；

        LinkedList linkedList = new LinkedList();

        long time1 = new Date().getTime();

        for(int m=0;m<300000;m++){
            linkedList.add(0,null);
        }

        long time2 = new Date().getTime();

        System.out.print("linkedList批量插入时间:"+(time2 - time1)+"ms\n");




        ArrayList arraylist = new ArrayList();

        long time3 = new Date().getTime();

        for(int n=0;n<300000;n++){
            arraylist.add(0, null);
        }

        long time4 = new Date().getTime();
        System.out.print("arrayList批量插入时间:"+(time4 - time3)+"ms\n");

    }
```
结果：

**linkedList批量插入时间:9ms
arrayList批量插入时间:3696ms**


####ArrayList和LinkList的使用

**Q：什么时候使用Arraylist，什么时候使用LinkedList？**
A：当你需要频繁查询数组的时候使用ArrayList比较快，当你需要频繁操作数组进行增删插入操作的时候使用LinkList比较合适。当然直接在末尾添加数据ArrayList用时也不是特别多，因为在末尾操作后面没有数据。

**Q：那什么时候适合用list呢**
A：涉及到“栈”、“队列”、“链表”等操作，应该考虑用List，具体的选择哪个List，根据下面的标准来取舍

对于需要快速插入，删除元素，应该使用LinkedList。
对于需要快速随机访问元素，应该使用ArrayList。
对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类(如ArrayList)。
对于“多线程环境，且List可能同时被多个线程操作”，此时，应该使用同步的类(如Vector)。
**Q：线程安全的数组，什么是线程安全？**
A：线程安全就是当前资源只能被单独一个线程访问，也就是加同步锁的线程。默认的线程安全的list是Vector；




###Set接口

总的特点：

**不允许相同元素，最多有一个null元素**

####TreeSet

TreeSet是一个**有排序功能，且没有重复元素**的集合，**通过TreeMap实现**。

TreeSet的构造函数都是通过新建一个TreeMap作为实际存储Set元素的容器。因此得出结论: TreeSet的底层实际使用的存储容器就是TreeMap。
对于TreeMap而言，它采用一种被称为”红黑树”的排序二叉树来保存Map中每个Entry。每个Entry被当成”红黑树”的一个节点来对待。


TreeSet中含有一个"NavigableMap类型的成员变量"m，而m实际上是"TreeMap的实例"。


例子：
让元素自身具备比较排序功能，具备比较排序功能的元素只需要实现Comparable 接口。覆盖接口中CompareTo方法
```
public class TreeSetDemo {
 
	/**
	 * @param args
	 */
	public static void main(String[] args) {
 
		demo1();
	}
 
 
 
	/**
	 * 
	 */
	public static void demo1() {
		TreeSet ts = new TreeSet();
		
		ts.add("abc");
		ts.add("zaa");
		ts.add("aa");
		ts.add("nba");
		ts.add("cba");
		
		Iterator it = ts.iterator();
		
		while(it.hasNext()){
			System.out.println(it.next());
		}
	}
 
}
```
输出结果：

    aa
    abc
    cba
    nba
    zaa


####HashSet
**无序集合，不允许相同元素，最多有一个null元素**

例子：
2种方法遍历 
用Iterator来遍历
for循环遍历
```
package cn.java.text.Main;
import java.util.*;
public class Main4 {//HashSet
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner ip = new Scanner(System.in);
        HashSet<String> hashSet = new HashSet<String>();
        int i;
        String aString;
        for(i = 0; i < 6; i++) {
        	aString = ip.next();
        	hashSet.add(aString);//加入列表
        }
        Iterator<String> iterator = hashSet.iterator();//遍历器
        while(iterator.hasNext())System.out.print(iterator.next()+" ");//判断是否有，有就输出
        String bString;
        bString =  ip.next();
        hashSet.remove(bString);//删除
        /*Iterator iterator2 = hashSet.iterator();
        while(iterator2.hasNext()) {//遍历器遍历
        	System.out.print(iterator2.next()+"  ");
        
        }*/
        for(String string: hashSet)System.out.print(string + " ");//for循环遍历
 
	}
 
}
```
结果：

    aa KK ff tt ff kk
    aa kk ff tt kk
    aa ff tt



###HashSet/TreeSet与HashMap/TreeMap之间的联系

[![](https://ae01.alicdn.com/kf/H9aadabf1ed184624bfc2b2efb8556d29H.jpg)](https://ae01.alicdn.com/kf/H9aadabf1ed184624bfc2b2efb8556d29H.jpg)

[![](https://ae01.alicdn.com/kf/H70d59821495c4109bc847bcb09c8071a1.jpg)](https://ae01.alicdn.com/kf/H70d59821495c4109bc847bcb09c8071a1.jpg)

Set内部干脆就放了一个map！
HashSet和TreeSet内部的很多方法实现，就是简单的调用了HashMap/TreeMap的方法

##Map接口

**没有实现collection接口，key不能重复，value可以重复，一个key映射一个value**

Map特点：
键值对；键不可以重复；值可以重复； Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。

###TreeMap

**TreeMap是有序的,底层是红黑树,使用Comparator或者Comparable来比较key是否相等与排序的问题~**

因为没有学过红黑树，所以这里就敷衍的过去吧。

例子：
```
TreeMap<Integer, Integer> treeMap = new TreeMap<>();

    treeMap.put(1, 5);
    treeMap.put(2, 4);
    treeMap.put(3, 3);
    treeMap.put(4, 2);
    treeMap.put(5, 1);

    for (Entry<Integer, Integer> entry : treeMap.entrySet()) {

        String s = entry.getKey() +"大海，湖，河流" + entry.getValue();

        System.out.println(s);
    }
```


###HashMap
**实现Map接口，非同步，允许null作为key和value，用的多**

HashMap的方法有：

常用的方法有

    put(key,value),
    get(key),
    size(),
    containKey(key),
    containValue(value).


例子：
```
public class Main {
   public static void main(String[] args) {
      HashMap< String, String> hMap = 
      new HashMap< String, String>();
      hMap.put("1", "1st");
      hMap.put("2", "2nd");
      hMap.put("3", "3rd");
      Collection cl = hMap.values();
      Iterator itr = cl.iterator();
      while (itr.hasNext()) {
         System.out.println(itr.next());
     }
   }
}
```
结果：

    1st
    2nd
    3rd


另外的例子：
都是常用的方法

```
package map.Test;
 
import java.util.Collection;
import java.util.HashMap;
import java.util.Set;
 
public class HashMapDemo {
 
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<String, String>();
        // 键不能重复，值可以重复
        map.put("san", "张三");
        map.put("si", "李四");
        map.put("wu", "王五");
        map.put("wang", "老王");
        map.put("wang", "老王2");// 老王被覆盖
        map.put("lao", "老王");
        System.out.println("-------直接输出hashmap:-------");
        System.out.println(map);
        /**
         * 遍历HashMap
         */
        // 1.获取Map中的所有键
        System.out.println("-------foreach获取Map中所有的键:------");
        Set<String> keys = map.keySet();
        for (String key : keys) {
            System.out.print(key+"  ");
        }
        System.out.println();//换行
        // 2.获取Map中所有值
        System.out.println("-------foreach获取Map中所有的值:------");
        Collection<String> values = map.values();
        for (String value : values) {
            System.out.print(value+"  ");
        }
        System.out.println();//换行
        // 3.得到key的值的同时得到key所对应的值
        System.out.println("-------得到key的值的同时得到key所对应的值:-------");
        Set<String> keys2 = map.keySet();
        for (String key : keys2) {
            System.out.print(key + "：" + map.get(key)+"   ");
 
        }
        /**
         * 另外一种不常用的遍历方式
         */
        // 当我调用put(key,value)方法的时候，首先会把key和value封装到
        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取
        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来
        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了
        Set<java.util.Map.Entry<String, String>> entrys = map.entrySet();
        for (java.util.Map.Entry<String, String> entry : entrys) {
            System.out.println(entry.getKey() + "--" + entry.getValue());
        }
        
        /**
         * HashMap其他常用方法
         */
        System.out.println("after map.size()："+map.size());
        System.out.println("after map.isEmpty()："+map.isEmpty());
        System.out.println(map.remove("san"));
        System.out.println("after map.remove()："+map);
        System.out.println("after map.get(si)："+map.get("si"));
        System.out.println("after map.containsKey(si)："+map.containsKey("si"));
        System.out.println("after containsValue(李四)："+map.containsValue("李四"));
        //map.replace是jdk1.8方法
        System.out.println(map.replace("si", "李四2"));
        System.out.println("after map.replace(si, 李四2):"+map);
    }
 
}
```

###HashMap的put()源码浅析
[![](https://ae01.alicdn.com/kf/Hbe262020d3174f3ba4945f14b080582do.jpg)](https://ae01.alicdn.com/kf/Hbe262020d3174f3ba4945f14b080582do.jpg)

个人的理解：
    这段源码就只是告诉你
    
    哈希表是  **数组 + 链表**  组成的，2合1的结构表格
    Put的过程是把key放如数组 ，value放入链表的过程
    

这里面的判断语句，个人觉得有些累赘，有用但是麻烦。

#数组和集合都有哪些区别？
**数组特点：** 

    1. 数组本质上就是一段连续的内存空间，用于记录多个类型相同的数据； 
    2. 数据一旦声明完毕，则内存空间固定不变； 
    3. 插入和删除操作不方便，可能会移动大量的元素并导致效率太低； 
    4. 支持下标访问，可以实现随机访问； 
    5. 数组中的元素可以是基本数据类型，也可以使用引用数据类型。

**集合特点：** 

    1. 内存空间可以不连续，数据类型可以不相同； 
    2. 集合的内存空间可以动态的调整； 
    3. 集合的插入删除操作可以不移动大量元素； 
    4. 部分支持下标访问，部分不支持； 
    5. 集合中的元素必须是引用数据类型(你存储的是简单的int，它会自动装箱成Integer)；

可以看出数组和集合在数据的存储，访问，类型，长度等都有不同的地方。


#简单总结

##Collection系

[![](https://ae01.alicdn.com/kf/H376ab3e106d941a68f39f7e2f8345dfa9.jpg)](https://ae01.alicdn.com/kf/H376ab3e106d941a68f39f7e2f8345dfa9.jpg)


List接口：(允许有重复元素)
    

 - **ArrayList**:（查询多的情况下使用）
    底层数据结构： 数组Object[]    
    常用方法： **查询Get,遍历iterator，修改Set**
 - **LinkedList**：（增删多的情况下使用）
    底层数据结构： 环形双向链表
    常用方法： 增加add，删除remove



Set接口：（不允许有重复元素，保持唯一性）

 - **HashSet**
    底层数据结构： HashMap    


 - **TreeSet**
    底层数据结构：TreeMap


##Map系

[![](https://ae01.alicdn.com/kf/He8580339ffe04465a965683992449202h.jpg)](https://ae01.alicdn.com/kf/He8580339ffe04465a965683992449202h.jpg)


 - **HashMap**
    底层数据结构： 链表 + 数组 = 哈希表（元素是链表的数组）
    常用方法： **put(xxx,xxx) ,  get(XXX), remove(XXX);**

 - **TreeMap**
    底层数据结构：红黑树
    **可以实现按Key排序**

---------------------------------------
XJB不知道从哪里抄来的有点B用的总结
```
    /**
     *  数组和集合，都是干装载数据这工作，为什么集合就那么火啊？
     *
     *  答：
     *          差别在数组和集合的长度上。
     *          不同点：
     *                  1 长度的区别
     *                      集合的长度是可以增加，而且是自动扩容的
     *                      数组的长度是固定的
     *
     *                  2 内容不同
     *                      集合可以装不同类型的数据（一般不会）
     *                      数组一定是同一类型的元素
     *
     *                  3  数据的基本类型
     *                      集合只能装载 引用类型
     *                      数组可以装载 引用类型，也可以装载 基本类型
     *
     *           数组是手动增加容量，集合是自动增加容量，这样集合比数组方便，方便这点是最重要的。
     */
     
     
        /**
     *             集合就是容器，容器可以是茶壶，杯子等，那么杯子，茶壶等容器最重要的2个作用就是存，取
     *             所以，学习集合的时候就是要学习3个特点
     *                     集合它如何    存    数据（Collection体系用add() ，Map体系用put()）
     *                         它如何    取    数据（迭代器Iterator，增强for，List系还有普通for和ListIterator）
     *                         容器特点造成的一些问题
     */ 
```

写代码的重要思想：
```
    /**
     * 写代码：
     *          1       明确需求。 我要做什么？
     *          2       分析思路。 我要做什么？ 1，2，3.
     *          3       确定步骤。 每一个思路部分用到哪些语句，方法，对象。
     *          4       代码实现。 用具体的Java语言代码把思路体现出来。
     *
     *
     * 学习新技术的4点：
     *          1，该技术是什么？
     *          2，该技术有什么特点（使用注意）
     *          3，该技术怎么使用。demo
     *          4，该技术什么时候用？ test
     */
```



#参考：

https://zhuanlan.zhihu.com/p/60374460（大体参考知识框架）


https://blog.csdn.net/weixin_42139757/article/details/82108515(arrayList和LinkList的比较)

https://www.jianshu.com/p/12f4dbdbc652（treeSet）
https://blog.csdn.net/zhanshixiang/article/details/82492872（TreeSet的例子)


https://www.jianshu.com/p/e11fe1760a3d(treeMap)
https://zhuanlan.zhihu.com/p/35598760(treeMap)
https://blog.csdn.net/cyywxy/article/details/81151104（TreeMap和红黑树的解析）


https://zhuanlan.zhihu.com/p/21673805(HashMap)
https://www.cnblogs.com/weiziqiang/p/8947134.html(HashMap结构方法)
https://blog.csdn.net/qq_40374604/article/details/83057061（hashMap的例子)


https://zhuanlan.zhihu.com/p/36791608（上）
https://zhuanlan.zhihu.com/p/36797326（下，深入的理解HashSet和HashMap的区别）


https://www.cnblogs.com/java-zhao/p/5112542.html（小简单总结）

https://www.cnblogs.com/java-zhao/p/5112542.html（总结参考）
https://www.cnblogs.com/java-zhao/p/5101695.html（总结参考）
"	2019-09-23 16:56:25
kumika	Java基础复习--I/O流	#Java基础复习--I/O流



#输入/输出
俄罗斯套娃，把这类输入输出作为一个娃娃对象

##文件

###创建

**构造文件：**

**File(String pathname)：**通过给定 **路径名字符串** 转换为 **抽象路径名** 来创建一个新 File 实例

特点：windows中的路径或文件名**不区分大小写**，但是最好别这样，**跨平台**可能会出现问题

**File(String parent, String child)**：根据 parent **路径名字符串** 和 child **路径名字符串**，创建一个新 File 实例

    好处: 单独操作父路径和子路径

File(File parent, String child)：根据 parent **抽象路径名** 和 child **路径名字符串**，创建一个 File 实例

    好处: 父路径是File类型,父路径可以直接调用File类方法

```
public class Test {
    public static void main(String[] args) {
        /*
        * File(String pathname)
        * 传递路径名: 可以写到文件夹,可以写到一个文件
        */
        File file = new File("f:\\a.txt");
        System.out.println(file);

        /*
        * File(String parent, String child)
        * 传递字符串父路径,字符串子路径
        */
        File file = new File("f:\\", "a.txt");
        System.out.println(file);

        /*
        * File(File parent, String child)
        * 传递传递File类型父路径,字符串子路径
        */
        File parent = new File("f:");//带不带"\\"都可以
        File file = new File(parent, "a.txt");
        System.out.println(file);
    }
}
```



**创建单/多级功能：**
public boolean createNewFile()：**创建文件，如果文件已存在，不再创建**
public boolean mkdir()：**创建单级文件夹，如果文件夹已存在，不再创建**
public boolean mkdirs()：**创建多级文件夹，文件夹已经存在了,不在创建**

    mkdirs() 也可以创建单级文件夹，所以推荐使用 mkdirs()

例子：
```
public class TestFile {    
    public static void main(String[] args) throws Exception {  
        File f1 = new File("E://aaa//bbb");  
        if (!f1.exists()) {  
            f1.mkdirs();  
        }  
        // f1.mkdirs(); 生成所有目录  
        // f1.mkdir(); 必须AAA目录存在才能生成BBB目录  
  
        File f2 = new File("E://aaa//bbb//c.txt");  
        if (!file.exists()) {  
            // 不能生成目录，只能创建文件，且/aaa/bbb目录必须存在  
            file.createNewFile();  
        }  
    }          
}   
```

###读写

读写的方法就是下面写的那些read，writer

1、按字节读取文件内容
2、按字符读取文件内容
3、按行读取文件内容
4、随机读取文件内容 

我原本以为文件file类是有自己的读写方法的，实际上是根本没有，有也是能否对这个文件进行读写的判断方法。
所以读写都是file类以外的类进行执行的，比如：字节流，字符流。

###删除

public boolean delete()： **删除文件或者文件夹，不走回收站，直接从硬盘删除！**
如果此路径名表示一个目录，则该目录 必须为空 才能删除。

```
//创建文件夹
File f = new File("C:/a/b/c");
f.mkdirs();  //可以递归创建文件夹，如果没有s则不行

//创建文件
File f1 = new File("C:/a/b/c/123.txt");
f1.createNewFile();

//删除文件
f1.delete();

```

boolean deleteOnExit():
文件使用完成后删除

###重命名
**public boolean renameTo(File dest)**

重新命名此抽象路径名表示的文件。
此方法行为的许多方面都是与平台有关的：重命名操作无法将一个文件从一个文件系统移动到另一个文件系统，dest为新命名的抽象文件
例子：
```
public boolean ReName(String path,String newname) {//文件重命名
        //Scanner scanner=new Scanner(System.in);
        File file=new File(path);
        if(file.exists()) {
        File newfile=new File(file.getParent()+File.separator+newname);//创建新名字的抽象文件
        if(file.renameTo(newfile)) {
            System.out.println("重命名成功！"); 
            return true;
        }
        else {
            System.out.println("重命名失败！新文件名已存在");
            return false;
        }
        }
        else {
            System.out.println("重命名文件不存在！");
            return false;
        }
    
    }
```
#I/O流

Output操作：把内存中的数据存储到持久化设备上这个动作称为输出（写）
Input操作：把持久设备上的数据读取到内存中的这个动作称为输入（读）
流的分类：

    流按流向分为两种：
            输出流：内存——>外设（写出数据）
            输入流：磁盘——>内存（读入数据）
    流按操作类型分为两种：
            字节流：字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的
            字符流：字符流只能操作纯字符数据，比较方便。


**字节流的抽象父类：InputStream ，OutputStream
字符流的抽象父类：Reader ， Writer**

个人理解：
**流向是以内存为主视角**，

    数据从内存流出，为输出流
    数据向内存流入，为输入流


##字节流

字节流和字符流的区别：
      **区别就是字节流不需要缓冲区且可以不关闭流，而字符流需要缓冲区且需要关闭流。**

①、为什么要使用字符流？

　　因为使用字节流操作汉字或特殊符号语言的时候容易乱码，因为汉字不止一个字节，为了解决这个问题，建议使用字符流。

②、什么情况下使用字符流？

　　一般可以用记事本打开的文件，我们可以看到内容不乱码的。就是文本文件，可以使用字符流。而操作二进制文件（比如图片、音频、视频）必须使用字节流


[![](https://ae01.alicdn.com/kf/Hf90498a6e1da438bb102cc9ea788e243H.jpg)](https://ae01.alicdn.com/kf/Hf90498a6e1da438bb102cc9ea788e243H.jpg)

[![](https://ae01.alicdn.com/kf/H2744c462f8e24620a07ea125e7e4aef1I.jpg)](https://ae01.alicdn.com/kf/H2744c462f8e24620a07ea125e7e4aef1I.jpg)


###普通字节流

####InputStream类
核心方法：
abstract int read()：读取一个字节

    read()方法的特点：read() 执行一次，就会自动读取下一个字节，返回值是读取到的字节, 读取到结尾返回 -1

```
public class IoDemo {
    public static void main(String[] args) throws IOException {
        //创建字节输入流的子类对象
        FileInputStream fis = new FileInputStream("E:\\a.txt"); //ABCD
        //读取一个字节，调用read方法，返回int
        //使用循环方式，读取文件，循环结束的条件：read() 返回 -1
        int len = 0; //接收read()的返回值
        while((len = fis.read()) != -1){
            System.out.print((char)len); //可以转换成字符
        }
        //关闭资源
        fis.close();
    }
}
```

**int read(byte[] b)：**读取**一定数量**的字节，并将其存储在缓冲区**数组** b 中
**int read(byte[] b, int off, int len) ：**读取**最多 len 个字节**，存入 byte 数组。
byte **数组的作用**：缓冲的作用, 提高效率 
read 返回的 int，表示**读取到多少个有效的字节数**
```
public class IoDemo {
    public static void main(String[] args) throws IOException {
        //创建字节输入流的子类对象
        FileInputStream fis = new FileInputStream("E:\\a.txt"); 
        //创建字节数组
        byte[] b = new byte[1024];

        int len = 0;
        while((len = fis.read(b)) != -1){
            System.out.print(new String(b,0,len)); //使用String的构造方法，转为字符串
        }
        //关闭资源
        fis.close();
    }
}
```

####OutputStream类
核心方法:
**void close():** 关闭此输出流并释放与此流有关的所有系统资源。

    close的常规协定：该方法将关闭输出流。关闭的流不能执行输出操作，也不能重新打开。 
    如果流对象建立失败了,需要关闭资源吗？ 
    new 对象的时候，失败了，没有占用系统资源；释放资源的时候,对流对象判断null，变量不是null,对象建立成功，需要关闭资源

**write(byte[] b)：** 将 b.length 个字节从指定的 byte 数组写入此输出流

**write(byte[] b, int off, int len)：**将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。

**write(int b)：** 将指定的字节写入此输出流。
**write 的常规协定：**向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。

###文件字节流

####FileInputStream类

    public class FileInputStream extends InputStream

**FileInPutStream类继承InPutStream类**

构造方法：

**FileInputStream(File file)
FileInputStream(String name)**

流对象 绑定数据源

**输入流读取文件的步骤：**
创建字节输入流的子类对象
调用读取方法 **read** 读取
关闭资源

读取数据的方式：

    一次读取一个字节数据
    一次读取一个字节数组

例子：
读取单个字节
```
public class Copy {
    public static void main(String[] args) {
        long s = System.currentTimeMillis();
        //定义两个流的对象变量
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try{
            //建立两个流的对象,绑定数据源和数据目的
            fis = new FileInputStream("D:\\test.mp3"); //8,003,733 字节
            fos = new FileOutputStream("d:\\test.mp3");
            //字节输入流,读取1个字节,输出流写1个字节
            int len = 0 ;
            while((len = fis.read())!=-1){
                fos.write(len);
            }
        }catch(IOException e){
            System.out.println(e);
            throw new RuntimeException("文件复制失败");
        }finally{
            try{
                if(fos!=null)
                    fos.close();
            }catch(IOException e){
                throw new RuntimeException("释放资源失败");
            }finally{
                try{
                    if(fis!=null)
                        fis.close();
                }catch(IOException e){
                    throw new RuntimeException("释放资源失败");            
               }
            }
        }
        long e = System.currentTimeMillis();
        System.out.println(e-s);
    }
}
//耗时：61817                    
```

读取字节数组
```
public class Copy_1 {
    public static void main(String[] args) {
        long s = System.currentTimeMillis();
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try{
            fis = new FileInputStream("D:\\test.mp3");
            fos = new FileOutputStream("E:\\test.mp3");
            //定义字节数组,缓冲
            byte[] bytes = new byte[1024*10];
            //读取数组,写入数组
            int len = 0 ;
            while((len = fis.read(bytes))!=-1){
                fos.write(bytes, 0, len);
            }
        }catch(IOException e){
            System.out.println(e);
            throw new RuntimeException("文件复制失败");
        }finally{
            try{
                if(fos!=null)
                    fos.close();
            }catch(IOException e){
                throw new RuntimeException("释放资源失败");
            }finally{
                try{
                    if(fis!=null)
                        fis.close();
                }catch(IOException e){
                    throw new RuntimeException("释放资源失败");
                }
            }
        }   
        long e = System.currentTimeMillis();
        System.out.println(e-s);
    }
}
//耗时：41        
```


####FileOutputStream类

    public class FileOutputStream extends OutputStream

**FileOutPutStream类继承OutPutStream类**

构造方法：
**FileOutputStream(File file) ：**创建一个向指定 File 对象表示的文件中写入数据的文件输出流。
**FileOutputStream(File file, boolean append)：** 创建一个向指定 File 对象表示的文件中写入数据的文件输出流，以追加的方式写入。
**FileOutputStream(String name) ：**创建一个向具有指定名称的文件中写入数据的输出文件流。
**FileOutputStream(String name, boolean append) ：**创建一个向具有指定 name 的文件中写入数据的输出文件流，以追加的方式写入。

```
//实现追加写入：
FileOutputStream fos = new FileOutputStream(file, true);
```

流对象的使用步骤：

     创建流子类的对象,绑定数据目的
     调用流对象的方法write写
     close释放资源

注意事项：流对象的构造方法,可以创建文件，如果文件存在，直接覆盖

```
public class IoDemo {
    public static void main(String[] args) throws IOException {
        //创建流子类的对象,绑定数据目的
        FileOutputStream fos = new FileOutputStream("E:\\a.txt");
        //用write方法写数据
        //写一个字节
        fos.write(100); //d

        //写字节数组
        byte[] bytes = {65,66,67,68}; //ABCD
        fos.write(bytes);

        //写字节的一部分,开始索引，写几个
        fos.write(bytes,1,1); //B
        
        //写入字节数组的简便方式
        //写字符串
        fos.write("Hello".getBytes());
        //关闭资源
        fos.close();
    }
}
```


###带缓冲的字节流

可提高IO流的读写速度
分为字节缓冲流与字符缓冲流



####BufferedInputStream类

    public class BufferedInputStream extends FilterInputStream

BufferedInPutStream类继承**FilterInPutStream**类,不是继承**FileInPutStream**类，注意类名。

标准的**字节输入流**
方法:

    read()
    read(byte[] b, int off, int len)

构造方法：
BufferedInputStream(InputStream in)：可以传递任意的字节输入流，传递是谁，就提高谁的效率
BufferedInputStream(InputStream in, int size)

**可以传递的字节输入流 FileInputStream**

例子：
```
public class BufferedInputStreamDemo {
    public static void main(String[] args) throws IOException{
        //创建字节输入流的缓冲流对象,构造方法中包装字节输入流,包装文件
        BufferedInputStream bis = new
                BufferedInputStream(new FileInputStream("c:\\buffer.txt"));
        byte[] bytes = new byte[1024];
        int len = 0 ;
        while((len = bis.read(bytes))!=-1){
            System.out.print(new String(bytes,0,len));
        }
        bis.close();
    }
}
```


####BufferedOutputStream类

    public class BufferedOutputStream extends FilterOutputStream

BufferedOutPutStream类继承**FilterOutPutStream**类,不是继承**FileOutPutStream**类，注意类名。


**作用: 提高原有输出流的写入效率**
方法：

    write(int b)
    write(byte[] b, int off, int len)

构造方法：
**BufferedOuputStream(OuputStream out)：**可以传递任意的字节输出流，传递的是哪个字节流，就对哪个字节流提高效率

例子:
```
public class BufferedOutputStreamDemo {
    public static void main(String[] args)throws IOException {
        //创建字节输出流,绑定文件
        //FileOutputStream fos = new FileOutputStream("c:\\buffer.txt");

        //创建字节输出流缓冲流的对象,构造方法中,传递字节输出流
        BufferedOutputStream bos = new
                BufferedOutputStream(new FileOutputStream("c:\\buffer.txt"));

        bos.write(55);
        byte[] bytes = "HelloWorld".getBytes();
        bos.write(bytes);
        bos.write(bytes, 3, 2);

        bos.close();
    }
}
```

###四种文件复制方式的效率比较
结论：
字节流读写单个字节 ：125250 毫秒
字节流读写字节数组 ：193 毫秒
字节流缓冲区流读写单个字节：1210 毫秒
字节流缓冲区流读写字节数组 ：73 毫秒
代码
```
public class Copy {
    public static void main(String[] args)throws IOException {
        long s = System.currentTimeMillis();
        copy_4(new File("c:\\q.exe"), new File("d:\\q.exe"));
        long e = System.currentTimeMillis();
        System.out.println(e-s);
    }
    /*
     * 方法,实现文件复制
     *  4. 字节流缓冲区流读写字节数组
     */
    public static void copy_4(File src,File desc)throws IOException{
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(desc));
        int len = 0 ;
        byte[] bytes = new byte[1024];
        while((len = bis.read(bytes))!=-1){
            bos.write(bytes,0,len);
        }
        bos.close();
        bis.close();
    }
    /*
     * 方法,实现文件复制
     *  3. 字节流缓冲区流读写单个字节
     */
    public static void copy_3(File src,File desc)throws IOException{
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(desc));
        int len = 0 ;
        while((len = bis.read())!=-1){
            bos.write(len);
        }
        bos.close();
        bis.close();
    }

    /*
     * 方法,实现文件复制
     *  2. 字节流读写字节数组
     */
    public static void copy_2(File src,File desc)throws IOException{
        FileInputStream fis = new FileInputStream(src);
        FileOutputStream fos = new FileOutputStream(desc);
        int len = 0 ;
        byte[] bytes = new byte[1024];
        while((len = fis.read(bytes))!=-1){
            fos.write(bytes,0,len);
        }
        fos.close();
        fis.close();
    }

    /*
     * 方法,实现文件复制
     *  1. 字节流读写单个字节
     */
    public static void copy_1(File src,File desc)throws IOException{
        FileInputStream fis = new FileInputStream(src);
        FileOutputStream fos = new FileOutputStream(desc);
        int len = 0 ;
        while((len = fis.read())!=-1){
            fos.write(len);
        }
        fos.close();
        fis.close();
    }
}
```

##字符流

[![](https://ae01.alicdn.com/kf/H83d94f3870af4908a5cf5e636d4413cao.jpg)](https://ae01.alicdn.com/kf/H83d94f3870af4908a5cf5e636d4413cao.jpg)

[![](https://ae01.alicdn.com/kf/H4d46cb5e776349449f29a77414006008t.jpg)](https://ae01.alicdn.com/kf/H4d46cb5e776349449f29a77414006008t.jpg)

###普通字符流

####Reader抽象类

    public abstract class Reader
    extends Object
    implements Readable, Closeable

专门读取文本文件
方法介绍：
int read()： 读取单个字符
int read(char[] cbuf)：将字符读入数组
abstract int read(char[] cbuf, int off, int len) ：将字符读入数组的某一部分

**没有读取字符串的方法**



####Writer抽象类

    public abstract class Writer
    extends Object
    implements Appendable, Closeable, Flushable


写文件，写 文本文件

常用方法：
void write(int c)：写入单个字符
void write(String str) ：写入字符串
void write(String str, int off, int len)：写入字符串的某一部分
void write(char[] cbuf)：写入字符数组
abstract void write(char[] cbuf, int off, int len) ：写入字符数组的某一部分



###文件字符流

####FileReader类

    public class FileReader extends InputStreamReader

Reader类 是抽象类，找到子类对象 FileReader
构造方法：

    FileReader(File file)
    FileReader(String fileName)

写入的数据目的。绑定数据源。参数也是 File 类型对象 和 String 文件名。

例子：
```
public class ReaderDemo {
    public static void main(String[] args) throws IOException{
        FileReader fr = new FileReader("c:\\1.txt");
        //读字符
        /*int len = 0 ;
        while((len = fr.read())!=-1){
            System.out.print((char)len);
        }*/

        //读数组
        char[] ch = new char[1024];
        int len = 0 ;
        while((len = fr.read(ch))!=-1){
            System.out.print(new String(ch,0,len)); //转字符串
        }
        fr.close();
    }
}
```

#####flush 方法和 close 方法区别
flush()方法：用来刷新缓冲区的，刷新后可以再次写出，只有字符流才需要刷新 
close()方法：用来关闭流释放资源的的，如果是带缓冲区的流对象的close()方法，不但会关闭流，还会再关闭流之前刷新缓冲区，关闭后不能再写出



####FileWriter类

    public class FileWriter extends InputStreamWriter

Writer 类是抽象类，找到子类对象 FileWriter
构造方法：

    FileWriter(File file)
    FileWriter(String fileName)

参数也是 File 类型对象 和 String 文件名。
字符输出流，写数据的时候，**必须要运行**一个功能，**刷新功能：flush()**

```
public class WriterDemo {
    public static void main(String[] args) throws IOException{
        FileWriter fw = new FileWriter("c:\\1.txt");

        //写1个字符
        fw.write(100);
        fw.flush();

        //写1个字符数组
        char[] c = {'a','b','c','d','e'};
        fw.write(c);
        fw.flush();
        
        //写字符数组一部分
        fw.write(c, 2, 2);
        fw.flush();

        //写如字符串
        fw.write("hello");
        fw.flush();

        fw.close();
    }
}
```

**字符流复制文本文件**

字符流复制文本文件，必须是文本文件
字符流查询本机默认的编码表，简体中文GBK
FileReader 读取数据源
FileWriter 写入到数据目的

```
//读取字符数组
public class Copy_2 {
    public static void main(String[] args) {
        FileReader fr = null;
        FileWriter fw = null;
        try{
            fr = new FileReader("c:\\1.txt");
            fw = new FileWriter("d:\\1.txt");
            char[] cbuf = new char[1024];
            int len = 0 ;
            while(( len = fr.read(cbuf))!=-1){
                fw.write(cbuf, 0, len);
                fw.flush();
            }

        }catch(IOException ex){
            System.out.println(ex);
           throw new RuntimeException("复制失败");
        }finally{
            try{
                if(fw!=null)
                    fw.close();
            }catch(IOException ex){
                throw new RuntimeException("释放资源失败");
            }finally{
                try{
                    if(fr!=null)
                        fr.close();
                }catch(IOException ex){
                    throw new RuntimeException("释放资源失败");
                }
            }
        }
    }
}            
```



###带缓冲的字符流

####BufferedReader类

从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取
读取方法： read()， 单个字符,字符数组
构造方法：**BufferedReader(Reader r)**：可以任意的字符输入流，有：**FileReaderInputStreamReader**

例子：
```
public class BufferedReaderDemo {
    public static void main(String[] args) throws IOException {
        int lineNumber = 0;
        //创建字符输入流缓冲流对象,构造方法传递字符输入流,包装数据源文件
        BufferedReader bfr = new BufferedReader(new FileReader("c:\\a.txt"));
        //调用缓冲流的方法 readLine()读取文本行
        //循环读取文本行, 结束条件 readLine()返回null
        String line = null;
        while((line = bfr.readLine())!=null){
            lineNumber++;
            System.out.println(lineNumber+"  "+line);
        }
        bfr.close();
    }
}
```


####BufferedWriter类

写入方法： write () ，单个字符,字符数组,字符串
构造方法：
**BufferedWriter(Writer w)**：传递任意字符输出流，传递谁，就高效谁

能传递的字符输出流： FileWriter, OutputStreamWriter

例子：
```
public class BufferedWrierDemo {
    public static void main(String[] args) throws IOException{
        //创建字符输出流,封装文件
        FileWriter fw = new FileWriter("c:\\buffer.txt");
        BufferedWriter bfw = new BufferedWriter(fw);

        bfw.write(100);
        bfw.flush();
        bfw.write("你好".toCharArray());
        bfw.flush();

        bfw.write("你好");
        bfw.flush();

        bfw.write("我好好");
        bfw.flush();

        bfw.write("大家都好");
        bfw.flush();

        bfw.close();
    }
}
```

###字符流缓冲区流复制文本文件

```
/*
 *  使用缓冲区流对象,复制文本文件
 *  数据源  BufferedReader+FileReader 读取
 *  数据目的 BufferedWriter+FileWriter 写入
 *  读取文本行, 读一行,写一行,写换行
 */
public class Copy_1 {
    public static void main(String[] args) throws IOException{
        BufferedReader bfr = new BufferedReader(new FileReader("c:\\w.log"));   
        BufferedWriter bfw = new BufferedWriter(new FileWriter("d:\\w.log"));
        //读取文本行, 读一行,写一行,写换行
        String line = null;
        while((line = bfr.readLine())!=null){
            bfw.write(line);
            bfw.newLine();
            bfw.flush();
        }
        bfw.close();
        bfr.close();
    }
}
```


###字节转字符流


####InputStreamReader类

    java.io.InputStreamReader 继承 Reader

 字符输入流，读取文本文件
 字节流向字符的桥梁，将 **字节流** 转为 **字符流**
读取的方法：**read()** 读取1个字符，读取字符数组

构造方法：
InputStreamReader(InputStream in)：接收所有的 **字节输入流**

    可以传递的字节输入流： FileInputStream

InputStreamReader(InputStream in,String charsetName) : 传递编码表的名字

例子：
```
public class InputStreamReaderDemo {
    public static void main(String[] args) throws IOException {
        readUTF();
    }

    //转换流,InputSteamReader读取文本，采用UTF-8编码表,读取文件utf
    public static void readUTF()throws IOException{
        //创建字节输入流,传递文本文件
        FileInputStream fis = new FileInputStream("c:\\utf.txt");
        //创建转换流对象,构造方法中,包装字节输入流,同时写编码表名
        InputStreamReader isr = new InputStreamReader(fis,"UTF-8");
        char[] ch = new char[1024];
        int len = isr.read(ch);
        System.out.println(new String(ch,0,len));
        isr.close();
    }
}
```


####OutputStreamWriter类

    java.io.OutputStreamWriter 继承 Writer 类


字符输出流，写文本文件
是字符通向字节的桥梁，将 字符流 转成 字节流
方法write()：字符，字符数组，字符串

构造方法：
OutputStreamWriter(OuputStream out)：接收所有的**字节输出流**

    字节输出流目前只有： FileOutputStream

OutputStreamWriter(OutputStream out, String charsetName)

    String charsetName：传递 编码表名字：GBK、UTF-8


例子：
```
public class OutputStreamWriterDemo {
    public static void main(String[] args) throws IOException {
        writeUTF();
    }

   //转换流对象OutputStreamWriter写文本，采用UTF-8编码表写入
    public static void writeUTF()throws IOException{
        //创建字节输出流，绑定文件
        FileOutputStream fos = new FileOutputStream("c:\\utf.txt");
        //创建转换流对象，构造方法保证字节输出流，并指定编码表是UTF-8
        OutputStreamWriter osw = new OutputStreamWriter(fos,"UTF-8"); //GBK可以不写
        osw.write("你好");
        osw.close(); //使用close()连刷新带关闭
    }
}
```

####转换流子类父类的区别

**继承关系**
OutputStreamWriter 的子类: FileWriter
InputStreamReader 的子类：FileReader
**区别**
OutputStreamWriter 和 InputStreamReader 是**字符和字节的桥梁**：也可以称之为字符转换流。**字符转换流原理：字节流 + 编码表**
FileWriter 和 FileReader：作为子类，仅作为操作字符文件的便捷类存在。当操作的字符文件，使用的是默认编码表时可以不用父类，而直接用子类就完成操作了，简化了代码。
以下三句话功能相同


    InputStreamReader isr = new InputStreamReader(new FileInputStream("a.txt"));//默认字符集。
    InputStreamReader isr = new InputStreamReader(new FileInputStream("a.txt"),"GBK");//指定GBK字符集。
    FileReader fr = new FileReader("a.txt");

注意：一旦要指定其他编码时，绝对不能用子类，必须使用字符转换流。什么时候用子类呢？ 
条件：1、操作的是文件。2、使用默认编码。



#总结
##字节流
###字节输入流 InputStream

    FileInputStream 操作文件的字节输入流
    BufferedInputStream高效的字节输入流
    ObjectInputStream 反序列化流

###字节输出流 OutputStram

    FileOutputStream 操作文件的字节输出流
    BufferedOutputStream 高效的字节输出流
    ObjectOuputStream 序列化流
    PrintStream 字节打印流

##字符流
###字符输入流 Reader

    FileReader 操作文件的字符输入流
    BufferedReader 高效的字符输入流
    InputStreamReader 输入操作的转换流(把字节流封装成字符流)

###字符输出流 Writer

    FileWriter 操作文件的字符输出流
    BufferedWriter 高效的字符输出流
    OutputStreamWriter 输出操作的转换流(把字节流封装成字符流)
    PrintWriter 字符打印流

##方法：
###读数据方法：

    read() 一次读一个字节或字符的方法
    read(byte[] char[]) 一次读一个数组数据的方法
    readLine() 一次读一行字符串的方法(BufferedReader类特有方法)
    readObject() 从流中读取对象(ObjectInputStream特有方法)

###写数据方法：

    write(int) 一次写一个字节或字符到文件中
    write(byte[] char[]) 一次写一个数组数据到文件中
    write(String) 一次写一个字符串内容到文件中
    writeObject(Object ) 写对象到流中(ObjectOutputStream类特有方法)
    newLine() 写一个换行符号(BufferedWriter类特有方法)

##向文件中写入数据的过程 
1，创建输出流对象 
2，写数据到文件 
3，关闭输出流
##从文件中读数据的过程 
1， 创建输入流对象 
2， 从文件中读数据 
3， 关闭输入流
##文件复制的过程 
1， 创建输入流（数据源） 
2， 创建输出流（目的地） 
3， 从输入流中读数据 
4， 通过输出流，把数据写入目的地 
5， 关闭流
##File类

###方法

    获取文件名称 getName()
    获取文件绝对路径 getAbsolutePath()
    获取文件大小 length()
    获取当前文件夹中所有File对象 File[] listFiles()
    判断是否为文件 isFile()
    判断是否为文件夹 isDirectory()
    创建文件夹 mkdir() mkdirs()
    创建文件 createNewFile()

###异常

    try..catch…finally捕获处理异常
    throws 声明异常
    throw 抛出异常对象

###异常的分类
编译期异常 Exception
运行期异常 RuntimeException
注意：
编译期异常，必须处理，不然无法编译通过
运行期异常，程序运行过程中，产生的异常信息
###实现文件内容的自动追加
构造方法

    FileOutputStream(File file, boolean append)
    FileOutputStream(String fileName, boolean append)
    FileWriter(File, boolean append)
    FileWriter(String fileName, boolean append)

###实现文件内容的自动刷新
构造方法

    PrintStream(OutputStream out, boolean autoFlush)
    PrintWriter(OutputStream out, boolean autoFlush)
    PrintWriter(Writer out, boolean autoFlush)


#参考：

https://www.cnblogs.com/yellowbananame/p/8946976.html（文件的操作）


https://zhuanlan.zhihu.com/p/39803062(文件大体框架)
https://zhuanlan.zhihu.com/p/39886428(大体框架)

https://www.cnblogs.com/ysocean/p/6859242.html（看不懂的就看下这里的例子）

	2019-09-25 19:43:39
kumika	Java基础复习--网络编程	#Java基础复习--网络编程



#网络编程

**网络编程三大要素：**

　　（1）IP地址：网络中每一台计算机的唯一标识，通过IP地址找到指定的计算机。

　　（2）端口：用于标识进程的逻辑地址，通过端口找到指定进程。

　　（3）协议：定义通信规则，符合协议则可以通信，不符合不能通信。

原理图：
[![](https://ae01.alicdn.com/kf/H587b6c6a11c345e183c80fbdf1a8d54b2.png)](https://ae01.alicdn.com/kf/H587b6c6a11c345e183c80fbdf1a8d54b2.png)

##网络模型
TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能

[![](https://ae01.alicdn.com/kf/Hc3df5c1de00b46698782de062eb8b47bU.png)](https://ae01.alicdn.com/kf/Hc3df5c1de00b46698782de062eb8b47bU.png)

**链路层：**链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。

**网络层：**网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。

**传输层：**主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。

**应用层：**主要负责应用程序的协议，例如HTTP协议、FTP协议等。

##IP协议
[![](https://ae01.alicdn.com/kf/Hc4902475653e43b0acdba247f86e3226m.png)](https://ae01.alicdn.com/kf/Hc4902475653e43b0acdba247f86e3226m.png)
每个人的电脑都有一个独一无二的IP地址，这样互相通信时就不会传错信息了。

　　IP地址是用一个点来分成四段的，在计算机内部IP地址是用四个字节来表示的，一个字节代表一段，每一个字节代表的数最大只能到达255。
　　
　目前，IP地址广泛使用的版本是 IPv4，它是由4个字节大小的二进制数来表示，如：00001010000000000000000000000001。
由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式， 每个字节用一个十进制数字(0-255)表示，数字间用符号“.”分开，如 “192.168.1.100”
127.0.0.1 为 本地主机地址(本地回环地址)
DOS命令 ipconfig：查看本机IP地址

##TCP协议和UDP协议

[![](https://ae01.alicdn.com/kf/H4272e8fcedfd4f1e9c71ba187b6bd1b5d.png)](https://ae01.alicdn.com/kf/H4272e8fcedfd4f1e9c71ba187b6bd1b5d.png)

TCP和UDP位于同一层，都是建立在IP层的基础之上。由于两台电脑之间有不同的IP地址，因此两台电脑就可以区分开来，也就可以互相通话了。通话一般有两种通话方式：第一种是TCP，第二种是UDP。

**TCP是可靠的连接，TCP就像打电话，需要先打通对方电话，等待对方有回应后才会跟对方继续说话，也就是一定要确认可以发信息以后才会把信息发出去。
TCP上传任何东西都是可靠的，只要两台机器上建立起了连接，在本机上发送的数据就一定能传到对方的机器上，UDP就好比发电报，发出去就完事了，对方有没有接收到它都不管，所以UDP是不可靠的。**

TCP传送数据虽然可靠，但**传送得比较慢**，UDP传送数据不可靠，但是**传送得快**。


##TCP协议

TCP协议是**面向连接**的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。

在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过**“三次握手”**。

    第一次握手，客户端向服务器端发出连接请求，等待服务器确认 
    第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 
    第三次握手，客户端再次向服务器端发送确认信息，确认连接

###HTTP
**HTTP就是一个用文本格式描述报文头并用双换行分隔报文头和内容，在TCP基础上实现的请求-响应模式的双向通信协议。**

基于TCP协议的一个报文协议，其报文头是不定长且任意扩展的，这也使得这个协议充满了生命力。


**没有人能完整描述HTTP协议**，因为这个协议的细节可以随时扩充。例如控制咖啡壶什么的……其实你说的越多，暴露的短处越多，所以什么都不说才是坠吼的。


####3次握手4次分手
参考：https://www.cnblogs.com/chenkeyu/p/8485412.html

个人理解：
3次握手：
客户端发出第一次请求----》服务端接收到，要告诉客户端：我接受到了，返回响应给客户端。
客户端接收到响应后，为了确保正确创建连接，再发出一次请求-----》服务端收到，此时完成3次握手。

握手是 建立连接的3次传递，2次由客户端发出，1次由服务端发出。

4次分手：
**TCP是双向的，所以需要在两个方向分别关闭，每个方向的关闭又需要请求和确认，所以一共就4次。**
客户端发出断开请求----》服务端收到，返回响应。
服务端发出断开请求----》客户端收到，返回响应。



###Sockect
[![](https://ae01.alicdn.com/kf/H9e071e8e97094f0e9fdd5cf0e426be88a.png)](https://ae01.alicdn.com/kf/H9e071e8e97094f0e9fdd5cf0e426be88a.png)

Socket的读写过程
[![](https://ae01.alicdn.com/kf/H9f2b216c9d60459895e25bedb72688f6E.gif)](https://ae01.alicdn.com/kf/H9f2b216c9d60459895e25bedb72688f6E.gif)

**出现Sockect的原因：**
TCP通信同UDP通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建 socket 对象。
区别在于，UDP中只有 发送端 和 接收端，不区分 客户端 与 服务器 端，计算机之间可以任意地发送数据。
而TCP通信是严格区分客户端与服务器端的，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。
在JDK中提供了两个类用于实现TCP程序，一个是 ServerSocket 类，用于表示服务器端，一个是 Socket 类，用于表示客户端。
通信时，首先创建代表服务器端的 ServerSocket 对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的 Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。

**一个socket连接如何唯一标识？** 

    源端（ip+端口号）、目的（ip+端口号）唯一确定一个tcp连接


####TCP的客户端程序

实现TCP客户端，连接到服务器和服务器实现数据交换
实现TCP客户端程序的类： java.net.Socket

构造方法：
**Socket(String host, int port) ：**传递服务器IP和端口号

    构造方法只要运行,就会和服务器进行连接,连接失败就抛出异常


**OutputStream getOutputStream() ：**返回套接字的输出流。
作用： 将数据输出,输出到服务器

**InputStream getInputStream()** 返回套接字的输入流；
作用： 从服务器端读取数据


客户端服务器数据交换，**必须使用套接字对象 Socket 中的获取的IO流**，自己 new 的流是不行的


代码：
```
public class TCPClient {
    public static void main(String[] args) throws IOException {
        //创建Socket对象，连接服务器
        Socket socket = new Socket("127.0.0.1", 8888);
        //通过客户端的套接字对象 Socket方法，获取字节输出流将数据写向服务器
        OutputStream out = socket.getOutputStream();
        out.write("服务器ok！".getBytes());

        //读取服务器发回的数据，使用socket套接字对象中字节输入流
        InputStream in = socket.getInputStream();
        byte[] data = new byte[1024];
        int len = in.read(data);
        System.out.println(new String(data,0,len));

        socket.close();
    }
}
```

####TCP的服务器程序 & accept 方法

表示服务器程序的类： java.net.ServerSocket
构造方法： 
ServerSocket(int port)： 传递端口号

**必须要获得客户端的套接字对象 Socket**：Socket accept()



代码：
```
public class TCPServer {
    public static void main(String[] args) throws IOException {
        ServerSocket service = new ServerSocket(8888);
        //调用服务器套接字对象中的方法accpet() ，获取客户端套接字对象
        Socket socket = service.accept();
        //通过客户端套接字对象Socket，获取字节输入流，读取客户端发送来的消息
        InputStream in = socket.getInputStream();
        byte[] data = new byte[1024];
        int len = in.read(data);
        System.out.println(new String(data,0,len));

        //服务器向客户端回数据，字节输出流，通过客户端套接字对象获取字节输出流
        OutputStream out = socket.getOutputStream();
        out.write("收到，谢谢！！".getBytes());

        socket.close();
        service.close();
    }
} 
```


##UDP通信

###**数据包和发送对象**
**DatagramPacket数据包** 的作用就如同是“集装箱”，可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”是不够的，还需要有码头。
在程序中需要实现通信只有 DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。
**DatagramSocket类** 的作用就类似于码头，使用这个类的实例对象就可以 **发送和接收DatagramPacket数据包**
DatagramPacket：**封装数据**
DatagramSocket：**发送 DatagramPacket**

###UDP发送端


**实现 UDP 协议的发送端**
实现**封装数据**的类 java.net.DatagramPacket 将数据包装
实现**数据传输**的类 java.net.DatagramSocket 将数据包发出去


**实现步骤**

 1. 创建 DatagramPacket 对象,封装数据, 接收的地址和端口
 2. 创建 DatagramSocket 对象
 3. 调用 DatagramSocket 类方法 send ，发送数据包
 4. 关闭资源


DatagramPacket构造方法：

    DatagramPacket(byte[] buf, int length, InetAddress address, int port)
    参数：字节数组，发送多少，IP地址，端口号

DatagramSocket构造方法:

    DatagramSocket()：空参数

DatagramSocket的方法: 

    send(DatagramPacket d)


代码:
```
public class UDPSend {
    public static void main(String[] args) throws IOException{
        //创建数据包对象,封装要发送的数据,接收端IP,端口 
        byte[] date = "你好UDP".getBytes();
        //创建InetAddress对象,封装自己的IP地址 
        InetAddress inet = InetAddress.getByName("127.0.0.1");
        DatagramPacket dp = new DatagramPacket(date, date.length, inet,6000);
        //创建DatagramSocket对象,数据包的发送和接收对象 
        DatagramSocket ds = new DatagramSocket();
        //调用ds对象的方法send,发送数据包 
        ds.send(dp);
        //关闭资源 
        ds.close();
    }
}
```

###UDP接收端


**实现UDP接收端**
实现**封装数据包**java.net.DatagramPacket 将数据**接收**
实现**数据传输**java.net.DatagramSocket 接收数据包


**实现步骤**

 1. 创建 DatagramSocket 对象，**绑定端口号**，要和**发送端端口号一致**
 2. 创建**字节数组**，接收发来的数据
 3. 创建数据包对象 DatagramPacket
 4. 调用 DatagramSocket 对象方法，receive(DatagramPacket dp)接收数据，数据放在数据包中
 5. 拆包：
 
    5.1. **发送的IP地址** ：数据包对象 DatagramPacket 方法getAddress() 获取的是**发送端的IP地址对象** ，返回值是 InetAddress对象
    5.2. **接收到的字节个数**：数据包对象 DatagramPacket 方法 getLength()
    5.3. **发送方的端口号**：数据包对象 DatagramPacket 方法 getPort()发送端口

6.**关闭资源**


代码：
```
public class UDPReceive {
    public static void main(String[] args)throws IOException {
        //创建数据包传输对象DatagramSocket 绑定端口号
        DatagramSocket ds = new DatagramSocket(6000);
        //创建字节数组
        byte[] data = new byte[1024];
        //创建数据包对象,传递字节数组
        DatagramPacket dp = new DatagramPacket(data, data.length);
        //调用ds对象的方法receive传递数据包
        ds.receive(dp);

        //获取发送端的IP地址对象
        String ip=dp.getAddress().getHostAddress();

        //获取发送的端口号
        int port = dp.getPort();

        //获取接收到的字节个数
        int length = dp.getLength();
        System.out.println(ip+" "+port+":"+new String(data,0,length));
        ds.close();
    }
}
```


#TCP图片上传案例

##TCP上传客户端
实现步骤:

 1. Socket套接字连接服务器
 2. 通过Socket获取字节输出流,写图片 
 3. 使用自己的流对象,读取图片数据源(FileInputStream、缓冲流）
 4. 读取图片,使用字节输出流,将图片写到服务器（采用字节数组进行缓冲）
 5. 通过Socket套接字获取字节输入流，读取服务器发回来的上传成功，
 6. 关闭资源

代码:
```
public class TCPClient {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("127.0.0.1",8000);
        //获取字节输出流，将图片写到服务器
        OutputStream out = socket.getOutputStream();
        //创建字节输入流，读取本机上的数据源图片
        FileInputStream fis = new FileInputStream("D:\\test.jpg");
        //开始读写字节数组
        int len = 0;
        byte[] bytes = new byte[1024];
        while((len = fis.read(bytes)) != -1){
            out.write(bytes,0,len);
        }

        //给服务器写终止序列,向服务端写入一个结束标志
        socket.shutdownOutput();

        //获取字节输入流，读取服务器的"上传成功"
        InputStream in = socket.getInputStream();

        len = in.read(bytes); //复用byte数组
        System.out.println(new String(bytes,0,len));

        fis.close();
        socket.close();
    }
}
```

##TCP上传服务器

 1. ServerSocket套接字对象,监听端口8000
 2. 方法accept()获取客户端的连接对象
 3. 客户端连接对象获取字节输入流,读取客户端发送图片
 4. 创建File对象，绑定上传文件夹（判断文件夹存在，不存在，创建文件夹）
 5. 创建字节输出流，数据目的File对象所在文件夹
 6. 字节流读取图片，字节流将图片写入到目的文件夹中
 7. 将上传成功会写客户端
 8. 关闭资源

代码：
```
public class TCPServer {
    public static void main(String[] args) throws IOException {
        ServerSocket server = new ServerSocket(8000);
        Socket socket = server.accept();
        //通过客户端连接对象,获取字节输入流,读取客户端图片
        InputStream in = socket.getInputStream();
        //将目的文件夹封装到File对象
        File upload = new File("E:\\upload");
        if(! upload.exists()){
            upload.mkdirs();
        }

        //防止文件同名被覆盖,重新定义文件名字
        //规则:  域名+当前毫秒值+6位随机数
        String filename="wangdao"+System.currentTimeMillis()+new Random().nextInt(999999)+".jpg";

        //创建字节输出流,将图片写入到目的文件夹中
        FileOutputStream fos = new FileOutputStream(upload+File.separator+filename);
        //读写字节数组
        byte[] bytes = new byte[1024];
        int len = 0;
        while((len = in.read(bytes)) != -1){
            fos.write(bytes,0,len);
        }

        //通过客户端连接对象获取字节输出流
        //将"上传成功"写回客户端
        socket.getOutputStream().write("上传成功！".getBytes());

        fos.close();
        socket.close();
        server.close();
    }
}
```


#多线程上传案例

##客户端（不变）
代码：
```
public class TCPClient {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("127.0.0.1",8000);
        //获取字节输出流，将图片写到服务器
        OutputStream out = socket.getOutputStream();
        //创建字节输入流，读取本机上的数据源图片
        FileInputStream fis = new FileInputStream("D:\\test.jpg");
        //开始读写字节数组
        int len = 0;
        byte[] bytes = new byte[1024];
        while((len = fis.read(bytes)) != -1){
            out.write(bytes,0,len);
        }

        //给服务器写终止序列,向服务端写入一个结束标志
        socket.shutdownOutput();

        //获取字节输入流，读取服务器的"上传成功"
        InputStream in = socket.getInputStream();

        len = in.read(bytes); //复用byte数组
        System.out.println(new String(bytes,0,len));

        fis.close();
        socket.close();
    }
}
```

##创建 Upload，实现 Runnable
```
public class Upload implements Runnable {
    private Socket socket;
    //传递socket
    public Upload(Socket socket){
        this.socket = socket;
    }

    @Override
    public void run() {

        //通过客户端连接对象,获取字节输入流,读取客户端图片
        InputStream in = null;
        try {
            in = socket.getInputStream();
            //将目的文件夹封装到File对象
            File upload = new File("E:\\upload");
            if(! upload.exists()){
                upload.mkdirs();
            }

            //防止文件同名被覆盖,重新定义文件名字
            //规则:  域名+当前毫秒值+6位随机数
            String filename="wangdao"+System.currentTimeMillis()+new Random().nextInt(999999)+".jpg";

            //创建字节输出流,将图片写入到目的文件夹中
            FileOutputStream fos = new FileOutputStream(upload+File.separator+filename);
            //读写字节数组
            byte[] bytes = new byte[1024];
            int len = 0;
            while((len = in.read(bytes)) != -1){
                fos.write(bytes,0,len);
            }

            //通过客户端连接对象获取字节输出流
            //将"上传成功"写回客户端
            socket.getOutputStream().write("上传成功！".getBytes());
            fos.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

##服务端
```
public class TCPThreadServer {
    public static void main(String[] args) throws IOException {
        ServerSocket server = new ServerSocket(8000);
        while(true){
            //获取到一个客户端,必须开启新线程,为这个客户端服务
            Socket socket = server.accept();
            new Thread(new Upload(socket)).start();
        }
    }
}
```

#参考：
https://zhuanlan.zhihu.com/p/39987217
https://www.cnblogs.com/xdp-gacl/p/3631965.html（TCP通信的Socket的例子）
https://www.cnblogs.com/wangcq/p/3520400.html（socket的细节解说）
https://www.cnblogs.com/chenkeyu/p/8485412.html

http://www.52im.net/thread-1095-1-1.html（总框架的资料）

https://www.cnblogs.com/chenkeyu/p/8485412.html（3次握手和4次分手）

大牛的博客：
http://www.ruanyifeng.com/blog/computer/


	2019-09-28 11:49:18
kumika	Java基础复习--多线程	"#Java基础复习--多线程



#多线程


##进程与线程
**进程**：进程指正在运行的程序。
**线程**：线程是进程中的一个执行单元，是程序 **使用cpu** 的基本单位（**调度**）。负责当前进程中程序的执行。是进程中单个顺序控制流（执行路径），是一条单独执行的路径

**一个程序运行后至少有一个进程，一个进程中可以包含多个线程**


个人理解线程的概念：
**进程就是工厂里的一条生产线，
线程就是生产线上的可以流动的工人。**

在操作系统中，**进程是资源分配的基本单位，线程是调度的基本单位。**

    在没有出现线程之前，进程既是操作系统进行资源分配的基本单位，又是调度的基本单位


**单线程程序**：若有多个任务只能依次执行。当上一个任务执行结束后，下一个任务开始执行**。程序只有一条执行路径**
**多线程程序**：若有多个任务可以同时执行。**程序有多条执行路径**


**5条执行路径**

 1. **操作系统发展**：单道批处理操作——>多道批处理操作系统——>分时操作系统(多进程的)——>线程
 3. **批处理**：程序在执行过程中，不会响应用户的请求
 4. **单道批处理操作**：一次只能运行一个程序，如果要在计算机运行多个程序，这多个程序，只能一个一个的顺序执行，如果这个正在运行的程序，在运行过程中，执行了一些非常耗时的IO操作(传输数据的过程是没有使用到cpu)，这样一来，cpu就闲下来了，但是cpu是计算机中，最为昂贵的
 4. **多道批处理操作系统**：同时运行多个程序，显著的提高了cpu的利用率，但是我们一旦一个，程序运行起来，都是是需要使用计算机资源的
 5. **分时操作系统**：每一个进程，有一个固定的时间片，在运行一个固定的时间片后，紧接着轮到下一个进程运行（切换）


</n>
**为什么还会有线程呢？**
答：
进程切换的代价太高了，这样一来，每一次进程切换，都需要付出不小的额外的代价，**为了减小进程切换的代价**，引入了线程，**提高CPU的利用率**


##线程

**线程**：线程是进程中的一个执行单元，是程序 **使用cpu** 的基本单位（**调度**）。负责当前进程中程序的执行。是进程中单个顺序控制流（执行路径），是一条单独执行的路径



###线程的一些控制方法

**线程睡眠：**

    static void sleep(long millis)

在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）
```
//让主线程，休眠3秒
Thread.sleep(3000);
//sleep新的写法
TimeUnit.SECONDS.sleep(3);
System.out.println("睡醒了");
```
</n>
**线程加入**


    public final void join()

（让当前线程）等待该线程(新加入的线程终止)终止。

```
SecondThread sec = new SecondThread("zs");
SecondThread thr = new SecondThread("lsii");
SecondThread fou = new SecondThread("wangwu");

//启动这三个线程对象
sec.start();
//sec线程上调用join方法 ，让当前线程（main）等待sec线程执行完毕
sec.join();
thr.start();
fou.start();
```
</n>
**线程礼让**

    public static void yield()

暂停当前正在执行的线程对象，并执行其他线程

    只是让当前线程放弃cpu执行权，但是不能阻止它放弃后继续抢夺cpu执行权

</n>
**后台线程（守护线程）**

    public final void setDaemon(boolean on)

将该线程标记为**守护线程或用户线程**。当正在运行的线程都是守护线程时，Java 虚拟机退出；该方法必须在启动线程前调用。

```
SecondThread sec = new SecondThread("zs");
SecondThread thr = new SecondThread("lsii");
//将sec和thr线程设置为守护线程
sec.setDaemon(true);
thr.setDaemon(true);
//启动
sec.start();
thr.start();
//之后发现sec和thr是守护线程，就会中断
```

</n>
**中断线程**
public void interrupt()
让一个线程控制另外一个线程（有条件的：受阻），可以利用该方法**终止**另一个线程的运行。


 1. 如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的
    join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int)
    等阻塞方法处于阻塞状态，它还将收到一个 InterruptedException
 2. 中断一个不处于活动状态的线程不需要任何作用。 
中断一个不处于阻塞状态的线程，没有其他任何效果


```
public class Test {
    public static void main(String[] args) {
        FiveThread fiveThread = new FiveThread();
        fiveThread.start();
        //在主线程中，终止fiveThread，休眠状态
        fiveThread.interrupt();
    }
}

// 睡5秒之后，再让该线程输出一句话
class FiveThread extends Thread{
    @Override
    public void run() {
        try {
            //假如申请了很多的系统资源
            TimeUnit.SECONDS.sleep(5);
            System.out.println("FiveThread 睡醒了");
        } catch (InterruptedException e) {
            e.printStackTrace();
            //异常的意义：即使我的线程被异常终止，我也可以保证资源的正常释放
        }
    }
}

//会抛出 java.lang.InterruptedException: sleep interrupted
```





##线程的创建

创建新执行线程的两种方法

 1. 将类声明为 **Thread** 的子类。该子类应重写 Thread 类的 run
    方法。创建对象，开启线程。**run**方法相当于其他线程的main方法。
 2. 声明一个实现 **Runnable** 接口的类。该类然后实现 **run** 方法。然后创建 Runnable的子类对象，传入到某个线程的构造方法中，开启线程。


--------------------------------

    虽然实现线程有两种方式，其实从客观来讲，线程本身只代表独立的执行路径, 执行的具体内容其实是Task本身，和执行路径的实现本身没有联系；只是我们开发者，想将一个task放在某条独立的执行路径(Thread 类对象，也就是一个线程中)来运行

###介绍Thread类

 - Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程
 - **不是抽象类**


**构造方法：**
**Thread()**： 分配新的 Thread 对象
**Thread(String name)**：分配新的 Thread 对象，将指定的 name 作为其线程名称

**常用方法：**

**void start()**：使该线程开始执行，Java虚拟机调用线程的 run 方法
</n>
**void run()**：该线程要执行的操作，
</n>
**static void sleep(long millis)**：
在指定毫秒内让当前正在执行的线程休眠，暂停执行
</n>
**static Thread currentThread()**：
返回**当前正在执行的线程对象**的引用Thread.currentThread()

###创建线程：继承Thread类

**创建线程的步骤**

 1. 定义一个类继承 Thread
 2. 重写 run方法
 3. 创建子类对象，就是创建线程对象
 4. 调用 start 方法，开启线程并让线程执行，同时还会告诉jvm去调用 run 方法

线程对象调用 **run方法 不开启线程**。仅是**对象调用方法**。 
线程对象调用 **start 开启线程**，并让 jvm 调用 run 方法在开启的线程中执行


```
//测试类
public class Test {
    public static void main(String[] args) {
        //创建自定义线程对象
        MyThread mt = new MyThread("新的线程！");

        //错误启动线程,这只是普通的方法调用
        //firstThread.run();

        //开启新线程
        mt.start();

        //再次启动一个线程，会抛异常IllegalThreadStateException 
        //因为一个线程对象只能启动一次，
        // 如果同一个线程对象，启动多次，就会抛出异常
        //firstThread.start();
        //只能创建一个新的对象
        new MyThread("第二个线程！").start();
        //获取主线程的名字
        System.out.println(Thread.currentThread().getName()+"：主线程！");
    }
}

//自定义线程
class MyThread extends Thread {
    //定义指定线程名称的构造方法
    public MyThread(String name) {
        //调用父类的String参数的构造方法，指定线程的名称
        super(name);
    }

    //重写run方法，完成该线程执行的逻辑
    @Override
    public void run() {
        //获取线程的名字getName()
        System.out.println(getName() + "：正在执行！");
    }
}
```

###创建线程：实现Runnable接口

**Runnable 接口的构造方法**

    Thread(Runnable target)

分配新的 Thread 对象，以便将 target 作为其运行对象

    Thread(Runnable target,String name) 

分配新的 Thread 对象，以便将 target 作为其运行对象；并将指定的 name 作为其名称

**创建线程的步骤**

 1. 定义类实现 **Runnable** 接口。
 2. 覆盖接口中的 **run方法**
 3. 创建 Thread类的 **对象**
 4. 将 Runnable接口 的**子类对象**作为**参数**传递给 **Thread 类** 的**构造方法**。
 5. 调用 Thread类的 **start()** 开启线程。

-

    Thread 类的一些构造函数：
    1. Thread()： 分配新的 Thread 对象
    2. Thread(String name)：分配新的 Thread 对象，将指定的 name 作为其线程名称
    3.Thread(Runnable target)：Allocates a new Thread object.（就是分配一个新的线程）

Thread类的构造方法，方法，自己看Api,这里写的不够详细。

创建线程代码：
```
//测试类
public class Test {
    public static void main(String[] args) {
        //创建实现 Runnable 接口的子类对象
        MyRunnable myrunnable = new MyRunnable();
        //创建Thread实例，在Thread的构造方法中传递Runnable实例
        //Runnable就代表在 Thread 上运行的任务
        Thread thread = new Thread(myrunnable);
        //开启线程
        thread.start();
        for (int i = 0; i < 10; i++) {
            System.out.println("main线程：正在执行！"+i);
        }
    }
}

//自定义线程执行任务类
class MyRunnable implements Runnable{
    //定义线程要执行的run方法逻辑
    //run方法，不能抛出编译时异常
    //run方法，没有参数没有返回值
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("我的线程：正在执行！"+i);
        }
    }
}
```

**为什么需要定一个类去实现Runnable接口呢？继承Thread类和实现Runnable接口有啥区别呢？** 

答：
    这是实现Runnable接口的原理
    只有创建Thread类的对象才可以创建线程。线程任务已被封装到Runnable接口的run方法中，而这个run方法所属于Runnable接口的子类对象，所以将这个子类对象作为参数传递给Thread的构造函数，这样，线程对象创建时就可以明确要运行的线程的任务

###**两种方式的比较**

**继承 Thread 类方式**
   
 - 如果某个类已经有父类，则无法再继承 Thread 类

**实现 Runnable 接口方式**
    
 1. 解决了方式一的单继承的局限性
 2. 还有一个优点，便于多线程共享数据

    
    第二种方式实现Runnable接口避免了单继承的局限性，所以较为常用。实现Runnable接口的方式，更加的符合面向对象；线程分为两部分，一部分线程对象，一部分线程任务。

</n>

继承Thread类，线程对象和线程任务耦合在一起。一旦创建Thread类的子类对象，**既是线程对象，有又有线程任务**。

实现runnable接口，将线程任务单独分离出来**封装成对象**，**类型就是Runnable接口类型**。Runnable接口对线程对象和线程任务进行**解耦**。



##线程的调度

**分时调度**：所有线程 **轮流使用** CPU 的使用权，平均分配每个线程占用 CPU 的时间。
**抢占式调度**：优先让 **优先级高的** 线程使用 CPU，如果线程的优先级相同，那么会随机选择一个**(线程随机性)，Java使用的为抢占式调度**
体现了：**程序运行的不确定性**

    1. CPU 使用抢占式调度模式在多个线程间进行着·高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。
    2. 多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。

##线程同步

个人理解线程同步：

前面比喻是  
**线程= 工厂生产线上的工人**
那**线程同步**就是
**生产线上的某个步骤只能某个工人执行**

同步为了防止多个线程同时访问同一个数据对象时，对数据造成破坏（就是多人做某个步骤会破坏生产机器）。

**问题引入——线程安全问题**

发生线程安全问题的**3个条件**

1. **多线程运行环境**
2. 多线程访问**线程共享数据**（存在共享数据）
3. 访问共享数据的操作不是**原子操作**。 
注：原子操作：**不可分割的操作** ，相当于一次性完成的操作

当这三个条件**同时满足**的时候，才会发生多线程的数据安全问题


**解决多线程的线程安全问题**：如何实现线程对共享资源的**排他性访问**（只有我访问完了你们才能修改）？

答：
使用 同步代码块


###同步代码块

同步代码块实现 **线程同步**

**线程同步**：就是利用锁对象，完成多线程运行环境中，对共享资源的排他性访问（我走你不能走， 你走我不能走）

优点：解决了多线程的安全问题
缺点：消耗资源（当线程很多时，每个线程运行的时候都需要去判断同步锁，这个是很耗费系统资源的）


**线程异步**：线程之间，互不干扰，各自独立运行（我走我的，你走你的）


代码格式：
```
synchronized（对象）{
    //critical section
        对共享资源的访问的代码
}
```
1. 同步代码块中所使用的对象，称之为**锁对象** ——> 锁的角色 
锁对象中，有一个**标志位**：可以表示两种状态，**加锁** 和 **解锁**

2. **持有锁的是线程**（一个线程给一个锁对象加锁，我们就说这个线程持有了锁对象）

3. **同步代码块何时给锁对象加锁？**
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  进入同步代码块的同时，就给锁对象加锁

4. **线程何时释放持有的锁？**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当执行完同步代码块的时候，就会释放同步代码块的锁对象

5. **判断和修改**锁对象**标志位**的操作，这是由 jvm **保证**一定是原子操作 
</n>
6. **锁对象，究竟是什么对象？**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java语言中任意一个对象，都可以充当锁对象的角色（因为任意一个对象中都有一个表示加锁，解锁状态的标志位）


注意点：
虽然锁对象可以是任意对象，但是**针对同一个（同样的多个共享变量）** 的所有操作，都必须保证在同步代码块中，使用**同一个锁对象**，才能避免线程安全问题。


###同步方法

 - 当同步代码块的范围扩大到**整个方法的方法体**的时候，我们可以将整个方法定义成**同步方法**，在**方法声明**上加上**synchronized**

**普通的同步代码块**： 

    synchronized(锁对象) {}

**同步方法**：

    void synchronized 方法名(){}

同步方法的锁对象就是 
this

**静态方法是否可以定义为同步方法？** 
静态的同步方法， 在方法声明上加上`static synchronized` 
它的所使用的**锁对象**是：当前类的字节码文件对象：`类名.class`

 - Lock方法

Java.util.concurrent.locks 中的 Lock 是一个接口，它的实现类是一个 Java 类，而不是作为语言的特性（关键字）来现 。

**Lock锁实现同步的步骤**

1) 创建 Lock 对象---使用**实现类ReentrantLock**

2) 调用 lock()方法上锁

3) 调用 unlock()方法解锁

注意：如果同步代码有异常，要将 unLock() 放到 finally 中。

代码：
```
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
public class CountRunnable implements Runnable {
	private int count = 0;
	//创建一个Lock对象
	Lock lock = new ReentrantLock();
	@Override
	public void run() {
		for (int i = 1; i <= 10; i++) {
			try {
				lock.lock();//加锁
//			synchronized (this) {
				count++;
				try {
					Thread.sleep(300);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName() + "执行操作：count=" + count);
//			}
			}finally {
				//确保解锁成功放入finally语句块中
				lock.unlock();//解锁
			}
		}
	}
}
```
测试类：
```
public class Test {
	public static void main(String[] args) {
		CountRunnable cr = new CountRunnable();
		//创建代理类对象
		Thread t1 = new Thread(cr, "A");
		Thread t2 = new Thread(cr, "B");
		Thread t3 = new Thread(cr, "C");
		t1.start();
		t2.start();
		t3.start();
	}
}
```

####Lock 与 synchronized 的区别

1) Lock 是显式锁 (手动开启和关闭锁 ,别忘关闭锁)，synchronized 是隐式锁

2) Lock 只有代码块锁，synchronized 有代码块锁和方法锁

3) 使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（提供更多的子类）

4) Lock 确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待(即被阻止)，直到该对象被释放。lock()方法会对 Lock 实例对象进行加锁，因此所有对该对象调用 lock() 方法的线程都会被阻塞，直到该 Lock 对象的 unlock() 方法被调用。

5) Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。Lock可以提高多个线程进行读操作的效率。

6) ReentrantLock可重入锁是一种递归无阻塞的同步锁机制，简单意思就是说可重入锁就是当前持有该锁的线程能够多次获取该锁，无需等待。



##线程间通信

### wait()

 - 导致当前线程处于 **等待状态**
 - 只有在其他线程线程中调用了 `notify()`方法或 `notifyAll()` 来唤醒，因为 `wait()`方法阻塞了线程
 - 在调用 **wait方法** 之前，当前线程**必须拥有**此对象监视器(锁对象)，换句话说，必须在 **锁对象** 上调用**wait方法**（此方法只应该由作为此对象监视器的所有者的线程 来调用）
 - 一旦在锁对象上调用了 wait方法，紧接着：
 -- 当前线程放弃 cpu 执行权，并等待
 -- 放弃持有的 **锁对象**

</n>

####**wait() 和 sleep() 比较** 

**相同点**：
使当前线程放弃cpu执行权，处于阻塞状态 

**不同点**：
1. 线程因为 **sleep()** 方法 处于阻塞状态的时候，**不会放弃所持有的锁对象**；线程因为**wait()** 处于阻塞状态的时候，**会放弃锁对象**
2. **使用条件**： 
    </n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**sleep()** 没有任何特殊条件； 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 **wait()** 则必须持有锁，在锁对象上调用 wait() 方法
3. 唤醒条件：
    </n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**sleep()** 的唤醒条件是休眠时间结束；
    </n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**wait()** 被唤醒，只能是在其它线程中调用了同一个锁对象的 **notify()** 或者**notifyAll()**方法

###nofity()

 - 唤醒在**此对象(调用wait的同一个锁对象)** 监视器上等待的 单个线程；如果所有线程都在此对象上等待，则会选择唤醒 **其中一个线程**
 - 直到当前线程 **放弃此对象上的锁定** ，才能继续执行被唤醒的线程
 - 被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行 **竞争**



###notifyAll()

唤醒在此对象监视器上等待的 所有线程

##线程的生产者消费者问题
```
/**
 *
 * 在理解线程的创建后，就可以理解这个面包线程了
 *
 * 重点在于理解  面包需要容器来装和执行了Runnable接口的类的构造函数，这是没有想到的。
 *
        1       创建生产者，消费者这2个类，都执行了Runnable接口
        2
 *
 * @author : lenovo
 * @date: 2019/09/30--9:31
 */
public class CuProTest {

    public static void main(String[] args) {
        //先有容器装东西
        rongqi wan = new rongqi();

        //2个类 生产者和消费者
        Producter P = new Producter(wan);
        Consumer C = new Consumer(wan);

        Thread PT = new Thread(P);
        Thread CT = new Thread(C);

        PT.start();
        CT.start();
    }
}
/**

 支持多线程同步操作的堆栈的实现
 */
class rongqi {
    //容器当前有多少个面包
    private int index;
    //装面包的数组，也就是真正的碗/容器
    private char[] data = new char[9];


    //放面包进入容器中，有判断容器的最大值
    public  synchronized void push(char c) {
        //当容器满了的时候，进入等待
        if (index == data.length) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //此处的提醒，是提醒拿到的线程开始工作了，因为线程等待状态才会给这个方法使用的。
        this.notify();
        data[index] = c;
        index++;
    }

    //从容器中拿出面包，有判断容器的最小值
    public synchronized char pop() {
        //当容器里面空了的时候，进入等待
        if (index == 0) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //此处的提醒，是提醒拿到的线程开始工作了，因为线程等待状态才会给这个方法使用的。
        this.notify();
        index--;
        return data[index];
    }

}

class Producter implements Runnable {

    rongqi wan;
    public Producter(rongqi rq) {
        wan = rq;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            char c = (char) (Math.random() * 26 + 'A');
            //把面包放入碗中
            wan.push(c);
            System.out.println("producted: "+c);
            try {
                Thread.sleep((int) (Math.random()* 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class Consumer implements Runnable {

    rongqi wan;

    public Consumer(rongqi rq) {
        wan = rq;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            char c = wan.pop();
            System.out.println("吃了面包："+c);
            try {
                Thread.sleep((int) (Math.random()* 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

##线程的生命周期

**新建状态**
创建线程对象


**就绪状态**

 - start() 之后
 - sleep() 睡醒之后
 - yield() 之后
 - 有执行资格，等待cpu调度

**运行状态**

取得执行权，开始执行

**阻塞状态**

无执行资格，无执行权

**死亡状态**

执行完毕，等待垃圾回收

[![](https://ae01.alicdn.com/kf/H6535ee46d00543d5adcd228764543fb8V.png)](https://ae01.alicdn.com/kf/H6535ee46d00543d5adcd228764543fb8V.png)



##线程池

线程池的简单概念：
 - **我们创建一个线程，只能使用一次**
 - **线程池**
其实就是一个容纳多个线程的容器，其中的线程可以 **反复使用**，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源
 - **线程池的原理**
线程池里每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一次被使用


为什么要使用线程池？
答：
**线程池主要用来解决线程生命周期开销问题和资源不足问题。**


###使用线程池中线程对象的步骤：

创建线程池对象
创建 Runnable 接口/Callable接口 子类对象
提交 Runnable 接口/Callable接口 子类对象
关闭线程池

代码：
```
public class ThreadPool {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //创建一个newCachedThreadPool
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        //操作线程池
        //向线程池提交任务
        executorService.submit(new Runnable() {
            @Override
            public void run() {
                System.out.println("hello, thread pool");
            }
        });

        //Callable接口的使用
        Future<Integer> future = executorService.submit(new Callable<Integer>() {

            @Override
            public Integer call() throws Exception {
                TimeUnit.SECONDS.sleep(3);
                int sum = 0;
                for (int i = 0; i < 10; i++) {
                    sum += i;
                }
                return sum;
            }
        });
        System.out.println(future);
        System.out.println(future.get());
    }
}
```


#总结

非常简单的不完全的一次复盘线程，出现问题之后就会进行更新。



#参考：
参考的大体框架：
https://zhuanlan.zhihu.com/p/39204864
https://zhuanlan.zhihu.com/p/39788456


https://www.cnblogs.com/xdp-gacl/p/3634382.html（生产者消费者问题）





"	2019-09-28 11:52:45
kumika	算法简单框架	#算法简单框架

#算法
     * 时间复杂度
     * X =  logA（N） （这里无法正确写出log公式）
     * A 是底数，一般2分查询的时候，底数就是2 ， 3分查询的时候，底数就是3
     * N 是元素的数量， 查询的元素数量是1000，那么N = 1000
     * X 是对数， 就是A的X次方  等于  N  ====》 A^ X  = N  ,在算法中X就代表 比较的次数
     *
     * eg:   5个元素数量，使用2分查询 最多比较多少次？  答案：X = log2(5 + 1)  = 3 ，算法中计算比较次数的公式： X = log底数（N + 1）

#排序算法

##快速排序Quick Sort



##归并排序 Merge Sort


#2分法


#双指针Two Pointer


#搜索Search

##深度优先搜索DFS


##广度优先搜索BFS


#回溯法

#动态规划Dynamic Programming




	2019-09-29 19:07:09
kumika	简单复盘数据结构	# 简单复盘数据结构

#数组Array


##Subarray问题



##前缀和Prefix sum



#链表LinkedList



#队列Queue



#栈Stack



#堆Heap



#哈希表


##开散列


##闭散列


#并查集 2叉树Binary tree


#字典树Trie




	2019-09-29 19:11:06
kumika	公务员考试总结	#公务员考试总结


# 1 认清自己

承认自己就是一个非常普通的社畜，没有任何资历，没有任何特长，不会在国考上出现什么突然灵感，然后成绩飞升。


#2 复习

##**重复是学习的必要条件**


##2.1重复知识点是重中之重

掌握知识点的几个阶段：
##1.模糊地知道这个章节在讲什么，有哪些知识点
##2.能够做做题的过程中用到公式，对应知识点的掌握
##3.知道一个题目里常用的知识点公式以及对应题目的转化
##4.用题目来搭建整个章节对应的知识点，以及特定的转化，并且知道本章节与其他章节联合出题


注意：
知识点的记忆
##一轮复习1第一招 你只是记住了知识的描述还是记住了真正的知识本身,而知识本身是几乎不需要记忆的，只需要理解。

**举个例子,椭圆的定义是平面内与两定点的距离的和等于常数k的动点P的轨迹. 如果你仅仅是记住了这句话没有任何用处,只有当你不停动笔画图,不断保持这个常数关系地描点连线，在这个过程中构建出了一个图像, 它就是椭圆。
如果你有了这个慢慢画图的过程, 那么这个椭圆的定义你根本不需要记忆,因为你已经理解了这个知识, 这句话只不过是某个人理解了椭圆后用他的语言压缩而成的文字, 所以椭圆的定义不一定是唯一的表述, 比如椭圆的第二定义。 
以上两种对知识的描述都是椭圆的定义，而知识的描述是无限的, 如果要记忆你永远记不完, 但是只要你画了图就完全不需要记忆了, 因为你自己都完全可以给椭圆一个新的定义.
再举个例子,数列求和中有个方法：裂项法,定义是是将数列中的每项（通项）分解，然后重新组合，使之能消去一些项，最终达到求和的目的。
如果你仅仅是记住了这个定义而不自己亲自动手计算几次,那么你下次遇到裂项的题目也肯定不会写. 这就是为什么老师讲一遍知识的描述,你以为你听懂了,然后遇到题目你又完全动不了笔的原因.**
##你产生的听懂知识的错觉其实是仅仅死记硬背住知识描述的感觉。

在一轮复习中的第一个误区就是: 误以为一轮的基础学习就是记住知识的描述.

##而我想讲的，针对这个误区的第一个学习策略就是: ***亲自动笔绘画,计算,处理,而不是仅仅记住了老师或者课本对于知识的描述*.**



##一轮复习中第二个优秀的学习策略：出题.
注意,这里的出题不是让你出历年高考压轴题那样严谨漂亮的题目,而是用你做题的反思路,用知识堆砌成简单的题目. 
这个方法之所以特别适用于一轮复习,就是因为一轮复习偏向于学习一级知识而并非二级结论,能变化和演绎的形式并不多,在你学习完一个知识后你完全有能力对它进行一个逆过程.

举个例子：
让你自己出题,就相当于逼迫你想已知条件之间的数学关系,为什么呢----因为出题就意味着必须有一问题,而问题由条件得来,可以看成是问题的答案是由两个知识点组合而来的, 
比如条件a b 组成起来得到结论c，
而往往条件和结论都可以互相转化：
条件ac组合也得到结论b, 
条件bc组合也得到结论a 
这个过程就逼迫你思考 abc三者互相转换关系,在这个思考中,也瞬间让你对这三个知识点的理解达到了最高层次.







#3建立错题集/随记本

笔记的本质（辅助思考和记忆）

##需要写入错题本的题目类型：
##1类：记忆性题目，没记住，忘了。
##2类：有思路，但是时间紧没做出来（慢，看答案梳理步骤流程，优化步骤流程，看完答案脑子里过一遍这道题的思路方法）
##3类：计算错误（提醒自己就好了，如果说是特定的计算步骤一定要加强）
##4类：完全没思路的题目（如果答案复杂，先不用管，不用越级打怪），看得懂答案照第二类进行。



**错题本强调做错题本的思维过程，思维你自己的思维路径的错误，自己知识点掌握的错误，这些错误不要再犯。**

做错题本的错误关键：
**Ａ**、**多问为什么**。                                           
做错题本关键的是思考错题这个过程，想想你为什么错了，错在哪，哪个知识点没弄明白，哪个解题技巧我还没学会。多在白纸上演算几遍就记住了。
**B**、**错题分类**                                                 
你要在脑子里分类。把知识点进行分类，把题目进行分类，把解题技巧进行分类，把错题经验进行分类。**标出“概念错误”“思路错误”“理解错误”“审题错误”等错误原因；**
**标出“错误知识点等”**。
**C**、**比较**                                                         
比较题目和解题思路共同和相同，还有不同，确定出事物的主要特征和次要特征。
**D**、**总结经验、题型，找寻联系**                       
归纳出解题思路，总结经验。抽象出新的、你没见过的解题技巧。抽象知识点的深层结构，题目的前后逻辑。总结题型做题经验。找寻知识点与知识点，知识点与题目，题目和题目，还有解题技巧之间的内部联系、规律。

比如
我在本子上只记录我犯错的原因，以及没有想到的或出错知识点。所谓犯错的原因，就是我之前举的例子那样，比如很多大题要讨论x是否等于0，我就会在笔记本上记“讨论x的取值”，没有想到的或出错知识点举个例子来说就是，有时候我会忘记一些小知识点，其实也是自己基础不扎实，我会忘掉0！是0还是1，于是我就会在错题本上记“0！=1”。


从做出的结果里面迅速提炼一些反馈信息，并找到快速有效的方法判断其是否合理。

知识点不熟练导致在解题中注意力无法集中，或者干脆没弄明白解题步骤。这种情况建议退回知识点学习的初始阶段，对定理进行推导练习，多推导几次，直到完全掌握整本书所有知识点的推导过程。
回顾推导过程，做完之后推导模糊的地方也要进行回顾，确保每个点都是清晰的。这样相当于每次练习都在进行推导，经常进行推导可以加深知识点之间联系的紧密度，学习新知识的时候，理解速度会提高很多。

掌握每个题型的解题步骤。
这是建立在绝对的熟练基础上的，一看到题目应该就立即想到分哪几步。



#4 什么是总结

![负熵学习者的学习状态.jpg](https://i.loli.net/2020/12/19/rQLe64tajnplNH3.jpg)

数据（Data）：相对来说是零散的，杂乱无章的
例如：**给你1000个从高中各科课本上摘录出来的知识点、公式、定理，堆在面前**

信息（Information）：在数据的基础上进行了初步的分类
例如：**你好不容易把这1000个知识点分类完了，有125个数学知识点，218个物理知识点，95个化学知识点……等等；**

知识（Knowledge）：在信息的基础上，建立了不同信息之间的关联关系
例如：**你对这125个数学知识点进行了排序，谁在前，谁在后，谁能推导出谁，谁是一级目录，谁是二级目录等；**

洞察（Insight）：在知识的基础上，能够发现若干个看似毫不相关的知识之间的相互联系
例如：**你觉得这个题我虽然没做过，但经验告诉你，如果用这个知识点和公式大概能行**
又例如：**你隐隐的感觉到物理学中的楞次定律，化学中的勒夏特列原理以及生物中的负反馈机制其本质是同一回事；**

智慧（Wisdom）：不止于洞察，而是成功地解锁了二者之间的一个可达路径，拨开了战争迷雾，成为一条新的经验，或者说智慧
例如：**你不再止步于求一次导数，终于第一次成功地运用了多阶求导的手段判断了原函函数F(x)的单调性，那这种方法对你来说就不再是思维盲区，你已经解锁了新的解题手段。**

事实上，我们在学习的过程中，老师能给我们的大脑输入的，是前三者：
大量的数据、
信息以及知识，
但你想要得到洞察以及智慧，是没有人能够给你。它需要你总结。


##总结具体说来是以下几种操作：
###1分类（classification）：最初级的操作
例如：**不同章节的错题放在不同的位置，或者把错误原因分成审题不清，计算错误，答题规范，知识盲点，思维定式，思维盲区等；**

###2排序（sort）：下一级的操作

例如：**对错题进行一星二星三星的标记，再来根据不同的难度使用不同的策略应对；**


###3索引（index）：高级操作，相当于图书的目录，即对大脑中的**数据块**（block）进行成块成块的编码，在调取知识的时候利用索引，形成**“定式”、“固定搭配”或者说“肌肉记忆”**

例如：**你看到一个题目立马就知道你要用什么知识和方法来解决它。**
你的大脑里充满了上面这样的黄色线条，也即解题快速通道。

#**总结的最大目的，或者说建立索引的最大目的，就是为了节省未来的时间！**


#参考：

作者：铁匠qwer
链接：https://www.zhihu.com/question/286143549/answer/1483536299


作者：信息
链接：https://www.zhihu.com/question/421510786/answer/1503647312


作者：罗生门竹林中
链接：https://www.zhihu.com/question/31405289/answer/687085545


	2019-10-10 12:50:17
kumika	资料分析复习总结	#资料分析复习总结

数量关系和资料分析的速算，一切想要快速计算，都遵循一个法则：
假设存在一个公式---对象A  = 对象B X 对象C ，那么所有存在对象A，B，C的公式，这些公式变形为对象A，B，C是积数、商的形式后，这些变形公式整体都可以代入这个公式进行计算（注意积数、商变量都要同单位类型）。**然后，题目所求的变量就存在在这些变形公式中，化简代入后的变形公式，就是速算的公式了。**

关键点：**题目所求的变量**和**题目给出的变量**之间**存在**什么**联系**什么**公式**

使用速算情况的判断： **题目没有明确**给出题目**所求的变量**





#分数速算

资料分析： 1 找数据对象，2 写出公式，3 计算，大方向的做题模式下，出题人最恶心人的方式出现在 1 找对象 和 3 计算这2个方向上。

其中3计算分数，是各种机构培训班给出各种技巧的根本原因。


所以，分数速算，是集合各种分数计算技巧的部分------**前提看选项（选项数值差距），再进行计算**

##基期增长量速算




1---直除倍数法（直除然后四舍五入）
**选项数值差距大的情况：**
$$
公式1  ： \frac{现期}{1+r} \times r 
$$
速算思路：
 1 + r = 1xx%   增长率转换结合到百分数上
 
现期（时间紧，就省略后几位） 除以 **1XX %**  得到  基期（粗略的值，保留1位数字）
$$
 \frac{现期}{1XX}  = A
$$
基期 乘以 增长率r 得到答案结果 
A X r 


2----**百分数和分数相互转换法（小于10%的时候）**

$$
 增长量 = \frac{现期}{1+ r} * r 
$$
这个公式里面的增长率r，因为小于10%，**所以转换成分数后，可以直接约分，使用直除法得**出答案
比如增长率r = 7.4% 约等于 7% ，又因为7% 约等于 1/14，所以得出：
$$
 增长量 = \frac{现期}{1+ \frac{1}{14}} * \frac{1}{14} = \frac{现期}{14 + 1}
$$


--------------------------------------------------------

**选项数值差距小的情况：**

出题人老头的思路： **增长率R在进行百分数转换分数过程中取近似值，其中取近似值会导致误差，这个误差在选项中体现出来**，选项给几个近似值计算出来的值，让你进坑还觉得自己做对了。

**例子： 35948 X 54.2%  / （1 + 54.2% ）**

选项： 12653 ，  12635

解析：
题目给出的选项的目的就是让你消耗时间在计算上，像只取1位数的直除法无法运用，达到反套路的效果。

头铁-----需要高精度的使用直除法，**必须分母截取3位数以上，商保留3位数以上**，这里例子必须要将35948与154的商取到3位数，不能只取1位数，不能达到快速速算，但是能达到精度。个人在考场上头铁过，但是会对后面的题目影响很大，后面做题时间会急剧压缩，不是上策，属于没有办法的办法。

技巧：
在选项差距小的情况下， 被除数 / 除数  ，**选项数值的差值，被除数与被除数近似值的差值，除数与除数近似值的差值，这3个数都相近，则可以进行保留2位数除法，不用高精度的保留3位数**，这样可以节省时间。


##截取数字
什么情况下，截取接近的数字，这个接近的数字是多少？
答： 看选项，选项数值差距是决定题目难度的重要元素之一，要是选项数值差距小，则是商要截取3位数字。



 
#分数比较

##4个分数之间进行大小比较

解决公式：

分子与分母的差值 A ，再把 A 换算表示为分母的**XXX %**, 含义就是---A 是 分数距离 1 的差值，是差了**XXX%** ，**百分数XXX%越大，分数越小。**

例子：
$$
 \frac{32}{33} ， \frac{98}{99} ， \frac{77}{78} ， \frac{53}{54} 
$$
$$
 \frac{294}{320} ， \frac{380}{420} ， \frac{817}{860} ， \frac{550}{580} 
$$
$$
 \frac{698}{699} ， \frac{198}{199} ， \frac{498}{499} ， \frac{798}{799} 
$$

#查找对象

对象1  根据题目条件1，经过多组数据分别计算得出结果，比较结果得出题目要求的对象，然后再根据题目条件2，计算出题目结果。

二级结论： 条件1的计算过程只需要计算2个数据对象，然后得出的结果进行比较，不会出现大量的多组数据计算（关键要记得相同量是可以约分约去的）

#年均增长量
##题型识别：
**年均增长量，年均增量，平均每年增长量**

公式：
年均增长量D = （末期量A - 初期量B ）/ 相差年数C



以下四种描述，都是给定时间段的之前一年作为基期（增量的平均数）

十一五期间，XXX年均增长

江苏的题目

2012~2016这五年，年均增长

**2016--2020，同比增量（增长量）的平均值**


以下四种描述，都是给定时间段的第一年作为基期

2000～2015年间，年均增长

从2009到2012年，年均增长

2016年到2022年，平均每年增长

2016-2020年，平均每年增长

---

平均数与年均增长量的区别：都是平均，但是一个有“增长”字眼，一个没有

年平均数：指各年份的值之和与年份数的比值;

年均增长量：指一段时间内某个指标平均每年增长的量。


例子：
【求年平均数】
2016年到2022年，全国平均每年普通本专科招生人数为多少万人?

【求年均增长量】
2016年到2022年，全国普通本专科招生人数平均每年增长多少万人?
2016-2020年，全国固定互联网宽带接入用户数平均每年增长多少万户?


公式：

①N年的平均数  （N年总和÷N）

②年均增长、平均每年增长…… （现减基，除以现期基期年份差）








#年均增长率--r

题型识别：年均增长率约为r





**(1 + r)^n  ≈  1 + （n * r ）** ====》此公式有前提选项的数值都 < 5,根据应用**泰勒二项式展开公式**，忽略第2项及后面的数据得到的

所以
$$
 \frac{1+a}{1+b} - 1
$$
已知A和B数量的条件下，使用的正规公式：
n为相差年份，X为所求的增长率

**末期量B = 初期量A *（1 + r）^ n** ≈ A（1 + n * r ）约等于右边的式子计算结果偏X，所以选择要数字相近且偏X的选项

公式变形：
已知B,n X的数量，求A
求A  = B / ( 1 + n * r ) 此时 （1 + n * r）在分母，因此计算结果偏X，所以选择要数字相近且偏X的选项


n的时间范围，因为题目可能会误导我，要注意是自然年个数，还是时间段区间
如计算2001~2004年间的GPD增长率，计算期间为2001~2002、2002~2003、2003~2004，n=3。
有的公式中n-1中的n，表示的是2001~2004年的自然年个数，2001、2002、2003、2004，n=4，n-1=3，实质是一样的。

具体的区分：根据**起算点**和**截止时间点**之间，总共经历过多少个完整年份进行确定

eg1：
计算2001的**年末**至2005的**年末**之间的年均复合增长率，总共经历了**4**个完整的年份，则开方数取4；（始点和终点一致）

eg2：
计算2001的**年初**至2005的**年末**之间的年均复合增长率，总共经历了**5**个完整的年份，则开方数取5。（始点和终点不一致）



72法则： 当现期是基期的2倍时，年均增长率约等于（72 / 年份差）% 《===》 B/A=2时，r=72/n%
115法则： 当现期是基期的3倍时，年均增长率约等于（115 / 年份差）%《===》B/A=3时，r=115/n%

##正常题目情况

简单类型：直接给出各年的增长率

正常类型：给出各年的数据，自己求增长量，然后计算增长率。
比如：
若已知2004年到2009年各年产量是：100、110、120、140、140、160，求2004-2009的年均增长率是多少？



#混合增长率

题型识别与判断考点：
题目给出的A，B，C这3个对象，**在基期/现期方面存在加减关系，**比如 A + B = C；并且知道ABC这3个对象其中2个对象的增长率，题目问剩下一个对象的增长率同比增长/减少。

一般可以使用现期量代替基期量，**但是增长率出现1倍以上，160%的增长率，超过100%的增长率时，就一定要计算基期，看谁基期大**。X倍= X00%，比如：X.5倍 = X50%

--------------------------------------------------------------------------------
居中法：
**核心要点----分量中谁的基期大，总量的增长率偏向谁，总量的增长率一定在2个分量的增长率之间，可以居中，但是会有偏向。**
已知A，B的增长率和基期，求C的增长率，其中A是总量，C，B是分量，**第一步**看谁基期大，判断出总量A增长率偏向谁；**第二步**看总量A的增长率与B的增长率相差多少，

已知A、B的增长率和基期，求A+B的增长率，要是A和B的增长率一样，看基期量，谁大答案的数值就趋向大的一方。


--------------------------------------------------------------------------------
十字交叉法 = 线段法：
A  &emsp; a    &emsp; &emsp; &emsp;r - b
         &emsp; &emsp; &emsp; &emsp; r       
B   &emsp; b &emsp; &emsp; &emsp;  a - r

可得出增长率：  
$$
\frac{r-b}{a-r} =\frac{A}{B}
$$

----

#间隔增长率
题型识别：出现3个时间点，比如2020年，2016年，2015年



**R：2020对比2015的增长率
R1：2020对比2016的增长率
R2：2016对比2015的增长率**

**公式：R，R1和R2时间实际上都可以不连续，只是题目没有这么出
R = R1 +R2 +R1*R2**

注意，公式R，R1 和R2 计算的时候是百分数，有百分号的，假设R1是7.7%，R是10%，当使用R2 = X代入的时候，是 10% = 7.7% + X + 7.7% X  ===》2.3% = 107.7% X  ，不是2.3 = 8.7X

R1 和 R2 其中一个或者2个的绝对值小于 10% 的时候，结果等于或小于1%，所以R1 X R2 可忽略不计。


#时间区间

2015---2018年的哪年增长量最大（变换题目的话，随便一个量）
是要计算上2014---2015年的增长量的。


2012--2016年，XXX平均每年较上年增长----相差年份是2016-2012 = 4；没有特别说明求增长量的，就直接是2个年份数相减。

“江苏卷”，在做江苏卷的年均增量相关题目时，初期值和初始年份都要向前推1年;其二是“五年规划”，本次五年规划的末期值-上次五年规划的末期值，相隔年份也就变成了5年。



#平均数

a除b是b÷a，a除以b是a÷b。
除表示除数除被除数；除以表示被除数除以除数。“以”字的意思就是“用”“拿”。
8÷2=4，这道除法题用“除和除以”可以描述为2除8等于4或者8除以2等于4。


考点识别：问题中一般会有平均(人均、月均、年均、户均)、每、单位，单价，AB型2个不同单位。


**平均前后 = 后 / 前 = 后除以前 = 前除后 = 前分之后**


**平均BA = A÷B**

例子：5个苹果，100元，每个苹果的平均价格===》元 / 个数（个数在前，价格在后）
 
没有出现“均，每”等字，出现亩产，单位面积产量等词时候-----**2个不同的单位相互连接在一起比如AB就属于数学上表示A除B=B除以A，中文表示AB=亩产=亩除产量，单价=元/个数，第一个单位是分母，第二个单位是分子；**


##平均每

要知道哪个是分母，一个口诀： 平均每后面第一个对象就是分母 OR  平均每前面第一个对象就是分母

**简单点： 每后（包括平均每），均前都是母，无论说什么只看单位**



##平均数的对象
平均数在题目中的对象

**B均A = A/B = B分之A，这就是平均数**

##平均数的考点：

题型识别：问题中一般会有平均(人均、月均、年均、户均)、每、单位。

平均数的计算形式也是A÷B，但是到底哪个是A哪个是B你能瞬间看出来吗？往下看：

基本公式：

所求平均数=“后”÷“前”，即用问法中后出现的词，除以先出现的词。


---
明显的考点：**题目中有平均（人均，月均，日均，年均，户均），每。而且是先有平均数，后求增长率。**
隐藏的考点：题目没有给出“均，每”等字，给出了亩产，单位面积产量，就是考察除数算法里面中文的文字表达：AB=A除B=B除以A，




**有平均每等字，分母则是：均前每后；
没有平均每等字，分母则是： 前母
如果2个对象单位在平均每之间，则按照2个对象单位的位置来计算：后 /前，后面的单位除以前面的单位，分母则是：前面的单位**
核心：后/前（后除以前）
例子：2014年每实现100万元的社会物流额，其运输费用平均约为多少万元？

**题目B均A，平均数就是A/B ，增长率a和b
平均数的现期： A/B
平均数的基期： 【A/( 1+ a) 】 /【B / (1+ b)】
平均数的增长率： (a-b) / (1+b)；两期增长率比较的分母：比A平B**

题目是平均XX是平均YY的多少倍，直接列出分数，然后计算。


特别考点： 题目出现平均每人每月，则是分母是人数和月数，**“每后”的都是分母。**



##平均数的增长率


平均数增长率定义：平均数的增长率

题型识别：题干问法中要同时体现平均数、增长率两层含义，题目出现的字眼：平均每，与上年的增长率比较，比上年同期增长等等。

要点：
【1】两个时期做比较：与上年相比、同比、……

【2】题干相关词汇：平均每、单位、均、……

【3】百分数：增长(减少)了百分之几、增速、%、……

例子：
【例1】与1978年相比，2008年平均每个卫生机构的卫生技术人员数约增加了百分之几?

【例2】2012年棉花单位面积的产量同比增速为百分之几?

【例3】2010年10月入境旅游人均消费支出同比增长了百分之几?


注意要点：
第一步：根据均前每后，AB，A除B，B除以A，判断出分子分母，找出增长率a和b，注意a和b是上升还是下降，是正还是负。

第二步：代入公式-->(a-b)/(1+b),这里的a和b是以百分数形式，1 = 100%



下面是推导过程：
假设已知**平均数A和B都是现期，平均数A的增长率是a, 平均数B 的增长率是b，**
$$
平均数增长率 =\frac{现期平均数-基期平均数}{基期平均数}\quad  = \frac{现期平均数}{基期平均数}\quad -1 
$$

所以得出----**现期平均数÷基期平均数-1**，代入平均数A和B，平均数增长率a和b得出下面公式

$$
\frac{ \frac{A}{B}}{\frac{\frac{A}{1+a}}{\frac{B}{1+b}}}\quad -1  =\frac{\frac{A}{B}}{\frac{A}{B} \cdot \frac{1+b}{1+a} } - 1
$$
化简得出
$$
 \frac{1+a}{1+b} - 1
$$
最后得出
$$
 \frac{a -b}{1+b} 
$$

###现期平均数

题目识别：问题时间与资料一致 +  平均（均/每/单位）

公式：
$$
 平均数 =  \frac{总数}{个数} 
$$

###基期平均数

题目识别：问题时间与资料之前 +  平均（均/每/单位）

公式：
$$
\frac{A}{B} \cdot \frac{1+b}{1+a}
$$


###两期平均数

题目识别：题目中涉及两个时间 +  平均（均/每/单位）

公式：
$$
平均数的增长率 =  \frac{a -b}{1+b} 
$$


##平均数的增长量

公式与2期比重公式一样

$$
\frac{A}{B} \times \frac{a-b}{1+ a}
$$




#倍数

2个有联系的指标对比出来的相对数

A是B的XX倍   ====》A/B
增长到X倍，表示是多少倍，比如增长到5倍，就表示原来X，现在是5X。


A 比B 增长多少倍 ====》（A-B）/B 或者写成 A/B - 1
增长了 = 增长，都是表示比原来多，比如原来是X，现在增长3倍，现在是X+3X = 4X。

增长/多XX倍，这是求增长率，增长率r = 倍数n - 1 ===》r = n -1； n = r + 1。

增长/扩大X倍 = 是X + 1倍，比如增长/扩大了3倍 = 是原来的 4 倍 = 现在是 4倍。



A是B的5番 《====》A = B X  （2的5次方）
A翻了XXX番 = A X 2的XXX次方


##现期倍数与比值

题目识别： 问题时间与资料一致，A是B的多少倍

公式：
$$
 倍数 =  \frac{A}{B} 
$$

##基期倍数与比值

题目识别： 问题时间与资料之前，A是B的多少倍

公式：
$$
\frac{A}{B} \times \frac{1 + b}{1 + a}
$$





====================================================================================

#同比和环比

##同比

同比：本期与同期做对比

###题目识别


公式：
同比增长率=(本期数-同期数)÷同期数×100%。
$$
同比增长率=\frac{本期数-同期数}{同期数}
$$


##环比

环比：本期与上期做对比

###题目识别

公式：
环比增长率=(本期数-上期数)÷上期数×100%。
$$
环比增长率=\frac{本期数-上期数}{上期数}
$$

##同比增率和环比增率关系问题

重要结论：
**某月同比增长率大于上月，则该月环比增长率大于上年同期月份的环比增长率；
某月同比增长率小于上月，则该月环比增长率小于上年同期月份的环比增长率；**

具体考法：
已知今年各月份的同比增长率，问今年环比增长率（增速）大于上年同期的月份有几个月？

示例：2019年5月同比增长5%，2019年4月同比增长4%，则2019年5月的环比增长率大于2018年5月的环比增长率。


====================================================================================

#比重

题型识别：占，比重，**贡献率（部分与整体的增长量比值），利润率（利润/收入；利润/成本），产销率（销量/产量），**


**A占B**


##比重题目类型识别


###现期量比重
题目识别：**现期时间 （问题时间与资料一致）+ XXX比重**

考点变形：
已知整体与部分所占比重，计算部分；
已知部分与其占整体的比重，计算整体。


**需要题目哪些已知量：
简单题目---2个对象的现期量，共2个变量
进阶题目---2个对象的基期量，增长量，增长率**，共4个变量或者6个变量


一般公式推导：
$$
\frac{现a}{现b} \quad = \quad {基a + 增长量a\over 基b + 增长量b}\quad = \quad\frac{基a \cdot（1+增长率a）}{基b \cdot （1+增长率b）} \quad = \quad\frac{增长量a \cdot（1+ \frac{1}{增长率a}）}{增长量b \cdot （1+\frac{1}{增长率b}）} \quad  
$$

---------------------------------------------------
###基期量比重


基期比重类型识别： **基期时间（问题时间在资料时间之前） + XXX比重**

**需要哪些已知量：
简单题目---2个对象的基期量，共2个变量
进阶题目---2个对象的现期量，增长量，增长率**，共4个变量----多数情况使用**现期量和增长率**
$$
基期量比重  = \frac{现期量A}{现期量B} \times \frac{1+b}{1+a}
$$
一般公式推导：
$$
\frac{基a}{基b}\quad = \quad {现a \times (1 + 增长率b) \over 现b \times (1 + 增长率a)}\quad = \quad \frac{增长量a \times 增长率b}{增长量b \times 增长率a}\quad = \quad \frac{现a - 增长量a}{现b -增长量b}
$$



计算时均可先计算A/B的数值（观察选项，截位除得1位或2位），然后利用后方数值与1的大小关系结合选项判断答案，当无法锁定答案时，可将后方数值计算到小数点后1位，即0.几或1.几，然后与前方A/B数值相乘即可。当然若前后存在一些明显的约数倍数关系，亦可考虑左右进行近似约分~




###2个比重差
题目识别： **2个年份时间** + **XXX比重 比  YYY比重 高/低 多少**
需要哪些已知量：（6个）
现期量：整体量B，部分量A，C，
ABC的3个增长率


题目： 基期比重差一般使用的公式是
$$
\frac{现期量A}{现期量B} \times \frac{1+b}{1+a} - \frac{现期量C}{现期量B} \times \frac{1+b}{1+c}
$$
这个公式需要已知**4个现期变量**，但是进阶题目会把其中的2-3个变量隐藏在题目中，不是直接给出数值，隐藏的方法----**关注题目给出的变量之间的关系式（表格中也可能有）**，需要的现期变量是根据题目给出的加减关系得出来的。
21
其中这类进阶题目会给出**特别长的词**，这时候只需要画出来，然后**使用ABC或者语文，数学等名词代替**就可以了。


---------------------------------------------------
增长量比重
增长量比重类型识别：
现期增长量比重：
需要哪些已知量： 现期量，基期量，增长率

基期增长量比重：
需要哪些已知量： 基期量的基期量， 现期量，基期量，增长率




一般公式推导：
$$
\frac{增长量a}{增长量b}\quad = \quad \frac{现a - 基a}{现b - 基b}\quad = \quad \frac{现a \times 增长率a \times (1 + 增长率b) }{现b \times 增长率b \times (1 + 增长率a) }\quad = \quad \frac{基a \times 增长率a}{基b \times 增长率b}
$$

---------------------------------------------------
增长率比重
增长率比重类型识别：
现期增长率比重：
需要哪些已知量： 现期量，基期量，增长量

基期增长率比重：
需要哪些已知量： 间隔增长率，基期量的基期量和基期量，现期量，基期量，增长量



一般公式推导：
$$
\frac{增长率a}{增长率b}\quad = \quad \frac{(现a - 基a)\times 基b}{(现b - 基b)\times 基a}\quad = \quad \frac{增长量a \times 基b}{增长量b \times 基a}\quad = \quad \frac{增长量a \times (现b - 增长量b)}{增长量b \times (现a - 增长量a)}
$$

---------------------------------------------------









##2期比重差值（基期和现期）

###题型识别：
**比重（2个不同时间+占比）+上升/下降（增长/减少）+ 选项有关键字--百分点**

① 判断比重变化的方向

②**数值可直接猜最小的**，或验证，**答案（百分点）远小于|a%－b%|**

比如：
选项均为两组上升下降＋百分点，数值较大的那组百分点的数值，大多都是部分增长率a%与整体增长率b%做差之后的差值，但是实际上答案应远小于该数值

###公式


**2期比重差的公式： 这个公式是计算两个比重之间的差值，现期比重 -  基期比重。**只是描述这个公式的变量是现期量和现期增长率。

该公式需要题目**已知4个变量： 2个现期量，2个现期增长率**


X是现期整体（数字大）的变量
Y是现期部分（数字小）的变量
a是Y（数字小）的增长率
b是X（数字大）的增长率

$$
推导过程：\frac{Y}{X} - \frac{\frac{Y}{1 + a}}{\frac{X}{1 + b}}  = \frac{Y}{X} - \frac{Y}{X} * \frac{1 + b}{1+ a} = 最终公式\frac{Y}{X} *\frac{a - b}{1+a}  
$$


**2期比重差值（基期和基期）----这样的题目本质就是求2个不同的2期比重差，然后再相减**
需要题目**已知8个变量： 4个现期量，4个现期增长率**






**2期比重的速算**

-------------------------------

##2期比重变化比较类型

题目识别： 2个时期（年份）**利润率**比较升高下降（或者**其他分数类型比较---也看作比重类型比较**）或者上升下降/提高降低XXX个百分点。

题目表现表达： XXXX年与YYYY年相比较，**利润率**是上升了还是下降了？改变多少个百分点？

需要题目**已知4个变量： 2个现期量，2个现期增长率**，但是因为**现期量比重和1+a的数值都是大于0，**所以上升下降正负都取决于分子**a - b**,--------》一般做这类题直接判断**a - b的值**，然后得出结论推导出答案。
$$
\frac{A}{B} *\frac{a - b}{1+a}  ==》只看a - b，不放心就把A和B代入公式算
$$

所以结论：
部分的增长率高于整体的增长率，比重上升；反之，下降。
即a%＞b%，则A占B的比重（A/B）上升，反之，下降。
**①直接猜数值最小的（准确率较高）；**
②**百分点一般远小于|a%-b%|**（因为你要乘上A/B ，也就是说要乘上0.几）。



2级结论：
1 利润增速大于收入增速（a - b > 0），利润率上升，反之（a - b < 0），利润率下降。

2 上升或者下降的结果 《《《《利润增速和收入增速的差值的绝对值

3 **比重差一定小于2期增速差的绝对值|a - b|**   《=======》 **上升或者下降的百分点 < |a - b|**

4 如果出现两个选项都小于 |a -  b| ，**选择最小的选项。**


-----
2级结论：


1 比重中出现百分比和具体数字，可以直接使用百分比进行计算得出结果。

2 当题目提问的对象在材料中没有直接表明（找不到）的时候，说明是同义词转换，此时变通一下，找类似意思的对象。

3 当题目找不到你要找的数时候，考虑材料中给出的关系公式里面的变量，与题目提问中的变量是否有关系，有关系就代入公式里面。

4  **比重差一定小于2期增速差的绝对值|a - b|**





--------------------------------------------------
##2期比重差和平均数的增长率区别

**题型识别：**
2期比重差： 2个不同时间+ **占比** + 比较大小 + **选项有关键字--百分点**----比重题目是A占B，A比B，A是部分，B是整体
需要题目给出**4个已知量： 现期量A，B，增长率a，b**



平均数的增长率：  2个不同时间+ **平均数** + 比较大小+ **选项有百分号**----平均数题目是 B均A，每BA，BA 
需要题目给出**2个已知量： 增长率a，b**


**通过a%和b%入手，比重差值远小于增长率的差值，平均数的增长率一般略小于增长率的差值（b%＞0的时候）。**





分子都是**a -b** ， 分母有区别，**平均数是1+b ,比重是1+a**

**平均数：B均A，每BA，BA**
$$
\frac{a - b}{1+b}
$$
当平均数增长率没有给出a和b 的增长率的时候，求出a 的增长率，估算b的增长率，然后判断选项。

**比重：A占B，A比B，A是部分，B是整体**
需要题目给出**4个已知量： 现期量A，B，增长率a，b**
题目材料给出的A占B，可以是分别给出A和B的现期量，也可以给出A占B的现期比重是C%，也就是A/B = C%
$$
\frac{A}{B}  \times \frac{a - b}{1+a}
$$


相同点：
增长率a 和b代入公式的时候都要注意**正负号**，**下降是负号**。

---------------------------------------------------
##比重的增长率（乘积增长率）

比重的增长量

比重的基期，现期


---------------------------------------------------
##比重的逆应用

①利用已知的现基期比重，判断部分增长率和整体增长率的大小关系；

题目识别：已知比重上升/下降，题目问部分增长率/增速/增幅与整体增长率/增速/增幅之间的关系

思考过程只涉及4个变量：分数：现期和基期的比重，2个百分数：部分和整体的增速，实际上题目只出现2个变量---现期和基期的比重

推理思维思路：部分增长率》》》总体增长率，推出基期和现期比重的结果是上升，现在要求反过来从2个比重相比，结果是上升反推出部分增长率》》》总体增长率





②利用已知的现期比重，部分和整体的增长率，判断基期比重的数值大小；

题目识别：题目问基期比重大小


推理思路： 已知现期比重，部分和整体增长率，根据题目给出的部分增长率 《 整体增长率，推出现期比重对比基期比重是下降的，所以基期比重数值 》 现期比重。

快速解决：直接就是找XXX对象的现期比重，部分增长率，整体增长率。



③利用比重差值公式（计算百分点那个），求部分的增长率。

题目识别：问部分的增长率


题目给出两期比重差，整体增长率，现期比重，代入下面的公式（其中1 + a%这个分母一般可直接看作 1 ）

两期比重差数值 = 两期比重差公式





---------------------------------------------------

#现期，基期，增长量，增长率

**现期量： 基 X（1 + r）= 增长量 + 基 = 增长量 X (1 + (1/r))
基期量： 现 / (1 + r) = 现 - 增长量 = 增长量 / r
增长量： 现 - 基 = 现 X r / (1+r) = 基 X r
增长率 r ： （现- 基） / 基 = 增长量 / 基 = 增长量 / 现 - 增长量**

=============================================================

##基期和基期量：


**基期**定义：是一个时间的概念。指的是基础期、起始期，即起始时间。
题目识别：2017--2022，问2017年


**基期量**定义：指的是起始时间的数量。----在统计学上，基期量即是一个基数。基期量一般作为参照基数，其它时间段的数据都参照这个基数，计算增长率等。
题目识别：2017--2022，问2017年的斗鱼引资项目有XXX亿元？



###题目识别
问题中涉及到的时间一定为材料中已知时间的基期（通俗一些：已知今年的萝卜价格，求上一年的萝卜价格，给现在，求过去）

计算基期量的题目，材料中通常已知现期量和对应的增长率。

具体的考法问法：
①计算基期量

②基期量做差

③基期量大小比较




###基期速算：

当r ≤ 5% 时， 
$$
\frac{A}{1 + r}  =  \frac{A （1 - r） }{1 - r^2} = A - A*n （n是r的去百分号形式，当r ≤ 5 时，使用）
$$

已知现期和增长率r的2个基期比较
 $$
\frac{现期1}{1 + r1}  - \frac{现期2}{1 + r2} 
$$
通分成分母一样，**分子根据分子是分母的XX倍数增加或者减少分母的倍数数值**进行加减，然后计算分数，本质还是遵从分数计算，只不过牺牲准确性，提高速度


**基期比重速算：**
已知条件 现期量 A 和 B  现期增长率 a 和 b，求基期比重

 $$
\frac{A}{B}  \times  \frac{a - b}{1 + a} 
$$
方法 ：A/B这个分数仔细算，后面的估算比1大还是比1小；**当A/B这个分数的分母大于分子的时候**，可以**把分母化成1%的数值**再与分子进行直除法运算，算出**分子占多少个1%**。

当选项差距小的时候---最稳健的还是直除法




================================================================

##现期：

现期定义：相对于基期而言，指的是其它时间段。
题目识别：2017--2022，问2022年

现期量定义：即其它时间段的数量。与基期进行比较的时期的数值。
题目识别：2017--2022，问2022年的斗鱼引资项目有XXX亿元？

###题目识别



###现期比重加减速算：
**核心是分数加减速算**

方法： 直除法，重点能忽略几位数和快速约分







================================================================

##**增长率：** 
识别词语：同比增长XXX %


增长率定义：
**一定时期内某一数据指标的增长量与基期数据的比值。
时间序列中报告期观察值与基期观察值之比减1 后的结果，用%表示。**

题目识别：XXX年 XX项目，同比增长/下降 XXX%。



###题目识别
满足3个条件：
1 问题中出现明显的2个时间相比
2 出现关键字：增长，减少，上升，下降，升高，降低，增速，增幅
3 选项一般都有百分号“%” ，百分之几



相对量，无单位(百分数)，一般用最快最慢来形容

唯一计算公式---

 $$
增长率 = \frac{现期量 - 基期量}{基期量}  =  \frac{增长量}{基期量}  = \frac{增长量}{现期量 - 增长量} 
$$

只能用这几种公式，不然题目给出的条件不够，比如 增长率R2022 - R2021 ，其中R2021是需要知道2020的数值，并且把2020的数值作为基期，但是一般题目给出的条件是2021的数值作为基期，所以2020的数值是基期的基期，这是不符合题目设计的。**所以 增长率A - 增长率B   这类似的想法是行不通的**



###现期和基期增长率


###题目识别
题目给出一个增长率后出现“增速，增幅”+“高，回落”的字眼






计算现期或者基期增长率通用公式：

基期增长率  = 现期增长率  **-**  增长率增量（减号是不变的，增长率，增量都带有正负符号，这正负号是根据题目给出的增长率增量表达方式而变化）（一般求基期使用此公式）

现期增长率 = 基期增长率 + 增长率增量（此公式为上面公式的变形，一般求现期）

注意：要是题目提到降幅，则要现期或者基期提取绝对值计算，并且在公式结果前面加上负号。

增长率表达方式：
**正数值：扩大，提高，增长，增加，提升，回升，加块**


**负数值：下降，降低，减少，收窄，放缓，回落，减慢**



比如：
第1题：2022年收入XX万元，同比**增长** 10%，增速(增幅)比去年**提高** 5 个百分点，则2021年的增长率？
10 % - （ + 5% ） = 5%

第2题：2020年收入XX万元，同比**增长** 10%，增速(增幅)比去年**回落** 5 个百分点，则2019年的增长率？
10%  - （ -  5%） = 15 %

第3题：2018年收入XX万元，同比**下降** 10%，增速(增幅)比去年**回升** 5 个百分点，则2017年的增长率？
-10%  - （ +  5%） = - 15 %

第4题：2018年收入XX万元，同比**下降** 10%，增速(增幅)比去年**回落** 5 个百分点，则2017年的增长率？
-10%  - （ -  5%） = - 5 %

第5题：2016年收入XX万元，同比**下降** 10%，**降幅**比去年**扩大** 5 个百分点，则2015年的增长率？
 | - 10  | - （+ 5%） =  5 % ，然后计算结果加一个负号可得最终结果：   **- 5%**

第6题：2014年收入XX万元，同比**下降** 10%，**降幅**比去年**收窄/回落** 5 个百分点，则2013年的增长率？
 | - 10  |  - （ -  5%） = 15% ，然后计算结果加一个负号可得最终结果：   **- 15%**


现期和基期增长量计算小结：
需要哪些已知量：



###平均数增长率


###题目识别
平均/平均每/单位 ＋增长/减少＋选项是x%（一定要%，不是百分点）

直接套公式：（a%－b%）÷（1＋b%）
根据公式（a%－b%）÷（1＋b%），
**当b%为正数时**，分母**（1＋b%）**略**大于** 1，最终结果数值会略**小于**|a%－b%|，
**当b%为负数时**，分母**（1＋b%）**略**小于** 1，最终结果数值会略**大于**|a%－b%|
So，最终答案都在（a%－b%）附近，由于增长率大多是正数，故答案一般略小于增长率的差值。

（a%－b%）的结果如果是正数，平均数增长率是上升的；如果是负数，平均数增长率是下降的。


通过a%和b%入手，比重差值远小于增长率的差值，平均数的增长率一般略小于增长率的差值（b%＞0的时候）。

只有2个变量进行计算 平均数分子的现期增长率 a，平均数分母的基期增长率 b
$$
\frac{a - b}{  1+b}
$$

为什么只有增长率，没有平均数？

因为增长率计算公式，把平均数约去了。


###2级结论
-------------------------------------------------------------------------------


1 比较**增幅，涨幅，有个幅字的**===========》说明要求的量是**增长率**。

2 题目问增长**最快**，**速率，增长速度（增速）**===========》说明要求的量是**增长率**

3 题目问**增幅（有幅字的），增速，增长率---XXX变化最大最小**==========》说明要求的是**增长率的绝对值大小**


4 求基期量，已知现期增长率同比上升XX ==》 1+XX%，同比下降XX ==》  1-XX%，回落XX是 现期增长率+XX%。 

5 求基期增长率，已知现期增长率XX，同比增长YY，==》基期增长率 = XX+YY； 同比下降YY====》基期增长率 = XX-YY


6  增速回落----增长率没有去年同期高**（以去年的增长率为标准，低于则是落，高于则是升）**，比如，去年8月增长率是20%，今年增长率是10%，所以是增速回落10%。
再比如：2020年同比增长16%，增速回落29%，这里的增速回落是指2019年的增长率是29+16 = 45%，推出2019年的增长率是45%。



增长率比较大小：

多数使用的是现期和基期的比较，本质为分数的比较，后面的1可以忽略
$$
增长率 = \frac{现期 }{基期} - 1 
$$

情况1 ： 当现期是基期的倍数的时候，

情况2：  当4个选项 的基期相互之间差值都在100以内，可以看现期和基期的差值，差值越大，增长率越大。


情况3： 4个选项的分数，分母相互之间差值都超过100，只能用直除法了。

情况4： 4个选项的分数，分母相互之间差值都超过100，并且分子大于分母，此时可以反过来除，然后找最小的分数，此时就是增长率最大的。


情况5： 4个选项分数都很接近，提1法：$$
  \frac{6.99 }{5.67} = 1  +\frac{1.32 }{5.67}  或者 \frac{17779 }{18104} = 1 -  \frac{325 }{18104} 
$$


================================================================
##**增长量：**

题目识别： 同比增量，增量···


绝对量，有单位(增长或增加+单位)，一般用最多，最少来形容


题目问增长**最多，最少，多少**，**大小**===========》说明要求的量是**增长量**

题目给出现期，增长率，问同比上升或者下降，则是问增长量


###增长量速算：

第一种：倍数法
$$ 
增长量 = \frac{现期 }{1+r} * r = \frac{现期}{\frac{1}{n} + 1} *  \frac{1}{n }= \frac{现期}{n + 1}（n分之1就是增长率r的分数形式）
$$
----处理已知变量是现期和增长率的情况，过程是现期 / 100% + r 的商 乘以 r不要百分号的绝对值 （商小于1的时候，看选项是否有小于r的绝对值，有就选，没有就GG） 得出的结果，**判断选项哪个与结果数值接近，就选哪个。**

第二种：树状法--2分法---假设分配
根据题目给出的的 r %，换成比例100 ：r ，然后根据这个比例，以100为主**，100乘X倍数分解现期**，100乘X倍数的积数超过现期，**则100乘（X - 1）倍数继续分解**，当分解现期到**不足100时候，使用10：0.r** 这个比例进行分解。


###增长量大小比较

口诀：大大则大，一大一小看倍数

①大大则大：2个对象的增长量增长率比较，现期量和增长率都大于另一个对象，则增长量一定大

②一大一小看倍数（乘积），分别计算两者现期量之间的倍数关系与增长率之间的倍数关系（计算倍数关系的时候，无所谓谁是分子分母，只要倍数最大的那个），锁定倍数关系明显大的那一组（如现期量是5倍关系，增长率是3倍关系，就看现期量），其中数值大的（在刚才的例子中就是现期量），增长量大。
现期量倍数大，则是产量的大小判断决定增长量大小
增长率倍数大，则是增长率的大小判断决定增长量大小

比如：
蔬菜产量500T，增长率5，水果产量100T，增长率8，产量倍数（5倍） 大于 增长率倍数（8/5 = 1.6倍），此时是产量的大小判断决定增长量大小，500 》 100 所以蔬菜增长量大。



③友情提醒：当增长率较大时（50%以上吧），此时回去老老实实计算增长量，别用口诀判断，当然这样的数据考试中出现的比较少啦，别担心~）

---
齐麟的方法：
n分之1就是增长率r的分数形式的快速转换：
1  对于增长率在4% -----7%区间内的百分号转换分数的快速转换：该百分数X2，结果在进行转换分数，分数X（1/2）的结果就是4%------7%区间的转换结果

2 对于小于增长率4%的区间，该区间内的数X10 ，得到的结果进行转换分数，分数X（1/10）的结果就是小于4%区间的转换结果。


==============================================================

2级结论：

 1. 综合题从D---》C----》B---》A ，计算难度优先级：加减 》》》 乘除
 2. 任何名称+率===》代表这对象是分数，分子是，分母是
 3. 4个分数比较大小， 选3个分母大小不一致的比较，分母越大，分数越小，此时进行3个排列，根据题目要求选最大OR
    最小的，与最后一个分数比较。
 4. 
 5. 增长率r 在百分比与分数之间的快速转换:  $$ \frac{1}{1000} $$
    =0.0001 = 0.01%,就是加够了0，然后在前面加0.就对了。


 6. 2个超过10%的百分比数相乘，结果》10%， 2个百分数要是其中一个《10%，结果就是《10% 

 7.  当题目给出的数据无法直接使用的时候，一定在逻辑公式上设置转弯点，此时要列出逻辑公式，**根据题目给的数据逻辑词和材料中给出的数据逻辑词，看是不是符合逻辑公式，是不是逻辑公式的变形**，是变形就直接根据数据计算。
 
 9. XX较YY，用分数表示： XX/YY 
 
 10. XX与YY的比值，用分数表示： XX/YY

=====================================================

待验证的一些2级结论：

1 直除法的快速估算：
 分子/分母 ，分子和分母分别增加X%和Y%（X,Y《 10%），此时估算是以分子为底数，用X加减Y，最终结果误差不大。
 

2 每篇资料的最后一道综合题，从B开始--》C--》D ---》A，自己的是从CDAB；要是选项中要全表格算干净的选项就排除先，算其他的选项争取时间。
网上比较好的顺序是D----C----A----B，


**现在自己是：----D----C----A----B，在这些DCAB中要是有加减乘除的计算，优先计算加减的（比如D是乘除，C是加减，先算C），查找对象数值是可能出现的题型**

时间（时间范围，区间），主体对象（全国，某省···**前缀有范围的对象**很容易忽略），

3 在10%以内转换成分数的快速方法

4 最后一题的选项中的对象，在题目材料中找不到，大概率是A对象的互斥对象非A，此时只有用大集合U - A = 非A，大集合U是全国XX的对象之类的，大范围对象。


5  选项数值差距大，资料中增长率之类的在0.XX的，可以忽略不计算。

6  在2期比重题目中，在知道增加或者减少后，选最小。

7   接近的标准是
看分母A1与分母A2的差值A3 <==>A1-A2 =A3，
分子B1与分子B2的差值B3 <===> B1-B2 =B3, 
**如果B3 > A3，则是分母接近，分子越大，分数越    
如果A3 > B3，则是分子接近，分母越大，分数越小。
$$ \frac{B1}{A1} ,\frac{B2}{A2} $$
 总结：分子接近，大小判断看分母；分母接近，大小判断看分子。**


===================================================================

#题目类型分析和分类与坑

1 文字材料提供X变量，图表材料提供Y变量，然后根据相关公式带入X与Y，其中更加难的难度的就是X变量是由文字材料a和b这2个变量根据相关公式计算得出，Y变量是由图表材料c和d这2个变量根据相关公式计算得出；总结就是**函数f{x,y}计算得出的正确答案，前提是需要计算函数f{a,b}，函数f{c,d}得出X和Y，一共需要逻辑计算3次。**其中函数计算多数是乘除法，出现的关系有：比重，现期，基期，增长率，平均数

2 坑：XX较YY，用分数表示 XX/YY ，较后是分母

3 坑： 材料给出的变量名称与题目要求的变量名称不一致，或者是参数名称不一致。

4 材料在X和Y关系公式上不给1级公式，给2级公式（直接给出关系公式是1级，根据文字推导出来的都是2级公式），比如超标和达标，总=超+达，但是材料不写明题目要求达标或者超标，不读懂题目的话会迷惑卡壳找不到数据。

5 在2级函数下，现期基期，增长量 是加减法的函数，比重，平均数，增长率是乘除法的函数。

6 坑：材料中给的1级公式是比重，但是公式名称为平均XXX，题目中要求2期比重，但是名称是2017相较于2018的平均XXX，是增加还是减少多少，此时时间紧的会迷惑人使用2期平均数比较公式，实际上要使用2期比重比较公式这是个坑。

7 分析和坑：资料分析关系公式理论最多极限是7条公式，

    1级公式是题目要求的**f[X1,Y1]**，
    2级公式是函数**f1[X2,Y2]**，和**f2[X3,Y3]**，
    3级公式是**f3[X3,Y3],和f4[X4,Y4]**，
    4级公式是**f5[X5,Y5],和f6[X6,Y6]**

（此时X1到X6和Y1到Y6可能是自变量也可能是因变量，具体关系是加减乘除关键看材料给的是4样中哪一样）
现实中不可能这么变态，浙江最多是5条式子，其中3条是一个概念的公式，这类题目突破点是参数的单位和总量的单位。

8 迷惑名称类题目----

平均后面有2个不同单位，或者是2个不同单位中间有平均，此时才是使用平均数公式，不然就只是单纯一个变量。

材料中有平均XXX（A与B的比重），抽象出来就是X定义(Y定义)，此时是要括号内的公式为准，题目中使用平均XXX是为了迷惑考生，时间紧高压下很容易就使用X定义了，很容易误导导致做错，所以要记得以括号内的定义为准。


9 百分比转换分数

 1---20的分数转换成百分比

=========================================================================

#资料分析第五小题

综合分析考查的唯一能力：能否通过扫一眼选项，大致判定知识点和难易程度，如果你能做到快速判断，那么题目一定做得很快。

综合分析一定不是一道“死算”的题目，而是考查你能否高效的选出本题答案，避开复杂选项和陷阱。


##①验证顺序：
**倒序验证，DCBA**；（国考的话正序倒序没啥影响，各省省考切记倒序）

相对来说，在省考中综合分析题目选择C、D两个选项的概率高于A、B，故倒序验证可以更快速的找到正确答案，且避免跳坑（陷阱会更容易设置在A项）。




##②“习惯”跳过

验证DCBA时专挑软柿子捏，**碰到不会的、计算量大以及没找到数据不知道怎么算的选项**都**优先跳过**，要相信，一定可以通过简单选项选出答案。

2023年开始反培训思维，建议优先看前面4题没有选过的字母，记住，是第一优先级，假如不会，直接跳过，开始选简单的选项。



##③改掉强迫症

从节约时间的角度考虑，选出答案后不要继续验证剩余选项，不要觉得你验证剩余选项可以提高准确率（基本不会提高准确率的，你算得选项越多，你出错的概率反而越大），恰恰不是，可能让你最后更加纠结了。




实在改不掉，请不要验证没做过的选项，可以检查一下你认为是正确答案的这个选项，时间、主体萝卜、考点是否都没有看错










=========================================================================

#战时计划


找不到数据的情况：

数据是什么数据？
===》相关公式里面的参数变量还是结果参数，比如 是 X + Y = U，题目求的参数有3个选项，判断好是谁。

此时题目求的参数有2种情况： 材料中直接给出来，材料中利用关系公式计算出来。


快速判断隐藏公式，隐藏参数？=====》当没有找到对应的数与单位（一样的字眼，字眼不匹配）的时候，要反应过来是题目考隐藏数了，隐藏数分类成2种，1种是改变名称（同义词转换）类的数，另外1种是题目要求的数是关系式的因变量或者自变量，然后找出材料给出关系公式和其中2个参数（可以是因变量或者是自变量），； 所以第一反应应该是在材料中寻找和题目有关联的式子和参数单位名称，然后把题目要的参数代入公式进行2级计算（就是资料分析的多级计算内容了）

---
齐麟的方法：

##资料分析速度的解决
速度慢的原因有3个：
①读题理解列式慢；
②数据查找慢；
③计算速度慢。


对于①，证明你方法虽然掌握了，但是对于知识点识别，对应公式方法不够熟练，经常需要想挺长时间。
解决：对应题型的对应公式方法一定要非常熟练，比如增长率，脑海里立马想到“现减基除以基”，得达到条件反射的程度。


对于②，可能是天生的阅读速度偏慢，建议多试试连连看，养成查找数据的好习惯：**利用2、3个字去锁定数据**，而不是看着一个很长的词语（萝卜）发呆。
解决：多练习读题圈圈，提高自己读题速度，识别考点的能力，也就是圈出---时间，主体，考点
例子：
2012年全国规模以上工业企业中国有及国有控股企业利润总额是集体企业利润总额的多少倍？要圈出----**2012年，国有，利润总额，集体，利润总额**

2019年，我国知识密集型服务出口额占服务出口额比重-----要圈出----**2019年，知识密集，出口额，服务，出口额**

2014年，全国平均每个图书馆月均流通人次约为-----要圈出----**2014年，平均，每个图书馆，人次，月均**

对于③，应该是两方面的原因：速算方法不熟练，纯粹的计算速度不过关。
解决：把常用的速算方法的操作步骤巩固熟练，直除、特殊分数、分数比大小的方法等等（可能你还有自己的一些方法，只要用着顺手就接着用）。另外，计算速度不过关，加减乘除每天刷一刷，一定会有提高，别偷懒！



##资料分析高效刷题要点

###1 逐题回顾
逐题回顾每道题的知识点、方法、易错点等等，判断哪些题型掌握，不是蒙对。

掌握题型的标准：
在脑海里想想方法，考点即可，如果能瞬间（其实也就浪费你2、3秒吧）确认这道题涉及到的所有知识点方法技巧自己是完全掌握的

没有掌握题型的标准：
想半天都没想出来这题考啥，自己咋做对的


###2 错题整理

重点关注自己做错的题目和蒙对的题目，此时需要根据解析，找到做错的原因，如“看错”、“跳坑”、“算错”或是“公式方法误用”，然后强化记忆正确的方法，记住这次跳的坑，下次只要出现类似的情况，立马提高警惕。




###3 针对性练习


发现本题题目中存在明显掌握不熟的考点或方法，找到对应的专项练习



###4 方法优化
如果发现本套题中某些题目自己做对了，但是比较费时间或者觉得可能有更好的方法，改掉自己的一些不太好的算法，优化自己的方法库



##资料分析能力框架

###第1优先级

快速理解题干的所有内容：
1 **包括时间，主体（萝卜），以及所问考点（读题圈圈应运而生）**，
2 找数据时，心中有“数”：有明确的目标，利用材料结构，段落结构，以及题干中的两三个关键字，锁定数据。
3 找到数据之后，心中有“物”：快速根据你确认的考点进行列式。题目理解的清晰到位，可以帮助你快速找到数据，分析考点方法，避开陷阱。


###第2优先级

掌握一套常用的速算方法，以及加减乘除的计算能力。资料分析速算技巧没有那么重要，也不是说完全没用，截位直除再结合一些特定题目的快速分数化简，基本就足够啦。
其余特定题型的再利用点什么笑脸公式，两期比重变化，平均数的增长率，增长量大小比较口诀，分数大小比较等等轻松完成。
除此之外可能就是一些加减法、读数比较的送分题了。

###资料分析基本不需要的能力：“秒杀”

切记，不要总幻想着轻松看出答案，先把走路学会，再想着去飞~不要总觉得动笔计算就一定很麻烦，截位除一除可能反而是最优解。

记住：拿不准，动笔除（算）！

做资料分析的时候往往能口算就口算了，口算不了的也会动笔写出来除一下

###复习
####整体框架复习：
1 增长率的识别与公式熟记

2 基期量识别及公式熟记

3 增长量识别与强化练习题

4 平均数考点识别与公式熟记

5 比重相关考点识别



####错题复习：
第一：
注意总结：
错误的题目出现的原因
1） 压根不会，
2） 找错数据，
3） 考点列式有误，
4） 纯粹的计算错误，
5） 不小心跳坑里了

第二：
总结出自己常出错的地方，以后注意。哪里不会学哪里，读不懂题就跟着公众号练习读题，知识点方法不熟就在公众号找资料分析的专项知识点方法讲解，计算出错就去练直除练计算。


第三：
真题不要只刷一遍，可以隔一段时间总结一下易错题和常见题型，常见陷阱，那些你1-2个月内做过的题目，可以再做一遍了，看看之前出错的地方是否继续出错，**如果是，请重点标记出来：并且告诫自己，这个地方我容易做错（加深印象），**以后碰到类似题目时，第一时间反应到

第四：
不要和你连解析看了N遍都都看不懂的题目较劲，这样的题目对你的考试几乎没有影响。直接在题目旁边打叉叉~

---
#参考：

https://mp.weixin.qq.com/s/gQTkF06BhcLsTqtYWPFMfw

读题圈圈数据：
https://mp.weixin.qq.com/s?__biz=MzI3MTExNTA4NA==&mid=2652665942&idx=2&sn=4be7e559ad189093eb3bba4d731d018f&chksm=f12e6e75c659e763379bb1b4010a5280e648dd378420f6d1ec8f2e267152476b514497757f4f&scene=21#wechat_redirect

资料分析知识点方法技巧系列：
https://mp.weixin.qq.com/s?__biz=MzI3MTExNTA4NA==&mid=2652667600&idx=1&sn=a15aad22d1009ef421f8abe46b96bff1&chksm=f12e68f3c659e1e553d1406918243739e30e28b524948fab6c7981f90d9d894535d456ba99fb&scene=21#wechat_redirect

资料分析0基础全部内容合集：
https://mp.weixin.qq.com/s?__biz=MzI3MTExNTA4NA==&mid=2652665945&idx=1&sn=6cef3a7acaadf796972f03ff2fe97982&chksm=f12e6e7ac659e76cf9894c88285d5db21f83792de0c57877eaf12133581bc221fe199aa13f71&scene=21#wechat_redirect

资料分析自学课程讲解合集：
https://mp.weixin.qq.com/s/6jqovaD1Vc1qDHMNb-EE0A

比重：https://zhuanlan.zhihu.com/p/473732242


---

markdown的公式手册
https://www.zybuluo.com/codeep/note/163962
https://blog.csdn.net/sunchengquan/article/details/104662650

注意点：

 1. 1.言语中心理解注意主题词配合关联词抓行文脉络，别纠结信自己信预感，国考40题25分钟解决掉，你可以去试试，25分钟做完和40分钟做完基本都是75到80的正确率。
 2. 2.资料分析无他，唯手熟尔，一天2套40题，齐麟有刷题课可以听。
 3. 3.判断图推不强求，不会选个c走人，类比定义不能错，宁愿多花5分钟，做稳点，逻辑部分，翻译推理送分题，加强削弱送分题，难在合理舍弃组合排列上，组合排列如果是5选3，7选2，而且从头到尾就一个或者干脆没有事实真的，直接放。
 4. 4.数量不能放弃，数量不能放弃，数量不能放弃！

 找能做的，放不能做的。




迭代，反馈，试错


=================================================================================

刷题，总结，主要刷言语和判断，至少刷个七八千以上，边刷边总结，分数自然就上去了。。仔细思考为什么这题会这样出，以及这样的思路可以换一种题型之类的


齐麟数资

数学:好好思考出题思路和演练计算过程

解构和祛魅
ひろせたくじ---破灭的女友

数学/物理完整的理解：定义引入的背景，发展，性质的证明并且概念之间形成的联系

===============================

物理公式记忆：

要把最基本的原理理解透，了解它出现的历史背景，以及适用性。而推导过程，要分情况来看。我觉得数学推导过程不用烂熟于心，但是它的思考过程，理解过程，里面的物理内涵需要熟稔于心。数学推导过程是一个辅助的东西，这些东西如果是在你研究的范围内的，可以去推导推导，如果是在外，了解一下就行。

作者：南寒
链接：https://www.zhihu.com/question/470453850/answer/2016786672
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。




自学的能力和逻辑思考的能力，这样可以在你今后需要的时候，立即通过书本获得知识。


方程的推导步骤中有很多细节是不需要记的，尤其是纯数学推导，除非有适用性很强或者你认为有深刻数学联系的，否则“数学推导=等价的废话”，研究者完全可以查书或者使用计算软件来完成，不需要记忆。真正需要注意的是推导中明示或暗示的物理假设、物理输入、物理近似，这些才是物理推导的灵魂。

作者：melonsyk
链接：https://www.zhihu.com/question/470453850/answer/2062914136
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


本科物理:经典力学记住拉格朗日方程 哈密顿方程，电动力学记住麦克斯韦方程，量子力学记住薛定谔方程 狄拉克方程。


有些试题两家机构给出的答案天差地别，那我们就中和一下答案，选择和题目最贴近的答案就可以了，没必要在这上面生气、抱怨、钻牛角尖。




头脑在梦中对记忆的调用：梦里当时的思绪转变：前一天高考英语考砸了>转念一想不对我昨天好像不是在考试>淦！我昨天tm在苦逼地上班。然后我就醒过来了

先将自己置入情境，问自己怎么办。然后列出所有关键因素，化为关键字，收集相关资料素材。一边看，一边对照，去伪存真，提炼出来。做足笨功夫，加勤奋思考。敢否定自己，客观看事，主观体会人。
最后总结过程，找到自己的方法。	2020-12-22 16:16:38
kumika	逻辑判断	# 逻辑判断

对于理论公式，自己推导一遍是很好的学习方法。
对于经验公式，要懂得使用条件，各种参数的意义，以及得出的过程。

如果想学的扎实点，必须深入理解公式的推导过程，假设条件，适用范围。本科阶段的力学基础知识的学习，都是从17世纪伽利略开始到19世纪末的经典科研成果，很多公式都包含巧妙的思想在里面。我们在学习时，不明就里地简单接收，实在是错过了领悟前辈经典思想的机会。



**需要理清这个考点框架的体系+做题+反复回忆
笔记应该是用自己的理解把整个框架复述一遍，要用自己的语言。
理解基本概念，熟悉基本概念，熟悉几种基本的极限结果和求解过程**


#1类比推理
要求：给出一组相关的词，找出在**逻辑关系上最为贴近或相似**的词

常见题型：
2词类型-----A： B
3词类型-----A： B
填空类型-------A 对于（） 相当于 （） 对于 B



一般2个字的描述词，是考虑主谓结构，动宾结构，偏正结构····
逻辑学导论关于概念的内涵和外延、类比推理、因果连接这三块的论述



类比的对象常错的没有想到的3种关系
包含

交集

并列

##填词类型

把选项代入，分别分析2组词语的逻辑关系，然后看2组词语的逻辑是否一致


因果关系

顺承关系

近义词组关系

反义词组关系(跟你不一样的就是反对)

动宾关系


对应关系识别标志：地方+功能/职业
种属关系识别标志：符合数学上集合关系的对象




---



##1  语义关系

###1.1近义关系：
一级辨析（看意思）选不出的时候，需要二级辨析---》感情色彩（褒义，中性，贬义），词语结构，具体点就是题目给出的词只要有一个是褒中贬色彩的，选项中与题目同一个位置的词语色彩不一致，那就可以排除了。

比如：满意：中意； 锲而不舍： 坚持不懈

###1.2 反义关系(跟你不一样的就是反对)

###1.3比喻意义，象征意义：
把一种事物比喻成另外的事物，或者词语本身的含义同时是另外一种事物的象征。
识别标志：一词多义，或者是一个特别文雅的词+大白话的词，此时多考察词语描述的对象：月亮：玉盘；  松鹤：长寿；
心腹：信任=====》错误的原因：心腹是指信任的人，不是指信任，对象不能混淆。
耳目：刺探=====》错误的原因：耳目是比喻刺探的人，不是指刺探这个动作，对象不能混淆。

###1.4字词拆分：

词语/成语拆分
1.4.1）识别拆分
成语原本被拆分-----南征：北战
两组词语或者成语之间没有明显逻辑关系--------成败：呼吸

1.4.2）解题思路
1.4.2.1）思路1：
两两看关系或者拆成单字看关系

1 近义，反义关系：势均力敌，古为今用
2 并列关系： 笔墨纸砚（单字都分开看）
3 因果关系： 水滴石穿
4 方式目的： 刻舟求剑
5 语法关系（主谓宾）： 愚公移山


1.4.2.2）思路2：
相同的单字反复出现：看该字在词语中的意思

1 苦：同甘共苦：痛苦








---

##2 逻辑关系

2.1 全同关系

2.2 并列关系： 
1）矛盾关系（集合里只有2个元素，除了A就是B）----生：死； 对称：不对称
2）反对关系(同一个分类里跟你不一样的就是反对，集合里不只有2个元素)----白色：黑色

并列关系的2级解析会转到对应关系上，举例子也就是并列+功能并列



2.3 包容关系：
1）种属关系 -------A是B的一种

2）组成关系--------A是B的一个组成部分

组成和种属的区分： 能用“谁是谁”造句子的就是种属关系，比如苹果是水果（种属），轮胎是汽车（组成）。



2.4 交叉关系----女士：公务员
题干特征：从不同角度描述同一事物

判断技巧------造句子
有的A是B，有的A不是B；有的B是A，有的B不是A，当这几个判断句都是正确的时候，就是交叉关系。





2.5 对应（搭配）关系（前提要求词语搭配正确）：
属性，材料，功能，依据 这4个关系是高频考点，所以要多多注意。


1）材料----小麦：馒头
2）工艺----白酒：发酵
3）功能----银行卡：支付
功能关系二级辨析-------主要功能和次要功能


4）属性（一定/可能）----盐：咸
5）时间顺序（2个或者2个以上的行为词语）----学习：考试
时间顺序二级辨析---------行为发出的主体是同一对象。


6）依据（原则，指导方向）----航行：航线
使用：“根据，依据”造句，航线根据航线，教学依据教案



7）因果（充分，必要，关键因素--》就是逻辑链上的远近，要近的）----炎热：中暑；
一般因果关系多出现在成语拆分类型题目中，一个成语拆成2组词，比如滴水：穿石


8）方式目的（职业）----老师：上课




功能对应关系与属性对应关系的区分： 
功能是对于人的用途来说的，物品的使用者一定是人；
属性是物品本身客观具备的，自带的。




---

3 语法关系（1个词语与另一个词语之间的关系）

学生（主语）学习（谓语）功课（宾语）


主谓关系（主语+ 动词）------学生： 学习

动宾关系（动词+名词）-------学习： 功课

主宾关系（主体+客体）-------学生： 功课

偏正关系---------前一个词对后一个词起到修饰或限制作用，第一种为名词+形容词，中间加上“的”能够起到修饰作用，例如：美丽：人。第二种为副词+动词 中间加上“地”能够起到修饰作用，努力：推进。

https://pic.imgdb.cn/item/637c580716f2c2beb1b481b1.png

---


#2逻辑推理

思路：
根据题目给出的命题，判断出题目是属于下面哪一种命题类型，然后按照它的解法推理出答案，再看看题目是选正确的还是选不正确的。

所有推理基础框架：


形式逻辑
必然性推理：  
1直言命题
2负命题
3联言命题（P且Q）
4选言命题（P或Q）
5假言命题（P推Q）


----------------------
非形式逻辑
或然性推理：
论点----论据----论证方式
1加强型
2削弱型
3解释型
4结论型
5评价型






===========================================================================

##2.1 形式逻辑

形式逻辑最坑的地方：区分逻辑真，事实真。



题目问题出现“真假”字眼的时候，就是考察形式逻辑的考点。

###2.1.1 直言命题

所有 女孩儿 是 美丽的
量项 主项 联项 谓项
量项：所有、有些、某个
联项：是、否


直言命题类型题目：
只含有一个判断的句子，这个句子判断了两个概念之间的关系。

比如： 小时代这电影是一部好片子。

概念A和B的关系： 
1 完全相同  
2 A $\subseteq$ B (A是B的真子集)    全部A是B
3 B $\subseteq$ A (B是A的真子集)    全部B是A
4 A $\bigcap$  B   (A 交集 B  )  有些A是B 
5 B $\bigcap$  A    (B 交集 A  )   有些B是A
6 完全不同

或者使用文氏图表达

3个判断对象范围的判定
1） A和B的圈内有没有相交（A和B有没有交集），有没有同时具有A和B属性的元素

2） A的圈外有没有B（非A和B有没有交集） ，有没有不具备A属性的，但具有B属性的元素

3） B的圈外有没有A（非B和A有没有交集） ，有没有不具备B属性的，但具有A属性的元素








5种文氏图关系
1 全同

2 全异

3 交叉


4 属种（A包含B，B是A的真子集）

5 种属（B包含A，A是B的真子集）

前提知识：属范围 》 种范围。
属种和种属关系的确定 取决于A与B的大小，假设A大于B ，A与B的关系就是属种关系，B与A的关系就是种属关系，这是次序规定了。


|  判断A与B的范围情况  | 全同 | 全异 | 交叉 | 属种| 种属  |
| -- | -- | -- | -- | -- |  -- |
| A和B的圈内有相交（A和B有交集），有同时具有A和B属性的元素| 1 | 0  | 1 | 1 | 1|
|  A的圈外有B（非A和B有交集） ，有不具备A属性的，同时具有B属性的元素 | 0  | 1 | 1 | 0|1 |
| B的圈外有A（非B和A有交集） ，有不具备B属性的，同时具有A属性的元素 |0  | 1 | 1 | 1| 0|

画圈原则：小圈推出大圈，比如A是B = A--》B = A推出B =  A画的是小圈，B画的是大圈，B 包含A

文氏图逻辑思维误区

误区1 ：有些A是B  能推出 有些A不是B
有些A是B 等价于 A and B 为真  / B包含A  /AB全同/ A与B交叉
有些A不是B  等价于 A and 非B 为真 /有一些A在B的圈外/有一些A属性的同时没有B属性的

所以正确的结论：有些A是B  不能推出 有些A不是B


误区2： 有些A不是B 能推出 有些B不是A

有些A不是B  等价于 A and 非B 为真 /有一些A在B的圈外/有一些A属性的同时没有B属性的

有些B不是A  等价于 B and 非A为真 / 有一些B在A的圈外/有一些带B属性的同时没有A属性

所以正确的结论： 有些A不是B 不能推出 有些B不是A

文氏图常考思路：
种属/属种 ：所有的A都是B  =  不是B的就不是A 
 全异： 所有的A都不是B = 所有的B都不是A
交叉： 有的A是B = 有的B 是A

有的A是B， 所有的B都是C===》有的A 是C



**文氏图与下面讲的AEIO类型题目的区别：**
文氏图： 主项 ， 宾项可以变
AEIO类型：主项，宾项不变


没有一个是   =  所有都不是
原理：没有一个是中文缩写，原型任何一个都没有，最后演化成没有任何一个，比如没有一个xxx能投资 缩写的原型是 xxx中任何一个都不能投资
比如：没有一个不美丽的人是善良的 = 所有不美丽的人都不善良。



推理取反关系：-------------------------------------------------------------

所有是——推理取反——》某个是
所有是——推理取反——》有些是
某个是——推理取反——》有些是


所有非——推理取反——》某个非
所有非——推理取反——》有些非
某个非——推理取反——》有些非


矛盾关系：--------------------------------------------------------------


所有是——矛盾——有些非
所有非——矛盾——有些是
某个是——矛盾——某个非

总结推理和矛盾关系：

所有 S 是  P            &emsp;&emsp;   &emsp;&emsp;              所有S不是P

张三是P        &emsp;&emsp;   &emsp;&emsp;       &emsp;&emsp;                     张三不是P

有的 S 是P        &emsp;&emsp;   &emsp;&emsp;                    有的S不是P


1  这6个命题中处于对角线的位置的命题是矛盾关系，个体张三是反对加矛盾，

2  矛盾关系是必有一真一假

3  真命题是同侧自上向下推理，假命题是同侧从下向上推理，真假方向不可相反。
简单点：左边是真命题只能从上到下推，假命题不能从上到下推理，右边是假命题只能从下往上推，真命题不能从下往上推理

4  最上面的一组命题中必有一假，最下面一组命题中必有一真（上一假，下一真）。


5  矛盾命题与逆否命题的区别
[矛盾命题] 考虑的是：矛盾与正确 ，题目问题出现反驳，反对，不同意···等词语。

[逆反命题] 考虑的是：正与逆
正并不代表正确，同理，逆也不代表矛盾，两者完全没关系，所以不是一回事
数学逻辑：  
原命题是S===》P， 
当原命题是正确的时候，矛盾命题是 P ====》非S，矛盾命题是错误命题，
逆否命题是与原命题同正确同错误的，只是逻辑符号转换了而已 非P ====》非S

AEIO类型表示：

上反对关系： AE （两者至少有一假）


逻辑连词优先级： 才>如果（若）>除非


---
形式逻辑的四大考点：

（1）对逻辑关系加非

非（A or B)=非A and 非B

非（A and B)=非A or 非B

非（A⇒B）=A and 非B

（2）或和推出的转换

对于or的逻辑，对or的左边加非可以推出右边，对or的右边加非可以推出左边。

（3）逆否命题



（4）逻辑箭头可以顺推不可以逆推。

--------------------------------------------------

适用范围，题目提示词

当题目或者选项出现有的，全部，每个，所有等范围词，并且选项或者题目中带有个体比如小明之类的词，使用此方法。

题目的解题点：

1 用符号写出题干
2  两两结合
3 用符号写出选项，并找到已知条件

4 选项内容出现新对象，直接表明不确定选项，然后排除。

----------------------------------------------------------------------------


题目多个命题，并且有些是可以连结起来，题目问矛盾或者假的主要是看最长链接的，题目问真命题的就从短的不连接的看。

----------------------------------------------------------------------------

补前提类型题目
题干特征：  题目命题多个，但是需要补充条件前提，类似于三段论，有“因此”等词语






问成立：


1 观察符号是否一致 ，其中符号 “ ---》”是推出的意思， “====》”是是的意思，比如A是B中的是。


2 若一致，则重复项左对齐 ，补充的命题是  上---》下
若不一致，则重复项右对齐， 补充的命题是  下==》上

比如：
类型1：
原命题：A----》B
根据题目需要自己补充的命题：（B---》C）
结论命题：A-----》C

类型2：
原命题：A----》B
根据题目需要自己补充的命题：（C===》A）
结论命题：C===》B

类型3：
原命题：A====》B
根据题目需要自己补充的命题：（B----》非C）
结论命题：A====》非C




问反驳：

方法1： 先找到结论的矛盾，再补充前提（使用范围：不能直接补充前提的时候，比如上是下推的情况）
方法2： 先补充前提，再选其矛盾（使用范围：结构能直接补前提）


===============================================================================

**或（假）命题：一真则真，同假则假。
且（真）命题：一假则假，同真则真。
必要条件，充分条件，冲要条件，这3个条件使用范围都是在1个命题2个情况P，Q之内的，或者是弱关联离散状态下的。**

####2.1.1.1直言命题的换质推理和换位推理

**判断考点：P-->Q的定义推理中P和Q当中有一个或者2个存在全部，所有，有的，有些等前缀。**



换位推理是指将直言判断的主项和谓项在遵循一定规则的情况下进行调换，换完后与原句的意思表达相符。既然只有主项和谓项位置调换，那么换完前和换完后的肯否定形式是不变的。

这4个判断可以用集合画圆圈来理解
（1）全称肯定判断：所有S(都)是P          换位后：有的P是S………………单向不可逆

（2）全称否定判断：所有S(都)不是P        换位后：所有P(都)不是S………………双向等价

（3）特称肯定判断：有的S是P            换位后：有的P是S………………双向等价

（4）特称否定判断：有的S不是P          换位后：有的非P是S………………双向等价

★注意：（4）不能直接换位，并且换位后不得出有的P不是S。
具体换位过程：
第一步：先进行换质，换为：有的S是非P；
第二步：根据换位规则（3），换为：有的非P是S。

我们再来看一下换质推理的定义，换质推理是指经过改变某直言判断的质，从而推出一个新的直言判断的推理。

（1）全称肯定判断：所有S(都)是P         换质后：所有S(都)不是非P……………双向等价

（2）全称否定判断：所有S(都)不是P        换质后：所有S(都)是非P………………双向等价

（3）特称肯定判断：有的S是P            换质后：有的S不是非P………………双向等价

（4）特称否定判断：有的S不是P          换质后：有的S是非P………………双向等价

①所有的金属都是导电的。所以，所有的金属都不是不导电的。
②有的昆虫不是害虫。所以，有的昆虫是非害虫。
换质法的规则
第一，改变命题的质。即如果前提是肯定命题，结论变成否定命题；如果前提是否定命题，结论变成肯定命题。
第二，变换命题的谓项。即把结论中谓项变换成前提中谓项的矛盾关系的词项。
第三，主项与谓项的位置不变。在前提中作主项的词项，在结论中仍然作主项：在前提中作谓项的词项，变换成其矛盾关系的词项后，在结论中还作谓项。


-----------------------
个人理解：

换**位**推理使用的提示：
题目给出的推理定义的主宾对象，与选项推理主宾对象相反，并且谓语（都是，是，都不是，不是···）不变

全肯 所有S是P------------>  有的P是S      单向不可逆
全否 所有S都不是P------------>  所有P都不是S
特肯（有的是）  有的S是P -----------》有的P是S
特否（有的不是） 有的S不是P  -------》换质：有的S是非P ------》换位： 有的非P是S

2个情况是随便换位，2个是特殊情况。


换**质**推理使用的提示：
题目给出的推理定义的主语对象，与选项推理主语对象一致；**或者是题目多个推理定义合并一起组成的定义的主语对象，与选项推理主语对象一致**；**谓语改变，否定变肯定，肯定变否定**，简单概括为 是变为不是，不是变为是。题目给出的推理定义的宾语对象，与选项推理宾语对象相反，P变为非P。

全肯 所有S是P  --------》所有S不是非P
全否 所有S都不是P  ---------》 所有S都是非P
特肯 有的S是P ----------》有的S不是非P
特否 有的S不是P --------》有的S是非P


关于“所有”命题可以使用逆否命命题，“有的”命题不能使用逆否命题（直言判断的换位规则中的逆否问题）的解释：
原命题有的S是P，用欧拉图表示可以有4种表现形式：
1）SP相交
2）S包含P
3）P包含S
4）S=P
这四种情况都可以表述为“有的S是P”，那么取逆否有的非P是非S，就要分4种情况讨论啦
1）SP相交：有的非P是S，有的非P是非S，当有的非P是S的时候逆否不成立。
2）S包含P：有的非P是S，有的非P是非S，当有的非P是S时候逆否不成立。
3）P包含S：所有非P是非S，那么有的非P是非S，逆否成立。
4）S=P：非P和非S全同，有的非P是非S成立，逆否成立。
小结一下：特称判断的时候，逆否命题与原命题不一定同真同假。

-------------------------------------------------------------------------------

####2.1.1.2  直言命题-考点考法

4种考点：
1 题干未提及的信息，不要脑补

2  直接代入比较，逐个排除

3 最多人数，最少人数

4 哪个论述不可能被新信息推翻

不能判断真假的问法：一定是考察直言命题的6边形解法

---
真假对话
解题方法论：
第一步：找出矛盾或者反对关系
第二步：绕开矛盾或者反对关系，利用题目问题，判断剩余的条件关系是真还是假；如果是假，推出事实
第三步：利用第二步的事实，代入矛盾或者反对关系，并推出最后的结论/答案



---
2种考法： 1 推理   2  先考推理再求假

其1 推理：
“所有”词可**逆否**的公式： 
S--》P  = $\neg$P --》$\neg$S  

S --》 $\neg$ P  =  P --》$\neg$ S


“有的”词可**换位**的公式：

有的 S --》 P  =  有的P --》 S 
有的S --》$\neg$ P  = 有的  $\neg$ P  --》 S

“有的”进行题目整体推理，“有的”只能在第一个并且是唯一的一个，不能出现在逻辑链条的中间




&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;






| 一个总结题型模型表格  | 题干无结论/连环推理 |  | 题干有结论/补充推理  |
| -- | -- | -- | -- |
| |  |   | |
|  求真（推理） | 题干：A--》B--》C--》D；<br /> 问题：得出什么？<br />答案：A--》D  |   |  题干：A--》B ，结论A--》C；<br />问题：哪项可以让上述论证成立？<br />答案：补充条件，要补充B--》C命题 |
| 求假（重点）  |  题干：A--》B--》C--》D；<br /> 问题：下列选项一定为假？<br />答案：<br />1 根据题干得出A--》D；<br />2 再求A--》D的矛盾命题 |   | 题干：A--》B，结论A--》C<br />问题：哪项为真，可以推翻/反驳结论<br />答案：<br /> 1 先对题目结论推翻得出有的A--》非C<br /> 2 再补充条件：B--》非C|

**直言命题的真假只能用六边形模型来推理判断，假言命题则是使用逆否命题，负命题等公式来推理判断。**


直言命题不可能是假言命题
假言命题也不可能是直言命题
2个命题用的箭头符号含义不一样，直言表示 是，假言表示 交集并集

逻辑大类做题过程：
1 分类： 因为公考只有形式逻辑/非形式逻辑所以简单点，考研有3大类形式逻辑/非形式逻辑，相似，分析推理
（1） 看题目问题的关键词，逻辑连词是否属于形式逻辑/非形式逻辑
（2） 看题干内的关键句/整句的逻辑连词是属于形式逻辑OR 非形式逻辑
（3） 看选项内的逻辑连词是是属于形式逻辑OR 非形式逻辑

2 判断属于形式/非形式其中一个后，对逻辑连词进行分类，根据逻辑连词确定考察的考点
逻辑连词分类：
形式逻辑
直言命题：所有，任何，全部，有的，有些，部分
模态命题：必然，不必然，可能，可能不
假言命题：（如果··那么···，如果···就···，只要···就···，若···则···，为了···一定···），（只有···才···，除非···否则···，基础/前提/必须的/重要前提/必要条件/不可或缺（谁是基础的必要的对象就谁是箭头指向目标终点））
联言命题：并且，···和···，···也···， 不但····而且···· ， 虽然···但是····，不是····而是·····，既···又···，同时···，且，但，既又，“逗号”等等
选言命题： ···或···，····至少···，····要么···，或····或····， 可能····也可能····，也许···也许···，不是···就是···，要么···要么··· 
负命题：不，并非，并不


非形式逻辑
支持： 支持，赞同，成立
削弱：反驳，反对，质疑，削弱
假设：假设，XXX前提，XXX必要条件
评价--推理：
解释：


3 根据考点，做出该考点的解题模式



======================================================================================

2级结论：

 直言命题类型题目辨别标志是：给出的定义或者命题中带有----- “所有，有的，每个，任何” 字眼

 负命题类型题目辨别标志是：给出的定义或者命题中带有----- “并非，不是” 字眼

 联言命题类型题目辨别标志是： 给出的定义或者命题带有----- “且，但” 字眼

 选言命题类型题目辨别标志是： 给出的定义或者命题带有----- “或（至少），要么” 字眼

 假言命题类型题目辨别标志是： 给出的定义或者命题带有----- “如何···那么···” 字眼

 模态命题类型题目辨别标志是： 给出的定义或者命题带有----- “必然，可能” 字眼


1 题目给出的定义或者命题中量项与选项量项关系处于子集或者真子集关系，量项的范围 》》选项量项的范围，则选项量项是正确的


2 直言命题题目里面有“因此”等结论词，说明题目答案是补充命题。

3形式逻辑只有陈述句，没有疑问句。


4 机构给出的6边形的解题模型是解决命题S和P位置不变情况下的解题模式（选项中的S和P的位置也是与题目中的SP位置一致）；
换位推理和换质推理是命题S和P进行变化的情况下使用的方法（选项中的S和P的位置是改变的，与题目中的SP位置不一致）。
这2个解题模式，一个模式是解决矛盾命题（真假），一个是解决逻辑链条是否正确问题。

5  6边形模式和换质换位模式进行结合，组成求真假的推理链条类型题目，要记得这类题目可分为无结论类型，有结论类型。



6 不都 = 不是所有的···都··· = 有的不是，指的是部分否定




================================================================================

### **2.1.2 负命题（矛盾命题）**

在其余5种命题前面加入非这个逻辑。

题目出现的词：并非，不是，不都，不可能

原命题： A---》B 
负命题： A---》非B
逻辑前件和箭头不改变，后件改成非，遵循前真后假的假言判断标准，不服看它的真值表。

对逻辑取非，就是对前真后假的判断。


主项前有量词，量词要取非，主项不变：每一个/所有人，取非就是有的人

已知A且B→C为真
A且B→C = 非（A且B）或C=非A或非B或C=非A或（B→C）


$$
A——》B 与 A\cap  \neg B   互为矛盾命题
$$


也可以这样简单理解：矛盾命题就是杠精，就是完全贯彻落实**前件真后件假就是假命题**这个口诀（前提条件一样，结果不一样）这口诀是判断逻辑式子真假的唯一标准。


直言命题取非：本质是对量词（所有，每一个，有的，有些···）进行取非，转换成与之矛盾的量词


假言命题取非（求假）：取非的结果是联言命题。
比如假言命题的取非：非（P--》Q） = P 且 非Q


---
直言和模态相对应的负命题转换（取非的结果）
1 所有 《--------》 有的
2 必然 《--------》 可能
3 肯定 《--------》 否定


联言，选言，假言的相对应的负命题
1 肯定 《--------》 否定
2 且 《--------》 或者（两边取否定）




================================================================================

###**2.1.3 假言命题**
假言命题===条件命题（不存在时间顺序，不要被时间迷惑,关键判断谁是前件后件）

简单说：使用有箭头符号的逻辑式子都是假言命题。

命题定义：陈述某一事物情况是另一件事物情况的条件，前面事物情况叫做P ，后面事物情况叫做Q，使用一个箭头符合进行连接的逻辑式子。

题目类型范围：
XXX陈述，观点，结论 为真/假，下面哪项为真/假/不确定？
下面哪项为真/假，最能反驳XXX陈述，观点，结论 ？

**考试考察方式：
求真 即：推理   答案：逻辑形式是假言命题，内容是原命题的逆否命题
求假   答案：逻辑形式是联言命题，内容是 前提真 并且 结论假（前真后假）**


极度简易的概况假言命题原理：杠精思想（前提一致，结果不同）

$$
P \to Q = \neg  P \cup   Q  
$$ 

$$
\neg（P \to Q） =   P \cap  \neg Q 
$$ 


假言命题求假的答案是：联言命题 

---
有3种形式：
充分和必要的区别：**语文表达不同，推理方式不同，本质没有区别**：

1  充分条件（P--》Q）
P是Q的充分条件


充分”的含义是，一个命题A的成立足够保证另一个命题B的成立——如果我们知道A成立，那么我们可以“充分”认为B成立。


 充分条件类型题目辨别标志是： 给出的定义或者命题带有----- “如果···那么；若····则····；只要····就···” 字眼

比如：如果在淀粉溶液里加入碘酒，那么淀粉溶液会边蓝

仅有P就足以带来Q，无需考虑别的条件《=====》仅有P就有Q，无P则Q不确定


2   必要条件（P《---Q）
Q是P的必要条件

数学上定义：如果没有A，则必然没有B；如果有A而未必有B，则A就是B的必要条件，记作B→A，读作“B含于A”。数学上简单来说就是如果由结果B能推导出条件A，我们就说A是B的必要条件。

逻辑学上定义：如果没有事物情况A，则必然没有事物情况B；如果有事物情况B就一定有事物情况A，A就是B的必要条件，应注意必要条件不是必要不充分条件的简称。

只有p，才q。符号为：p←q(读作“p逆蕴涵q”）


必要条件的意思是，要使得某个命题B成立，我们必须要有A成立（因为A是B的推论，A的不成立将会否定B，所以把A称为B的必要条件）。




 必要条件类型题目辨别标志是： 给出的定义或者命题带有-----“···才···” “只有···才···；除非···否则···；必须，前提，假设，基础，必要，不可或缺” 字眼
 
 公式：
 **B是A的前提，假设，基础，必要，不可或缺 = A---》B（谁是基础的必要的对象就谁是箭头指向目标终点）
 要A必须要B，= A----》B
只有B才A，= A---》B
除非A，否则B = 非A-----》B**

比如： 
只有水分充足，庄稼才能茁壮成长。
水分充足是庄稼茁壮成长的基础/前提/必须的/重要前提/必要条件/不可或缺。


没有P条件，结果Q一定不会发生 《===》无P就无Q，有P则Q不确定



3  充要条件


冲要条件类型题目辨别标志是： 给出的定义或者命题带有----- “当且仅当” 字眼

比如：一个代数方程能得到根的计算方式，当且仅当，这个代数方程的次数不超过4。




一般题目问的样式：

**题目给出的论据A--》B，结论是B---》A**
难点：论据A---》B和结论B---》A 这2个逻辑给出的很绕，需要对论据进行转换才可以得出。

解题：因为A---》B 和B---》A是2个不同的命题，所以选出结论B---》A的逆否命题就可以了或者把结论B--》A重新复述一边的选项。



---


“A推出B”＝"如果A成立，那么B成立"＝“A是B的充分条件”＝“B是A的必要条件”；

“如果A不成立，那么B不成立”＝（逆否命题）“如果B成立，那么A成立”＝“A是B的必要条件”＝“B是A的充分条件”。

A is sufficient for B. = For B (to hold), A is sufficient.
A 是 B 的充分条件。 = 要 B（成立），有 A 就够了。

B is necessary for A. = For A (to hold), B is necessary.
B 是 A 的必要条件。 = 要 A（成立），必须要有 B。


--------------------------------------------------------------------------

####条件→结论（充分条件，箭头开始的是前件）
**充分条件**题目求**ture**的时候用的公式：
这是用**逻辑语言公式转换成数学公式**，做题目的时候，判断好**PQ对象**，代入数学公式就可以了。

 数学公式意思： **- P 或 Q = -（P 且 - Q）**
$$  
P\to Q  = \neg P \cup Q  = \neg (P \cap \neg Q)
$$
**充分条件**题目**求fault**或者对题目命题进行**反驳**的时候用的公式：

数学公式意思：  **P 且 - Q ，肯前否后**=》肯定前件必定肯定后件，否定后件必定否定前件，2个正确的确定的推论。

$$
P \cap \neg Q
$$

充分条件下假言命题的真值表：
真是1，假是0
使用真值表的题目类型：题目问选项哪个为真/假，不是问能推出哪个选项


快速判断原则： 


|A | B| A ----》 B| 
|  :----:  |  :----:  |  :----:   |  
|1 | 1| 1|
|1 | 0| 0|
|0 | 1| 1|
|0 | 0| 1|



后面2个A都为假，结果A--》B都是真，这里有疑惑。
这起源于 Philo 对条件句的定义。Philo 是公元前一世纪到公元一世纪的斯多葛派哲学家。他对条件句的真值作了如下定义：“如果p，则q”这一命题仅在“p真且q假”的情况下是假的（这符合直觉），并将凡不是这种情况的这一命题规定为真的。这样有一个好处，就是条件句的真值可以直接由前件和后件的真值得出，而不必考虑其内容。参考：Anthony Kenny, A New History of Western Philosophy (Oxford: Clarendon Press, 2012), 112






--------------------------------------------------------------------------

####条件←结论（必要条件，箭头开始的是前件）
**必要条件**题目求**ture**的时候用的公式：
这是用**逻辑语言公式转换成数学公式**，做题目的时候，判断好**PQ对象**，代入数学公式就可以了。
数学公式意思：  P 或 - Q = -（- P 且  Q）
$$  
P\leftarrow Q  =  P \cup  \neg Q  = \neg (\neg P \cap  Q)
$$
**必要条件**题目求**fault**的时候用的公式：

数学公式意思：  **-P 且  Q ，否前肯后**=》肯定后件必定肯定前件，否定前件必定否定后件，2个正确的确定的推论。


这否定推论都是以XX《---XX 中的箭头指向的XX对象为描述起点


$$
\neg P \cap  Q
$$


必要条件下假言命题的真值表：
真是1，假是0
使用真值表的题目类型：题目问选项哪个为真/假，不是问能推出哪个选项


快速判断原则： 


|A | B| A 《---- B| 
|  :----:  |  :----:  |  :----:   |  
|1 | 1| 1|
|1 | 0| 1|
|0 | 1| 0|
|0 | 0| 1|

充要条件下假言命题的真值表：
真是1，假是0
使用真值表的题目类型：题目问选项哪个为真/假，不是问能推出哪个选项

快速判断原则： 


|A | B| A 《----》 B| 
|  :----:  |  :----:  |  :----:   |  
|1 | 1| 1|
|1 | 0| 0|
|0 | 1| 0|
|0 | 0| 1|



----------------

条件⇔结论（充要条件）


前推后：（充分条件）
如果····那么·····
那么····就·····
只要····就····
因为····所以····
若····则····
····将····
一（旦）····就····

肯定前必定肯定后  P---->Q
否定后必定否定前  非P ---->非Q

充分： 肯前，否后2个推论是得到确定的结论

后推前：（必要条件）
···才····
只有····才····
不····不····
除非····才··· 
除非····否则不···
···否则·····


除非···· = 除非····否则·····（除非否则类型题目，只有除非，没有否则时候，就自己填上否则，简单记忆口则：留非去否）
除非····否则···· = 如果不···那么··· =只有···才不···  

例子：

除非A否则B ：非A ----》B  = A《-----不B
除非····否则不···· = 除非A否则不B ：非A---》不B  =  A《----B

只有A才B= B----》A
除非A才B= 只有A ，才B = B ---》A
除非A否则不B = 只有 A ，才B  = 非A----》非B = B---》A


------
2级结论


假言命题类型的题目解题模型
第一步要判断这是充分条件，还是必要条件，明确箭头指向；
第二步因为充分和必要的真假判断是不一样的（但都是只有2种判断正确的标准），所以根据箭头指向和相对应的条件进行真假判断，
**充分条件**真假判断：选项命题对题目命题进行**肯前或者否后**，选项命题必正确；
**必要条件**真假判断：选项命题对题目命题进行**肯后或者否前**，选项命题必正确；




求假的，质疑类的类型题目，无论P==》Q 还是 P 《===Q ，都是 题目给定的条件（前提不变） 且  非（推理出的条件）

除非，否则是必要条件逻辑连接词。“则”可以看作一个语言标志，在它之前的句子是充分条件假言命题的前件，其后的句子是后件；其次，“否”要求对前件作否定。

-----------------------------------------------------------------------------

非A推B暨题目抽象成符号


除非A，否则B ，也就是说一般情况下都会实行B，但如果特殊情况A出现，那么就不实行B了。
例如：除非明天下雨，否则我就去旅游。  也就是说：一般情况下我明天都会去旅游，如果遇到特殊情况也就是下雨的话，我就不去了。

“除非否则”句式中，“除非”是没有任何含义意思的，做标识用，“否则”中的“否”和“则”是分开的，“否”是否定前件作用的，“则”是那么的意思，引出后件作用的。例子：除非A，否则B = A否，则B = 非A--》B。
除非否则句式的推理方向口诀：否前则后
**除非否则是一定联系在一起的，是一个固定逻辑连词搭配，如果题目少了其中一个必定是省略了。**

除非：
（1）除非 A，否则 B

去除去否，箭头向右

除非有辣条，否则不是土豪 等价于  非有辣条---》不是土豪

（2）A，否则B

加非去否，箭头向右

真心喜欢辣条，否则不要辣条  等价于 非真心喜欢辣条 -----》 不要辣条


（3） A，除非B

除字去掉，箭头向左

不做你女朋友，除非你是肖战  等价于  不做你女朋友 《----- 不是肖战


(4)除非P，否则Q  = P，否则Q = Q，除非P
$$
P\vee Q  = \neg P \to Q = \neg Q \to P
$$
[例]
除非买房，否则离婚
博士，除非本校毕业的硕士
涨工资，否则辞职


---

这里面的否A，否B，是A命题的否命题，B命题的否命题，也就是吃饭，不吃饭。
关键点是在于，你认为的这个命题A是哪个为原型，吃饭是A命题，则不吃饭就是否A；不吃饭是A命题，则吃饭是否A。
一般题目直接给命题的就是原型命题，选项里面的就是变形命题，否后必否前说的就是选项给出的变形命题是不是符合这个逻辑公式。

肯前否后是选项的推理定义与题目中的推理定义进行比较后，对选项推理定义PQ推理过程是否正确的总结判断----》题目要求推理正确的选项，选项符合这个**肯前否后**总结---》正确选项；要是题目要求错误选项，则选项要符合**肯后否前**的推理过程。


-------------------------------------------------------------------------------

题目的解题点：


解析：



不足以 = 不充分  ，所以题干是  缺少一个证据，这个证据是被告行为构成犯罪的充分条件。
缺乏的是一个充分条件，而不是必要条件。


假设Ⅰ项为假，即原告提出的证据中，包括这样一个证据，有了它，足以断定被告有罪，则法官的断定就不成立。这说明，如果法官的断定为真，则Ⅰ项一定为真。
有了一个可以断定有罪的证据，现在原告没有，所以不足以说明有罪.
Ⅱ项不一定为真。假设原告提出的论据中，包括这样一个证据，没有它，不足以断定被告有罪，但有了它，并不足以断定被告有罪。在这种假设下，Ⅱ项为假，但法官的断定仍然成立。这说明，如果法官的断定为真，Ⅱ项不一定为真。   
这句虽然是双重否定句，但是从逻辑说：没有就不足以断定，不代表有就能断定。因为这个证据不是一个2选1的选项，有了这个证据一定是能证明或者不能证明，可能是个无用的证据，所以证据跟定罪没有关系。
Ⅲ项也不一定为真。因为原告提出的所有证据完全可能都符合事实，但不足以说明被告的行为已构成犯罪。




否XXX推 否XXX ， 肯XXX 推 肯XXX 这些定义的作用范围是 当题目问推出/得出下面哪些结论，的时候用的。



---
假言命题逻辑连词优先级判断：
前提内容：句子中有2个命题，命题需要2个或者1个逻辑连词连接形成一个假言命题逻辑，哪个命题作为开始点推理，此时需要优先级判断

逻辑连词优先级： 才>如果（若）>除非否则

“除非否则”句式中，“除非”是没有任何含义意思的，做标识用，“否则”中的“否”和“则”是分开的，“否”是否定前件作用的，“则”是那么的意思，引出后件作用的。例子：除非A，否则B = A否，则B = 非A--》B。
除非否则句式的推理方向口诀：否前则后

“除非否则”的优先级判断
1 适用情景：存在“除非，才”2个逻辑连词，以 “才”为准，作为开始点
2 使用情景：无“才” 以第一个逻辑连词为准，作为开始点
3 适用情景：无“才” ，无“第一个”逻辑连词，以第二个逻辑连词为准，作为开始点


-----------------------------------------------------------------------------

###2.1.4 模态命题

研究必然，可能及其相关概念的逻辑性质。



必然        &emsp;&emsp;   &emsp;&emsp;         必然不



可能        &emsp;&emsp;   &emsp;&emsp;         可能不


对角线命题关系互为矛盾关系 上下命题关系：真命题只能从上向下推，假命题只能从下往上推。
上命题必有一假，下命题必有一真。


一般等价转换词：
不必/不必然/不一定  《====》可能不
必然不/一定不  《====》 不可能
必然/一定  《====》 不可能不
不必然不/不一定不 《=====》 可能



考察核心: **不必/不必然/不一定 = 可能不**， 不必不 = 可能 

-------------------------------------------------------------------------

适用范围，题目提示词


当题目或者选项出现有的，全部，每个，所有等范围词，并且选项或者题目中带有个体比如小明之类的词，使用此方法。

题目给出原命题中有不XXX，则代入4边形中有XXX意思的那个角，然后找对角线的命题。




-----------------------------------------------------------------------------

###2.1.5 联言命题

在数学上是属于交集。

**联言命题的求假是考试的主要考察方式。（联言命题求假是假言命题）**


联言命题是反映事物的若干（2个或者2个以上）种情况或者多种性质，同时存在的命题

逻辑公式： P 且  Q   《=====》P $\bigwedge $ Q 

非的逻辑公式：非P 或 非Q     《=======》$\neg$P  $\bigvee$ $\neg$Q 

连接词：  并且，···和···， 不但····而且···· ， 虽然···但是····，不是····而是·····，既···又···，同时···，也等词语，这些都是意思里面带有并列，递进，转折，顺承等关系的关联词。

逻辑符合与或的区分：开口方向上是或，下是且


-------------------------------------------------------------------------------

适用范围，题目提示词

题目内容给出P且Q ，P或Q 类似的命题，然后说 根据以上信息，得出下面哪个选项


题目的解题点：

选项一个个代入进去。


---
联言命题的真值表：
真是1，假是0
快速判断原则： **一假则假**


|A | B| A $\bigwedge $ B| 
|  :----:  |  :----:  |  :----:   |  
|1 | 1| 1|
|1 | 0| 0|
|0 | 1| 0|
|0 | 0| 0|

**联言命题求假一定是假言命题：因为联言命题求假得出选言命题“Or”句式，但不可能给出这样的选项，需要否定一个确定另外一个来得出一个陈述句的命题，此时这个命题属性就是假言命题。**






---------------------------------------------------------------------------------


### 2.1.6 选言命题


在数学上属于并集



选言命题的主要考察方式：**求推理**，比如 P v Q = P or Q  = 非P ---》Q  = 非Q ---》P

选言命题求真结果是假言命题

选言命题是反映事物的若干（2个或者2个以上）种情况或者多种性质，至少有一种存在的命题
选言有2种分类：至少选一个； 2选一。
至少选一个这种情况，是包括了2选一这种情况，所以在箭头和或字转换的时候，注意至少一种情况是有全都要的，2选一是没有全都要情况的。

口诀：否定一个命题得到另外一个命题（Or转换箭头的情景）


逻辑公式： P  或 Q   《======》 P $\bigvee $ Q  （至少选一个）；要么P ，要么Q
非的逻辑公式： 非P  且 非Q　　《=======》 $\neg$P $\bigwedge $ $\neg$Q （都不选都不要）


连接词：  ···或···，或····或····， 可能····也可能····，也许···也许···，不是···就是···，要么···要么··· 



德摩根定理：

非（P 且Q）《======》$\overline {P \bigwedge Q}$ 《=====》$\neg P \bigvee \neg$ Q 《======》 非P 或 非Q


非（P 或 Q）《======》 $\overline{P \bigvee Q } $《======》  $\neg P \bigwedge  \neg Q$ 《======》非P 且 非Q



------------------------------------------------------------------------------


适用范围，题目提示词： 或者，至少，要么

 **或者 = 至少一个**




---
选言命题的真值表：
真是1，假是0


至少选一个的情况的真值表：
快速判断原则： **一真则真**
|A | B| A $\bigvee $ B| 
|  :----:  |  :----:  |  :----:   |  
|1 | 1| 1|
|1 | 0| 1|
|0 | 1| 1|
|0 | 0| 0|


2选一情况的真值表：
快速判断原则：**同则假，异则真**
|A | B| A $\forall $ B| 
|  :----:  |  :----:  |  :----:   |  
|1 | 1| 0|
|1 | 0| 1|
|0 | 1| 1|
|0 | 0| 0|

至少选一个这种情况，是包括了2选一这种情况，所以在箭头和或字转换的时候，注意至少一种情况是有全都要的，2选一是没有全都要情况的。

----

求推理为主要考试形态

P V Q = 非P ---》Q = 非Q---》P


选言命题求真一定得到假言命题




==================================================================================

##2.1的2级结论：

···是··· ···不是···   ···必须···  若···则···   

（除非···否则···）与其他逻辑连词出现的时候，除非等价于必须，画逻辑箭头的优先级，除非是最低级的，一般优先级顺序：才》如果（若）》除非



###形式逻辑的4大基本考点

####1对逻辑关系加非

1 非 （非A） = A

2 非（A or B ） = 非A and 非B

3 非（A and B ） = 非A or 非B

4 假言命题取非：非（A --》B） = A and 非B  
解释下箭头取非的过程：  非（A --》B） 是对 （A---》B）这个逻辑式子（假言命题）整体进行取非取假，不是分别对单个变量进行取非取假，而逻辑式子取假只有1个判断标准---前真后假，不服看假言命题的真值表（无论必要条件，充分条件都是一样的），所以直接得出 A 真 同时（and） B假，只有A真 同时(and) B假，才符合前真后假这个标准。最后总结可以写成A and 非B

####2or和箭头的转换

A——》B 为什么等于非A　OR　B

1 用箭头与OR进行转换 

2 仔细推理 A——》 B =  非（非（A——》B）） = 非（A且非B） = 非A or B 



区分假言命题与联言与选言的转换关系
答： 可以浓缩为箭头和“或”字转换，没有什么可以区分，只是转换表达方式而已，实在不明白，就画出A ，B，A--》B的真值表，再画出A，B，A或B的真值表，当A，B2个值相同的时候，2个表进行对比。


箭头推理的时候，已知A是1，非A--》B，这时候不能直接代入非A---》B，要进行转换成非B---》A，此时才可以代入A，因为这是形式逻辑，必须要一致才能代入，如果A代入非A进行推理，容易出现计算机里面指针运算错误。

箭头转换成“或”字类（无论充分必要条件）

箭头变成“或”（随便否定其中1个）：箭头类表达 P----》Q  
“或”类表达： 
表达1： 非P 或 Q 
表达2： P 或非Q
这3个表达都是一样的。

要求A---》B这类逻辑的假/非/负命题，只看前后件，并且只有前件真And后件假的时候，整个推理逻辑是假的。


目的：箭头转换成“或”字类，是因为有些题目选项改变语言表达方式，此时答对要认出这个选项是不是属于题目给出的逻辑

或转换箭头（否定1个推出另外1个，否定那个作为箭头开始点）
A or B  = 非A--》B  = 非B---》A
非A or 非B = A ---》非B = B---》非A






####3 A--》B成立其逆否命题也成立

####4事实真的推理只能顺着逻辑箭头方向传递

事实真的推理只能顺着逻辑箭头方向传递，而不能逆推

事实真与逻辑真的区别：逻辑真表示的是（A——》B）这个式子/公式是确定的存在的，不会突然出现A推出CDE多种结果，简单说就是表示数学公式A推B是确定的存在的（形式逻辑体现出形式）。

在逻辑真这个形式基础上，确定出逻辑箭头是不能逆推的：
A——》B是不能由非A这个变量代入这个式子进行推理的，要代入也只能先对A——》B进行转换成非B——》非A，再代入进非B——》非A这个式子里面。

**形式逻辑需要2个条件才可以进行推理，1是数学公式A--》B，2是变量A或者B的值；**因此题目只给你一个A——》B为真，只是表示数学公式AA+ BB是真的，你还需要知道变量A或者变量B，才可以进行推理。


####5逻辑范围推理
逻辑范围推理：
使用范围识别特征：题目出现大于等于小于，集合，数量比较的时候
范围大的对象---不能推出---范围小的对象
范围小的对象---可以推出---范围大的对象



##2.1形式逻辑常见思维误区

代入逻辑推事实真假误区

###1 逻辑不能逆推

形式逻辑里面的前件和后件是类似编程里面的对象，赋值的时候变量名是一定要一致，在逻辑里面就是**题目给出的条件对象名称一定要一致（无论是命题还是逆否命题）。**
比如题目给出A--》B，条件是非B，非A。A---》B的逆否命题是非B---》非A，此时题目给出的条件非B，是只能代入逆否命题非B---》非A里面，不能代入A---》B里面的。非A则是不能推出什么东西。



逻辑：A--》B为真
事实：只有A为真能推出；如果B为真，什么也推不出；如果非A为真（A为假），什么也推不出
误区1：A---》B 等价于非A---》非B
正确理解1：A---》B 不能等价于非A---》非B，把日常理解代入形式逻辑中去，这是不对的。
误区2：：A--》B为真，代表的是表示A为真同时B为真
正确理解2：A--》B为真，代表的是A---》B这个逻辑真，不能表示A为真同时B为真，只有A--》B这个逻辑真+A为真，才能推出B为真。


逻辑：A《---B为真
事实：如果B为假（非B为真），什么也推不出；如果A为真，什么也推不出

逻辑：A or B ---》D
事实：给出D为真的条件，什么也推不出；给出非A为真的条件，什么也推不出
正确理解：A or B ---》D是一个逻辑，A or B是另外一个逻辑。
给出A，B其中一个为真的条件，在A or B 逻辑里是可以推出A，B另外一个对象，但是在A or B ---》D逻辑里面是不能推出的，因为题目给出的是A or B ---》D这个逻辑，A or B这个逻辑是真是假，我们是不确定的，所以不能推出。



###2 不同文字描述下逻辑本质

1 不管题干用什么逻辑连词来描述一个逻辑，我们都先把它转换成逻辑箭头

2 对于OR的逻辑，否定一边可以推出另外一边
比如：A or B 等价于 非A---》B  等价于 非B---》A  ，这三个表达式没有任何区别

3 对于一个逻辑箭头，A---》B 等价于 非B---》非A  这2个表达式没有任何区别

4 A---》B （非A or B ）和 A and 非B 互为矛盾命题，也就是假设A---》B为真，等价于A and 非B为假； 假设A---》B为假，等价于A and 非B为真。



逻辑本质不变，但是不同的文字描述的4种情况：
A---》B
A----》非B
非A----》B
B-----》A

先说A---》B的情况
使用充分条件的文字描述： 如果A，那么B；如果A，则B； 只要A，就B； 除非不A，否则B； 所有的A都是B

使用必要条件的文字描述： B是A的基础/必要条件；只有B，才A； 必须有B，才有A；


使用逆否命题（非B---》非A）的文字描述： 如果不B，那么不A； 只要不B，就不A；没有B，就没有A；除非B，否则不A


从使用箭头转换到使用 “或者”连词“ or ”连词（非A or B ）的文字描述：或者不A，或者B； 并非（A and 非B）；非（有的A不是B）


A---》非B的情况
使用充分条件的文字描述： 如果A，那么非B；如果A，则非B；只要A，就非B；除非不A，否则非B；所有的A都是非B

使用必要条件的文字描述： 非B是A的基础/必要条件/不可或缺/假设前提；只有非B，才A；必须有非B，才有A


使用逆否命题（B---》非A）的文字描述： 如果B，那么非A；只要B，就非A；有B，就没有A；除非不B，否则非A



从使用箭头转换到使用 “或者”连词“ or ”连词（非A or 非B ）的文字描述：或者非A，或者非B；非（A and B）；非（有的A是B）


非A----》B的情况：

使用充分条件的文字描述：只要非A，就B；如果非A，那么B；如果非A，则B；除非A，否则B；所有的非A都是B

使用必要条件的文字描述：只有B，才非A；B是非A的基础/必须/必要条件/不可或缺/假设前提；必须有B，才有非A


使用逆否命题（非B---》A）的文字描述：如果非B，那么A；如果非B，则A；只要非B，就A；只有A，才非B； 没有B，就有A；除非不B，否则A

从使用箭头转换到使用 “或者”连词“ or ”连词（A or B ）的文字描述：或者A，或者B；非（非A and 非B）；非（没有A是非B）




B-----》A的情况：
使用充分条件的文字描述：如果B，那么A；如果B，则A；只要B，就A；除非不B，否则A；所有的B都是A



使用必要条件的文字描述：只有A，才B；A是B的基础/必须/必要条件/不可或缺/假设前提；必须有A，才有B



使用逆否命题（非A---》非B）的文字描述：如果非A，那么非B；只要非A，就非B；如果非A，则非B；只有非B，才非A；除非A，否则非B；没有A就没有B



从使用箭头转换到使用 “或者”连词“ or ”连词（A or 非B ）的文字描述：或者A，或者非B；非（非A and B）；非（没有A是B）

###3代入逻辑推命题真假

考官出题套路特征：
1 题干通过逻辑连词给出数个逻辑箭头，一定还会给出某个命题的真假的条件

2 选项均是要判断命题的真假

解题模式：
1 对A and/or  B ---》C 进行逆否，得出逆否命题非C----》非A or/and 非B
2 根据题目给出的事实真非C，代入逆否命题，然后得出逻辑非A or/and 非B为真，最后再根据题目给出的事实真 非A/非B代入，推出答案。


###4判断逻辑关系的真假

考官出题套路特征：2点同时存在
1 题干一定通过逻辑连词给出数个逻辑箭头

2 正确选项一定也是通过逻辑连词给出的逻辑箭头

简单题型： 只是通过3个基本考点做基本的逻辑变换
1 题目给出A---》B，答案要求A--》B或者非B---》非A

2 题目给出条件A---》B，非B--》非A，答案要求A--》B或者非B---》非A

3 题目给出A or B，描述的是非A---》B或者非B---》A

4 A--》B  等价于 非（A and 非B） ，因为A and 非B = 非 （非A or B）


复杂题型： 选项逻辑跟题干逻辑不完全一致
判断事实，找矛盾的时候，用是否为真，这是判断题目给出的逻辑式子是否为真；这是考察逻辑真和事实真的区别，一般事实真是题目给出条件A为真或者考生假设A为真的时候，对题目给出的逻辑式子进行真假判断（前真后假为假），看真值表。

1 题干给出A or B ---》 C 为真的条件，问A---》C，B---》C是否为真

错误思维：A or B 为真，A不一定为真，所以A不能推出C，A---》C不为真
错误原因：A是否为真，不能判断A----》C是否成立
正确理解：判断A---》C这个逻辑式子是否成立的方法是---**假设确定A为真**，代入题干条件，看能不能推出C为真（原理是前真后假，看真值表）

其实也等价于问：**假设A为真，加上A or B ---》C 这个逻辑式子，能否推出C为真**


2 题干给出A---》C为真的条件，问A or B ----》C是否为真
其实也等价于问：**假设A or B 为真，加上A---》C 这个逻辑式子，能否推出C为真**



3 题干给出A and B --》C为真的条件，问A---》C是否为真

4 题干给出A---》C为真的条件，问A and B ----》C是否为真

上面4个问题出现的原因：
1没有严格区分逻辑真和事实真的不同，条件给出A---》B为真，不等于A为真
2没有正确理解如何判断，一个逻辑A---》B是否成立



###5推矛盾和两难推理

反三段论：逻辑推理的本质原理---先做逆否，再做OR的推理（否定Or的一边，推出Or的另一边为真）；本质原理：已知题目给出后件的否命题为真，先做逆否是为了确定前件逻辑式子为真，前件逻辑为真并且是Or类型式子，可以用否定Or的一边，推出Or的另一边为真这个推理。

####推矛盾类题目：



考官出题套路特征
推矛盾蕾题目一般同时具有下面三个特征
1：题干通过逻辑连词给出数个逻辑关系
2：选项给出的均为事实的真假
3：题干往往会给出A，B这2者不能共存这类条件

具体套路特征：
1 B和非B不能同时为真，同时为真会产生矛盾
2 题干给出A和B不能共存的条件，那么如果推出A和B同时为真就会产生矛盾----》推出A and 非B
3 题干给出A---》非B，那么如果推出A和B同时为真，就会产生矛盾


套路1：
A----》B
A----》非B，同时为真的情况下，如果A为真，那么会导致B和非B同时为真的情况，产生矛盾----》推出A为假（非A为真）


套路2：题干首先给出条件A和B不能共存的条件。又给出C-----》A，C----》B的条件。那么如果C为真，会导致2个不能共存的命题同时存在，产生矛盾，所以推出C一定为假


套路3：题干首先给出A---》非B的条件，那么意味着A和B不能同时为真，也可以表述为：非A or 非B一定为真，非A or 非B 一定要选一个。

推矛盾类题目的个人理解解题模式：
解题模式1：
1 题目给了几个逻辑式子，给了一个前真后假式子
2 使用前真后假式子的矛盾命题得出目标逻辑式子
3 前几个逻辑式进行连接，目的是连接出目标逻辑式子，缺少部分就是答案

解题模式2：
1 题目给了几个逻辑式子
2 经过逆否得出几个前件一致，后件矛盾的命题
3 得出此时前件为假
4 看选项有前件为真的就是答案

考官设计思路：
1  给几个逻辑式子
2  对这几个式子选择其中1个作为模板，模板推出它的矛盾命题（前真后假，否命题）
3  矛盾命题的对象是存在在其他逻辑式子里面
4  矛盾命题的对象为真，并且是由其他逻辑式子经过否命题/逆否 推理出来的
5  此时矛盾命题的对象作为后件的逻辑式子，该逻辑式子前件被后件要求满足为真，并且与最开始给出的几个逻辑式子中的1个式子的条件相矛盾，此时就完成了矛盾命题与模板同时存在
6  此时这道题目出现了A---》B and C 为真，A----》非B or 非C 也为真
7  说明经过逆否得出的式子（其他逻辑式子的否命题）的前件一定为假，此时就可以设计该前件的矛盾命题作为答案

简单说就是A---》C/ A and B  作为模板，矛盾命题 A----》非C / 非A or 非B
矛盾命题非C/ 非A or 非B 是其他逻辑式子经过逆否/否命题的后件，并且为真
因为考点是模板和矛盾命题同时存在，推出前件为假
所以其他逻辑式子逆否/否命题的前件就是作为矛盾命题，推出前件就是假，原逻辑式子的前件就是真，就是正确答案。

####两难推理
两难推理：逻辑推理的本质原理---做Or的推理，再加入2个箭头

考官出题套路特征：
所谓的“两难推理”只是逻辑学上的一个名词，通俗一点就是描述就是无论实际是两种可能中的哪一中，结果都是很难。
比如：万能的上帝能创造出一个连他都搬不动的石头吗？

套路1：
题干给出如下的条件：
1 A-----》B
2 非A---》B
3 A or 非A（这个条件往往不会在题干出现，默认成立），因为A和非A必然存在一真一假，无论如何都可以推出B为真，所以可以得出B一定为真。

例子：
明天刮风或者不刮风
如果明天刮风，那么张就选择火车出行
如果明天不刮风，那么王就选择火车出行

套路2：
题干给出如下的条件：
1  A----》C
2  B----》D
3  A or B 
这3个条件可以推出A or B ----》C or D 为真
非A---》B---》D为真
非B---》A----》C为真


例子：
明天刮风或者下雨
如果明天刮风，那么张就选择火车出行
如果明天下雨，那么王就选择火车出行

坑：
顿号表示并列的意思--有或者的意思 = 至少其中一个的意思
高血压、心脏病患者不能入内 = 高血压不能入内  ，心脏病不能入内（这个顿号，表述得病其中一个，不是同时2个都要有）
王都不会选择火车或者汽车出行  = 王 非选择（火车 and 汽车）
王都不会选择火车或者选择汽车出行  = 王 非选择火车 or 选择汽车


套路3：
鱼与熊掌不可得兼

1 非鱼 or 非熊掌

2 如果有鱼，那么一定没有熊掌 ； 鱼----》非熊掌

A---》非B ； 非A or 非B ； A和B 不可能同时为真，A和B只能选择一个

题干给出以下逻辑：
1 A---》B
2 B---》C
3 C---》非D

可以推出：A--》B----》C----》非D
A---》非D 成立  等价于 非A or 非D  这就意味着：如果A真，那么D为假； 如果D假，那么A为真
A and D 两者同时为真是不可能发生的，也可以说非A 或者 非D 必须选择一个。




###6真话假话

前真后假---只是判断逻辑式子的真假。
理解：任何一个逻辑式子，代入事实真后，逻辑式子的前后件出现，前件真后件假的情况，可以判断该逻辑式子一定是假；，代入事实真后，如果没有出现前真后假的情况，该逻辑式子一定为真。


考官出题套路特征：
题干中一定是给出了数句话，一般是4--6句，然后告诉你这些话中**只有1句真话或者只有1句假话**。

解题思路：
1 优先找到矛盾的论述，通过矛盾判断其他的论述的真假
2 如果找不到矛盾的两句话，那么就找同真同假的论述
3 如果同真同假的两句话也找不到，那么就直接把选项代入验证题干论述的真假



思路1的几个套路：
套路1：矛盾

矛盾的2句话： A---》B   与 A and 非B （A---》B的否命题）矛盾
A----》B 与A----》非B 是2个不同的逻辑式子，不属于矛盾关系。

套路2：
两者至少有1个和两者一个都没有相互矛盾，即（A or B ）和（非A and 非B）矛盾；（A and B） 和（非A or 非B）矛盾

例子：

班长和学习委员都得到优秀  A and B 
班长和学习委员至少有1个不能得到优秀  非A or 非B

套路3：
当主语完全相同的时候，陈述相反的话相互矛盾

甲：乙是罪犯
乙：我不是罪犯


套路4：AEIO和前真后假
有些是 和  所有都不是 矛盾（IE矛盾）
有些不是 和 所有都是 矛盾（AO）
可能是  和 必然不  矛盾
必然 和  可能不 矛盾

例子：
明天可能不会下雨
明天必然下雨


思路2：找同真同假（判断逻辑前真后假）

1  A 跟A or B 同真， 表示A 真的情况下，A or B 也为真

2  非A 跟非A or 非B 同真

3   小张参加了比赛，与有人参加比赛（i命题）同真
    小张没有参加比赛，与有人没有参加比赛 （O命题）同真

4  如果只有1个名额，B跟非A同真


思路3：直接代入数真假的数量
题目给出的2个条件特征：
1 有些比较复杂的题目给出的句子中，即没有矛盾的两句话，也没有同真同假的两句话

2 选项直接给出了具体的事实真假情况

解题思路：
直接代入选项，验证真话的数量和假话的数量
代入选项注意----对于论述中的逻辑A----》B，满足当且仅当是A and 非B （前真后假）的时候为假，其他情况都是真话。


###7 常见思维误区

1 混淆事实的真假和逻辑的真假
A---》B 为真 不等于 A真 和B真，逻辑式子为真 ，只是说明A推出B是行得通的，想要B为真，要多加入一个条件就是A真这个事实真

A---》非B 与A---》B 是2个不同的逻辑式子，不存在矛盾关系，逻辑式子的否命题（负命题）才是矛盾关系。

如果A---》非B 与A---》B 都为真，再加上A真，只能说明这是推矛盾类型命题，一定能推出A为假；2难类型命题是2个后件一样，前件一个为A，另一个为非A




2 混淆A or B  和非A or 非B

1） 如果明天去游泳，那么明天就不去唱歌  
A---》非B，转换成or的逻辑：非A or 非B

2）如果明天不去唱歌，那么就去游泳
非B---》A，转换成or 的逻辑： B or A 



3 混淆充分必要条件，没有关注箭头的方向
在质疑逻辑的时候，一个逻辑仅在满足前真后假的时候，才为假。
有时候题干明明给出的是A---》B的逻辑，考生却用非A and B来否定，这是因为把A---》B 错误理解成 B---》A。

混淆条件类的考点：（混淆逻辑箭头方向）
1） A and 非B （A---》B的否命题）与 A---》B 矛盾，试图使用A and 非B来质疑 B---》A，说明把B---》A 错误理解成A---》B了

2）非A and B（B---》A的否命题） 与 B---》A矛盾，试图使用非A and B来质疑 A---》B，说明把A---》B 错误理解成B---》A了



------------------------------------------------------------------------------
##2.2非形式逻辑

###2.2.1推理形式和削弱增强


对论点、对论据、对论证过程，这些只是培训机构为了方便记忆的提法，或然性推理、必然性推理、同一律、矛盾律、排中律才是基本理论。


分句和主句的关系： 
分句是支持证明主句的理由，具有前提性，条件性；
主句是叙述的中心和主旨，具有结论性



论据是：前提，OR原因，指根据什么（分句）
论点是：结论观点，结果，指所以怎么样了（主句）
论证：用论据去推理出论点正确性的过程。


论证方法：一个个中立性的事实如何能够结合起来为自己的论点服务去证明论点，将这些中立性的事实整合起来的方法就是论证或者叫做论证方法。





--------

论点提示词： 由此，因此，所以，结论是，这表明/说明/意味着，由此推出/可知，据此认为

论据提示词： 由于，因为（因为后面的一定是论据），鉴于，根据
论据常见形式： 原因，数据，事例，实验或者调查内容等，论点前面的一句话



论证方法：
1直接阐释道理----就是下定义。
2举例子，对比，类比
3引用
4比喻

论证过程： A→B，A是前提，B是结论。→就是论证过程。已知A→B成立，表示A与B是因果关系。论证过程就是找到这个因果关系。当找到的不是因果关系时，论证过程就是错误的论证、无效论证。

论证分为演绎论证和归纳论证两大类，演绎论证属形式逻辑范畴，直观的表述即为推理的符号化；归纳论证属非形式逻辑范畴，是非符号化的推理过程。说这个分类是为了说明，有效这个概念在两种论证中意义的不同。演绎论证属于必然性的推理，即前提的真能够给结论的真提供必然的支持，属于必然性推理，它的有效是必然有效；归纳论证属于或然性的推理，即前提的真不能够保证结论必然为真，只能提供一定程度的支持，它的有效只有支持强弱程度的区别，而没有一定支持。比如：所有哺乳动物都会死，牛是哺乳动物，所以，牛会死。

所有M都是P；

S是M；

所以，S是P;

--------

削弱力度： （题目出现反驳、削弱、质疑等字眼的时候）

    削弱论点 》 削弱论证（拆桥） 》 削弱论据 》 他因削弱（举例子）


加强力度：（题目出现---提问为前提、假设、必要条件···等字眼的时候）


    补全逻辑假设（搭桥） 》 加强原有论点 》 加强原有论据  》 举例子 》 类比

搭桥（论据指向论点）是：三段论中的：所有M都是P；S是M；所以，S是P。个人理解：2个已知条件是A-B-C--》R和D--》R，把C，D2个元素联系起来定义成C---》D，最后整个逻辑形成A-B-C-D--》R，其中**把C---》D的这一步就叫做搭桥（论据指向论点）。**一般选项就要选C--》D的这一步论证。出现搭桥的题目特征：论点与论据出现不一样的抽象对象OR论点与论据的关系是整体与部分的关系，当提问为前提、假设、必要条件、加强论证的时候，优先搭桥选项。
拆桥：A-B-C-D，任何一个元素不指向后方就是了。
**注意这里的搭桥是考公机构自己造的概念，实际上就是逻辑学的三段论，就是补全逻辑假设，A---》B，结论A--》C，需要假设B---》C，所以答案只能是B---》C，选项里面出现C--》B的都是迷惑选项。**

补全逻辑假设（搭桥）总结：简单说就是假设论据A与结论B有关系，文字描述就使用逻辑联词。



加强论点：对论点的补充说明

加强论据：对论据的补充说明（可以是引入他因）


=============================================================

题目1：

近来，国外一些学者和媒体对西方民主体制较为集中地进行了反思和批评，指出西方民主正在衰败。对此，有学者认为，西方民主衰败的原因之一是其存在基因缺陷。西方民主是建立在一个假设前提的基础上的，即权利是绝对的。也就是说，权利与义务本应是相对的，但在西方民主模式中，权利绝对化已成为主流，各种权利绝对化，个人主义至上，社会责任缺乏。

以下哪项如果为真，最能支持学者的观点？

A西方民主制对权利绝对化的偏好，导致对他人权利与生存环境的忽视

C美国两党常把自己的权利放在国家利益之上，互相否决，危害国家和公民的利益


解析：

---

理解1：

用独立于题干之外的A推B论据来做作为加强   
这是不可以的，再次论证的结论必须与提干相重合，否则风马牛不相及
ABD都是同样的错误  。。。。导致了。。。   。。。会造成。。。  
这样的论断是不需要提干的假设而自成一体的       
举个例子  
如果今晚没有星星，那么明天就会下雨    
正确的加强是   
看不到星星是因为云层的遮挡，有云就会下雨（第一种，再次论证，结论还要回到下雨，论点还要与提干形成关联）      

第二种加强：
前三天都没有星星，第二天下雨了（加强力度较弱）     

错误的加强：
天上没有星星会导致天气预报报到下雨的可能性增加   

他最后没有落到提干的下雨上，而是落在了预报下雨的可能性上，要完善这个加强，你需要加上，天气预报的准确度非常高 

题目结论：权利绝对化
A：权利绝对化导致了对他人和环境的忽视

C：举例子，确实存在权利绝对化

区别：A是论断推导   C是肯定论断

肯定材料的论据是有效加强    A最后没有回到论据上去
观点是  西方民主正在衰败（原因是基因不好，基因不好的体现是权力绝对化）
要加强这个，你最后要回到民主衰败或权力绝对化上来（或者与之形成呼应，这个呼应必须是强烈显而易见的，不是你臆断的）
权利绝对化导致了。。。    
A他从绝对化继续推导  最后没有回到绝对化上来   
A应该反过来  改成   **对他人权利与生存环境的忽视，是西方民主制度对权力绝对化的偏好的体现**

这么一改就和选项C形制类似
C美国两党常把自己的权利放在国家利益之上，互相否决，危害国家和公民的利益
把自己的权力放在国家利益之上，这个就是强烈而显而易见的权力绝对化

------------
理解2

**论点：“西方民主正在衰败”；**
**论据：**西方民主建立的假设前提：权利绝对化（由“权利与义务是相对的”可知潜台词是权利和义务不对等），是存在缺陷的。

论据是一种理论，选项C是从现实的角度加强了论据的可信性。（先提出一种理论假设，然后从现实中找例子来支持这种理论假设，这是文章中非常用的一种写作手法）

论点：
主项：西方民主 
谓项：衰败（事物的发展具有衰退和败落的样子）也就是论点在声称：西方民主的发展正在衰退败落

那么整个题干的推理是：“权利绝对化”可以起到使西方民主的发展衰退败落的作用
选项A：
“西方民主制对权利绝对化的偏好”和论据是一致的，“对他人权利与生存环境的忽视”与**论点“西方民主衰败”不一致，犯了偷换概念的错误，与逻辑上的同一律原则相违背。**
而且由“对他人权利与生存环境的忽视”很难推出“西方民主衰败”所以选项A基本没有支持论点的作用。

选项C: “美国两党常常把自己的权利放在国家利益之上”
根据政治常识，这种行为显然违反了权利和义务的相对性（不管哪个党派执政，首要的义务就是维护自己的国家利益，国家赋予执政党执政的权利也是基于这个前提条件的），同时我们有&#172;（义务与权利相对性Λ权利绝对化 ）这个条件，我们可以推出“美国两党常常把自己的权利放在国家利益之上”→ &#172;“权利和义务的相对性”→“权利绝对化”这个命题。那么选项C的主项和论据的主体是一致的。
再看 ：“互相否决，危害国家和公民的利益”说明这种政治制度已经无法适应社会现实的发展，那么这种政治制度存在的合法性也就受到了质疑，是可以推出这种政治制度在衰败的。 
那综上所述，C项有一定的加强作用。



=================================================================

鲨鱼一般都是肉食性的，但一些科学家称，他们在某海域发现了一种以植物作为食物重要组成部分的窄头双髻鲨鱼。

以下各项如果为真，最能支持这一发现的是：

A. 研究人员分析其胃内食物发现，一些窄头双髻鲨鱼的食物组成中有一半是植物

B. 以海草占比90%的特制饲料人工喂养的窄头双髻鲨鱼，在为期3周的实验时间内体重均有增长

C. 研究发现窄头双髻鲨鱼的肠道里存在一种能对植物进行高效分解的酶，这种酶在其他鲨鱼肠道里并不存在

D. 窄头双髻鲨鱼的血液中含有大量非自身合成的某种营养物质，在自然界中，仅海草含有少量的该物质





解析：

A 项：不明确项。胃内食物组成中有一半以上是植物，有可能是吞食鱼虾的过程中误食的植物，也有可能说明该鲨鱼并不能消化植物才导致剩余一半以上是植物，不具有加强作用。

　　B 项：无关选项。以海草占比 90%的饲料喂养窄头双髻鲨鱼，在为期 3 周时间内体重增加，与植物是否是其食物的重要组成部分无关，论题不一致，排除。

　　C 项：不明确项。该项说明窄头双髻鲨鱼的食物中有海草，但无法确定海草是否是其食物的重要组成部分，不具有加强作用。

　　D 项：增加论据。窄头双髻鲨鱼的肠道里存在一种能对植物进行高效分解的酶，并且其他鲨鱼体内没有，说明窄头双髻鲨鱼吃植物，植物是其食物的重要组成部分，具有加强作用。D项不能自产的营养物质只能从外界获得，而在自然界中只有海草有该物质，就否定其他一切生物或非生物含有这种物质的可能性。


解析2：
A一些，比例高低不知道，不明确；B无法证明重要和大量，只能说明能吃；C还是只能说明能吃，重要和大量无从得知；D血液要大量，而只有海草有，重要啊



加强论点的例子：
一份关于酸雨的报告总结说，“大多数森林没有被酸雨损害。”
而反对者坚持应总结为，“大多数森林没有显示出明显的被酸雨损害的症状，如不正常的落叶、生长速度的减慢或者更高的死亡率。”
下面哪项如果正确，最能支持反对者的观点？（ ）
A.目前该地区的一些森林正在被酸雨损害
B.酸雨造成的损害程度在不同森林之间具有差异
C.酸雨可能正在造成症状尚未明显的损害
D.报告没有把酸雨对此地区森林的损害与其他地区相比较


C
［解析］ 反对者实际上是想说，森林已被酸雨损害了，只是症状没有显露出来，C项起到了补充说明的作用，因此，C项对反对者的意见起到了支持作用。



===============================================================================

###2.2.2 MBA的非形式逻辑

论证3要素： 论据，论证方式，结论


论据----》论证方法-----》结论

论据一般出现在结论前面的1 到2句话，多数是结论前面1句。

**论证： 就是 一个论据通过一定的方法得出一个结论的过程。**

考试快速解题，读题读的就是论证，论证旁边是结论，其他背景等文字可以不看。



围绕论证形成6类非形式化逻辑类型题目：
削弱
支持
假设
解释
推论
评价


方法论 = 解题模型，解题套路


####2.2.2.1 削弱 

削弱：使得论证变弱。总原则：使得结论不成立。

题型有2种：1削弱结论 2削弱论证


削弱结论和论证的差异性： 论证是通过论据推出结论。

1，最能削弱（反驳）上述结论？
====》推翻结论

2，最能削弱（反驳）上述论证？
====》 1 推翻结论 
&emsp;&emsp;&emsp;&emsp; 2推翻论据 ，比如题目中存在A怎么怎么样，选项直接说非A怎么怎么样，非A就是推翻论据
&emsp;&emsp;&emsp;&emsp; 3推翻论证方法，方法实验**过程**存在问题，有漏洞


削弱型正确答案的答案特点：

在论据和论点描述对象一致的时候，反驳论点最强；
论据和论点描述对象不一致的时候，就用到下面3个知识点的内容：

1 因果型 
（强）因果倒置
（中）无因有果（无题目前置条件论据也得出题目结果结论），有因无果（有题目前置条件论据没有得出题目结果结论），因果无联系（题目前置条件论据与题目结果结论无关联）
（弱）他因有果


2 措施/计划/目的/建议型（题目出现政府，专家，科学家，建议，提议，倡议···）
（强）措施，计划不可行，或者目的达不到
（弱）措施，计划不可取，或者实施起来弊大于利

建议/提议类型：找出题目建议中的目的，答案必定有目的中的核心词。（口诀：建议找目的）



3 论证漏洞（实验方法）型
调查统计样本有误（无强弱之分）：答案是与样本有关，与数量无关，样本对象选择错误。识别标志---调查显示后面
不恰当类比，
非黑即白：题目给出1个，2个对象，要在这1，2个对象做选择，正确答案是跳出2选一思维，说还有第三者。
以偏概全：答案是全面的宏观的。
诉诸于权威，
偷换概念（简单理解为广告）：论据当中发生的概念，到结论当中却换成了不同的概念/说法；论据当中的概念，到结论当中发生了变化；论据推结论当中发生了变化。
集合体误用（难度大）：大家都有，不代表你自己就有；集体团体有的属性，个体没有




 削弱解题模式： 
第一步看题目类型是不是非形式逻辑，看问题，目的是读题目材料里面的哪些内容；

第二步找XXX与XXX有关系的核心词（**至少2个词**），找不到核心词就找核心词的近义词 ；如果题目问削弱结论，则这2个XXX是结论里2个核心词；如果题目问削弱论证，则这2个XXX是论据

第三步看选项内容缩小范围 ，选项内容有核心词的留下，别的排除。
要是选项都没有核心词或者都有多个核心词的其中1个，此时看题目前文有没有给出核心词的解释，再找出对核心词的解释，如果解释里面的词与选项里面的词一样，该词就是核心词的近义词/指代词，该选项就是正确答案。
存在2种特殊情况（最难的情况）：
----当**题目结论是XX且YY**（题目结论是“且，逗号等并列标识，不存在"或"）然后选项内容与XX且YY一致**（不管选项内容是全部一致还是部分一致）**的选项（该选项方向与结论一致，属于支持）要排除； 
----当**题目结论是XX或YY**，选项是反对XX，选项这个反对是属于部分反对，有可能题目中YY是正确的，所以反对题目结论XX或YY，正确的反对是2个都要反对；

第四步验证选项（重要）：
验证选项削弱强度---》强削弱-----因果倒置，中削弱------有因无果，因果无联系，弱削弱------他因；
当问论证类型题目出现，选项中出现他因，不要第一时间选，看其他选项是不是也存在反对，存在则他因选项排除。





####2.2.2.2 支持

支持，假设考题类型要点： 目标----使**论证的结论成立**。

支持看论据


核心解题思路：支持的是结论，加强的是论据（增加新的论据构成论据与结论的桥梁或者使用逻辑连词）

题型2个类型： 1 因果类 ， 2 专家学者建议类

支持类答案特点：
**1 因果关系
建立联系：题目给出的论据和论点是断层的，因果之间联系不充分，需要搭桥（新的论据或者论据论点用逻辑连词结合）。**


2 题目给出科学家，政府，专家措施计划/方法/方案/实验
答案特点：**实验/措施/计划/方法可行；目的和效果达到。**


 支持解题模式（方法论）：

第一步： 看问题

第二步： **找论据（论据的核心词），根据题目材料，总结出XXX人XXX事XXX时间XXX地点XXX物品，论据的核心词就在这几个XXX中。**

第三步： 缩小范围

第四步： 验证（搭桥--论据与结论之间的桥梁，能联系起来），有论据的核心词的选项，如果能使得题目论据和题目结论连接起来，就是正确选项。**难度进阶方向就是论据的核心词与选项的核心词是同义词，不能直接看出来的那种词。**


---
（建立联系型）支持
正确选项是通过建立了论据和结论之间的关系来强化从论据到结论的推理，强化2个对象之间的相关性（题目给出结论，这时候等于给出1个A--》B公式，说明了**逻辑真**，此时需要选出1个**事实真的选项**，选项的**事实真**能证明题目结论**逻辑真**不仅仅只是数学公式，更是真实的存在的，简单总结就是对论据的加强相关性紧密性）

例子比如：
马拉松 ---》休息
补全逻辑（增加逻辑连词）：只要跑马拉松，就需要休息；如果跑马拉松，则需要休息；大部分人跑了马拉松，都需要休息。
联系型支持（强化2个对象的相关性）：跑了马拉松导致消耗大量精力，需要休息回复精力。


海外代购能避开关税，再卖给内地顾客从中牟利，让政府损失税收，XX专家指出：政府应该打击代购行为。
论据：海外代购，避开关税，卖给客户从中牟利，让政府损失税收
结论：政府应该打击海外代购行为

补全逻辑类型选项（逻辑连词）：
如果让政府损失税收的行为，就会打击

联系型支持选项：
1 代购行为确实让政府损失了税收
2 代购行为对政府产生了不利影响


####2.2.2.3 假设

题目类型提示词：假设，前提···



支持，假设考题类型要点：  目标：使**论证的结论成立**。

因果之间的联系缺乏必要条件。


1 补全逻辑（也可以叫做充分型假设题目）
补全逻辑题目识别特征：
（1）题干问的是假设，不是问哪个选项一定为真/假
（2）大部分题干有逻辑连词，或者A是B这种论述
（3）选项中大多数情况有逻辑连词，并且跟题干内容有较多重复

解题思路：
论据： 因为A---》B或者A是B
结论： 因为A---》C或者A是C
正确选项：B----》C或者B是C


2 引入前提（也可以叫做必要型假设题目）
前提型假设实际上引入的是一个结论成立所需要的前提条件或者必要条件。因为这个必要条件经常来自题干外的信息，所以这类题目难度大。
解决方法：对选项取反（假设选项的矛盾命题），选项取反后能让题目结论不成立，这选项就是正确选项。
论据： A为真
结论： B为真
正确选项：A----》B 或者非B----》非A






---


假设类型的题目给出的不完整逻辑链条，补充完整，补充的命题属于必要条件命题。
注意区分： 假设类型题目是补充必要条件，支持类型题目是补充充分条件。 


假设类题目特点：有2种---充分类型，必要类型


---

假设类答案特点：

**1 充分型假设类题目（出题人能力不足导致出现，本质是支持类题型）：**题干中给出了一些前提，需要再补充一些前提，使推理有效。补充的前提可以视为桥梁，是题干已知条件和结论之间的桥梁。简称搭桥。核心是根据题目给出的不完整逻辑链条，补充完整，补充的命题属于充分条件命题（加强论据）。

充分型假设题目（本质是支持类题型）识别： 题目给出一个结论，需要补充论据逻辑

比如：
题目出现A ---> B ---》C---》D，结论是C---->E，要你选择选项，此时要选择D---》E的选项；
又比如结论是一样C---》E，题目给D---》E，此时题目问假设，你要选择C---》D。


**2（重点） 必要型假设类题目（正统类型的假设题）：根据已知结论，找出让结论成立的必要条件。没有这个条件，结论一定不成立。**


必要型假设题目识别： 上述论证/结论所需要的**前提**，XXX基于的**前提**是，题目问题出现**“前提”**这2个字，正统的假设题，也是有假设的。


必要型假设答案验证方法： 如果选项取否定，代入/替换到题目论证方法中，**以选项的否命题作为前提进行推导，推出一个结论，要是这个选项否命题结论能推翻题目命题结论**，则该选项为必要条件。若选项否命题结论不一定能推翻题目命题结论，则该选项错误。



必要型假设的正确选项的套路1：
选项类型1：这件事情没有被做过
选项类型2：不会有更大的损害损失，注意损失损害还是存在的，不是完全消失了
选项类型3：这次事件事物，跟它所在的环境寿命相同的前提下，此次事件事物不是之前/之后被放置的
选项类型4：这件事的主体有能力/条件可以做这件事







取反（矛盾命题）常见4大错误：
取反题型1： A只能做B这件事
错误取反：  A不能做B这件事
**正确取反：  A除了B还能做别的事**

取反题型2： 所有的A都会去做
错误取反：  所有的A都不会去做
**正确取反：  有的A不会去做**

取反题型3： A这件事情之所以发生，完全是因为B
错误取反：  A的发生，完全不是因为B
**正确取反：  A的发生，不完全是因为B**

取反题型4： 题干的主体C除了能做A这件事，还可以做B或者其他事情
错误取反：  主体C不能做A这件事
**正确取反：  主体C能做A这件事，不能做B或者其他事情**



---
必要型假设假设解题模式（方法论）：

第一步： 看问题（假设类，前提类，最能类型，最可能类型）

第二步： 找结论（结论的核心词）

第三步： 缩小范围

第四步： 验证选项---》对选项取反，代入题目逻辑得出的结论与题目给出的结论矛盾，该选项正确------因为把选项命题改为否命题，若**选项改后的命题推出的结论能推翻题目命题结论**，则该选项是必要条件**，若选项否命题结论不一定能推翻题目命题结论，则该选项错误，因为必要条件是没有P就没有Q，所以说明没有这个选项**，结论不成立。


总结3种类型：削弱类型找关系（论证方法），支持类型找论据，假设类型找结论


--------------------------------------------------------------------------------
例子1：
所有市民都迫切希望加强城市绿化，但是需要市民们为一个绿化方案付费时，总有一些人认为即使他们不出钱也能享受到绿化的好处，所以他们拒绝承担费用。

以下哪项如果为真，是上述论证所需的前提?

A.这些人喜欢占小便宜 
B.这些人认为绿化应该由政府出资
C.为绿化方案出钱具有强制性 
D.这些人认为总有人会付费


解析：
第一步：找出论点和论据。

论点：他们拒绝承担费用。

论据：总有一些人认为即使他们不出钱也能享受到绿化的好处。

论点说拒绝承担费用，论据说不出钱，讨论话题一致，且提问方式中出现“前提”，优先考虑必要条件的加强方式。必要条件即没他不行，否定代入必要条件的后论点不成立。

第二步：逐一分析选项。

A项：这些人喜欢占小便宜，因此拒绝承担绿化费用，补充论据加强，保留；

B项：这些人认为绿化应该由政府出资，因此拒绝承担绿化费用，补充论据加强，保留；

C项：为绿化方案出钱具有强制性，那这些人就无法拒绝承担费用，不能加强，排除； 

D项：这些人认为总有人会付费，否定代入为所有人都不付费，那么他们想加强绿化的目的就无法达到，这些人就不能拒绝承担费用了，因此D项为论点成立的必要条件，保留。

比较A、B、D项，A项即使这些人不喜欢占小便宜，也可以拒绝承担绿化费用；同理，B项即使绿化不由政府出资，由其他市民买单，这些人也能不出钱就享受绿化的好处。因此A、B均不是论点成立的必要条件，而D项为必要条件，根据必要条件＞补充论据，因此选项中D项力度最强。故正确答案为D。

中公解析：
题干论据为：绿化方案需要付费;结论为：有一些人认为不出钱也能也能享受到绿化的好处。将D项的内容否定后再带回题干，如果这些人不认为总有人会付费，那么可能就没有绿化了，更不能享受绿化好处，结论不成立，所以D项是结论成立前提。故正确答案选D。


例子2：
上一个冰川形成并从极地扩散时期的珊瑚化石在比它现在生长的地方深得多的海底被发现了，因此，尽管它与现在生长的珊瑚看起来没多大区别，但能在深水中生长说明它们之间在重要的方面有很大的不同。 上述结论依据下面哪个假设（）。
A 、在冰川未从极地扩散之前的时期，还没有发现相应年代的珊瑚化石
B 、冰川扩散时代的地理变动并未使珊瑚化石下沉
C 、今天的珊瑚大都生活在与那些在较深处发现的珊瑚化石具有相同地理区域的较浅位置
D 、已发现了冰川从极地扩散的各个时期的珊瑚化石
E 、现在的珊瑚能够在更深、比它们现在生活的温度更低的水中生存

分析：
在“深得多的海底”发现“珊瑚化石”，于是就认为“珊瑚能在深水中生长”，所以“发现珊瑚化石的地点就是珊瑚生长的地点”是论证的一个假设，B选项是上述假设的一种表述。

自己的分析：
题目给出的结论： 珊瑚化石与现在的珊瑚有区别
正确选项取反后得出的结论：珊瑚化石与现在的珊瑚没有区别；对B选项进行取反，得出扩散时期珊瑚化石下沉，只是因为发现地点与现在珊瑚不同，所以珊瑚化石与现在珊瑚是一样的，没有区别

这道题暗含一个点：远古珊瑚化石发现地点环境就是生长环境。


假设类题目的2级结论：
1----当题目没有明确结论提示词的时候，要看全文，同时把每个分句的逻辑连接起来，这样才是题目给出的结论，每个分句是不看先后顺序的。

2----当题目没有明确结论提示词的时候，出现“要，建议”等建议类词的时候，这个分句就是结论。



---
过强假设

假设选项的功能：
1 补全从题干信息推出到结论的逻辑过程中的缺失部分
2 引入一个能够保证结论成立的前提条件

根据以上2点，出题人老头给出2个陷阱
1 过度扩大需要假设的范围（以偏概全，偷换概念）
比如主体讨论的是猫，选项的主体却是所有动物


2 过度强化了假设需要的条件
比如题干只需要利大于弊，选项却说没有任何弊




--------------------------------------------------------------------------------

####2.2.2.4 推论-评价

推论：指的是从一个或者一些已知的命题得出新命题的思维过程或思维形式。其中已知的命题是前提，得出的命题为结论。

推论答案特点： 紧扣论据（题干），题干未提及的概念不会出现再答案中。


推论： 论据（题干）----推出结论----结论（就是选项）

推论的条件就是题干

没有假设就用词绝对： 一定，仅有，只有

解题模式：
1 分辨什么是推论题
2 无条件绝对化是错误的

####2.2.2.5 解释

解释：就是在观察的基础上进行思考，合理地说明事物变化的原因，事物之间的联系，或者是事物发展的规律。


解题模式（方法论）： 
第1步  看问题，看是不是解释类型题目。

第2步  提问（在哪里问）
提问的方式方法：
1 针对具体的问题提问
2 针对结论（因此，所以）提问
3 针对转折（但是，然而，相反）提问
4 针对现象的问题提问

在宽泛问题下 首先针对结论提问，其次针对转折提问，最后针对现象提问，这是固定顺序。

方法：先问再答（有问题才会有解释），问与答的主体保持一致。就事论事。人，物，事都可以是主体。

例子：突然下大雨，但是路上的行人都不打伞。
问1：为什么不打伞？===》因为在地下商城，不需要
问2： 为什么路上的行人不打伞？===》因为行人没有带。

第3步 缩小范围


第4步 验证


####2.2.2.6 相似

相似类题型：2个考点---论证类相似； 结构型相似。

答案结构类型5个特点（要2个以上符合）
1 肯否一致（关注结论）
2 概念位置一致
3 陈述与疑问一致
4 句式长短一致
5 推理方式一致


=========================================================

###2级结论：


1 一段材料5道题目的就一定要画表格，时间不够也要画。

2 论据之间的类比不能证明论点，没有说服力

3 题目是加强类型，论据证明论点，选项要论点一致的----当2个选项都是加强/减弱类型的时候，关注选项的论点是否与题目一致。

4 增强减弱论点的强度：在选项中存在削弱他因和无法判断削弱论点还是论证的2个选项，优先选无法判断的削弱选项

    论点 》》》 论证方式 （反驳推理过程，反驳论据）》》》论据（他因）




5  支持/加强结论的形式有两种，  一是再次确认结论，  二是举例子，    再次确认结论比举例子的支持力度大
搭桥---前置条件----解释原因----举例---加强重复论据

6 选项加强减弱论点的判断点。
**加强论点：**
        对论点的举例子支持
        对论点的逻辑增加严谨性，完整性，成为一条直通无阻的论点逻辑
  **减弱论点：**
 &emsp;&emsp;    1.切断因果关系。切断任一节因果链即为削弱。注意这里面包括一个提出排他性他因的情况。这种我也归为切断因果关系。
  
&emsp;&emsp; 所谓排他性即除了我别人都不行，即除了我提出的这个原因，别的因都推不出这个果，包括题干中的因，所以我把这种情况也归于切断因果关系。

  &emsp;&emsp;      2.**提出他因**。这种他因是非排他性的。**即我提出了一个他因来推出题干中的果，但是我不否认题干中的因也能推出果**。

  &emsp;&emsp;   3.因果论证。因果倒置走起来。**题目与选项的对象主体一致的就是切断因果，主体不一致就是他因**（严谨一些就是题目与选项的因果一致的就是切断因果，因果不一致就是他因）




7  逻辑题里，不能看带有常识的法律专家或法律条文/标准字眼的选项，都属于认证类的无关项，基本都是不能选，因为法律权威的不能质疑。


8 **论点论据话题一致**：在2个选项难以选择的情况下，**明确题目论点的主体对象，干什么事，然后对比选项的主体对象，判断是不是对象不一致，概念放大的问题**，有就不选。


9 **寻找和判断论点**，论点是：**结论观点，结果，指所以怎么样了**（主句）


10 &emsp;&emsp;  实验类的减弱题，削弱论点》》》削弱实验，一般选项只给你削弱实验的选项，给削弱论点就太简单了。削弱实验----**实验样本削弱，实验结果无关**
&emsp;&emsp;&emsp;&emsp;实验类的加强题-----**实验样本完全一致，论据具有代表性普遍性可重复性，实验结果与预期一致**
  &emsp;&emsp;  &emsp;&emsp;    对比类实验，实验样本起点是否一致，论据不具有代表性
  

11 题目出现“因此，意味着" 这2个字，后面就是结论，观点，无论前面说什么，只看”因此“后面的观点就可以了。



12  逻辑词汇： 或 = 至少     ，不都  = 不是所有的都，表示部分否定

 

13 非形式逻辑题目问**最能**削弱/增强的时候，选项里面含有“可能”等不确定性类型的词，就排除。当题目问**最可能**削弱/增强的时候，含“可能”是可以选的。


14 适用于削弱，支持，假设，仅此3种类型的经验做题方法：判断错误选项的典型性
&emsp; (1) “有些，有的”开头
&emsp; (2) 含“可能”的选项一定是错误的（当题目问**最可能**的时候就不符合这结论，此情况较少）
&emsp; (3)题干描述的2个事物没有存在表示比较/不比较的涵义，选项中却存在表示比较/不比较的意思（无中生有）。**识别词语：相比，比较，比，较，更好···**
 &emsp; (4)诉诸于权威，比如专家指出，XXX说，真理定义类型表述事物，经过XX次实验检验


15  论据一般出现在结论前面的1 到2句话，多数是结论前面1句。

16  对于不能 支持（赞同）/削弱（质疑）类题型，在题目下根据题目要求画出箭头，**向上表示支持，向下表示削弱，无关项就用横线表示**，因此 **题目问不能支持/削弱，则是题目要你选出 支持/削弱的相反项或者无关项。**



##2.3因果推理类的基础

当我们知道，一件事是另外一件事的原因，或者是另外一件事的结果，我们就能从原因推理到结果，或者从结果推理到原因。如果原因和结果之间的假定关系是被正确的建立起来的，那么基于这些关系的推理就是十分强有力的。

因果推理是依赖于因果连接方面的知识。

形式逻辑：能够区分---事实真---逻辑真

论证推理：能够区分---事实上因果关系----逻辑推理关系

事实因果的方向是指客观的世界中两件事情的因果关系，这个关系是客观确定的。
逻辑推理的方向是指在题干中从论据到结论的推理方向。

论据-----------------------》结论
因--------------------------》果（由因推果模型）
果--------------------------》因（由果推因模型）

###2.3.1由果推因模型
这个果推因模型是因只有1个并且是主要的，果也只有1个，没有1对多的情况。
从**当前时间点**，基于**事实结果往过去推理**，去推理那些**已经发生**，但我们不知道的真正导致该结果发生的原因。
引入其他变量导致结果成立的原因，是削弱。
排除其他变量导致结果成立的原因，是支持。

比如：
论据-------------------》结论
最近工作没做好----------》1能力不行（真实原因）；2生病了；3失恋了
有3个可能原因，但是当原因1 作为结论1的时候，原因2和原因3对于结论1是一种削弱；
当3个可能原因都作为结论的时候，排除任何一个原因都是对剩下的原因进行一次支持或者加强。


###2.3.2由因推果模型
从当前时间点，往未来推理，推理那些还未发生，如果没有意外因素，按理说会发生的结果
引入其他变量导致结果不成立/对结果有负面影响的原因，是削弱。
排除其他变量导致结果不成立的原因，或者是引入其他变量对结果有正面影响的原因，是支持。 
一般指大概率事件

###2.3.2区分论据和结论，果与因
果，往往是一个现象，一个数据，一个比较后的结果
因，往往是一个行为，一个动作，一个主观结果

1）当我们先看到结果时候，对导致该结果原因的推理，直接影响了我们对世界的认识（事不过三，早干嘛去了，我以为）

2）而当我们计划实施某事件（原因）时，对是否有对结果有影响的其他因素的判断，会直接影响了我们的计划是否如期达到效果。




=========================================================
#3定义判断

大纲：每题先给出一个概念的定义，然后分别列出四种情况，要求考生严格依据定义选出和一个**最符合或者最不符合该**定义的答案




「定义判断中的定义是正确的，不容置疑的」----题目给出的定义是真理，别的不用想，别脑补，重点在于选项中出现的对象是不是在题目给出的定义范围内========》注意是**题目定义范围包含了整个选项的对象范围，不能出现题目定义范围与选项对象范围有一部分交集，不重叠部分就是出题人给的坑**。


定义判断从大的方向就2个要求： 1概括理解定义词 2与选项对比，找出符合或者不符合题目要求的选项


解题思维：
看清楚提问方式--------------属于/不属于，单定义/多定义
识别有效信息---------------找准关键词，关键句
逐一分析选项---------------对比选项


快速识别有效信息
主体/客体
条件/结果
包含定义的句子优先看
补充说明
多定义问谁先看谁

小技巧：同构选项优先排除





##单定义
单定义判断条件：
根据下面这个公式，分析题目定义，然后一个个套到选项上：

**主体、原因 -----》方式，条件、策略、手段-----》客体、目的、结果**


识别标识(这些标识后面就是关键句子，圈出关键词)

1 主体：行动的发出对象
2 客体：行动作用的对象
3 方式：以···方式，···手段，通过，利用，用
4 时间：当···时，在···情况下
5 原因：因为，由于···，由····导致，···引起
6 结果：导致···，从而···，造成···，最终····
7 目的：以···为目的，为了···，确保···，出于···，达到···


**who、what 、where、when，why-----谁，在什么时间，什么地点，做了什么，目的是什么**



**除了判断选项内容能否都对应匹配题目定义，还可能考察选项优中选优的情况，一般情况都是选择对应匹配定义数量多的。**

题目类型有4种：
1： 题目只问正确或者错误的，属于或者不属于的
2： 题目问最可能属于（带有不确定性）----》选项一般优中选优
**3： 题目给出了2个或2个以上定义，问均/都符合以上定义的
4： 题目给出了2个或2个以上定义，问均/都不符合以上定义的（选项一个定义都不符合）**


定义做题顺序：
1 看题目要求----选择正确的，不正确的，明确是非题型
2 看题目给出的定义名词



---------------------------------------------------------------------------------


当出现争议题的时候，一定要清楚，这是出题老头能力不足，出现错误，下次一定不会出现类似的错误，所以花时间在这类题目上是没有意义的，可以略过去。




==============================================================================
方法论（解题模式）：

第一步：看问题，**问的是属于定义，还是不属于定义**


第二步：提取定义核心（**时事人地物**）
---主语：人，物
比如：XXX您好（人），因为XXX（事），所以我们要做XXX（物），希望可以在XXX（时）前完成上线（地）



第三步：缩小范围
1）观察4个选项，发现有同构选项，直接排除。
2）选项的人，事，物是不是在定义范围，题目定义每一样都能对应上，没有对应上的排除。


第四步：验证 




现在是设计方法论的阶段，首要目标是明确，知识点与题目提示词之间的联系，因为定义题很容易就明确问什么，但是不知道知识点考点。

定义判断关键在于题干的几个条件，一般一道题目是三个条件，由易到难。我是从第一个条件依次带入到选项，可以很快的排除错误答案，并且避免去纠结那个最复杂的条件。之前我经常性会去想读懂全部的定义条件，但是又浪费时间又会忘记。



-----------------------------------------------------------------------------------

题目例子1：

侵蚀作用指风力、流水、冰川、波浪等外力在运动状态下改变地面岩石及其风化物的过程。侵蚀作用可分为机械剥蚀作用和化学剥蚀作用。
根据上述定义，下列选项属于侵蚀作用的是：


A 裸露的人造雕像在长期的风吹日晒雨淋下，会出现机械剥蚀，甚至会出现崩塌碎裂


B 植物根部在岩缝中向岩石施加物理压力，并提供一个水及化学物的渗透渠道，造成岩石分解开裂


C 可溶性石灰岩在流水中部分溶解形成天然溶液而随水流失，造成岩体缩小甚至消失，形成岩溶地貌

D 在气温变化突出的地区，岩石中的水分冻融交替，冰冻时体积膨胀，像楔子插入岩体内，导致岩石崩碎

解析：

-----------------------------------------------------------------------------
侵蚀作用---H
风力，流水，冰川，波浪等外力----X
运动状态下改变地面岩石及其风化物 的过程（出现过程等词表明是方式，条件、策略、手段）----Y


A：人造雕像 与地面岩石，材料上可能出现一致，但是岩石材料不是完整包括人造雕像的材料，题目和选项中2个对象范围存在交叉，所以排除，正确选项是题目对象范围包含选项对象范围。

B：风化作用与侵蚀作用的区别---岩石的最终状态是分裂留在原地还是随着侵蚀液体远离原地。这里有很大的问题，风化和侵蚀是可以共存的，也就是说B选项描述的现象是同时具有2层意思的化学侵蚀+生物风化，但是B选项判断不是侵蚀作用的标准概念是来自风化作用的判断标准，你要是没有风化作用判断标准的概念，你是无法区分判断侵蚀作用和风化作用，因为现实实际的现象就是2个作用同时存在同时发挥作用，但是人为的定义主体作用是风化作用。此时就引出一个非主流判断法----同结构选项法。此选项为易错选项，因为不知道风化概念就很容易选择此项。



C：岩石在流水中溶解流失，符合外力在运动状态中对岩石进行侵蚀进行改变。


D：水结冰后，冰的体积膨胀这过程不属于水的运动状态，也不属于冰川的运动状态，是凝固过程，不是运动过程。

同结构选项
选项的主语，谓语，宾语的位置差不多或者一致，也就是使用的是一种表达手法。
EG: 此题目选项中都给出了岩石的最终状态--- A，B，D项是碎裂，C项是溶解随着流水流失，根据题目给出的定义，ABD这几个选项的主谓宾结构都是相似的，而且结构也是一致，所以可以判断ABD是属于同构项，可以排除，最后选择C。


题目描述对线或者内容范围对应选项的描述对线或者内容。

此题目逆向工程：
从选项设置来说就是把风化作用与侵蚀作用区别判断作为考点，然后设计选项的内容。

选项中给出的关键字与题目定义中关键字之间匹配程度的引导，哪些内容导致了错误引导？
A：裸露的人造雕像-----裸露，雕像这2个词语很容易使人对应到题目定义地面岩石及其风化物，但是，正确的应该是3个词语：裸露，人造，雕像，其中人造这个词含义与地面岩石存在交集，所以要是遗漏了人造（的）这个词就很容易造成误选。

B：施加物理压力，水及化学物的渗透渠道，造成岩石分解开裂-----------物理压力，水及化学物，符合外力，化学侵蚀作用，但是，这题考点实际是考风化作用与侵蚀作用的区别：岩石最后是流失了还是保留在原地，所以此题很恶心的地方。

C：可溶性石灰岩在流水中部分溶解，随水流失---------地面岩石，流水，运动状态下，改变过程，符合题目定义，正确答案。

D：岩石中的水分冻融交替，冰冻时体积膨胀，像楔子插入岩体内----------地面岩石，冰块膨胀压力对应着外力，但是，题目中定义外力要在运动状态下改变地面岩石及其风化物，水变成冰膨胀过程不属于冰块的运动过程，是属于水的凝固过程，不符合题目定义，考察点是常识知识点。

--------------------------------------------------------------------------------

主体，动作，关键词，目的，结果

包含，交叉，并列========包含，交集，并集

----------------------------------------------------------------------------

题目2：

图灵测试是指测试者在与被测试者（一个人和一台机器）隔开的情况下，通过一些装置（如键盘）向被测试者随意提问。问过一些问题后，如果被测试者有超过30%的答复不能使测试者确定出哪个是人、哪个是机器，那么这台机器就通过了测试，并被认为具有人类智能。
　　根据上述定义，以下哪项中的测试**一定通过**了图灵测试
　　A．对机器甲40%的答复所有人都确认其为机器
　　B．对机器乙60%的答复测试者能确认其为机器或人
　　C．对机器丙30%的答复有90%的某小区居民确认其为机器
　　D．对机器丁30%的答复有10%的某校大学生不能确认其为机器

解析：

---

定义：超过30%的答复不能使测试者确定出哪个是人、哪个是机器
-----也就是说超过30%的答复使测试者不能确定出哪个是人、哪个是机器
----》测试者不确认出 人OR机器，超过标准线30%

主体：测试者----》有3个选项：确定是人，确定是机器，不确定人或者机器。
条件手段： 超过30%，不能确认人OR机器
目的，结论：
通过测试----不确认人OR机器，超过30%

**3种条件状态： 确认人，确认机器，不确认人OR机器**

A：40%的确认机器 ----》60%的，确认人，或者不确定人OR机器
这里出现**2种条件状态**，
因为题目**一定通过**的要求，是要100%确定的唯一结果的选项，
而现在A选项有确认出人，和不确定人OR机器，这2种结果，所以排除。

B：60%的确认人OR机器-----》40% 不确认人OR机器
符合定义条件。

逻辑就是 机器或人，这是一个并集，也就是说，机器+人 总共的和的概率是60%， 剩下的就是不确定人或机器的概率。




**另一种解法： 看主体是测试者，选项中只有B的主语是测试者。**

------------------------------------------------------------------------------

题目3：
（2019年79题）确认偏差是指人一旦产生某个信念，就会努力寻找与它相符的例子，并无视那些不符的。根据上述定义，下列最可能属于确认偏差的是：

A. 小刚认为终有一天会天降横财，便痴迷于彩票，尽管从未中奖，他还是整日游手好闲，甚至贷款买彩票

B. 小东听到某个所谓的“预言家”断定自己会遭遇车祸后时常感到担忧，某天他突然发生车祸，于是他更相信那位“预言家”了

C. 尽管别人告诉小黄所有泡菜坛里的泡菜原料、泡制时间都一样，但小黄仍认为用黄色泡坛里的泡菜烹饪鱼香肉丝会更可口

D. 股票经理人告诉客户小明某股票会涨的同时又背着小明告诉其他客户该股票会跌，结果该股票大涨，从此小明对该经理人十分信任

分析：

第一步，观察提问方式，“最可能属于”，是选是题，且题干中只有一个定义，就是确认偏差；
第二步，理解题干，锁定关键信息，题干中的关键信息有“一旦产生某个信念”、“寻找与它相符的例子”、“无视不符的”；
第三步，比对选项，
A  ：选项中小刚认为终有一天会天降横财，体现其产生了某个信念，但是该项中并没有明确提及其找到了一些例子去佐证他终有一天会天降横财，无视信念的例子是很多次没中奖还在买，所以，只符合题干中的前面一个关键词，不符合后1个关键词，因此相对不符合；
B  ：选项中小东感到担忧体现其已经产生了自己终有一天会遭遇车祸的信念，并且其最终发生了车祸，体现其找到了例子去佐证自己是会遭遇车祸这个信念的，相对来说，符合题干中的前两个关键词，因此更加符合一些，保留该项；
C  ：选项中小黄认为黄色的更加可口，体现的也是其形成了信念，但是其也是没有找符合信念的例子去佐证它，所以也只是符合了前一个关键词，不符合后两个关键词，相对来说也不符合；
D  ：选项中小明只是对经理人非常信任，并不体现形成了某一观念，所以不符合题干中的所有关键词，很不符合。


因此，该题择优选择B选项。




------------------------------------------------------------------

一些个人理解：
A选项中产生给出的信念是大发横财，找出的例子也应该是某人大发横财，不是没有中奖或者屡次不中，从未中奖-----不符合大发横财的信念，不合适的例子，所以错误。

B选项中则是给出了自己出车祸这个例子，是符合信念的例子，所以正确。


选项中给出的关键字与题目定义中关键字之间匹配程度的引导，哪些内容导致了错误引导？

题目给出的3个定义要求：主语====》人，信念,找出与信念相符合的例子，并且无视不符合信念的例子。
看得到题目给出了4个要求，其中主语是人这是明显知道的，关键在于信念，和它的例子还有无视信念的例子，A选项中的大发横财是指中奖后的大发横财，此时相符例子必须是XXX买了YYY彩票中奖得到了HHH位数的钱，**强调的是例子和例子内容**，而寻找与它相符的例子，自己做题时的想法是XXX有了YYY的想法信念，然后买彩票是实践想法信念的过程，不管是成功还是失败，重点落在了寻找这个词中，所以选择错误了。

-----------------------------------------------------------------------------

题目4

拟态，是指某些生物在进化过程中具有与另一种生物或周围自然界物体的相似的形态，这种相似性很高，几乎难以分辨，可以保护某一物种或两个物种。

根据上述定义，下列选项属于拟态的是：

A  海豚、企鹅和带鱼虽然分别属于鲸类、鸟类和鱼类，但为了适应海洋生活，都进化出了流线形的身体

B  北极熊生活在白雪皑皑的北极，为了掩护自己捕食时不被猎物过早发现，皮毛逐渐变成与周围环境相似的白色

C  大鲵，俗名娃娃鱼，已在地球上生活了数亿年，其受到刺激时的叫声酷似人类婴儿哭声，让人听到不忍心伤害，对一些猎食动物也有威慑作用

D  杜鹃会将与宿主卵酷似的卵产在宿主巢内，其雏鸟在孵出后不久就会将宿主雏鸟挤出巢外，独享体型只有自己一半大小的宿主父母的喂食


-----------------------------------------------------------------------------

个人理解：
题目4的破题点----相似的形态，相似性很高，几乎难以分辨---高相似的形态
A项： 海豚、企鹅和带鱼虽然都是有流线形，但是不是高相似的形状或状态

B项： 北极熊的毛发颜色和周围物体雪颜色相似，不是形状或者状态相似，形态和保护色不是一个概念，形态是生物体外部的形状，框架结构一样，竹节虫之类的。

C项： 声音不是物体或生物外部形态

D项：蛋外部一致，雏鸟大小大一半，形状相似的。


-----------------------------------------------------------------------------

题目5
诱发运动是指由于一个物体的运动使其相邻的一个静止物体产生运动的错觉现象。

　　根据上述定义，下列属于诱发运动的是：

　　A.多张图片按一定空间间隔与时间距离相继呈现形成电影

　　B.当我们注视夜空时，会看到月亮在动，而云是静止的

　　C.在黑板前点燃一支蜡烛，并注视着烛光会看到烛光在运动

　　D.注视瀑布的某一处，再看周围的树木，会觉得树木在向上飞升




题目5抄袭青海卷的原题：

诱发运动是心理学中有关运动知觉的概念。它是指一个物体正在运动时，人们感觉其相邻的一个相对静止的物体也在运动。
根据上述定义，下列属于诱发的是：

A两列相向行驶的火车会车时，坐在车上的乘客会觉得车速提高了很多

B两张相同照片先后在屏幕上快速出现时，人们常感觉是同一张照片

C点亮蜡烛后，注视着烛心的火苗，会发现火苗在不断地跳动

D仰望夜空时，由于浮云的运动，人们感觉月亮也在运动

---------------------------------------------------------------

###个人理解：

什么是好的题目，都是相对运动，描述定义准确的选项是符合定义字面上的意义，不会有隐藏的第二层意思在定义描述上。
具体的说就是：读第一遍定义就能明确意思，明白YYY状态下XXX事物存在RRR情况，在AAA事物感觉/观察下BBB事物也存在YYY状态。

当考场上出现定义改编题的时候，如何区分错误选项，观察选项的动词，出现2个以上的动词时候，不要选，排除。

定义改编题判断点：
**第1种------**出现**“几乎，很，差不多，接近，非常，甚至，极度，极，特别多”**等无法量化的人文用词，没有出现10%，4分之一，3倍等量词，基本上物理定义都是要求准确，量化，所有情况都考虑到的描述，所以出现一个这样的人文用词，就可以直接判断了。

**第2种------**缩减了简写了原来的定义，就是把一些主语，形容词，定语省略了缩减了，导致定义的范围减少，但是主要的内容没有变化，在考场上是无法判断的，唯一能判断的就是定义明明很短，但是选项一个都没有对上，或者是定义读**第一遍**无法明确XXX时间XXX地点XXX人/物要做XXX事（句子**无法简单容易**分清楚谁是谁，谁干了什么事），此时立即判断是缩减定义，然后看选项用词，动词多的，内容不在定义范围内的排除。
**改编定义题有2类： 更改描述词类---人文用词， 缩减原有定义内容类---动词多，定义范围外的选项排除**



=========================================================



###2级结论：

1 单定义题目的否命题类型，关键是看 3个主要对象（主体对象，条件手段对象，结果对象）是否符合题目的定义，不符合就是答案了


2 看选项是否符合单定义里面的定义（题目里面的描述所用的动词，名词物体之类的）

3 定义题要是选项里面2个选项是结构相同，字不同，大概率都是错误选项。


4 定义题里面要判断题目选非题（定义的反面），看题目问的是不是支持OR不支持（隐藏深的---有效控制···等具有抑制发展类似的词语）


5 假如4个选项中的定义效果有3个或者2个是属于同一种效果（广义上同属一类）的就可以排除了。


6 题目的类型：
XXX作用是 在 A 对象 中，以B对象和C对象形式到达某种程度后，当发生YYY变化后，出现XXX现象，因此称为XXX作用。其中 B对象 是 D对象 的某种状态，C对象是E对象的某种状态。
假如出现定义中的对象在题目后有补充说明的，重点就不是补充说明的内容或者对象，而是YYY变化，转移视线的技法，此时就判断选项中哪个有或者没有YYY变化。

7  选非题=====》当题目定义看不懂的时候，看选项内容，主要关注主谓宾和句子结构，结果内容差不多或者一致的选项，根据相似内容的选项数量，判断出唯一不同的哪个选项。


8 形容主语状态的都是谓语，所以谓语越长的题目中，关键点是看关键词：在XXX中，越XXX越XXX。

9 从第一个条件依次带入到选项，可以很快的排除错误答案，并且避免去纠结那个最复杂的条件。之前我经常性会去想读懂全部的定义条件，但是又浪费时间又会忘记。

10 根据题目判断出X,Y ,H后，使用排除法，根据“X”来判断4个选项，哪些不符合就排除，排除不了了，就根据“Y”来进行判断排除，再排除不了，就使用“H”来进行判断排除。


11  **定义题要是提高难度就是考常识，找2个难以区分的定义概念，再分别给出2个各自定义下的典型例子，知道的就秒选，不知道的绕不开。**


12  题目定义缺什么，注意选项有什么吗？ 粉笔给出的知识点考点，哪些词哪些结构，如何提示出题目是考什么考点？









13 定义改编题判断点：
第1种--出现**“几乎，很，差不多，接近，非常，甚至，极度，极，特别多”**等无法量化的人文用词，基本上物理定义都是要求准确，量化，所有情况都考虑到的描述，所以出现一个这样的人文用词，就可以直接判断了。
第2种--缩减了简写了原来的定义，就是把一些词省略了缩减了，导致定义的范围减少，但是主要的内容没有变化，在考场上是无法判断的，唯一能判断的就是定义明明很短，但是选项一个都没有对上，此时立即判断是缩减定义，然后看选项用词，动词多的，内容不在定义范围内的排除。
改编定义题有2类： 更改描述词类---人文用词， 缩减原有定义内容类---动词多，定义范围外的选项排除


14  在看不懂，或者2选1中无法排除选项时候**同构选项排除是第一权重，一定正确的。**



-------------------------------------------------------------------------



##多定义

1 问啥看啥
看清题干问的是哪个定义，重点看目标定义

2 比较定义
纠结两个选项时候，再与其他定义比较



---
题1：
直观教学是指利用教具作为感官传递物，向学生展示相关内容，以达到提高学习效率或效果的一种教学方式。直观教学包括实物直观、模象直观和言语直观。实物直观通过直接感知实际事物而进行；模象直观通过对实物的模拟性形象来直接感知；言语直观是在形象化的语言作用下，通过学生对语言的物质形式（语音、字形）的感知及对语义的理解而进行的一种直观形式。 根据上述定义，下列**不属于**上述三种直观教学的是：

A、请学生在课后阅读整篇小说内容并撰写读后感



----
解析：

①实物直观：直接感知实际事物； 
②模象直观：直接感知实物的模拟性形象； 
③言语直观：在形象化的语言作用下，感知语言的物质形式，理解语义。 

个人解析：

言语直观的分析:  主体--学生，
                 条件手段-----形象化的语言，语言的物质形式（语音、字形）的感知及对语义的理解
                 目的-----理解教学内容

最明显的是：**学生在课后阅读**，现在是要求教学，选项是课后自己学。





======================================================

二级结论：

1 要注意题目是要选 属于 还是  不属于。

2 多多注意**主体，方式（行为，策略、手段），状态（主体的前缀），目的，结果**。

3 定义题目的ABCD选项中出现矛盾选项，则必在这2个选项中出现正确答案。

4 定义题目出现**在XXX中，在XXXX上，在XXXX下**，都是**表示XXX是前缀是前提，不是主语**。

==========================================================================

个人参考和借鉴的理解：

「定义判断中的定义是正确的，不容置疑的」

对「定义判断」题干中和「定义词」相关的句子描述浓缩为**1~3个要素**，并将**要素与选项进行比对**，从而确定其是否符合定义。

定义题型：
定义描述中（无论单个、多个定义）**能够简单使用1~3个词语、短语进行概括**------


定义描述中（无论单个、多个定义）**无法使用1~3个词语、短语进行概括**，必须使用一长串描述词定义词描述的定义------



定义考察的难点：

    「把一个定义的概念拉的特别长，甚至拉成2~3句话，但只考察其中一个词」
    「在定义句中插入大量的限定词，4个选项分别考察不同的限定词」
    「在定义和选项中，使用语义看似相近但实际相差较大的词」
    「故意考察考生不熟悉的知识，有的定义词和考生通常理解有所不同」

==========================================================================

定义题的坑/干扰设定：

选项中的主语名词设置很长（学术专业类题目），其中带有歧义词语-----解决：只看最后一个词

题目定义来自专业学术类，选项出现难以区分的情况-------重新看定义，对定义进行一次包含集合的判断，然后再对选项进行判断。

排除法存在的陷阱---选项给出的内容对象，有2个是符合/不符合题目定义（要求答案符合/不符合）的，然后剩下2个选项，1个






================================================================================
个人理解：
题目定义描述的简单，选项里要你套定义里面的对象，策略，结果，效果，可能就会出错了。关键看选项分析，几个内容是符合题目定义的。

主语法-------前提、前缀+主语===》做什么事，想什么事（这里面的事情也要分清楚对象，是主语本身还是其他对象）====》结果是什么，效果是什么。
主语法变形题----做什么事，想什么事=====》前提、前缀+主语====》结果是什么，效果是什么。
或者是---------做什么事，想什么事=====》结果是什么，效果是什么=====》前提、前缀+主语。






定义类型的争议题，看机构OR个人给出的解释是不是符合题目的定义对象，符合生活逻辑；要是解释中出现笼统的解释（一笔带过，无视选项某个明显的说明，这就是机构在留后路），此时就要坚持自己的看法了。

#3.1管理专业的逻辑定义

##1.1概念
概念是反映对象本质属性的思维形式

有2层含义：内涵，外延
内涵：是指概念所反映的事物的本质属性
外延：是指概念的内涵所具有的哪项属性的事物的范围

例子： 硕士  内涵是介于学士及博士之间的研究生学位，外延是学术型硕士，专业型硕士

##1.2定义

定义是对概念的描述，它包含被定义项，联项和定义项

例子： 土豪（被定义项）/是（联项）/有钱并且炫耀的人（定义项）


定义的规则：
|编号 | 规则| 违反规则的错误| 例句 |
|  :----:  |  :----:  |  :----:   |  :----:   | 
|1 | 定义项不得直接包含被定义项| 同语反复| 聪明人就是脑子很聪明的人 |
|2 | 定义项不得间接包含被定义项| 循环定义| 奇数就是偶数+1；偶数就是奇数+1 |
|3.1 | 定义项的外延和被定义项的外延必须完全相等| 定义项 > 被定义项；错误原因：定义过宽| 人类是用肺呼吸的哺乳动物 |
|3.2 | 定义项的外延和被定义项的外延必须完全相等| 定义项 < 被定义项；错误原因：定义过窄| 人类是指女人 |
|4 | 定义不应包括含混的概念,不能用比喻句| 定义含混| 儿童是指祖国的花朵 |
|5 | 定义不应当是否定的| 用否定句下定义| 男人就不是女人的人 |



##2.1概念的种类--正概念和负概念

正概念和负概念是根据概念所反映的对象是否具有某种属性来划分，强调的是有没有这种属性，不是属性的内容是什么。

|概念 | 定义| 例子|
|  :----:  |  :----:  |  :----:   |
|正概念 | 具有某种属性的概念| 成文法，理性，成年人|
|负概念 | 不具有某种属性的概念| 不成文法，非理性，未成年人|

注意：
漂亮 与 丑 ，正义与邪恶都是正概念，都是一种属性，无关褒贬。
不漂亮，不善良是负概念，因为表明了不具有该属性。


##2.2单独概念和普遍概念（多设计为干扰项）

概念数量的区分

|概念 | 定义| 例子|
|  :----:  |  :----:  |  :----:   |
|单独概念 | 概念数量只有一个| 清华大学|
|普遍概念 | 概念数量至少2个| 大学|


##2.3集合概念和非集合概念（类概念）

集合概念：反映集合体的整体性质的概念就是集合概念（集合体是指一定数量的个体所组成的全体）
例子：我们班（集合概念）/是一个优秀的/班集体（集合概念）

非集合概念：也可称为类概念，是指这个概念中每个个体共同具有的性质（共同属性）。

例子：鸟是卵生的。


集合概念和非集合概念的区分：

在概念前加“每个，每只”，或者概念后加“之一”，句子的意思改变了----》集合概念
在概念前加“每个，每只”，或者概念后加“之一”，句子的意思没有改变----》非集合概念/类概念

因为集合概念有的性质属性，集合体里面每一个个体不一定有的
我们班是一个优秀的班集体---》每个我们班是个优秀的班集体---》我们班是集合概念
鸟是卵生的 ---》每只鸟是卵生的----》鸟是类概念
我是中国人----》我是中国人之一----》中国人是类概念


集合概念只反映集合体的整体性质，不反映构成集合体的个体的性质，同样地，每个个体的性质也未必能准确反映集合体的性质
分解谬误：把集合体的整体性质，误认为是每个个体或者部分的性质。
分解谬误使用范围：一般出现的题目内容是用**集体概念具有的性质去推出个体的性质也应该有**

合成谬误（以偏概全）：把个体或者部分的性质误认为是集合体或者整体的性质。
合成谬误使用范围：一般出现的题目内容是用**个体概念具有的性质去推出集体的性质也应该有**

##3概念的划分与概念之间的关系

###3.1概念的划分（分类）

划分/分类：按照一个标准对概念进行细分

例子：以性别为标准，把人这个概念划分为 男人和女人

|编号 | 规则| 违反规则的错误| 例子 |
|  :----:  |  :----:  |  :----:   |  :----:   | 
|1 | 划分标准要统一| 划分标准不一致| 杂志分月刊，周刊和外文刊物，错误原因：一个按时间，一个按语言 |
|2 | 层级要一致| 不当并列| 学生分为大学生，中学生，1年级学生，错误原因：大中学生不能与1年级学生并列 |
|3 | 不重复| 子项相容| 人可分为男人，女人和孩子 ；错误原因：孩子有男的有女的 |
|4 | 不遗漏（各部分相加要等于原概念，不能比原概念外延小）| 划分不全| 人可分为老人，中年人，小孩 ；错误原因：老+中+小 < 人，缺少青年人 |
|5 | 不多（各部分相加要等于原概念，不能比原概念外延大）| 多出子项| 孩子可分为中年人，少年，婴儿，幼儿 ；错误原因：中年人不属于孩子 |

题目识别：A个对象划分出2个标准a1和a2，B对象划分出2个标准b1 和 b2，然后拿出A对象a1标准与B对象b1/b2标准进行比较，此时就是划分不统一错误。



###3.2概念之间的关系（类比题目用的最多）

逻辑判断题目也有这考点的题目
题目识别：题目给出2个或者2个以上的命题，然后题目问2个命题结合起来的问题（2个命题可以看成2个标准，题目问都符合2个标准的/都不符合2个标准的）


####1 全同关系
2个概念的外延完全相同。

EG:等边三角形    所有角均为60度的三角形

####2 种属关系
1个概念A（种）的外延包含于另一个概念B（种）的外延，称为种属关系/从属关系/真包含于关系

EG：兔子是动物的一种

####3 交叉关系（不等于交集）
2个概念在外延上有且只有一部分是重合的。

交集（4种情况）： A与B完全相同； A真包含于B； B真包含于A； A与B有部分重合

交叉关系例子：男人-----教授------重合部分是男教授

####4 全异关系

全异关系分为2种： 1 矛盾关系  2 反对关系

矛盾关系：2个概念的外延没有重合，并且2个概念的外延相加是**全集**。矛盾双方必定一真一假。

EG：人（全集）---》男人，女人
又比如：
$$ABCD至少3人，按照数学上描述为   X \geq   3,它的矛盾是 X \lt   3$$

反对关系：2个概念的外延没有重合，并且2个概念的外延相加不是全集，至少还有一个事物不属于这2个概念。反对关系可以同假，不能同真。

EG：人： 儿童，青年，中年，老年，随便其中2个对象拿出来都是反对关系，但是不能有既是儿童又是青年/中年/老年的，不能都是真的。

###3.3四种与概念的关系有关的谬误

####1 偷换概念
在同一个论证中，同一个概念的内涵和外延应该完全一致（全同关系）。否则就是描述2个不同的对象。

EG：象是动物，所以小象是小动物（小象的小是年龄上，小动物的小是体型上，描述的不是同一个对象）

题型识别：题目种出现2个不同的命题或者概念，其中这2个命题都有完全相同的字的对象。



####2自相矛盾

两个命题或者概念相互自相矛盾，比如一真一假；相互反对的2个概念或者命题，至少一假。

EG：这个人，既是男人，又是女人。



####3 摸棱两不可

两个命题或者概念相互自相矛盾，比如一真一假；下反对的2个概念或者命题，至少一真。

下反对是六边形逻辑图那里的下边的反对关系（就是有些是----》推出有些不是的那对关系）


####4 非黑即白

误把反对关系当作矛盾关系，黑色和白色是反对关系，不是矛盾关系，因为还有其他颜色，不是黑色也可以是红色···这个误解也可以称为非此即彼，或者不当二分（全集理解错误）

题目识别：题目给出2个命题或者概念（2个概念是属于反对关系），要求你二选一，不是XXX就是YYY。



#逻辑学的判断（判断就是命题）









#4图形类比

图形推理里面发现题目几个图形中有一个图形与其他图形规律不一样，则考点一定不是多数图形的规律，也不是单独图形规律，直接排除

快速定位到某一个考点： 图形特征


---
位置类识别特征：  元素组成相同，比如外框一样，里面的线条有变化，可以考虑位置类考点

考点：平移，旋转，翻转
 
平移：（运动轨迹--重合，循环）
１　方向：　直线（上下，左右，斜对角线），绕圈（顺逆时针）

２　常见步数：　恒定， 递增（等差）

旋转：（方向+角度）

旋转－－－顺时针，逆时针　常见角度： 45度，90度，180度（左右对调和上下对调）


翻转：（注意区分180度旋转和翻转）

左右翻转：竖轴对称 或者 左右对调，上下不变；  

上下翻转：横轴对称 或者 上下对调，左右不变；




---
样式类型识别特征：  元素组成相似（线条重复出现）


考点1 ：加减同异

1 相加，相减


2 去同存异


3 去异求同


考点2 ： 黑白运算

1 识别特征：图形轮廓和分割区相同，内部颜色不同

2 方法： 相同位置运算

平移和黑白运算区分： 
黑块数量相同：优先平移

黑块数量不同：优先黑白运算

---
属性类识别特征： 元素组成不相同，不相似优先属性

考点： 对称性，曲直性，开闭性（优先级：对称 》》》曲直》》》开闭）

考点1： 对称性
 1  轴对称
 **基础考法：角度，方向和数量**
一般特征图形：三角形，一个角，一个箭头
 
 **新式进阶考法：对称轴与图形的关系---平行或者交点，或者与图形的线重合。**
 
2   中心对称（某条线穿过中心点后能交于一个点，该点围绕中心点旋转180度后，图形不变） ：比如 S，N ，Z，平行四边形。 

3  轴对称 + 中心对称

轴对称与中心对称的区别：
中心对称是正看倒看都一样。轴对称是按照一条线对称。

特殊图形：有一个图形，有横竖2条相互垂直的对称轴，既是轴对称又是中心对称


考点2： 曲直性（多数时候考全曲全直，半曲半直很特殊）

1 全曲线

2 全直线

3 半曲半直（此考点多出现在分组类题型）

4 曲直与位置
内直线外曲线，外直线内曲线
左直线右曲线，左曲线右直线

考点3：  开闭性   识别特征： 完整的图形留了一个小开口

1 全封闭

2 全开放




---
数量类识别特征：元素组成不相同，不相似 （属性规律都不符合的时候）

考点： 面，点（交点），线，角，元素

考点1： 点（交点）数量---线与线的交点（包括切点），端点不是交点

点（交点）类型的特征图： 
1） 线条交叉明显 （一个完整图形 + 一条线或者是大树杈，1个点发射多条线） 
2） 乱糟糟一团线交叉  
3） 顶点，切点，相切较多


进阶细化考法：
1 曲直交点：出现数点（交点）特征图，但**整体数点无规律，且存在曲直相交**

2 内外交点：出现数点（交点）特征图，但**整体数点无规律，图形有内外**

3 内部线与外框交点：外框一致或者相似，内部线条明显，且常规没有规律，考虑内部线与外框交点

考点2 ： 直线或者曲线的数量

1条曲线的判断： 像C或者波浪线这样平滑的，没有像Z这样的弯折的。

直线特征图： 
多边形，图形中含有单独的单一的直线（直线角度也要考虑，比如45度有3条直线）

曲线特征图： 
图形中含有单一的平滑的无折点曲线（全曲线图形，圆，弧线），有折点算2条曲线


曲线的进阶细化考法：
1） 如何识别：像C或者波浪线这样平滑的，没有像Z这样的弯折的。
2） 1笔画：同时满足2个条件---线条之间连通---奇数点为0或者2
3） 多笔画：




考点3：  面数量

面类型的特征图： 
封闭图像，一个三角形里面留白的部分是面，要是三角形的线加粗加黑了，这些黑的部分也不是面。

1 图像被分割，封闭面明显


2 **生活化图形**，粗线条图形中留空白部分


进阶细化考法：
1） 面的形状
2） 最大面的形状（也可能考最小面）
3） 最大面的属性（对称性--中心对称--轴对称，曲直）



考点4： 元素数量

元素类型识别特征：多个独立小图形，并且有几种考察特点---- 1 元素种类（形状一样大小不一样也算一种），  2 元素个数 ， 3 元素替换（比如1个三角形 = 5个圆圈）



组成部分数量识别特征： 生活化图形，黑色粗线条图形
考察特点1 ： 组成部分数量

考察特点2 ：面数量（黑线条内部留白比较多）

考察特点3： 属性（对称，开闭）


考点5：  角（角度）数量


数角度的内容： 锐角，直角，钝角 （0----180度的角）

角题型类型识别特征： 扇形图，改造图（有缺口），折现图

角数量判断顺序： 直角---》锐角---》钝角


---
特殊规律

考点1 ： 功能元素

点：
1  题目给出一个点，该点对其图形有标记作用，位置与图像关系
2  点与点之间的关系（一般是点与点进行连线，然后观察）


箭头：
1  箭头的指向性
2  箭头与箭头之间的关系（垂直，平行）


考点2 ：图形之间的关系

相离： 图形分开，没有公共部分

相压： 谁在上

相交： 
 1 相交于点（相交点的位置---上下左右内外）
 2 相交于面 （相交面的形状，面积等）
 3 相交于边（数相交边的数量，样式---相交边是长OR短）




这类题目就是一个特殊的标记处于图形的哪一个位置

标记位置：
上，下，左，右，内，外

标记在图形的位置：
点类：交点

线类：直线，曲线，最长线，最短线

角类：直角，锐角，钝角，最大角，最小角

面类：重合面，最大面，最小面，直线面，曲线面




---


##一般判断顺序

---
**元素组成相同（元素数量一样）-----》优先考虑位置规律-----》平移，旋转，翻转**

---

**元素组成相似（相似：至少有1个元素相同数量不同）------》样式规律-------》叠加图案的加减，去同存异，去异存同，黑白图案的加减叠加运算**





黑白图案运算和平移类位置规律 最大的区别： 当组成元素相同而且数量一致---位置规律，当数量不一致----黑白运算
样式规律+位置规律------复合考点：叠加后旋转翻转之类



---

**元素组成不同----》优先属性规律-----》再看数量规律-----》几个图中有什么共同的元素**




属性规律：

   **对称性，曲直性，封闭性**

**对称性：** 轴对称，中心对称（中心点旋转180°后不变，卷子正反2面看一样）

**封闭性**： 全封闭图形，全开放图形（整个图形没有闭合区域），半开放半闭合不优先考虑封闭性，所以半开放半闭合考虑对称性和曲直性

**曲直性：** 全曲线，全直线，半曲线半直线比如扇形就不优先考虑曲直性，半曲线半直线考虑对称性和封闭性


数量规律：

6种规律，**元素组成不同，不相似并且无属性规律特征**就考虑数量
点：直线，曲线（直直，直曲，曲曲）相互相交的点
线：线的数量---直线，曲线，平行线，包括**笔画数（一笔画）**就是考察线元素的，一条式的题目出现一个**类日字的图形**就是考察一笔画。
面：任何图形
素（元素）：生活化的图形，多个独立元素，比如分类种类的图形
角
笔画（一笔画以上的）：田字类

数量规律判断顺序： 
面数量--》点数量---》线数量----》笔画数量---》角数量---》元素数量

---
###**题目属于哪一种数量规律的判断：**


快速判断点线面元素是否是规律：只看2张图，要是有**公共元素**并且**数量相同**就是该元素的数量规律了。    









**考虑点数量标准：** 
1 图形都出现**曲线和直线，且有交点**；
2 **线与线交叉**明显并且**交叉多**；
3 **乱七八糟的一团线**，比如毛线团，可以优先考虑点；
4 相切比较多，图像中**相切圆**或者**曲线直线**和**圆相切**多。

**考虑面数量标准：** 
一排的题型---4或5个图形都有共同点（比如都有扇形，差别是面积大小），分两类的题型---图形有2个以上的共同点（比如2个面）

**考虑线数量标准**：
1 遇到单一直线和多边形，数直线数量，注意只数多边形外边，或者图形的某一部分的线。
2 遇到圆，单一曲线，数曲线数量
3 直线，曲线的数量
4 一笔画的特点
5 **题干出现多边形，选项出现单根线条**，考虑线。



**考虑元素数量标准**：
1 生活化的图形
2 纯黑图形，因为有可能是XX边形重叠形成的。



当属性规律（对称性，封闭性，曲直性）无法判断的时候就考虑数量规律-----数量规律的优先判断顺序：面---》点---》线---》1笔画

当题目出现上面的识别特征判断不了规律的时候，此时就是创新题，一般就是2级考点，这些就需要临时根据题目给出的图形进行判断，2种考点糅合在一起或者是2种考点相互进行加减乘除运算。



-----------------------------------------------
**一些杂乱的2级结论：**

1 图形出现数字，出现的考点：1对称性，封闭性，曲直性 2 封闭的面的数量，3 数字的笔画数

2 在5个图形**方格颜色**不一致，其他一样，出现的考点：1 位置类，2 叠加类， 3 对称性

3  一般出现日字或者B之类的日字变形图，5角星，就考虑一笔画


4 长方体可以一刀切出 **456边形**
正方体(立方体)可以一刀切出 **345边形**

5  没有思路的时候，从整体看，从特别的图形看（2个相邻的图）

6  出现一个特点就判断下定义是什么类型题目：
曲直相交---首先点数量，然后面数量
五角星，月亮，圆相切，日字以及其变形（比如日字，变形成字母B，奥运5环，品字及其字变形）------就是一笔画
图形只有直线OR曲线，或者遇到圆----数直线OR曲线的数量，这就是线数量

7  数量规律题型上，现在要是判断出题干的第一个考点存在，但是数量不符合，则是在第一个考点的基础上再进行图与图之间的观察（把第一个考点画在图上再进行观察），得出的第二个考点才是正确答案。

8 如何**判断题目考察双考点-----每一个图都存在一个符号某种类型考点，但是几张图连在一起没有形成规律**

9 汉字，数字类型题目考点(做题时按顺序考虑)： 1 笔画数量， 2 线数量 3 面数量， 4 组成部分数量 5对称

=================================================================================

##1笔画

    奇点数 ==》奇点的数量 
    奇点  ===》就是由点发散出的线条（无论曲直）数目是奇数，1，3，5···条
    eg： 一条线有2个奇点，就是说一条线（无论曲直）的2个端点就是奇点

   笔画图形判断条件：同时满足下面2个条件
   1 线条之间连通
   2 奇点数为0或者2
   
   奇点  ===》就是由点发散出的线条（无论曲直）数目是奇数，1，3，5···条
   
   笔画数  =  奇点数 /  2 （国考，省考奇点数一定是偶数个）
   
   所以 **1 笔画图形  = 整个连贯图形拆分成一条条线（无论曲直）,， 连通线条（无论曲直）的点是奇点，同时线（无论曲直）奇点的数量是0或者2**
   1笔画也可以是**全部偶点的连贯图形**

##一般一笔画的图形：

 简单一笔画图形特征图：
 **0奇点就是1笔画图形
 1）五角星
 2）月亮
 3）日字以及其变形（比如日字，变形成字母B，奥运5环，品字及其字变形）
 4）2个或者2个以上的圆相切（0奇点）或者相交
 5）多端点（2个或者2个以上的端点）**

复杂一笔画图形：**数奇点，注意线（无论曲直）的数量要0或者2**



二笔画：由“田”字及其变形

奇点与线端点关系：所有线端点都是奇点（数完图形的端点就看丁字类型图形）


多笔画：数奇点数的数量一定是偶数个，要是出现5，7等奇数个，一定是自己数错了。 



##立体图形
###立体拼合：

**记得用铅笔在图形上画图1和图2的阴影**

2020年国考开始出现的题型

**题型核心思路：凹凸有致： 有凹必有凸，有凸必有凹**
形状和深浅


功能规律：（大多出现分组类型题目）
图形间的关系：
特征：若干个封闭图形拼接再一起
相离
相交： 1交点，2交线（线的数量，样式，长短，整体/部分），3交面
相压


解题模型（方法论）：
解决方法有：数方块数量，拼接（旋转拼接--此为难点考点的设置）

第一步： 观察选项方块数量，数量不一致就数方块数量，按照与题目数量差选择选项；要是数量一致，就看下一步。

第二步： 如果选项的方块数量一致，此时就观察题目给出的方块形状，找特殊图形 A，根据特殊图形拼接分解题目图形，要是题目图形与特殊图形 A 存在 3个拼接方式，选择第一眼最容易最直观的拼接方式，和最不起眼最不直观最难想象的拼接方式。


第三步： 特殊方块最长最大最特别的地方与题目方块相契合的地方有3个，当选用最直观的拼接方式没有出现对应的答案的时候，直接就用最不起眼最不直观最难想象的拼接方式

存在漏洞的快速筛选：立体图形存在2个或者多个部分一样的选项保留，剩余选项的图形分别与其他3个选项都不一样的排除









-----
2020年国考题目：2道

题1 
设计思路： 图2方块是突破点，同时 面对 题目方块 存在2种可能，向左视图旋转90度，向右视图旋转90度

图2：顺时针旋转90度---》分割---》选项结合，不旋转



题2

图2：向右视图旋转90度；图1：向俯视图面旋转90度---》分割---》选项向俯视图旋转90度，再向左视图旋转90度


2021年国考题目：2道

题1：  

图1和图2 分割 ----》选项 向俯视图旋转90度，再向左视图旋转90度---》结合




题2：（副省级）题目图形 由同一个方块组成，判断是哪一个方块

排除法： 根据特殊形状，判断哪个选项不可以组成然后排除，再根据选项旋转后能不能符合题目方块特殊图形，不能就排除，符合则看特殊图形旁边方块的数量，然后排除。


2022年国考题目：1道


题1：
    图1向仰视图旋转90度，再向俯视图旋转90度，图2不旋转 -----》分割----》选项向左视图旋转90度





根据20，21，22年国考题目分析，题目设计主要是围绕正方体的拼接-----拼接是包含了 分割，结合，旋转 3个部分。
题目给出的正方体 与 图1 图2 正方体位置的定位判断， 
模式1：  分割----》选项方块结合

模式2：  分割----》旋转选项----》结合

模式3：  旋转图1 或者图2 ----》分割----》选项结合


模式4：  旋转图1 或者图2 ----》分割----》旋转选项----》结合

小技巧1：在判断完图1和图2旋转分割后，判断是哪一个选项的时候，可以根据题目方块剩下的特殊图形数方块数量或者旁边的方块数量，达成快速判断正确选项。


小技巧2： 判断图1和图2是不是旋转错误，分割错误 的标志----分割题目方块后出现相隔的方块，因为选项是不可能出现分离的方块，都是一块整体的，所以此时可判断自己在旋转或者分割的时候出现错误。


-----------------------------------------------------------------------------

立体视图法：

使用左视图，右视图，俯视图，仰视图，前视图，后视图，6个面计算出个数，然后进行空间拼接------重点当题目给出的一个积木无法直接拼接成功的时候，一定要旋转积木。




================================================================================
###空间重构：

相对面
1） Z字法： 展开图可以画Z，Z的2端就是相对面。
2） 同行或者同列相隔一个面就是相对面


相邻面

遇到正方体只有3个图案的题型的时候，**用公共边判断**，看选项给出的3个面图形的公共边与正方体的展开面的公共边是否一致，然后排除法



基准面

基准面的作用-----题目中自己认定的一个面A，若选项中存在面A，且面A已经是转动过的，此时就想象旋转题目中的面A，直到与选项中面A一致，然后再判断面A旁边的面是否一致。也可以根据选项判断需要哪个面，再回到题目中排除对立面，然后再进行判断公共边是否正确与旋转


相对面
确定了相对面可以确定相对边，确定了相对边可以确定相对面（222型检验）

---
外表面展开图：




---

刘文超给出的一个方法-----画边法： 根据题目给出的图形，确定某一个面，确定该面图形每一条边对应连接的图形，然后顺时针方向，对比和判断题目该面连接的图形与选项中该面连接的图形是否一致。


---

222型 或者42型

方法1（优先，因为方法2存在多种可能需要排除）
当题目或者选项图形出现2个以上的面相同的时候，**选择选项中2个以上的面相同图形的公共边或者公共点，看选项公共边或者公共点连接面的图形是否与题目相对应的公共边连接面一致**（只要选项和题目的展开图不一致，就是错误答案）


方法2
存在独一无二的面，从该面入手；
若没有独一无二的面，则观察选项中相同的2个面，判断在题目中是不是相对面，如果是相对面，则该选项排除；如果不是，以这2个相同的面的  公共边作为破题点。


左图为所给正方体纸盒的外表面展开图










6个面一致型
根据选项画出公共边，然后根据公共边相连接面和题目对应的公共边相连接面对比。

根据选项图形，选择2个相同面的公共边作为公共边，或者2个相同面其他边作为公共边。



6个面---组数量--面数量

6个面
1组6个面一样

21年新疆68---1组图形 6取3


2组
A组2个面，B组4个面；2-4
A组3个面，B组3个面；3-3
A组1个面，B组5个面  1-5

20年四川（上半？）60---2组图形2-4---选项4取3，2-4取1，4取2-2取1 
22年广东50---2组图形4-2---选项是4取1-2，4取2-2取1，4取3

3组
A组2个面，B组2个面，C组2个面； 2-2-2
A组2个面，B组3个面，C组1个面； 2-3-1
A组4个面，B，C组都是1个面      4-1-1

21年四川59---3组图形2-2-2---选项都是 2-1 
14年黑龙江68---3组图形2-2-2---选项是2-1，1-1-1
17年国考81---3组图形2-2-2---选项是2-1，1-1-1  
19年江苏86--2组+1个+1个图形4-1-1---选项是1-1-2取1，2取1-2取1-1，2取1-1，1-1-2取1
21年江苏87---2组+1个+1个图形4-1-1---选项是2取1-1，2-1

选项存在2-1的，优先观察相同面的公共边或者公共点，看公共边或公共点周围图案是否与题目的一致（只要存在一种一致的情况，选项就正确）

4组
A组1个面，B组1个面，C组2个面，D组2个面  1-1-2-2

5组
A，B，C，D组都是1个面，E组2个面  1-1-1-1-2

6组每一组1个面


题目构成元素： 面，旋转，图案（相同与不相同），平移


==============================================================================
假定旋转法：
 自己假定设定一个标准----任意一个顶点作为标记点，这点周围的线根据自己爱好假定是以顺时针/逆时针进行1，2，3的编号，然后找出选项中标记点所在位置，也根据顺时针/逆时针

简单说：
1） 找出一个特殊面的唯一点或者唯一边(点或者边的选择：选项给出的图像不好用点作为标准，就用边作为标准；同样不好用边做标准就用点作为标准)
2） 顺时针或者逆时针方向画边，并且标号（描同一个面）
3） 题干与选项对应面不一致就排除选项

关键点：找出题干与选项的同一个面，同一个边，同方向（顺逆时针），然后顺逆时针方向进行编号，对同一个面的边进行编号1，2，3，4，最后判断题干2，3，5号边所在的相邻面与选项的相邻面是否一致，不一致的就排除。



------------------------------------------------------------------------



根据题目给出的正方体，任选一面作为基础面，该面不动或者转换到与选项面一致，然后判断选项给出的相邻面与题目给的相邻面是否一致，若与题目一致则选项正确。

小技巧：
挪位法（先定基准面后定公共边）----面面相邻移位是靠**旋转**来进行位移，此时可以根据公共边进行旋转，当面与面之间位置一个最左一个最右且横向平行时，可以直接平移不进行旋转。

存在独一无二的面，从该面入手
若没有独一无二的面，则观察选项中相同的2个面，判断在题目中是不是相对面，如果是相对面，则该选项排除；如果不是，以这2个相同的面的  公共边作为破题点。


三面点不需要再进行配对，双面点和单面点需要再进行配对 作者：sevenjh https://www.bilibili.com/read/cv15811868?spm_id_from=333.999.0.0 出处：bilibili

=============================================================================


###空间截面：

题型判断：题干中给出一个立体图形，问哪项能够（或者不能）成为其截面

常见立体图形截面
最常见的立体图形：六面体，圆柱，圆台···
**现在题目都是几个立体图形进行结合后再进行切割，所以要注意，做这类复合性切面题，能分开切就分开（切的时候不能有拐弯和折角，一定要一刀切完），最后再合体组成面。**

六面体：
1 矩形（拦腰切，上下切，斜切） 
2 三角形（从棱上的某一点开始斜着切到面，只能切出锐角三角形，不能切出直角和钝角三角形）
3 梯形


圆柱：
1 圆（横切）
2 椭圆（斜切）
3 矩形（竖切)


圆锥：
1 圆（横切）
2 椭圆（斜切）
3 三角形（竖切)

圆台：
1 圆（横切）
2 椭圆（斜切）
3 梯形（竖切)



题目立体图形中存在曲线，则选项截面存在曲线

题目立体图形中不存在曲线，则选项截面一定不存在曲线

6面体（正方体或者长方体）：边数量最小的截面-----3角形，边数量最多的截面-----6边形

**6面体可能截出的面： 3---6边形**

**圆柱体类：边数量最小---椭圆形**

##图形推理向2个考点融合成一题的方向发展

1  相同图形在完成一次平移旋转翻转的操作后，再进行一次顺时针或者逆时针的旋转，才是正确答案。

2  相似图形在完成一次加减叠加，去同存异等操作后，再进行一次顺时针或者逆时针的旋转，才是正确答案。

3  不相似图形完成一次数量规律操作后，根据得到的数字再进行一次数量规律（判断出来难度很大，遇到可放弃）


目前要求：做出一个解题模型（方法论）---类似于非形式逻辑那种的解题模型。写出设置考题的思路，组成考题的元素和要点。


简单来说：当假定考点只有1或2个图不符合的时候，说明这是2个考点综合考察，此时需要把图像特点进行细化拆分成一个个考点，然后把最初假设考点与细化考点一个个进行 数量加减法，比如假设曲直交点只有1个图不对，需要把图像拆分成曲线数量，直线数量，最后进行数量对比。



截面图与剖视图的区别：

**截面图---只需要画出刀切割立体图形的部分，其他不用管。**
剖视图-------假想用一个剖切平面将物体剖开，移去介于观察者和剖切平面之间的部分，对于剩余部分向投影面所做的正投影图（简单点就是截面图+剩余部分的视图）




==========================================================================


#参考


https://zhuanlan.zhihu.com/p/60306460   这是直言判断的总结

逻辑上只有演绎推理和归纳推理这两种，其中归纳推理分为完全归纳推理和不完全归纳推理，完全归纳推理和演绎推理是必然性推理，不完全归纳推理是或然性推理。加强和削弱程度上来说必然性推理要高于或然性推理，剩下的就是对主项和谓项，内涵和外延的界定。

作者：褚子
链接：https://www.zhihu.com/question/458070281/answer/1885421962
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


链接：https://www.zhihu.com/question/21807687/answer/167456312


=================================================================================
题目答案能看懂么？
如果答案能看懂那说明对题目技巧不熟练，要多练；
如果答案看不懂说明其实并没有真正理解基本概念。


合上书，去操作，去重现，自己去完成整个的过程，去体会每一个细节。然后你才有可能明白小到一个定理，大到一套方法是要干什么，他的条件为什么要那样给出，他每一个step是要达到什么目的，相互之间的逻辑链条又是什么样的，中间有什么样的obstacle（障碍），又是怎么克服的。



##**深入思考的过程----题目的提问清单**

 1. 这道题目考察的是什么知识点？
 2. 这道题目是如何运用书中的定理/定义的？这些知识点有什么变形方式？
 3. 这道题目有什么特点？哪些条件是关键条件？
 4. 这道题目有什么特点，条件，导致用某个解法？
 5. 这个类型题都有什么解法？

在思考题目卡住的点上，继续使用这个提问方法，就像递归，那样不断的细分下去，然后在回来。

这样一步一步思考，你会发现在哪个地方自己没想到，卡住了，导致题目做不出来。那么你再分析分析这个地方存在的原因是什么？

**提问后总结的问题类型：**

    知识点没掌握
    无法识别考点
    公式不熟
    时间不够
    马虎掉坑




作者：李白
链接：https://www.zhihu.com/question/57427543/answer/1576392400



作者：klam
链接：https://www.zhihu.com/question/23067716/answer/170057522


https://www.zhihu.com/question/311885002/answer/1597431403


数学和逻辑学的关系：https://www.zhihu.com/question/36609267/answer/2719414663



shirakami


看原理看概念（阶段）-->看理论做点实践初步尝试阶段 ---> 理论与实践知识深入理解阶段--> 理论与实践反复磨合阶段 --> 突破理论---> 实践落地。 


揣测题目


高中数学好的一种方法
但我是彻底的文科脑子。有非常好的短期专注力和短期记忆力，以及对语言文字惊人的敏感度。数学就差得一塌糊涂，正常学法是根本学不会的，我高中那次考砸就是因为函数之类的东西我根本学不懂。——后来为什么成绩又好了？因为我把所有常见的有可能出的题型都做了一遍，由于记忆力惊人，我做过一遍的题就都能记住思路，整个高中数学全靠背题。

作者：匿名用户
链接：https://www.zhihu.com/question/488847649/answer/2156186860
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


但考试不仅要求会，还要求在短时间内会，你没有时间构建新的思路，所有题都必须直接套用已有的思路，你需要把练习题中所有二级结论，解题思路，在保证理解之后死背下来，考试时间才够用，这个从本质上讲就叫“熟练”。







如果一件事，你理解不了，那是因为你所掌握的真实信息不够。


公式：因子+权重




所有的难题偏题怪题，都是从基本概念上**演化**而来的，这就是学习规律。没有见过的题目，分析的时候，要分清楚哪些知识点是自己已知的，然后分成已知和未知**，在已知条件中，有哪些条件可以帮助你推理出未知。**



我不在乎这些看法，也不是因为我强大，我很普通。只是因为我目的明确，我知道我在做什么，要去何方，我说的话，做的事，对象是谁。只是因为我目的明确，我知道我在做什么，要去何方，我说的话，做的事，对象是谁。当我对他的赞美没有期待时，他的恶意也就根本无法伤害我。因为我不需要取悦他，我做任何事完全为了我自己。人和人相处的真相是——他人其实没法像你自己那样了解你自己，耐心去复盘你的点滴过往，做出客观的评价。很多时候我们在他人眼中得到的，只是碎片化的情绪。你要为了这些情绪毁了自己的好心情么？他人永远只是参考，最终做决定和承担代价的，只能是你自己。想明白这个，就不会那么容易care那些不重要的外部情绪。



迷茫的时候就干活儿，遇到问题自然知道该学什么了。而且要干的活儿压在那儿，想学什么都是能快就快，挑自己需要的知识摄入，不再是漫无目的、大海捞针。从书上磕磕绊绊地把理论和方法用到实际工作中，知道了这些知识内在的逻辑，也知道了这些基础知识的局限性、要如何改造才能够为己所用，最重要的是学一遍、用一遍，印象就加深了，自然也不会有那种学完就忘的情况了。




知识消化吸收的标准：将概念延伸，拓展，相互链接，最后就会初步形成了一个整体框架，再通过积累丰富内容最后就形成了一个较为完善的认知


生活工作的简易方法论
------------------------------------------------------------------------------

价值
价值的约束条件是:1 定义问题（必选） 2 解决必要性（必选）

定义问题的重点是是否明确定义的标准是否能量化。

一开始不能量化没关系，重要的是要用可量化的描述来看问题。很多人思考价值时一上来就喜欢从 商业价值或者技术价值角度来定性描述，这样写没问题，但这一定是在走向明确定义问题的路途上做的。定性描述是过程，定量描述才是最终目标。

**解决必要性有必要强调下，价值可以近似简化为：重要性^必要性，必要性是指数级放大价值的。**
即使问题能够明确定义，但当必要性不足时也不要去解决，需要解决的问题才有价值。俗话说时势造英雄，时势说的就是必须等待解决的时机到来。不要提前做必要性不足的问题，即使未来明确知道必须要做也不要去做，否则价值无法体现，善战者无赫赫之功，不要当真“善战者”。

目标
目标的约束条件是：1量化（必选） 2 达成共识（必选）

达成共识是为了减少内耗与迷茫，在任何行动开始之前，必须反复讨论目标。要兼顾多方利益，以求目标真正的达成共识，必要时需要放弃部分个人利益，以达成共识。


方案
方案的约束条件是：1可执行（必选） 2有备案（必选） 3 可迭代（可选）

**有时候为了方案的可执行，甚至需要降低目标。切不可为了目标而建立执行难度很高的方案。**

任何的目标，如果难以执行，往往会导致执行动作的变形，最终导致目标的偏差甚至中途放弃。这时反而不如降低目标，建立执行起来更简单的方案。

有备案说的是，不要理想化任何一个执行动作，现实的荒诞和不可理解性往往会在你认为没有任何问题时给你卡住，导致无法继续执行。所以，我们设计方案时往往要避免强依赖单个节点，也即要设计多条可达通路。

可迭代是可选的，但我们考虑行动方案时最好要考虑这一点，因为任何好的方案都是迭代出来的，不是设计出来的。方案执行完成，我们可能会发现没有达到目标，那么需要对方案进行升级迭代。这就要求我们设计方案时要避免多方在多路径上出现，此时最好是进行拆解，每一部分可以独立执行，或者依赖尽量少。


资源
资源的约束条件是： 可控（必选）  

资源这里只有一个必须要求，必须是可控的。不可控的资源必须可拆卸，对最终价值产生影响必须较小，否则宁可不用。


组织
组织的约束条件是： 1 共同利益（必选）  2 情感联系（可选）

建立组织的核心要义是明确共同利益，有共同利益才能形成凝聚力。

情感联系是可选的，足够强的共同利益足够保证组织的稳定了，加上情感联系可以共同利益临时分歧时，来维持一定的稳定。但万万不可将情感联系凌驾于共同利益之上，情感联系破裂产生的反噬远远高于共同利益的消失。



永远不去问自己「准备好了没有」，而是先立一个 flag，然后想办法去做。做的过程中，发现它跟你预期之间的差距，再通过学习，来弥补这个差距，让你更加接近这个目标……


努力正确的准确的涵义==》有效率的积累 = 勤快



逻辑题目：https://bbs.qzzn.com/thread-9898474-1-1.html





第一个问题，涉及到的是人在面对利益时的风险偏好；

第二个问题，涉及到的是人在「得到利益」和「避免损失」上的权衡；

第三个问题，涉及到的是人在面临必然损失时的个人担当。
三个问题加起来，几乎就构成了一个人的整个价值观。


数学设未知数考虑不全，问题根源出现在2元一次方程定义上？



主观的事情客观化，客观的事情可量化，量化的事情金钱化，金钱的事情尽量长期可持续化。


内心强大的秘诀是，我永远喜欢我自己，我有勇气敞开心扉去欢迎一切新的变化和想法，但我永远不因为别人的反应而惶恐不安，不因外界的评价而自我怀疑，我允许自己被否定，但我无需认同，也不会在意.
真心建议所有朋友，不要看与自己无关的信息，去爱自己，把时间和精力都专注在自己身上。在这个网络爆炸的的时代，你一天的信息量相当于古人的一年。但事实上90%的信息都与你自己无关。谁说了谁的坏话、同龄人的成功、明星的吃瓜爆料......这些和你能变优秀没有丝毫关系，但却在不经意间占用你的大脑，浪费你宝贵的时间，甚至引起你的焦虑情绪。要知道过多关注别人，不会让你变得更好，只会消耗自己的能量，长此以往寥寥此生，最终得不偿失。

作者：你看那只猫
链接：https://www.zhihu.com/question/392785137/answer/2768260836
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


---
努力不应该是无尽的开荒，而应该掌握核心方法，然后普世的运用到别的领域。
1、做的题、工作的内容、从世界中获取的信息，但凡是所用的，都可以从中提取关键路径。
2、一开始提取关键路径要有针对性，比如考试、工作、核心关系，集中精力把其攻克。
3、熟悉了提取的办法以后，可以把这套理论反复应用到不同的领域，一直去实践、完善、实践。
4、到了一定程度，你挖掘的路径越来越深，你对世界的理解会形成一套相对普世的系统。
5、系统的流程，不仅包括总纲，还包括具体的应用，以及细小的点。
6、把这个系统流程落到目标上，你可以预估一个合适的目标，并拆分成不同的步骤，量化成可以落地的措施。
7、将其落到不同的人身上，你能搭建不同的人物模型，你会比他们更了解他们自己，并能预测他们准备怎么做。
8、将其落到努力上，你就能把算力集中在核心的地方，努力的回馈更大、损耗更低，个人也会更有成就感。
所以长期努力，不是一个毅力问题，而是一个认知问题。


硅谷王川:
所有的我们以为的质量问题，大多本质是数量问题。因为数量不够，差几个数量级而已。数量就是最重要的质量。大部分质量问题，在微观上看，就是某个地方的数量不够。
最大的误区是，明明是数量不够的问题，因为错误地以为瓶颈在于质量，幻想在不增加数量的前提下，用某种奇技淫巧，偷工减料达到目的。这时候玄学，迷信和各种无病呻吟就出现了。数量不够，底子不够厚时，很多事情时做不到的。即使有时看似有捷径，欠的账迟早是要还的。


---
判断产业升级成功的政策提示
1、分蛋糕的切法有变化吗？

2、新的税源有着落了吗？

3、以法制、透明、连贯的政策取代随意、黑箱、朝令夕改的政策了吗？

4、年轻人面临的种种实际困难有被重视并试图开始解决吗？

5、停止以将风险往下层转移为目的的信贷扩张了吗？




	2020-12-24 18:09:15
kumika	言语理解与表达	#言语理解与表达

艾宾浩斯曲线是记忆无意群的陌生材料时使用的，英语单词非常符合这个特性才被广大人群采用，实际上效果也显著
艾宾浩斯遗忘曲线以第一次学习的时间为基础，每隔30分钟，1天，2天，5天，7天，15天，30天各复习一次

遗忘曲线的实验方法--记忆无规律的字母组合，这本身的目的是为了得到一个纯粹的遗忘曲线，但是多数的知识点之间是相互关联着的同时需要鼓励的是看到一个知识点就想起更多的相关知识点，让单个的知识嵌入到大脑已有的体系当中。

某个知识点在回忆时“脱落”了，重新花一点时间放回去就性。也就是间隔重复，而这个才是遗忘曲线最大的启示，反而是多久之后复习这个并没有太细致的指导意义，让注意力能自然分配到学习的对象上才是真正需要考虑的问题，也是提升效率的关键。



4大关系 转折，递进，因果，并列

---

#词语填空



实词辨析：
实词是语文词语类中的一种，是指词语中含有实际意义的的词语。（包括---名词，动词，形容词，数词，量词，代词等）





虚词辨析：

虚词指的是没有完整的词汇意义，但有语法意义和功能意义的词语（包括----副词，介词，连词，助词，拟声词，叹词）




成语辨析：



===================================================================================

逻辑填空陷阱

词面意思看似相近 ：品味  品位

易混淆的近义词：  边沿，边缘

语境限制


感情色彩：成果，后果，结果


语体色彩： 惠赠，赠送


成语不懂



===================================================================================

考点设置：

词义轻重：

词义侧重点：响亮，洪亮，嘹亮；深思，沉思

词语搭配：期望，希望

语境限制

色彩不符


关联词（题目出现关联词，并且作为提示）

望文生义

===================================================================================

关联词关系（8个）


并列关系
标识同义并列：既···又····，同时，一边····一边···，是···也是····，顿号（、），逗号（，）
标识反义并列：不是/不像····而是····，是····不是/而不是····

理论要点：根据标识判断语义相近或相反

关联词提示并列关系，所以无论填空词语是在前还是在后，**词义、程度**都要和并列关系的词语相接近一致或者相反（包括加双引号的比喻词）。




承接关系：几个分句描述连续动作或者事情，分句之间有先后顺序，语序不能任意颠倒
于是，然后，接着，继而





递进关系（不能出现重复字眼或词语意思）
标识：不但···而且····，不仅···而且···，尤其，甚至，而且，更，乃至，遑论等
理论要点：语义程度前面轻后面重（积极消极态度一直）





选择关系：几个分句分别描述2种或者2种以上的情况，供人选择
不是···就是····，与其···不如····，宁可····也不···






转折关系
标识： 但是，可是，然而，却，其实，实际上，事实上等
理论要点： 前后语义相反





假设关系
如果····就/必然····，即使····也····，



条件关系： 前一个分句描述条件，后一个分句描述结果
只要···就···，只有···才····



因果关系



解释关系
题干特点： 分句，__________ ， 分句
标识词：即，就是，可以说，无异于，比如，例如等
标识符号： 冒号： ，破折号————
无题干标识类---通过前后分句的内容进行解释说明
要点：所填词语与解释说明的语句形成语义对应 （大部分题目都是无标识无提示的解释关系类型题目）







------------------------------------------------------------------------------

词的辨析

一：看词义（词义重点不同）
辨析方法：
1 用不一样的字组词
2 整体进行搭配组词


二：看词色（情感色彩不同）
理论要点： 褒义，中性，贬义，所填词语的情感色彩与文段的情感色彩保持一致


三： 看词度（程度轻重不同）
理论要点：所填词语的程度轻重与文段意思的保持一致


四： 看词用 （固定搭配不同）
1： 常用词搭配，热点词搭配，注意固定搭配及其用法

2： 找准搭配对象

3： 横线所填词语搭配由 "和，及，与" 引导的并列结果，所填的词语要与并列结果搭配恰当


五： 看分句含义分句对象
理论要点：提示是以短分句（几个字的分句）形式出现的话（判断标志），此时要进行对分句概况，多个分句的含义都要概况，正确选项词语一定都沾点边沾点意思，是都，不是单独一个分句意思，总结就是正确答案是多个分句概况意思的汇总词。

提示分句的位置：填空前后的分句，要概况大意，不要求十分准确。



例子：投资是时间杠杆，在重要战役、关键赛点来临的时候，快速增加________；投资也是空间杠杆，让企业有机会以“小资本”________“大空间”，多点布局，静待花开。

A ：开拓   B ： 试探  C： 占领  D： 创造

解读： 此时，“多点布局，静待花开”就是提示分句，2个分句汇总就是提前布局的意思，此时看选项哪个接近，只有B试探，具有提前布局的含义，C占领只有布局的含义所以排除。


##逻辑填空解题模式思路

找提示---》定逻辑---》猜词义-----》排不符---》选最优

1 根据关联词判断，明确画出词义的范围（语义意思范围，程度范围）

2 根据选项给出的词语的词义，与关联词的提示进行对比匹配，符合的就是答案；匹配判断优先级：语义----》程度。
也就是说 **语义一般是指词语意思所描述的对象或者对象的属性或者动作（实词，虚词），与关联词提示内容的对象或者对象的属性或者动作（实词，虚词）一致，就是符合**，不符合提示的语义排除，**剩下的词语进行判断轻重，褒中贬 这2个方面的程度判断。**


语义----》程度 这个优先级判断过程，存在多种可能误判的情况：
1 填空要填的词语，是受到关联词提示（也称上下文提示）语义的影响，也受到关联词提示程度的影响。



------------------------------------------------------------------------------


重点语句对应

重点词： 主题词，因果类，形象表达

重点句： 完整语句



（——） 主题词
标志： 主题词（核心话题）
答题要点：所填词语与主题词形成对比

比如 铁打的营盘流水的兵， 大学和学生，大学则对应营盘，是具有铁打的固定的属性；所以题干中出现几个对象一定要注意顺序上的对应，含义和属性上的匹配。


（二）因果类
标识：填词横线前后出现表因果关系的词，比如 所以，因此，只有等
答题要点：所填词语与前后内容形成对应（底层逻辑还是解释关系，只是加强了题干对象之间的对应联系）


（三）形象表达
标识：运用比喻，拟人等修辞手法
答题要点： 所填词语与形象表达的词语形成对应

 (四)完整句提示
填空横线上下句子是完整句，作为解题提示



===================================================================================


第一判断： 逻辑 》 词义 

第一拆词法：比如吸取和汲取，拆了你就发现左边两个字不一样，这不一样两个字部首不一样
第二是结合语境，看你的语句需要个什么样的词，大概意思语意，程度，感情色彩等等
    

多空填词：排除法，第一空，排除12个词，第二空，排除12个词，

1空填词：第一标志看看词，再看意主旨语境 中性褒义贬义/   程度。

   词义>>>>>>>>  褒贬情感色彩  >>>>>>> 上下文描述提示词 >>>>>>>  词义程度                           

1空

2空：按照词义进行排除，要是第一个空排除不了，看第二个空； 要是第二个空也排除不了，**回头看第一个空的词义,程度，褒贬情感色彩**进行排除判断。

3空

题目上下文概况出来或者根据提示词，脑子里第一反应出来的词大概意思，此时若是与选项里面的字词一致，就会误选。

若是有犹豫的空，看选项词的字，就是直白翻译，就是词突出的意思，然后根据上下文进行排除。

正确答案是题目提示词的具体化日常事物名词的转义词，俗称别名。

MV=PT


=============================================================
二级结论：

1： 在词语都知道的情况下，判断4个词语形容的对象（日常搭配），一般是选项3个形容对象一样，最后一个就是答案了。

2： 根据题目出现的关系词，判断出要选的词语是什么类型的，比如是和下文XXX反义的。

3： 当都不确定的时候，一个个代入，然后看最近的关系词搭配，能搭配就是答案了。

4： 词语意思现场快速翻译，根据字面意思，一般是根据题目的对象作为主语对象，然后选项词代入主语，再看搭配合不合适。

5： 第一个空，能排除2个选项就排除，防止后面空被排除的选项干扰。

6： 3个空的排除做法: 第一个空排除一个，第二个空排除一个，第三个空就是2选一，经典排除法了。

7： 填一个空的题目，要是不知道怎么填，就看上下文的一些描述词语，连系词，推出空的词的意思，一般是与上下文的词类似或者相反的。

8： 一个空出现选择难的时候，看选项的词能描述多大的范围，选大范围的。

9： 填空词与上下文一定不会出现一样的字。

10：**当出现2或者3个空无法选择的时候，从题目的主旨/结论相接近的空入手，从该空的句子看主语要做什么，代入主语对象的角度看，清楚主语对象与XXX进行对比OR交谈，然后联系该句子的上下文的程度词语，动作词语，描述词语，判断空填入的词语。**

11： 前后文出现 什么描述自然景色，自然物品的词语，此时选项的词就要选择意思相近的。

12：有时候空是对前文说明描述的直译，说明


13：**散文就选文雅有内涵（有意境，简单说就是骚的装B的）的选项**
**科普，新闻，公文，选主题词一致的
申论，时政，政策，热点类的就上下推理，围绕对策
历史，文化，城市，人文，选立意深远，提升格调。**


14：一个句子内结构是多个对象并列的时候，前后看有没有提示一个例子，有则**例子是作为提示，表明它是类比作用，突出目的，而要填空的多个对象的目的，作用也是要与例子一致**

15：出现2个难以抉择的选项时候，看词语的第一个字，就是词义强调的意思，然后在代入空进行判断，符合前后文的意思就选。（要是出现一个词熟悉，另一个词不熟悉但就是答案，此时是必输的，所以看运气了）

16：**字，词，意思都不能重复，也不能和前后文的动词，描述词意思一致。**

17： 当出现并列的时候，要看逻辑发展--动作，事物的发展开看

18： 选择一个词语多重意思的。

19：几组2字词语出现一个字相同，另一个字不同的时候，看不同的字。**根基不同的字，判断该词的形容对象是否符合填空中要搭配的名词**，此时要注意褒贬搭配。

20：题目是3组词语，并且**有2组OR 2组以上是动词，adj**的时候，主要看情感色彩，褒义贬义。

21：词语搭配类型----adj（选项的词语） 搭配 名词，要注意此时adj是形容谁的，能不能和题目中的名词搭配；一般也考察固定搭配（此时就是看谁的文学底子好了）

22 优先级判断：词义 》》》》》》上下文推理，要是只看上下文推理，就会很容易进入出题人的坑中。

23 **当选项出现2选1 ，并且词义不相近的时候**，此时看句子里其他字词有没有与选项里面的**字词相近或者意思相近**


24：双引号只是起到一个突出强调的作用

个人总结
---
做逻辑填空题切忌问哪个空为什么一定不行，你要知道逻辑填空题的提问方式是填入横线中最恰当的一项是，也就是优中选优。还有一个你需要了解的就是逻辑填空题都是原文摘抄，所以答案基本上都是固定的，你要问为什么一定选这个词，那可能要问作者了


在几个词中纠结的时候，要选没看见过的，少用到的，也就是骚的。


|  填空题目出现的情况   | 解决模式和思路  | 思考优先级的顺序  | 
|  :----:  |  :----:  |  :----:   | 
| 题目无提示,<br>选项词义不明 | 看题目情感色彩，看选项情感色彩，选一致或者相近的。 | 1优先词义 |
| 题目无提示，选项词义相近  |   当题目的情感色彩褒贬程度，选项词语情感相近的，词义相近的时候，从词语的单个字进行拆解分析，然后选择符合题目上下文提示的。 |撒 |
|题目有提示，<br>选项词义相近|排除法，排除第一个空为后面选项的减少干扰，能排除一个算一个，此时看第二个空，选项词语的意义，单个字的意义（近义词来判断），也看程度：感情程度，语气程度，严重程度。如果选项的字词无法判断，则根据题目出现积极含义和消极含义的时候，说明选词要中性的。**当选项出现2选1 ，并且词义不相近的时候**，此时看句子里其他字词有没有与选项里面的**字词相近或者意思相近**。总结------先看字词，如果字词无法判断则根据词语情感色彩和范围判断，优先选择中性和范围大的。 | |
|题目有提示，<br>选项词义不明|根据提示确定题目的情感色彩，看词义的情感色彩，看词义拆开字的内容含义是否符合题目。**当选项出现2选1 ，并且词义不相近的时候**，此时看句子里其他字词有没有与选项里面的**字词相近或者意思相近**|  |
|选项词意不明，<br>程度不分，情感色彩不明|**只能使用排除法，根据上下文提示（一个句子内）进行排除第一个空，然后排除第二个空**····这样按顺序依次筛选，**不能先排除第二空或者第三个空**，不然很容易错误，同时**当选项出现2选1 ，并且词义不相近的时候**，此时看句子里其他字词有没有与选项里面的**字词相近或者意思相近**，看词语常不常用，读出来顺口不顺口。顺口常用就是了。| |







题目出现排比空，这叫做3并列题--------------解决：并列就是不存在交集，也不存在包含，所以选择词语要与并列2个空的词语没有交集的意思，也没有包含的意思，有时候要符合事情发展的逻辑顺序比如相识相爱结婚，但是也有白富美






题目是散文--------------解决：词语要选偏门的少见的，俗称装B的。


解读粉笔给出的思路
11题：  第一优先级处理顿号后并列词语的词义，第二优先级查看上下文给出的提示，要求横线词语的词义范围，第三优先级查看选项词语的词义（选项词语的描述对象，描述轻重程度，描述情感色彩），第四优先级是验证，根据第一第二优先级得出的词义和范围，验证选项中哪个与一二优先级的含义与范围匹配



---

B站北大学姐思路（不知道是不是为了推销她的课程）

step1 的思路 ： 跳读全文，了解文体，掌握粗略大意
step1 的具体步骤：
1 细读首尾句，推测意图。
首句一般不设空，向考生提供人物、时间、地点、因果等多方面的信息，是了解全文的窗口。
尾句是文章的总结，或起画龙点睛的作用。某些含糊不清的概念或细节都可借助尾句来判断是非、确认事实。  


2 通读全文，掌握主题思想和文章结构


step2 的思路 ： 词性、词义、**最佳答案**
step2 的具体步骤：
1 先易后难，边读边填

2 瞻前顾后，前后参照
文中前后句之间存在着内在的逻辑联系，比如：因果、转折、并列、让步、条件等。所选答案只有和前后文在**意义**和**结构**上适合才是正确的。

3 巧妙分析长难句，寻找前后逻辑关系
以逗号为一个分句标志，做一个断句处理，把一个长句子分成短句子分析。


step3 的思路 ： **复读全文**，验证答案
看所选答案是否使得全文**连贯畅通**

掌握一个词的多种引申意思、多种使用场合，是很重要的。

#GRE填空

##GRE出题原则

1 单词、句子、段落越难越简单
2 信息重现提示存在逻辑相关
3 所有的修饰语一律先跳过，专注于主干逻辑含义


###公平
不会出现某个专业秒懂题目，其他专业都读不懂题目的情况，这样不会违背公平性。
就算出现了，也是技巧类型的题目。


###重复
由已知推未知，没有选项给你，考场上不能由选项向填空推，一定是要由题目已知推未知，推测出选项的词语。



###冗余
冗余信息，干扰信息，一定要删除筛选多余的信息。


##学术逻辑思维训练


很多题目有不止一个解题线索，找到其一即可。正确选项这个词汇正好和原题中某个词汇构成了同义词（词性可以不一致），这在GRE填空中非常普遍，甚至在考场上救急的时候可以用来猜答案。
通过逻辑上的取同或取非，记住解题技巧：找关键词/已知线索的同义替换表达或者是反义表达（题目填空前有反义形容词，填上反义表达，所以负负得正）。由已知推未知。

##GRE填空解题步骤
三步曲
第一步：读主干，理关系
只读句子的主谓宾，其他统统不管，都是补充修饰，同时，找出空格内容和主干是什么关系，理清关系，空格扮演什么成分，是扮演主谓宾其中一个还是补充修饰

第二步：找关键词/短语/语气

第三步：选答案并适当理解全句验证


#GRE的方法论

##杀器之一：主干大法


介词及其后部分不可能是主谓宾



有4大主干大法
使用类似数学表达式的方式来表达：A是主语，---》是谓语，B是宾语，(~)是省略的修饰语

2空题做题顺序：先主干后细节

###第一主干大法（考察名词水平）

主谓宾 A推出B
A --》B  

假设题目空格挖了主语A，那么我们就用宾语B的内容（同义转换），填回去
假设题目空格挖了宾语B，那么我们就用主语A的内容（同义转换），填回去
比如：
年轻人是年轻的人



###第二主干大法（考察形容词水平）
怎么样的A推出怎么样的B
（~）A --》（~）B

假设题目空格挖了主语A的修饰语，那么我们就用宾语B的修饰语内容（同义转换），填回去
假设题目空格挖了宾语B的修饰语，那么我们就用主语A的修饰语内容（同义转换），填回去
比如：
好人做好事
坏的人做坏的事


A 谓语  B  
谓语里有一个定义：存在not等否定词，负面消极含义的词语时候就是负面，没有就是正面。
负面谓语的时候，A和B的逻辑是反义的，是相互取非的关系，包括A和B的形容词，修饰词都是反义取非的关系
正面谓语的时候，A和B的逻辑是同义的，是相互取同的关系，包括A和B的形容词，修饰词都是同义取同的关系
谓语动词在句子中有很多个，当这个谓语存在正面/负面，2种状态的时候，把多个的谓语动词看成一个（2个负面谓语就是负负得正），然后判断谓语是正面/负面。
正面： A + B  
负面： A - B  


###第三主干大法（考察动词水平）

A和A2 是广义上的同义重复表达，都可以描述一个事物概念，其中一个描述概念大，一个描述概念小

因为（怎么样的A）  （支持/反对） （ 怎么样的B），所以（怎么样的A2）  （支持/反对） （ 怎么样的B2）

（~）A （+/-）（~）B， because （~）A2 (+/-)（~）B2

因为有because等表达同义重复的连词，逻辑连词，所以2个分句是逻辑同义关系





###第四主干大法（考察动词水平）

A和A2 是广义上的同义重复表达，都可以描述一个事物概念，其中一个描述概念大，一个描述概念小

虽然A支持B，但是A2却反对B2


（~）A （+/-）（~）B， but （~）A2 (-/+)（~）B2


虽然蔡徐坤是很胖（的人），但是他的照片里却显得很瘦（的人）

因为有but等表达反义重复的连词，逻辑连词，所以2个分句是逻辑反义关系，两边逻辑取非取反的。




在遇见难题的时候，可以通过选项的词性来反推题目考察的主干大法









##杀器之二：细节大法

细节大法是在主谓宾完整的情况下（主干大法无法使用）才使用的。




###三位一体战术

adj + n + (·····)
(·····)包括但不限于 which引导的定语从句，of+n表达的所有格结构，后接同位语（或是逗号）或者同位语从句。


判断是不是修饰部分(·····)，同时也是判断是不是独立的分句，就看逗号后面有没有跟连词（because，but等之类），跟有连词就是独立的分句；没有连词就是修饰逗号前面的名词的从句。


修饰词(·····)对前面的n 名词进行补充修饰，这类结构里3个部分的修饰词要广义上的一致，不可以是相互矛盾的，比如 胖胖的蔡徐坤是一个丰满的人。

个人理解：
三位一体战术是逻辑上的一体，比如胖胖的蔡徐坤是一个看起来丰满的人，十分胖的胖子，年轻的年轻人=年轻人看起来是年轻的
adj + n + (·····)表现出一体的，形容词和名词和修饰部分是一个概念下的，也就是说名词和修饰部分内的名词是一个概念下的，形容词和修饰部分描述的词语可以是广义上的同义词语，胖胖的 = 丰满的 ，年轻 = 年轻的

要是挖空的部分是形容词或者修饰部分其中一个，只要知道形容词和修饰部分另外一个，就可以推出挖空的一个。

同理：adj + n + (adj + n2 + (·····))  ，名词n2 是名词n的同义重复

例子1：
The valedictory address , as it has developed in American colleges and universities over  the years , has becone a very strict form ,  a literary  __________   that permits very little  __________.
第一个空选项：
A text
B achievement
C genre

思路：
主谓宾完整，没有被挖空，或者难找出A，A2，B，B2，所以主干大法失效，使用细节大法，优先考虑三位一体战术。

根据adj + n + (adj + n2 + (·····))  ，名词n2 是名词n的同义重复

第一个空格根据“literary ”，所以应该填名词，是form的同义重复



第二个空选项：
D  tradition
E  deviation
F  rigidity

The valedictory address has becone a very strict form 主谓宾完整
 form的逗号后面分句是属于补充修饰部分，都是修饰名词form的，所以整个分句对应的意思是“a very strict”
所以第二个空格应该是“strict”的同义重复



例子2(GRE十大难题之一)：
Whereas the art critic Vasari  saw the painting entitled the Mona Lisa as an original and wonderful __________  feat , the reproduction of a natural object , the aesthetes saw it as __________  that required deciphering.
第一个空选项：
A technical ; 
B mechanical  ; 
C  collaborative

第二个空选项： 
D  a hieroglyph
E  an imitation
F  an illusion

思路：

Vasari某人看蒙娜丽莎，主谓宾完整，挖空格的部分是属于宾语蒙娜丽莎的修饰语部分，并且句首Whereas是虽然的意思，句子存在表示转折的连词，因此可以使用的是第四主干大法

feat后面的逗号，跟着的不是转折连词，不是独立的分句，所以是同位语从句，递进从句



第四主干大法里，转折连词前后的修饰词部分和形容词是要矛盾的，这里是把中间的转折连词提前到句首了（或者是中间的but省略了），所以有点别扭，所以第二个空格内容是要与宾语蒙娜丽莎的修饰语部分“original and wonderful + 空格”相矛盾的，但是选项词语没有直接是创新的和美好的反义词相关联，所以转进使用细节大法---三位一体

直接看第二个空格后面的修饰语部分“required deciphering”，找出选项词语意思与需要破译的相关联的词语

第一个空格解题思路：
feat 逗号后面没有转折连词，所以是补充修饰语“the reproduction of a natural object ”，是自然物体的再现，需要选项有“再现”同义重复的，所以选A





###物主代词

代词表示语言的重复点，很容易成为同义重复或者反义重复的考点，所以遇到代词一定要留心。

蔡徐坤和蔡徐坤的篮球，蔡徐坤和他的篮球，其中“蔡徐坤的”，“他的”都是物主代词，在公式中是A2，B2的变量，也要注意逗号后面跟随的是转折连词还是同位语，判断A2和B2的修饰语是取非取同。

such，so，this , these ,those, which，its，hers，his 这类物主代词代词往往都会成为解题的关键点。


确定了物主代词之后，就可以代入4个主干大法里A2，B2的变量中，然后按照主干大法，三位一体逻辑规则进行推理。

例子1：
 It is ironic that a critic of such overwhelming vanity now  suffers from  a measure of the oblivion to which he was forever ___________ others , in the end, all his _____________ has only worked against him.

思路：
a critic 是一个评论家
a critic of such overwhelming vanity 是一个XXX的评论家
his + 空格，也就是要说明填一个评论家的形容词，而前文描述评论家的形容词是“such overwhelming vanity”，“如此势不可挡的巨大的压倒性的vanity”
第二个空格要填的词语的意思是“vanity”同义重复的

第一个空格：词组结构变化，consign somebody to oblivion 和to whichXXXX从句进行结合，把somebody to 中的to 省略，只表现 to which 从句的结构。


例子2：
Professional photographers generally regard inadvertent surrealism in a photograph as a curse rather than a blessing ; magazine photographers in particular , consider themselves ___________ to the extent that they can ____________ its presence in their photographs.

思路：
photographers regard inadvertent surrealism 主谓宾完整，补充修饰语in a photograph as a curse rather than a blessing，这补充修饰语部分是负面的负评价的。
its presence 中的物主代词its  对应宾语inadvertent surrealism
第二个空格需要填的是形容词，修饰词，同时“blessing ;”后面跟的不是转折连词，分号两边取同，所以是同位语从句，起补充修饰的作用，所以根据第三主干大法，A2，B2的形容词和修饰词都要一致负面的负评价的。

第一个空格 填入一个形容词，又因为A，B，A2，B2的形容词已经工整对仗，所以只需要填入一个正评价的形容词



###细节大法小结

1 主干大法失效后，三位一体最常用，其次是物主代词

2 所有的代词，物主代词都是语言重现，容易成为考点，多多注意。such，so，this , these ,those, which，its，hers，his 这类物主代词代词往往都会成为解题的关键点。

##武器之三：关键词大法

并列关系包括取同和取非

关键词两边并列取同OR取非，这个同或者非，是同/反义的词性、词义。


###同义重复的关键词


关键词两边并列关系，并且取同，是同义的词性、词义。


表示同义重复的关键词：




and , also, or , as well as , just as···so··· , not only ····but also， such···as， NO greater（more、better）···than···；

because，since，when，even，as，in that， for， for the simple reason that； therefor，thus，accordingly， consequently ， given，thereby ，due to ，hence，so···that， so····as to， if，if····then，as a result ，result in ，in the sense that， cause， give rise to ， when···then，as long as···；








###反义重复的关键词

关键词两边并列关系，并且取非，是反义的词性、词义。

一般类型：
albeit， notwithstanding，although，though，but，despite，however，in spite of， nevertheless，nonetheless， while， whatever， regardless ， even if， even though ，whereas，yet ；

特征词词组类型:
in contrast to， on the contrary， far from ， on the other hand，rather than，instead of，not····but···，more····than··；

出现结构：A  more····than B，此时不要关注A比B更如何如何了，只需要关注A，B这两个对象相反对矛盾即可。
 




paradoxically（自相矛盾地；似非而是地；反常地），ironically（讽刺地；说反话地），surprisingly（惊人地; 令人惊讶地;），unexpectedly（意外地; 出乎意料地），curiously（好奇地; 奇异地）；这些单词用在陈述句中表示取非，而用在转折句中表示加强语气可以忽略。

动词词组类型：
decay from A to B， shift from A to B， reconcile A with B ， replace A with B ，distinguish between A and B ， mistake A for B；A is preferable to B ；


时间有关类型：
before， once， until ， previous， current， recently，early，now，medieval，today，later，future，initially，formerly，pristine，after，no longer····；
题目的类型大意：同一个事物，不同时间点，这个事物的状态一定是相反的。
时间相反，一切相反。
总是在时间尺度上后者否定前者，比如：现在否定过去，小心注意现在完成时；将来否定现在，小心注意一般将来时。








重点说下Rather than的3种考法：
1  一边有空格另一边没有空格，将没有空格的一边取非填回空格即可
2  两边都有空格，去选项中找出反义词即可
3  两边都有空格，选项中不止一对反义词，或者两边都没有空格，这时候只可读一半，读作者强调的那一半。

例子：Literature is inevitably a  ___________ rather than __________ medium for the simple reason that writers interpose their own vision between the reader and reality.

A distorting````a neutral
B transparent```` an opaque
C colorful````a drab
D flawless````an inexact
E flexible````a  rigid

思路：
Literature is a  形容词  medium 主谓宾完整，空格全都在形容词上，第一个空和第二个空意思上要相反的。
根据细节大法三位一体，后面补充修饰语的内容和第一个空格的内容一致

后面“ writers interpose their own vision between the reader and reality.”就是第一个空格的内容。





###关键词大法小结


something、anything、almost、nearly、actually、indeed、seem、seeming、seemly 等词不会修改句子的逻辑本意，所以看见了就当没看见，直接省略。

by无论怎么考，两边一定逻辑同义，所以遇见by，可以忽略主干大法，直接把by没有空格的一侧意思填到空格上。

感情色彩判断选择：一般选择感情色彩强烈的（公务员考试好像没有这样的定式）


正负评价（修饰）词的判断标准：
    正负评价（修饰）词不等于汉语中的褒义贬义词。判断一个单词是正评价（修饰）词还是负评价（修饰）词的唯一标准是判断对它的修饰对象**起到促进作用，还是起到阻碍作用。**

比如：
疾病恶化了，恶化是对疾病进行增强，所以恶化对于疾病这个对象是正评价（修饰）词。
协调矛盾，协调是一种修复手段，对矛盾进行阻碍削弱，所以协调对于矛盾这个对象是负评价（修饰）词。

一个公式：A  评价（修饰）词T  B ,
以B为基准，A是强化了B，还是A削弱了B；
如果是强化了，则评价（修饰）词T对于B是正评价（修饰）词，
如果是削弱了，则评价（修饰）词T对于B是负评价（修饰）词。 

题目翻译顺序：题目句子由2各分句组成，如果逗号后面出现although，though，because，我们可以先读逗号后的句子，再读逗号前面的句子（but除外）。

---
找不到取非的关键词就看成是同义重复

特殊关键词的变化：
so````as to ，decay from  A  to  B（decay to···from···），mistake A to B（mistake for B A），but（not but···）

so that 是以that为分界线两边逻辑取同，so as to 也是以as to为分界线两边取同，同时to后面跟的是动词，也是重点强调的动作，so到as之间的内容可以忽略。

decay from  A to  B（decay to B from A ），提升难度的考法：在名词A后面增加定语从句导致头重脚轻，所以一般出题人喜欢使用括号里面的结构。

mistake A to B（mistake for B A）：把A误以为是B，提升难度的考法：在名词A后面增加定语从句导致头重脚轻，所以一般出题人喜欢使用括号里面的结构。

##武器之四：蒙题（无赖）大法


###无赖大法第一式

第一式：题目说什么，空格就找什么

永远找和题干已知部分逻辑关系最密切的，最关联的，不要有任何的主观性想象，主观性发散思维，题干你说什么我就找什么。

例子1：
During periods of social and cultural stability, many art academies are so firmly controlled by ____________ that all real creative work must be done by the______.
（i）
A dogmatists
B specialists
C managers
（ii）
D disenfranchised
E imposters
F elite

思路：
art academies are 宾语，主谓宾缺少宾语
all real creative work  be done ，主谓宾缺少主语
合起来看公式: A (+/-) ___________ ====》___________ (+/-) B2， 所以公式缺少B和A2，这2个变量。
此时第一个空格内容不能使用主干大法，细节大法，因为解题公式结构都不完整，只能说什么找什么了。

目前题目给出art academies艺术学院，creative work创新工作，这2个对象在逻辑上没有关联，所以就说明第一个空格的内容是能够确定与创新工作有关系的，承上启下的作用，所以选项词是带有创新工作的意思（无论是同义还是反义）

第二个空格内容，可以使用第一主干大法推出，主谓宾结构，A推出B，题目空格挖了主语A2，那么我们就用宾语B2的内容（同义转换），填回去，同时也要修饰B宾语。
但是这里是by的被动结构，所以是有被动的语义，所以选项是带有被动的B宾语内容。

例子2：
Among the many __________ of the project, expense cannot be numbered ; the goals of the project's promoters can be achieved with impressive ___________.
（i）
A features
B highlights
C defects
（ii）
D innovation
E efficiency
F economy

思路：
第一个空格是属于修饰语部分，所以可以留着，先做第二个空格。

题目给出2个主谓宾结构，以分号为界限，分号左边是花费不能被计算，分号右边是目标可以实现，所以第二个空格内容是承上启下的作用，是花费和目标实现进行逻辑联系的关键，所以选项是与钱有关系的。

第一个空格内容：分号右边谓语是正评价（修饰），分号左边也应该是正评价（修饰），但是是cannot be，所以第一个空格部分也应该是负评价（修饰）的内容，负负得正，使得分号左右两边逻辑平衡。





###无赖大法第二式

选项中出现反义词，答案必在其中

整个大的分析思路的提示标志：分号，逗号+逻辑连词（包括转折）






###无赖大法第三式

题干中词汇的直接同义词或者反义词出现在选项中，则该选项极有可能就是答案。

例子1：
In stark contrast to his later_______，Simpson was largely ___________ politics during his college years，despite the fact that campus he attended was rife with political activity.
（i）
A acticism
B apathy
C affability
（ii）
A devoted to
B indifferent to
C shaped by

思路：
Simpson was  largely 形容词 politics  主谓宾完整，逗号 + 转折连词“despite” ，说明跟的是独立分句不是XXX从句，说明逗号前后的谓语，形容词，修饰词呈现相反关系，A (+/-) B  = A2  (-/+) B2。

独立分句的主谓宾：he was  political activity，形容词相反，所以第二个空格应该填的是“activity”的反义词的内容概念

第一个空：“In stark contrast ”是形成鲜明对比的意思，这个空就要与后面跟着的句子的形容词取非，此时就是“activity”的同义词


例子2：
New research on technology and public policy focuses on how seemingly _____________ design features, generally overlooked in most analyses of public works projects or industrial machinery, actually ______________ social choices of profound significance.
（i）
A insignificant
B innovative
C ingenious
（ii）
D mask
E produce
F permit

思路：

research focuses on 形容词 design features   主谓宾 完整，generally overlooked是补充修饰插入语，逗号后面没有转折，所以后面的一堆句子可以看成宾语从句。
此时可以只看宾语的主谓宾结构：“design features” 是宾语从句的主语，“actually + 空格” 是谓语，“ social choices of profound significance ” 是宾语从句的宾语

generally overlooked 就是修饰宾语“design features” 的，是带有负评价（修饰）的意思，所以第二个空格的内容也应该属于负评价的意思

第一个空格：使用三位一体战术。

形容词被挖掉有2种方法:
1 第二主干大法 
2 三位一体战术


###无赖大法第四式


优先选择感情色彩强烈的选项（考公慎重接受这个思想，毕竟这在GRE也不是100%能正确套用的）




###无赖大法第五式

直接看选项找答案，也就是找4个选项3个大致相同，选择意思不同的那一个。
要是选项意思都不同，则根据主谓宾的主干大法，细节大法，形容词，修饰词部分，正负评价来推导出，题干空格大概需要什么类型什么意思范围的词语，然后看选项哪个符合。


#GRE三空题的解构和特殊难题

##画图法
类似逻辑推理那样，画出A--》B那样的式子

例子1：
Unenlightened authoritarian manage rarely recognize a crucial reason for the low levels of serious conflict among members of democratically run work groups: a modicum of tolerance for dissent often prevents ______________.
A demur
B schism
C cooperation
D compliance
E shortsightedness

思路:
一般题目：第三主干大法 A----》B；  A2----》B2
难题题目： 
在第三主干大法基础上，增加了一个C，使得式子变为C---》A---》B。
C----》A-----》B 
= C----》B 
= C-----》非 非B


A是“authoritarian”
B是“a crucial reason”，修饰语是“the low levels of serious conflict”

“tolerance”是C，谓语是“prevents”阻止的意思，是负评价词语，所以空格内容是宾语B的反义词的意思，如果没有，则考虑增加宾语的修饰语的反义意思。



---
例子2：
The sociologist responded to the charge that her new theory was __________by pointing out that it did not in fact contradict accepted sociological principles.
A banal
B heretical
C unproven
D complex
E superficial

思路:

The sociologist responded to the charge 主谓宾  A ----》B

空格在宾语B的形容词位置上，所以这里使用第二主干大法：怎么样的A----》怎么样的B


The sociologist 的补充修饰语： by pointing out 
the charge 的补充修饰语：her new theory was  ______
her new theory 的物主代词（语言重现）：that it

所以只要清楚主语A的形容词内容，就可以知道宾语B的形容词内容，A和B取同还是取非的关系，因为宾语B是负评价词，所以B形容词要与A的形容词相反，所以空格内容是“contradict accepted sociological principles”的反义词内容

---
例子3：
The old man could not have been accused of __________his affection; his conduct toward the child betrayed his ___________her.
（i）
A rationing
B stinting
C promising
（ii）
D tolerance of
E adoration of
F dislike of

思路:
怎么样的A---》怎么样的B，使用第二主干大法，但是这个考法很隐晦，使用细节大法快。
老人不能被指责不够爱这个小孩，从他的行为上就流露出爱这个小孩

The old man could not have been accused 主谓宾完整，第一个空格是修饰“accused”，可以使用三位一体

old man 的补充修饰语 his ___________her

accused 的补充修饰语 of __________his affection

因为“accused”是负面词，“affection”是情感，钟爱的意思，是正面词，所以三位一体战法要求accused 的补充修饰语是负面的，所以第一个空格内容是负评价词。

第二个空格的内容，因为“have been accused”是被指责的意思，被反对的意思，表示别人骂你，一定是你的取非，别人骂你不够爱，，说明你一定够爱，所以“__________his affection”与“his ___________her”评价相反


也可以这样解决：his affection  等于 his ___________，选择affection的同义词

---
例子4：
Broadway audiences have become inured to ______and so ______to be pleased as to make their ready ovations meaningless as an indicator of the quality of the production before them.
A sentimentality.. reluctant
B condescension.. disinclined
C histrionics.. unlikely
D cleverness.. eager
E mediocrity.. desperate

思路：

Broadway audiences have become 只有主谓，缺少宾语，但是有一个“and”，这个“and”表明并列，2边词语是属于同一个类型评价的，只是不知道是正还是负





##时间对比题的顶级难题
更远的将来否定较近的将来

例子1：
Within the next decade, sophisticated telescopes now orbiting the Earth will determine whether the continents really are moving, ______the incipient ______among geologists about the validity of the theory of continental drift.
（i）
A forestalling
B escalating
C engendering
（ii）
D consensus
E rift
F rumors

思路：

 sophisticated telescopes   will determine  XXXsomething（whether the continents really are moving的缩减，太专业了直接缩减省略为XXX某事） 主谓宾完整，使用细节大法，三位一体战术

among是介词，介词后面的可以直接不看，所以“the incipient __________”，可以理解成年轻人是年轻的人类似句式，the incipient 是 incipient的something，所以第二个空内容是“incipient的something”的广义同义意思

第一个空：
“will determine”表示将来的某一个瞬间发生一个动作，这个动作就会对早期做一个动作，根据原则：后者否定前者，更远的将来否定较近的将来，所以“will determine”和“the incipient __________”之间是一个否定的状态，是负评价词，“will determine”对早期的分裂是一个负评价

---
例子2：
Until the current warming trend exceeds the range of normal climatic fluctuations, there will be, among scientists, considerable ______the possibility that increasing levels of atmospheric CO2 can cause long-term warming effects.
A interest in
B uncertainty about
C enthusiasm for
D worry about
E experimentation on

思路：

there will be  ______  主谓宾，缺少宾语，宾语的补充修饰语是 “Until···fluctuations”，补充修饰语太专业了，简称为直到XXX某事发生

所以这个句子的结构：那里将有什么直到某事发生

某事发生之前，肯定是不知道什么事情会发生，时间地点内容都不知道，所以一定存在不确定性，所以空格填的内容是不确定性的广义同义重复。


##三空题

例子1：
It is refreshing to read a book about our planet by an author who does not allow facts to be (1)__________ by politics: well aware of the political disputes about the effects of human activities on climate and biodiversity, this author does not permit them to (2)__________ his comprehensive description of what we know about our biosphere. He emphasizes the enormous gaps in our knowledge, the sparseness of our observations, and the (3)__________, calling attention to the many aspects of planetary evolution that must be better understood before we can accurately diagnose the condition of our planet.
（i）
A forestalling
B escalating
C engendering
（ ii ）
D enhance
E obscure
F underscore
（ ⅲ ）
G plausibility of our hypotheses
H certainty of our entitlement
I superficiality of our theories


思路:
出现一个新的概念topic sentence，以topic sentence为准，判断正负评价，取同或者取非

It is refreshing to read a book about our planet by an author，为主干，是topic sentence，都是正评价，所以当出现“does not”，说明第一个空格是负评价。


第二个空格：
this author does not permit them  这里的“them”指的是politic，又根据前文的“an author who does not allow facts to be ”信息，所以这里空格所填的内容应该和第一个空格内容一致的，同样是负评价。


第三空格:
and the (3)__________,因为前面有一个单独出现的“and”，and两边并列且同义重复，所以空格内容应该等于“and”前边的并列成分，“enormous gaps，the sparseness”都是负面评价，所以空格也应该填负面评价。

---
例子2：
Richard M. Russell said 52 percent of the nation’s growth since the Second World War had(1)__________ invention. He said, (2)__________ research, the government’s greatest role in assuring continuing innovation is promoting a strong, modern patent office.“Unless we can(3)_________ original ideas, we will not have invention.”Mr. Russell said. Speculating on the state of innovation over the next century, several inventors agreed that the future lay in giving children the tools to think creatively and the motivation to invent.

（i）
A been at the expense of
B no bearing on
C come through
（ ii ）
D in addition to restricting
E aside from supporting
F far from exaggerating
（ ⅲ ）
G evaluate
H protect
I disseminate

思路：

第一个空格：
since  等于 because ， since 两边是取同的，since左边是正评价，所以右边也应该是正评价。

第二个空格：
这个空是最后做的，根据第一三空是正评价，所以有理由推理出“research”也是属于正评价，“aside from supporting”是除了支持研究之外，属于间接支持，“far from exaggerating”是没有夸大，文章里没有提及夸大，属于无中生有（是不是很熟悉啊，考公里面也有这样的逻辑思维）



第三个空格：
Unless 是负评价，will not have也是负评价，负负得正，所以这里对“original ideas”要填正评价







##逻辑思维的测试


Liberty is not easy, but far better to be an ____________ fox, hungry and threatened on its hill, than a well-fed canary, safe and secure in its cage.
A unfriendly
B aging
C angry
D imperious
E unfettered

思路：

Liberty is not easy，自由不容易，作者对这里的自由是正评价还是负评价？自由是主语主词，不---否定词，容易---正评价，所以不容易是负评价，所以作者对自由是负评价


but转折连词，一定对前面的负评价取非，得出正评价，所以空格填正评价。
far better than ，翻译：than左边的远比右边的好。
but到than之间是正评价
题目是围绕自由这个词做文章，所以狐狸也应该是自由的，这空格内容是“自由”的广义同义重复
**自由 逻辑连词but/and等 自由，这样句子的逻辑就平衡了。**



---
Documenting science's ___________ philosophy would be ____________, since it is almost axiomatic that many philosophers use scientific concepts as the foundations for their speculations.
A distrust of.. elementary
B influence on.. superfluous
C reliance on.. inappropriate
D dependence on.. difficult
E differences from.. impossible


思路:
第二个空格修饰的是Documenting，还是第一个空格？答案：是Documenting，第一个空格是一个陪考选项


动词+ing形式，做主句的伴随状态，跳过不看直到逗号+逻辑连词since，since等于because，所以Documenting就不是伴随状态，是动名词，在这句子里做主语，所以整个真正的主干是 “Documenting  would be  第二个空格（宾语）”

since等于because，出现这样的字词时候可以直接先读后面，这类词导致英文句子结构和中文句子结构是相反的，中文习惯先读because后面的内容，英文习惯先读所以的内容

因为it is almost axiomatic  =  Documenting  would be  第二个空格（宾语）

所以第二个空格内容是“axiomatic”的同义重复。



#GRE同义重复

空格出处在什么地方，语言重现点是取同还是取非



##并列关系



例子1：
Kagan maintains that an infant‘s reactions to its first stressful experiences are part of a natural process of development, not harbingers of childhood unhappiness or _____ signs of adolescent anxiety.
A prophetic
B normal
C monotonous
D virtual
E typical

思路：
主干跟着宾语从句，可以直接看从句的主干
单独的Or在否定句中代替单独的and存在的，or 是两边并列取同
harbingers of childhood unhappiness 等于 _____ signs of adolescent anxiety.
childhood unhappiness 和 adolescent anxiety 是并列关系，所以harbingers 和 _____ signs 也应该是并列取同关系
所以空格内容是“harbingers”的同义重复


---

例子2：
Despite assorted effusions to the contrary, there is no necessary link between scientific skill and humanism, and, quite possibly, there may be something of a ______ between them.
A generality
B fusion
C congruity
D dichotomy
E reciprocity

思路：
出现单独的“and”，两边是并列取同
no necessary link between scientific skill and humanism  等于   a ______ between them
所以 空格的内容是“no necessary link”的同义重复



##因果关系

Any language is a conspiracy against experience in the sense that it is a collective attempt to __________ experience by reducing it into discrete parcels.
A extrapolate
B transcribe
C complicate
D amplify
E manage


思路：
in the sense  等于because 

做题步骤：先主干后细节，不行就关键词，不行就最后五个大法和画图

Any language is  conspiracy against experience  语言是针对经验的阴谋，宾语是conspiracy
现在只需要知道主语language，减 宾语conspiracy，A 减（负评价） B的格式，，所以in the sense 后面也应该是A减（负评价）B的格式

it is a collective attempt to __________ experience  的空格应该填入负评价的内容







##目的、手段、结果关系

例子1：
Once a duckling has identified a parent, the instinctive bond becomes a powerful channel for additional learning since, by __________ the parent, the duckling can acquire further information that is not genetically transmitted.
A surpassing
B recognizing
C acknowledging
D disturbing
E mimicking

思路:

since 等于 because ，先看原因后看结果，跟着by，可以忽略主干大法，直接看by跟着的内容

by __________ the parent这从句可以算作插入语，后面的才是主要内容从句，所以空格内容是根据后面从句内容决定的。

---
例子2：
He felt it would be ____________ , in view of the intense __________that would likely follow, to make the sacrifice required in order to gain such little advantage.
（i）
A welcomed
B charitable
C unrealistic
（ii）
D growth
E encouragement
F turmoil

思路：
little ，few 等于 NO 是属于负评价

it真正的主语是 从句“to make the sacrifice required in order to gain such little advantage.”，2个逗号之间的从句是插入语，完全可以不理。

in order to 两边平衡，两边都是负评价，sacrifice，little都是负评价。

所以第一个空格内容是负评价词语。

 in view of  等于 in terms of 等于with regard to 考虑到，由于，鉴于
主干要和细节保持一致，2个逗号之间的从句插入语要和主句保持逻辑一致，所以也是负评价

所以第二个空格也是负评价。


##解释关系

例子1：
The Muses are ________deities: they avenge themselves without mercy on those who
weary of their charms.
A rueful
B ingenuous
C solicitous
D vindictive
E dispassionate

思路：
The Muses are ________deities 是主干，主谓宾完整，缺少宾语的形容词，这里出现一个冒号，就是表示解释，对宾语deities的解释

解释从句的动词：avenge ，秦始皇是一个旰食宵衣的皇帝，Muses是什么样的人，是一个复仇的人。
所以空格的内容是“avenge”的同义重复的形容词

---
例子2：
Speakers and listeners arc often at odds: language that is easy for the receiver to
understand is often difficult to ___________, and that which is easily formulated can be hard to __________.
（i）
A estimate
B produce
C remember
（ii）
D confirm
E comprehend
F forget

思路：

Speakers and listeners arc often at odds，主谓宾完整，虽然结构是A和B怎么样，但是可以解构成A （+/-）B ，这里可以解构成A 减 B 。

冒号到应该重现主谓宾同义重复内容的。

receiver 是listeners的同义重复，easy和difficult 是odds 的同义重复，又因为and两边并列，而understand是listeners的同义重复的动作，缺少了Speakers的同义重复和它的动作，恰恰下文有一个“formulated”是制订; 规划; 构想; 准备;看起来是属于Speakers的同义重复的动作

所以第一个空格内容是“formulated”的同义重复，第二个空格是“understand”的同义重复




##直接重复

例子1：
The techniques now available to livestock breeders will continue to be ___________, but will probably be supplemented by new ones under development.
A fruitful
B refined
C inconvenient
D used
E harmless

思路：
第二主干大法

转折连词后面的内容取非，填回空格

但是，现在这道题直接就是可以使用年轻人是年轻的，“available”技术是“available”，所以空格内容是“available”的同义重复。

---
例子2：
Although some consider forcefulness and _____________ to be two traits desirable to the same degree, I think that making a violent effort is much less useful than maintaining a steady one.
A promptness
B persistence
C aggression
D skillfulness
E lucidity

思路：
单独and两边并列， much less useful than是一个比较级，一个说并列，我踩一捧一，2个对象在句子结构上一定有对应位置，所以2个对象一定在从句子里有对应的位置

所以“forcefulness”对应“ making a violent effort”，空格内容就对应“maintaining a steady one”

找“maintaining a steady one”的同义重复

---
例子3：
Famous among job seekers for its ___________, the company, quite apart from generous
salaries, bestowed on its executives annual bonuses and such _________ as low-interest home mortgages and company cars.
（i）
A largesse
B inventiveness
C altruism
（ii）
D reparations
E perquisites
F credits

思路:

第二个空格后面的As 是修饰空格内容的，所以直接看As后面说什么，然后空格填什么

第一个空格前面出现物主代词its，说明空格内容是形容词，同时its这是“the company”的物主代词，所以后面就找公司的内容或者属性，下文大意是公司给出好的待遇，所以空格内容是“好的待遇”的同义重复

空格一定有出处，一定来源于题干没有空格的地方




##间接重复

间接重复定义：它需要通过主句确定了，细节和主句保持一致来推断空格内容


例子1：
In an age without radio or recordings, an age ______by print, fiction gained its greatest ascendancy.
A decimated
B denigrated
C dominated
D emphasized
E resurrected

思路：
an age是句子的主语吗？ 为什么？

先假设an age是主语，所以空格内容是谓语（by的被动语态先忽略不管或者选择不知道），那么这个短句只是主谓结构，而后面fiction这个分句却是有主谓宾完整结构的句子，同时因为逗号隔开2个独立的完整的分句一定要有连词，但是这里没有连词，所以an age的分句就不是一个独立完整的分句，得出an age不是主语， 是 In an age的同位语。

真正句子的主语是完整结构的分句里面的fiction。

fiction gained  its greatest ascendancy 主谓宾完整

所以an age分句是补充修饰，间接重复主干内容

所以空格内容是“ greatest ascendancy”同义重复

---
例子2：
It is to the novelist's credit that all of the episodes in her novel are presented realistically, without any _________or playful supernatural tricks.
A elucidation
B discrimination
C artlessness
D authenticity
E whimsy

思路：

are presented realistically 被真实的表达了，后面跟着没有任何XXX，根据年轻人是年轻的，所以A被真实表达了，没有任何不真实。

所以空格内容是不真实的同义重复。




#GRE反义重复

反义重复有3种，直接取非，程度取非，褒贬取非。前面2个的区别在于是否是同一个精确主体发生转折。直接取非是广义上的主体才可以取非，如果是同一个精确主体就只能程度取非。

褒贬取非不常见，出现了觉得不意外就可以了，所有的反义重复先按照直接取非来找答案，然后有2个多个答案，就需要再验证是否同一个精确主体转折。

比如：A很胖，但是他很瘦，这叫做同一个主体直接取非，不是广义上的主体，是错误做法，是不可以的。
A很胖，但是他的照片上很瘦，A和他的照片是广义上的主体，此时可以直接取非。


##转折关系

例子1：
At first, I found her gravity rather intimidating; but, as I saw more of her, I found that ___________ was very near the surface.
A seriousness
B confidence
C laughter
D poise
E determination

思路:
gravity rather intimidating  转折连词but，后面内容要对“gravity rather intimidating”进行取非

所以空格内容就是“gravity rather intimidating”取非的同义重复

---
例子2：
The labor union and the company‘s management, despite their long history of unfailingly acerbic disagreement on nearly every issue, have nevertheless reached an unexpectedly ___________, albeit still tentative, agreement on next year’s contract.
A swift
B onerous
C hesitant
D reluctant
E conclusive

思路：
nevertheless 然而; 不过; 尽管如此;

disagreement  转折词nevertheless，agreement，

所以nevertheless 后面都是正评价，所以空格内容也是属于正评价褒义，albeit still tentative 尽管是临时的，属于贬义负评价。

褒贬取非此时就出现了。

个人理解：实际上就是AE2个选项代入题目，E选项与后面的tentative相矛盾了，所以选A

---
例子3：
While not completely nonplussed by the usually caustic responses from members of the
audience, the speaker was nonetheless visibly ___________ by their lively criticism.
A humiliated
B discomfited
C deluded
D disgraced
E tantalized

思路：
while 等于 although
逗号前面分句没有主语，所以是同一个精准主体，采用程度取非

空格内容是“not completely nonplussed”的取非，就是“completely nonplussed”同义重复



##直接对⽐
句子当中会出现一些短语，可能是动词短语或者其他一些结构，通过这些结构或者短语来判断取同取非

例子1：
From the outset, the concept of freedom of the seas from the proprietary claims of
nations was challenged by a contrary notion that of the ______of the oceans for reasons of national security and profit.
A promotion
B exploration
C surviving
D conservation
E enclosure


思路：
concept  was challenged by a contrary notion  主谓宾完整，结构是A 减 B

空格是对notion的补充修饰，可以填入形容词，所以根据第二主干大法，怎么样的A  正/负 怎么样的B，其中A的形容词和B的形容词根据正/负号，决定取同还是取非，正就取同，负就取非

这里是was challenged  被挑战，属于负，所以A的形容词和B的形容词是反义的。


---
例子2：
It is difficult to distinguish between the things that charismatic figures do _________ and those that are carefully contrived for effect.
A formally
B publicly
C prolifically
D spontaneously
E willfully

思路：
题目出现A，B这2个对象进行区分，只要其中一个对象被挖空格，另外一个对象取非就是空格的内容

---
例子3:
Recent research indicates that a system of particles which has apparently decayed to randomness from __________ state can be returned to that state; thus the system exhibits a kind of memory of its ____________ condition.
（i）
A an ordered
B an unusual
C a chaotic
（ii）
D lesser
E earlier
F settled



思路：

有一个结构是decay from A to B  ，从A衰减到B，本题很恶心，在A后面加上一个从句，结构变成了decay from A  从句 to B ，然后再把to B 提前到from前面，得出结构 decay to B  from  A 从句。

所以本题真正的结构是decayed  from __________ state   to randomness，从句是can be returned to that state

完整结构：
decayed  from __________ state can be returned to that state  to randomness

从___________状态衰变到随机的状态，根据A 负  B，形容词是反义的，所以第一个空格内容是不随机的同义重复。

第二个空格，根据三位一体，得出是修饰前面的词memory的

##时间对⽐比

时间偏后的点否定时间偏前的点，有关于时间关键词，在关键词的两侧逻辑是相反的（取非）。

例子1：
The idealized paintings of nature produced in the eighteenth century are evidence that the medieval ___________natural settings had been exorcised and that the outdoors now could be enjoyed without trepidation.
A fear of
B concerns about
C affection for
D disinterest in
E enthusiasm for

思路：

The idealized paintings are evidence 主谓宾完整

从句：the medieval ___________ natural settings had been exorcised  和 the outdoors now could be enjoyed without trepidation 在逻辑上是取同的，因为中间有单独的and，后面意思是现在享受因为没有害怕，前面意思是XXX已经被驱逐。
被驱逐，就是没有的含义，没有害怕中的没有已经语言重现了，只剩下害怕没有语言重现了，所以空格内容是害怕的同义重复。

更简短的判断：
时间近的是没有害怕，时间远的是害怕

---
例子2：
Often the difficulties of growing up in the public eye cause child prodigies to ______the world of achievement before reaching adulthood: happily, they sometimes later return to competition and succeed brilliantly.
A ridicule
B conquer
C retire from
D antagonize
E examine

思路：
 the difficulties cause child prodigies 主谓宾完整 ， A 减  B，所以空格内容是负评价的。

sometimes later return，所以前文是存在离开的动作的，所以空格内容是负评价的，有离开动作的同义重复。

---
例子3：
Scientists' pristine reputation as devotees of the disinterested pursuit of truth has been __________ by recent evidence that some scientists have deliberately ______ experimental results to further their own careers.
（i）
A reinforced
B validated
C compromised
（ii）
D published
E replicated 复制（中性）
F fabricated 编造; 捏造;

思路：

Scientists' pristine reputation  has been __________ by recent evidence，现在完成时， 早期的XXX被最近的证据，所以第一个空格内容是负评价的。

deliberately 故意; 蓄意; 存心; 
所以第二个空格内容也是负评价的







#阅读理解


快速确定题目的内容技巧：

宏观（行文脉络---文章结构）+ 微观（关联词语----逻辑标志）
    

理解材料中重要的句子

中心句、总结句、过渡句


题目材料的**行文脉络**的5种分类：

---

1 总分
2 分总
3 分总分
4 总分总
5 分分

----

题目材料的**逻辑标志**的5种分类：

----

1 转折复句： 虽然···但是···   ，**句子重点在转折之后**
2 因果复句： 因为···所以···   ，**句子重点在原因结论之后**
3 递进复句： 不但···而且···  ，  **句子重点在二级递进之后**
4 并列复句： 既···又···       ，  **句子重点是并列的，需要全文总结概括**
5 必要条件复句： 只有···才··· ，**句子重点是必要条件对象**

---







---
**宏观**（**行文脉络**） + **微观**（**关联词语**）

宏观是**快速查询到哪句话是重要的**，微观是**仔细判断哪个是题目要的答案**



**行文脉络**：


总分、分总、**分总分**、总分总 、分分（并列）。


============================================================
**关联词语**：



**转折，因果，条件，假设， 递进，并列** ，这 **6** 种类型的关联词语。
常考的关联词有五种，就是递进关系、转折关系、因果关系、必要条件关系和并列关系

###转折：
虽然，但是，不但，而且，为此····
但；却；其实；不过；然而
实际上；事实上····

关联词语的暗示：
**转折之后的内容是重点**


###因果：
因为...所以；由于...因此
因而；故而；从而；由此可见/看来
造成；导致；使得；归咎于；致使

结论的引导词如“总之、故而、总而言之、综上所述、概而言之、概而论之”等
这类词语虽然不是关联词，但是其意义是对前文内容的总结归纳


关联词语的暗示：
**原因是为结论服务的，找文段重点的时候自然
是找结论。**


###条件：
只有...才
必须；需要；应当；亟待
前提；基础；保障

关联词语的暗示：
**选项出现的对策是重点。**



###假设：
如果；倘若；一旦；除非...否则···

关联词语的暗示：
**题目中假设的内容是重点，一般来说反向推到出对策，选项中的对策。**

###递进
不仅...而且/还/更/甚至；
最...
正是；恰恰是；根本上


关联词语的暗示：
**题目递进后的内容是重点。**

#有7种类型的题目

##1 主旨概况
提问：

---
“这段文字表达的主要意思是”
“这段话主要讲述/介绍的是”
“这段话的主旨是”
“主要”、“主旨”、“意在”、“中心”、“核心”、“概括”

解决方法

###做此类题原则：
 1 找题眼（文段主题句）
 2 对比选项进行转换（同义转换，精简压缩）
 3 通常为   **核心观点**，或者概况总结句，**其次选择对策**的选项。
 4 优先 选 **忠于原文中心句，观点句的选项**，主语是句子中的内容。

注意： 主旨题多数争议题目出现2个主要问题：
1 题目没有明显观点总结
2 选项内容的总结（都存在表现重点内容的其中1点）

先说1  当题目没有明显总结观点词，主题词出现的时候（无明显观点），此时要重点关注转折词，介词、连词、助词、叹词和拟声词，这些词后面就是结论观点。同时看选项有没有结论观点的内容，有就选。
实在找不到，或者全部都是对事物事情的描述，则此时要看哪个句子最长，最长的句子就是主要观点主要内容，该句子里面的主语就是主题词，此时看哪个选项里面有主题词就是正确选项了。


再说2  选项内容的总结（都存在表现重点内容的其中1点），这类错误选项一般是  题目内的形容词 + XXX名词 来混淆判断标志，一般考生在短时间内题目记忆是 题目内形容词+ 题目内名词， 这时候在看选项出现一个题目内形容词 + XXX名词，就很符合大脑文字匹配，导致选错。








###错误选项常见设置

设置的选项错误，通常有以下三个维度：

    无中生有
    偏离重点
    针对重点但侧重点不符的选项

所谓的“无中生有”即文段中没有体现的意思在选项中体现了，比如过度推断的选项。

所谓的“偏离重点”是指选项设置虽然符合文段相关内容的表述，但没有针对重点内容，比如支持文段观点的论据或举例子的内容。

所谓的针对重点但侧重点不符的选项是指选项涉及了文段主题词或文段主旨的部分内容，但侧重点和文段强调的主旨观点不一样，比如偷换概念、概括不全、内容空泛、主客体关系混乱等选项。




====================================================

题1：
大数据、人工智能脱胎于网络，而又与网络的侧重点不同。网络强调的是设备和主体之间的连接，是信息社会的基础设施;大数据是因网络的连接和对世界的数字化而形成的数据资源;人工智能则是在大数据的基础上通过反复训练进化而成的处理数据的智慧体系。就当前的发展形势而言，中国拥有世界上最大的网民群体和网络基础设施体系，世界上最大的移动互联网用户群体、电子商务客户群体、电子金融和社交媒体用户群体等，这使得中国成为世界上大数据规模最大的国家，并由此产生了丰富的应用实践和人工智能衍生产品。

这段文字主要介绍：

　A. 网络、大数据和人工智能之间的关系

　B. 中国发展大数据、人工智能的优势


###解析

分析文段。文段前半部分介绍了大数据、人工智能和网络的区别，为引入话题的部分。
尾句通过宏观指代词“这”及**结论引导词“使得”**引出最终的结果，为**文段主旨句**，强调“中国成为世界上大数据规模最大的国家，并由此产生了丰富的应用实践和人工智能衍生产品”。

**行文结构： 分总**，**判断标志是结论引导词---“使得”**，引出结论总结，前面大段文字都是分，结论是总。

A项是非重点，分的内容，不是总的内容。

B项是对文段主旨句的同义替换。题目强调2次最大，这就是优势。


二级结论：
一般强调数量，技术的时候，出现最XX或者比较级的词，就是强调优势了。

==============================================


###2级结论：

1 选项是否将文中对象概念扩大（也就是无中生有），文中没有提及的。

2 选项干扰项是会说一些中性的OR摸棱两可的观点，然后**没有提及题目主旨对象**，因为没有判断认清楚题目主旨的对象，会无中生有。

3 题目中总分结构，其中分结构的主要介绍，题目求主要介绍，此时就要概况分结构的选项。

4 题目的行文脉络是**总分总，那么就是最后一个总作为重点**

5 总结的判断词句：因此，为此，这。
分论的判断词句： 现状阐述，解释说明。

6 **题目内容都是并列结构内容**的时候，多多注意**选项的内容**，题目**没有提及就别选**------**无中生有（片面）**是常见坑，此时的无中生/片面有是指明题目多点内容中只有一两点提及，不是全部要点都提及，正确选项是要全部要点都提及的-----题目多个要点内容的提炼总结。

7 同构选项都是错误的，无论看起来读起来是多么的正确，这些选项就是干扰选项。

8 凡是类似「介绍了XX相关知识」「讲述了XX与XX的关系」这样的选项，十有八九都是错误的


##2 意图判断

“这段文字意在说明/强调的是”
“这段文字介绍了”，则是内容概括，无需引申


意图判断是需要**对文章进行申引**，也就是通过这段文字，作者是想告诉我们什么。就是选择没明着说的。

问题类题目：**优选对策（重点句的内容，转折词之后的内容），次选主题主旨。**
观点类题目：选项当中**最能体现作者所要说明的观点事情(问题，现象，对策），优先级：对策--问题--现象**。


题目中对策提示词：“应”，“应当”，“需要”，“要”，“要求”····


通过行文脉络，把握主旨
总分、分总、分总分、总分总，分分等，只看总的那个句子，只关心该句子内的关键词是否匹配选项内的关键词，一致就选，不一致就排除。


行文脉络：
分总：
**XXX作为引入话题，后面说某对象没有XXX，需要某些对策（将来时态类，对策建议类）**，这个结构就是**分总结构**，**后面的对策是重点，是中心句，是观点句。**



分分（并列）：识别词语----2次出现当XXXX时。答案要选总结类型的选项。


关联词：
快速把握文段重点，判断出主次优先级。


选项判断：
要与文章中总结的**结论、观点、对策**一致



方法论（解题模式）： 找出中心句，观点句===》画出句子的核心词====》查找跟核心词一样的选项，难度提高的题目就是近义词，选项的也是近义词。




============================================================
2级结论：
1 **在叙述中心不清楚（找不到总分结构中的总结句）的时候，按照题目中的逻辑提炼出关键词对象，画出逻辑关系，就知道强调是什么对象了。**

2 在文段中出现科普类社会热点类，要选作者所要说明的事情(问题，现象，对策）


3 题目只有论证和论据，没有论点的时候，选项就是要论点。


4 科普文就要注意对象是否进行概念扩大了，或者有2个难选选项的时候就要看2个选项的主语是否是概念扩大了。




5 **题目说有对策，则选项要选总结；要是题目说有总结，选项则要选对策，没有对策就选总结；题目没有对策也没有总结，选题目主要描述的逻辑对象。**


6 行文脉络+关联词==》快速判断出重点===》看文段内容是问题现象 、对策还是总结，然后题目是现象问题、总结，选项选择对策，题目是对策选总结。


7 在看观点的时候，注意关联词，比如出现”并“说明观点中的2个事情都一样重要。

8 对策在转折词的前面，转折之后是重点A，此时对策优先级低于内容A。


9 排除法----判断错误选项的有XX特点：
片面（文中重点描述2种或以上的情况，选项只描述了1种），
无中生有（文中没有明确提及，描述的前提错误，结果错误，对象错误），
描述绝对化（任何）

10 意图题目说明A对象有XXX功能，B对象有YYY功能，最后结尾B对象功能不如A对象，今后还需要A对象功能--------------正确答案选择A对象有关的，多多选择材料题目直接说明的对象，不要潜台词、暗示等之类的对象。


**11  意图题优先选择对策选项，主旨题优先选择忠实于原文的选项（警惕无中生有）**


##3 标题填入

做题原则： 变形的主旨概括 + 文体风格

2级结论：


新闻类： 提炼导语的主干成分

说明文： 提炼说明对象的主要内容

议论文： 寻找论点，对策

故事，散文，游记和其他：概况性，趣味性

题目一定要契合文段中心，重点，也就说趣味性和言简意赅可以去掉。

----
2级结论：

1 例子的内容不可以出现在选项上，正确答案是概况性的。


2 **选项中有概况选概况，要是有对策和概况，选对策。**

3 选项中的内容不能**无中生有**和**片面（题目中存在2个特点，选项只给出1个）**。

4 题目的主题中心对象，中心观点句子，可能在第一句，也可能在第二句，判断观点中心主题对象的方法----看后面的句子的内容是补充说明，还是深入展开细分。补充说明---前面是主旨观点，深入展开细分----这些观点主题对象是题目的重点主体中心对象。


##4 细节理解

识别标志：
        下列说法正确/不正确的一项
        下列表述符合/不符合的一项
        下列理解正确/有误的一项
        从这段文字可推断出

做题原则：
            一一对应（抠字眼）
            正确答案的特点：
                原文部分语句的复述
                原文内容的理解和概括（主旨化）
                优中选优（更能概括文中内容，没有具体某一项事物）
            选项错误的类型：
                    1 无中生有
                    2 曲解文意（偷换对象）
                    3 概念混搭


### 曲解文意----偷换类型

    1 偷换时态
    2 偷换数量
    3 偷换逻辑关系
    4 偷换概念/话题
    5 偷换确定性表达/不确定性表达


####1 偷换时态

已然时态： 已，已经，曾经，了，过，虽然···但是
进行时态： 正，正在，在···中，着，现在
未然时态： 将，要，立即，马上，如果，即使···也

**任何时态上的越级偷换行为，都是错误的**

####2 偷换数量


较多量： 较多，很多，许多，大量，大部分，大多数，广泛，一片，不少

中间量： 某些，一些，部分

较少量：较少，很少，少量，少部分，少数，少许，不多

**同级别的名称可以替换
不同级别中，中间量可以向两级替换，少量与多量的替换就是偷换**



####3 偷换逻辑关系

**充分条件和必要条件的混淆**

充分条件：
只要····就····
**A---》B  = -B ----》-A**

必要条件：
只要····才····
**A---->B  =  -A ----->-B**

**因果倒置**


**并列关系/对象混淆成因果OR条件关系**





---
####4 偷换概念/话题

对象，时态的变化，选项是否与文段一致。

---

偷换概念/话题例子：
2020年12月，德尔黑和三位同事在《当代生物学》上发表了文章，他们认为葛洛格将温度和湿度混为一谈了。潮湿的环境使植物生长茂盛，这为动物躲避捕食者提供了荫蔽。因此，动物在潮湿的地方往往颜色更深，以伪装自己。德尔黑说，许多温暖的地方是潮湿的，但潮湿又凉爽的森林也是有的，比如塔斯马尼亚的森林，那里也有最黑的鸟类。
从这段文字可推断出：

A. 德尔黑的观点，动物的颜色在温度低的地方会是浅色的

B. 葛洛格的观点，温暖而潮湿的地区，鸟的羽毛颜色会是深色的

C. 葛洛格的观点，阳光充足的赤道地区，鸟的羽毛颜色会是深色的

D. 德尔黑的观点，阳光充足的赤道地区，鸟的羽毛颜色会是浅色的


---
个人错误解析：
葛洛格 ： 动物在潮湿的地方往往颜色更深。
德尔黑：  许多温暖的地方是潮湿的，但潮湿又凉爽的森林也是有的，那里也有最黑的鸟类。

推出：
葛洛格：湿度===》颜色
德尔黑：温度===》颜色

QTD： B项---葛洛格的观点，温暖而潮湿的地区，鸟的羽毛颜色会是深色的


---
正确解析：
葛洛格 ： 温度===》颜色，因为葛洛格将温度和湿度混为一谈了。动物在潮湿的地方往往颜色更深，这句话其实是德尔黑的论点，湿度==》颜色，又因为葛洛格将温度和湿度混为一谈了，所以是根据德尔黑从湿度改变成温度反推出，葛洛格的推理温度===》颜色。
德尔黑：  许多温暖的地方是潮湿的，但潮湿又凉爽的森林也是有的，那里也有最黑的鸟类。

推出：

葛洛格将温度和湿度混为一谈了，而且 文中德尔黑观点是潮骚湿度==》颜色，所以湿度和温度在葛洛格的推论中是：温度 ===》颜色

查看选项推理：

A项： 温度===》颜色，这是葛洛格的推理，不是德尔黑的。
B项： 葛洛格的推理是单纯的温度，不是温度和湿度混合，混合说法是德尔黑评论葛洛格的。
C项： 温度上升，颜色越黑，符合文中格洛格的温度===》颜色推理。选项正确
D项： 温度上升，颜色越白，不是德尔黑的 湿度===》颜色推理。

---
易错点：
            这题目把德尔黑的论点说明了，但是没有把葛洛格的论点说明，用德尔黑的论点覆盖了葛洛格的论点，用湿度覆盖了温度，隐藏了葛洛格的论点。
            **这是偷换概念，或者话题的类型。把湿度概念 偷换成温度概念。**









####5 偷换确定性表达/不确定性表达

不确定性表述： 预测，断言，推测，可能，未必，也许，大约，大概（常用于科技说明文）








##5 态度观点

识别标志：
            作者支持的观点是什么？
            作者认为XXX有无道理/是否正确
            作者对XXX的态度是
            符合作者观点/意愿的一项是
            下列说法与文意作者态度不符合的是？
            
            
            
做题原则：

            明确观点： 引导词（我认为，XXX认为，XXX希望）+ 关联词
            
            隐含观点：  倾向性（关联词，设问，有倾向性的词语）
            
            没有观点：  仅为客观陈述 OR  引述他人观点，没有任何评价

杂糅观点的特殊句式：
笔者认为A（有观点），至于B就仁者见仁智者见智了（无观点）。
无论A怎么样（无观点），B都怎么样（有观点）

##6 词语理解

##7 代词指代

仔细看它们的代词,而且只看该代词所在的句子，不看句子之外的任何内容。



##8 接语题

题目提问： 接下来最可能讲述XXXX的？ 选项都是词语。


1 尾句核心，重点选，若无选项，管角度。

2 并列尾句,概况全面A+B,考全面，概括为**主题词+话题**，也就是选项主语和主题词一致，内容也属于题目材料的话题。

=============================================================================
阅读理解类题型的个人理解：

细节类题型：多使用排除法，错误类型有偷换概念，无中生有，片面···其中无中生有是有很多坑的，大多坑是题目表示不确定摸棱两可的意思，选项表示100%确定的意思。


题目材料的框架是并列结构，**是描述现象+对策，选项就要选对策**；**是总分结构，选项就要选总结**；**是定义+例子，选项就要选例子-----定义没有情感色彩，重点突出例子这样有情感色彩。**


意图题要认清楚题目的**主体对象**是XXX，**选项中**一定**要有** XXX 并且作为**主要对象**。
 


排序题：有总结意思的句子，可作为首尾句。



#语句表达

##1 语句排序

1 确定 **首句**

适合做首句： 背景、下定义、观点、设问···

注意背景和定义的区别
定义是XXX是XXX

不能做首句：
            1 反面论证（关键词：否则，不然···）
            2 指代词（关键词：这，此···）
            3 补充类（关键词：当然，仍，也····）
            4 结论类（关键词：因此，所以····）

关键词重要，也不能只关注词，句子意思也要注意，有的句子没有关键词，也是结论类，补充类····

2 确定 **捆绑句**

看句中的特别显眼的对象，是跟哪些句子相连接的，然后对比选项，排除。

**看首句后**，看捆绑句子（捆绑不正确，排除），正确捆绑后，看捆绑句子前后连接句紧密程度。

捆绑句的前后，看关键词--指代词的句子与前后句子连接紧密的程度

**前面的几个数字一样，比如624和625，要是24和25不好判断，则继续看后面的数字捆绑，624135和625341，就看3 和5 谁在前面。**


3 确定 **尾句**



做申论和言语题的时候仔细研究下题目的段落、句子结构，搞清楚常见的写作逻辑，然后在做排序题时候不要只找关键点，不要用各机构的简易方法，就老老实实一句一句分析结构，搞清楚哪前哪后以及原因。

1 判断首句  2 看捆绑句----几个句子有相同词语的能关联一起并且存在前后逻辑关系的就是捆绑句，此时确定句子逻辑，根据逻辑前后顺序排除选项。

==========================================================
###2级结论：

1 看4个选项是否有关键词的捆绑句，接着看捆绑句是否正确，不正确就排除




##2 语句衔接

题目类型：
1 居首类、居尾类： 结论、观点
2 居中类：         过度，承上启下


###居首类的例子：


2级结论：
居首类的一般是总分结构，重点看主语，看选项的主语是否与文中主体的主语是否一致。


###居尾类的例子：

####情况1： 句号
居尾类的衔接题中，常常出现这样的情况，一个句号，然后加结论引导词（因此，所以）之类的，后边划横线让考生衔接。

这类问题，就不能单单看横线的前一句话了，要从**整个文段理解和思考**，填入结论语句。

也就是说这句话基本是总结全文的。



####句号题目：

----
2017 现在许多学者在讨论“全球变暖”这一话题时，常将其作为“科学问题”来
讨论。
**实际上**，在涉及这种超长时段的复杂问题时，现在许多标准的科学验证方法都是有局
限性的，**因而**从历史的角度来讨论这个问题，有其特殊意义。
**但众所周知**，历史学家在建构历史时，必须依赖史料之外的东西，而“全球变暖”涉及长时段的气候变迁，文字记载往往十分缺乏，只能通过地质材料间接推测；而且地球不是人类，它的行为和规律，不可能借助“史料之外的东西”来推测。**所以**，-------------------。


**解析题目和关联词：**

---
1  根据**“所以”**可知，所填入句子为对上文的总结。

2  **“实际上”**转折说明前面看法的局限性

3  **“因而”**引出结论，说明应该从历史的角度看待这个问题

4  **“但众所周知”**转折，说明从历史角度看待全球变暖作为一个问题，但是由于不可能借助史料之外的东西，存在研究难度。


1 从历史角度看待全球变暖，需要史料之外的东西，因为缺乏史料，只能借助地质材料推测
2 推测全球变暖不可能借助史料之外的东西 
  
 个人观点错误判断： 
 史料之外的东西 = 地质材料

因为===》
         从历史角度看全球变暖问题需要构建历史      1
         构建历史需要史料之外的东西                2
         古代的全球变暖需要地质材料                3
         推测地球的全球变暖不可能借助史料之外的东西4
         
         
所以===》从历史角度看待全球变暖需要史料之外的东西
         古代全球变暖需要地质材料
         推测地球的全球变暖不需要史料之外的东西
           
所以===》从历史角度看待全球变暖是不能推测地球的全球变暖
         古代全球变暖需要地质材料

所以===》将「全球变暖」视为一个历史问题显然是不妥的



===============================
题目正确判断：
**史学家处理历史问题，可以依赖史料外的东西；** 然而全球变暖问题，是不可能借鉴史料外的东西。

因此，对比发现，文段就是**将全球变暖问题视为一个历史问题**，**但是由于不可能借助“史料之外的东西”**，所以研究的难度更大。

解法2：
“因此” 作为关联词，是总结关联词，是作者观点，所以*将「全球变暖」视为一个历史问题显然是不妥的*
就是与文中的作者的观点相反，可以直接排除了。

解法3：
看作削弱题，根据“因此”判断出观点，后面接着“但”，所以是观点削弱，不是完全否定，所以排除B


======================================

####情况2 ：逗号
如果划横线的部分前面是逗号，则填入的横线句子应该与其的前半句语句联系最紧密。

因此要**重点分析横线部分的前半句语句的内容**，根据前面的语义内容，填入横线部分

####逗号题目：

----
题目1 ：
进行骨髓移植的前提条件是有配型成功的捐赠者。双胞胎配型成功几率最高，兄弟姐妹也有可能。但在中国，20世纪70年代到现在，大多数都是独生子女，有兄弟姐妹且能配型成功的概率也非常低。另外，父母和子女之间骨髓配型成功的概率非常低，几乎为零。因此，绝大多数患者都必须依赖不认识的志愿者配型。非亲缘关系骨髓配型成功的几率只有几十万至几百万分之一，__________________________。

A 即使这样，骨髓移植仍是大多数血液疾病患者的唯一希望

B 骨髓库里志愿者样本的多少，直接决定着病人找到合适配型的几率


解析：

---
关键在于选项于句子之间的紧密程度，
判断的标准：
填空所在的句子描述的主体对象 =  选项描述的对象

题目最后一句话重在强调志愿者的捐献影响着配型成功几率
A选项突出说明的是《骨髓移植》这个手术
**B选项突出说明的是  样本多少决定匹配几率，与题目强调的志愿者影响匹配几率相贴近。**

题干有个因此，这是前面内容的结论，因此里面指出配型的问题，最后一句顺着这个结论指出非亲缘关系配型几率低，那么衔接的句子也要体现配型的话题，与句子话题保持一致而不显突兀。主要看AB，再结合第一句引入的话题是捐赠者，实际就是志愿者，选b。


题目2：

以李鸿章为领袖的洋务运动曾给中国带来富国强兵的希望，而经其手签订的
各种丧权辱国条约却让中国陷入半殖民地半封建社会。正因如此，一百多年来，李鸿章头顶
变换着救国、误国、卖国三顶帽子。对这样一个复杂的历史人物，只有给其一个更为精准的
定位，才能更清晰地解读他的所作所为，而在如何定位上，诸多史学著作或抓小放大，或以
偏概全，或就事论事、隔靴搔痒、雾里看花， -----------。

A  有失公允之处颇多

B  难以摘掉这三顶帽子

解析：

---
关键看填空的前面是不是逗号，现在是逗号，说明要选的意思是和前面的句子紧密连接的，不是总结全文的。

B选项是联系全文的，前面几个句子的。

A选项是紧密联系前面的句子的，公允是能和“解读他的所作所为”、”定位“搭配的。


---

题目3：

当前，我国对互联网平台经济创新秉持“包容审慎”的监管原则，然而这并不意味着监管部门可以放任不管。“包容”意在鼓励创新，为各类企业特别是初创型中小企业在发展早期提供更加宽容的营商环境和法治环境，是尊重市场新业态发展规律的体现；“审慎”则是在法治框架和法治原则下开展监管，在触及法治底线和监管红线的问题上必须严格依法监管。因此，________________，应合理界定有效创新与有为监管的边界，在鼓励创新与防范风险之间寻求法治框架下的动态平衡。
填入画横线部分最恰当的一项是：

A. 保障平台经济在创新发展与监管内运行

B. 面对平台经济创新发展中的风险和挑战

---

解析：
“因此”进行总结，横线后属于对策表述，目的是“在鼓励创新与防范风险之间寻求法治框架下的动态平衡”。
所以，填入的句子应体现出“互联网平台经济创新过程中出现的问题”，既能承接上文话题，又能衔接下文对策。

选B

个人理解： 要总结上文，也要看下文的主题对象内容，算是变形的文中承上启下题目。



==================================================================================

###居中类的例子：

####句号类：

例子1：
2018 当我们仔细观察当今世界上的主流火箭时，就会发现它们用的发动机、燃料
箱等都是上世纪的产物。比如要在2018 年首飞的太空发射系统用的是改进过的航天飞机的
火箭发动机，燃料箱用的是改进过的航天飞机的外挂燃料箱，两侧的固体燃料推进器用的也是改进过的航天飞机的固体燃料推进器。----------------------------。火箭是非常复杂的东西，设计并制造火箭需要考虑的因素太多，就连火箭制造商们也只能去选择一些经受过时间考验的产物，从而确保产品的可靠性。

A  事实上，制造火箭的材料并不都是前沿科技产物

B  也就是说，在火箭这个领域内并不是最新的就是好的


解析

---
文段为总分结构。根据文段的“都是上世纪的产物”“改进过的”“经受过时间考验的产物”可知,火箭使用的材料都是经过时间沉淀的,不是最新的、前沿的成果。

A选项是“事实上”表示转折，用词不对，选项意思与上文冲突。

B选项 承上启下，文段意思要连贯，

=======================================================


例子2：

戴口罩等遮挡条件下的人脸识别其实是一项“老”技术，此前研究人员在解决军事刑侦和视频监控问题时就曾长期研究过该技术，并发展出诸多成熟应用。因此，________________。但是以往的技术基础并没有完全打消人们对戴口罩人脸识别“先天不足”的顾虑。相较于以往，口罩遮挡面部，使得人脸识别系统收集到的面部信息大量减少。不过研究表明，人脸识别的关键信息集中于眉毛和眼镜，只要模型训练得当，戴口罩人脸识别的准确率并不会大幅下降。

B. 该技术的稳定性和准确率是有一定基础的

D. 人脸识别并不需要对全脸进行整体识别


解析

---
承上启下作用，需要选项有下文的内容，也要有上文内容。
横线处所填内容和“但是”后面的意思相反,就是说阐述技术存在好的一面。

D选项的主体是：半脸的"人脸识别技术"
前文的主体是："戴口罩等遮挡条件下的人脸识别"
所以D选项无中生有，无法作为上文结论。

**理解误区：
半脸 = 戴口罩等遮挡条件**
自己个人理解为抠字眼，虽然很正确，但是没有必要，结果要改正，描述的画面是一样的，但是表述的方法有很大区别，**以后会遇到这样的题目**，
**即读完题目在脑海里出现的画面是一样的，但是表达不一样，导致的结果是画面一致然后突出的内容不一样**

####逗号类：



虽然物质生产是社会生活的基础，但上层建筑也可以反作用于经济基础，生产力和生产关系、经济基础和上层建筑之间有着十分复杂的关系，有着作用和反作用的现实过程，并不是单线式的简单决定和被决定逻辑。世界上的事物总是有着这样那样的联系，不能孤立地静止地看待事物发展，________________。正所谓“有无相生，难以相成，长短相形，高下相倾，音声相和，前后相随”。在观察社会发展时，一定要注意这种决定和被决定、作用和反作用的有机联系。对生产力标准必须全面准确理解，不能绝对化，不能撇开生产关系、上层建筑来理解生产力标准。


C. 否则往往会出现盲人摸象、以偏概全的问题

D. 任何事物都与周围的其他事物相互联系着


解析：

----
C项能够引出下文，是针对下文给出对策的对应问题

D项**语意重复** ,与前面的句子“世界上的事物总是有着这样那样的联系”一个意思，

=======================================================
第一步：通过分析行文明确文段的行文脉络，其中：

1.文段为总分文段，重点关注总述部分;

2.文段为非总分文段，重点关注尾句。

第二步：结合选项分析排除三种干扰信息，即：

1.排除本文提到的信息;

2.排除与文段无关的信息;

3.排除后文才会讲到的信息。

##3 下文推断

看尾句，最后的尾句：找出**尾句主体**，看选项是否有前文内容的排除，有无关内容的排除，基本有答案了。

直接就只看尾句内容。


---

当无法判断文段的主旨句（尾句也没有表明观点）的时候，关注特殊的标点符合的句子，语气词反问句···进而判断出作者对这种现象/问题是怎么样的态度，进而根据**提出问题----分析问题----解决问题**的逻辑顺序，选择分析问题/解决问题的选项。

**提出问题：识别-----描述出现实的问题
分析问题：识别词------总结词（这，这些，因此····） + 积极/消极的判断定义或者预期 
解决问题： 提出建议**

---



话题衔接不当：
题目尾句：

    因此，了解青光眼的发病特点，及早发现和治疗是非常重要的

选项中的治疗和检查与“发病特点”的话题衔接不当，应在介绍具体症状之后再阐述

=====================================================

选答案：
**话题一致、倾向一致、行文脉络一致**

==========================================================
题目1：
人们在评判手机拍照功能时，总是直观地认为手机像素越高，拍照效果越好。**事实真的是这样吗?**从成像原理来看，像素值的大小对生成的图像会产生一定的影响。当手机的图像传感器面积一定的时候，像素值越高，单位像素面积就越小。而单位像素面积又直接影响到进光量，单位像素面积越小，图像传感器上进光量就越少，拍摄出的照片就会变得灰暗模糊;像素值越低，单位像素感光面积大，感光性能更好，因此在成像的高感光画质以及画面层次等方面都有更好的表现。

　　A. 阐述像素的定义及其提升途径

　　B. 介绍提高手机拍照效果的技巧

　　C. 揭示进光量与像素值间的关系

　　D. 指出影响手机成像效果的因素
　　
解析：

---

5 句话 

文段话题落脚点在像素对成像效果的影响上
文段落脚点为提出观点——论证观点
文段落脚点为提出问题——分析问题/解决问题。



文段先介绍了人们总是直观地认为手机像素越高，拍照效果越好，接着，通过问句对人们的这一看法提出质疑。随后，文段指出像素值会对生成图像产生影响，并介绍了像素值的高低影响成像效果的原理。文段尾句话题落在像素对成像效果的影响上，接下来应论述其他会影响手机成像效果的因素。


A项，“像素”与“手机成像效果”之间的关系在文段中已经论述过，因此后文基本不会再围绕“像素的定义及其提升途径”展开论述，排除；

B项，文中**重点论述内容是手机的成像效果**，“手机拍照效果”概念扩大，排除;

C项，“进光量与像素值间的关系”为文段中已详细展开说明的内容，后文不会再对其展开介绍，排除。


个人理解错误的路程：
提出论点观点： 像素越高拍照效果越好
----》 反问句 说明是对观点的反驳/质疑，此时要是慌乱一点就直接容易理解成 答案是要观点的反面论点：**像素越高拍照效果越不好**。
-----》选答案的时候：下文出现的一定是有关拍照效果的，全文没有提及过的。

纠正点：
其实文中只是说明反驳论点：**像素越高拍照效果不一定好**
出现观点，然后出现反驳语句，时间短的话很容易直接想到全盘反驳，没有考虑到**削弱** 这个程度。

下文论述的对象一定要和全文**重点大量篇幅阐述的对象----像素**有关联，因为要有连贯性，拍照技巧与大量描述的像素没有连贯性，很跳脱。

=============================================================

题目2：

去近20年间，地球深部生命研究取得的重要进展之一便是发现了海底洋壳生物圈。洋壳的体积庞大，是全球海洋沉积物总体积的5倍左右，栖息于此的微生物规模巨大，不可忽视，它们对全球生物地球化学元素循环和海底地貌风化都具有重要的潜在影响。然而，受采样技术和条件的限制，目前对洋壳岩石生物圈的研究和认识还十分有限。此前，有限的研究几乎全部集中于洋壳表层的玄式岩中，而对占洋壳体积近三分之二的下洋壳，尽管认为其也是深部微生物的可栖息环境之一，但尚缺少直接的证据，对栖息于此的微生物及其对极端环境的应对策略研究还是空白。

A 海底洋壳生物圈的发现过程和重要意义

D. 海洋下洋壳中的深部微生物及其生存策略


解析：

---
重点分析尾句，判别文段话题落脚点。
文段话题落在尾句，接下来应**围绕“下洋壳”及“栖息于下洋壳的微生物及其对极端环境的应对策略”这一话题进行论述**




=====================================================
思路解法2

尾句：
概念、话题-----是什么或者为什么
问题------对策
现象------现象原因，对策


排除法：
选项中 无中生有，文章根本没有提到的
选项中 文章已写的


======================================================

题目3：

原子钟在日常生活和科学研究中非常重要。它以原子内部的电子在两个能级间跳跃时辐射出来的电磁波为标准，去控制校准电子振荡器，实现精准的时间测量。与原子相比，高电荷离子的外层电子与原子核的结合更强，对外部场的波动更不敏感，狭义相对论和量子电动力学的效应也更显著。因此，高电荷离子是未来研发更精准原子钟的理想选择之一。然而，由于内部结构复杂，要在高电荷离子中识别适合于原子钟的电子跃迁非常困难，常用的光谱法测量这种跃迁也不够精准。
根据这段文字，接下来最可能讲的是：

A. 高电荷离子的物理构造

B. 测量电子跃迁的最新技术

C. 高精度原子钟的意义和价值

D. 光谱法在原子钟研发中的作用

---

直接就只看尾句内容。

第一步，分析文段尾句，
“由于内部结构复杂，要在高电荷离子中识别适合于原子钟的电子跃迁非常困难，常用的光谱法测量这种跃迁也不够精确”，尾句话题是“电子跃迁”，
谈论内容是在高电荷离子中识别电子跃迁非常困难，光谱法测量也不行，接下来必然要分析如何识别或测量电子跃迁。
第二步，对比选项，只有B项谈到了电子跃迁的测量。

======================================================


2级结论：


1 下文推断，就是选择没有提到的————选项里有题目一样的字眼，第一眼就联想到的，一定是坑。科技文章尾句直接选择尾句的内容，要是社会经济人文类型的文章，根据转折词，关系词后面的句子，然后看尾句内容是不是接着它，接着就选择关系词后面的句子内容，不是就选择尾句

2 题目逻辑结构：（1） 抛出一个观点然后提出反问 （2） 分析原因  （3）此时题目要求下文推断。3是什么，根据逻辑顺序应该是提出正确观点，正确因素，所以这里有反问的题型是按照逻辑顺序答的。

---

1：
话题（分1） 转折观点（总） 话题（分2）尾句

考虑 **转折观点**与**尾句**的主体对象相结合


2：

话题（分） 话题结论（总） 话题（分）

考虑：  **话题结论**的主体对象


3

概念（分） 概念对象（总） 


考虑：    有概念对象的选项，还是尾句的对象。



4 



现象（分）    结论（总）

考虑：  **结论**的主体对象



5 （1句话

现象

考虑：  解决现象的对策


6

现象（分）   现象问题（总）  观点（分）


考虑:  解决现象问题的**对策**

7

现象（分）    现象结论（总）


考虑：  **结论**的主体对象+ 现象**对策**


8 （2句话

现象（分）  转折观点+行动（总）  

考虑：    分析**行动的后续**




======================================================
#2级结论：



概念扩大的标志是什么？-----对象不一样，关键点看前缀+对象，前缀少了表示的对象范围不一样了。


下文推断根据题型类型不足以面对出题人，要从理解题目结构+逻辑顺序+情感色彩方面开始入手了。



#参考：

记忆性知识和重复练习，当然不是学习的全部，但却是所有学习的基础。



时间和精力不要浪费在你压根就不能改变、也影响不了的事情上，要集中精力去做你能做的，改变你能改变的。这样才不会浪费你的生命。


作者：super玛丽
链接：https://www.zhihu.com/question/56011912/answer/1293573386


https://bbs.qzzn.com/thread-16305995-1-1.html


考点在哪里？每个错误选项的误导是那点？
做题的目的，是为了通过做题来加深对考点本质的理解，从而能更快地看懂条件与条件在考点本质上的关联，从而能够会做题。


为什么很多人不喜欢去理解考点本质呢？

1基础薄弱，不知道怎么去深入理解！
2枯燥乏味，根本看不进去！




记好关键词。然后迅速判别题型，抓住考点，进行整体构思。

真正的好是快速学习新的概念 能够很好的掌握其原理。想象其实际的空间模型。


第一个阶段就是分门别类的了解每一种题型，包括考点设置在哪里，常见的错误选项是怎么设计的。能够和出题人站在一个频道博弈。
第二个阶段就是练习速读的能力，哪些题型可以速读、略读、跳读，哪些需要精读。这个阶段需要配合对连接词和标点符号，快速的划分段落，做到对文章庖丁解牛。
第三个阶段就是找到自己每一次两难选项摇摆的原因，纠正自己和出题人思维的不一致。










哪些觉得难、慌、不擅长，这就是后面要加强的部分。

做题的过程会做一些标记，哪些是花时间长的，哪些是一遇到就没有信心的，然后把数据统计出来，根据自己的薄弱程度和时间去选择针对性补习还是选择性放弃。再比如我之前做数学题，找规律的题目我会归纳遇到的类型，用公式写出来，做题之前看一遍像以前考试前复习一样，应用题我会记录每一道题花的时间，事后去看是有简便算法还是我就是不会快算...之类的。






模电：模电就是设计放大器 从单极放大到多级放大到差分放大 然后到运放 然后放大需要电源来提供直流偏置吧 于是我们要设计稳定的电流源 于是就有了电流镜等电路。
教材：拉扎维的《fundermentals of microelectronics 》




------------------------------------------------------------------------
行测复习我觉得就是一个不断补短板的过程。我开始复习的时候拿了去年的真题全真模拟了一下，并且对每一类题型的正确率进行了统计，然后确定最差的部分，最先开始复习。

由于上一次参加公考已经过去很久，所以我在复习的时候还是先看了视频课，但不是看的基础课程，是看的进阶课程，而且由于时间紧，我看视频都是1.5到2倍速播放，遇见自己不会的才慢一点，并且记下来。

就这样，在这一模块结束后，我又来一次模拟考，再次统计正确率，发现新的短板，开始新的课程，如此循环往复，不断消除短板和知识盲点。

同时，我每周会参加某笔APP模考大赛，那个上面有对我的答题情况进行分析，根据分析结果，我会对自己的复习策略进行微调，特别是在后期，前面复习的内容有的可能没记牢，可以临时突击，将其吃透。特别是遇到分值比较大的一些模块的知识点没有掌握的，一定要花时间弥补。

在考前两三天，我主要就是全真模拟，每天一套，一来是寻找考试感觉，二来是磨合一下一些答题策略和小技巧，比如说如何快速审题，如何抓大放小等等。

总而言之，我认为行测考试看似考的是我们的知识点，其实是考验我们如何在有限的时间内抓住重点，拿到尽可能多的分数，所以考试策略与知识点的掌握同样重要。

作者：廊庑客
链接：https://www.zhihu.com/question/412674441/answer/1412470478
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



Looks like tears of joy for finally getting Xiao to paimon
派蒙看起来是抽到肖的幸福泪水呢


It won't start deteriorating before you finish doing so yourself
quality guarantee




第一：带肉的炒菜，放五香粉。PDD上15元一斤。即使天天做饭，也能够你用一年。第二：红烧的菜放草果，桂皮，八角。而且我做红烧肉不放水。直接倒一瓶清爽型啤酒。第三：鱼香味的菜。老老实实按照菜谱调汁。酱油，醋，糖，都加起来。第四：烧豆腐放蚝油。如果非要认为蚝油含有味精，认为不健康的，可以放一个打散的鸡蛋。第五：炒青菜放浓汤宝。第六：清蒸鱼放蒸鱼豉油。最后，做任何菜只要放盐的时候，都要加一点糖。量大概就和盐的量差不多。这个根据口味自己调节。

作者：lu luce
链接：https://www.zhihu.com/question/487776492/answer/2129664155
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


7泽亚美



工科数学的金指标就是数学思想，比如线性代数里线性空间、线性映射和线性变换；概率论里的贝叶斯背后蕴含的学习方法；微积分里蕴含的无限可分，以直代曲。把数学思想融入工科实践，才是工科数学的金指标.


Faker被过度神话了,faker其实并没有那么猛的，他就是运气好拿了三届S赛冠军而已

我国是zf主导投资（花钱）的形式，每年社会产出向zf集中，兑上新增信贷再由zf主导花出去。期间zf和其中个人能收到大量的正反馈（财收卖地和灰色收入）。但是投资效果最终递减了，投多少钱gdp都只能微涨了（体现成社会上缺少能赚钱的项目）。省略一万字后，zf去年开始深刻的体会到缺乏正反馈。



做每一件事情都全力以赴，可以不成功，但一定要足够**有效**，足够努力。



学习总结能力：解决什么问题，方法是什么，理论体系的框架是什么，策略是什么，策略是组成要素是什么。总结出这个套路，再看其他资料，再参照之前套路，不断修正套路，最后形成自己的套路。这个套路就是你解决问题的策略与能力。



表格制作参考：https://www.freesion.com/article/7192156710/

关联词： https://zhuanlan.zhihu.com/p/340194567


为什么和怎么做，为什么不光是这些结论为什么，还包括为什么讨论这些问题，为什么这么讨论；怎么做是说怎么去思考这些问题，以怎样的精神，怎样的方法论。思考过程的展示，问题意识和哲学反思贯穿始终。学习这些不是为了知道什么结论，而是掌握思考方式，应用来解决书上没讲的问题。

作者：稻荷正义观察破球
链接：https://www.zhihu.com/question/28987052/answer/2632127761
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


https://www.zhihu.com/column/c_1429453463108980736
https://www.zhihu.com/question/21990278/answer/21579298

https://zhuanlan.zhihu.com/p/340194567

不考虑： 南宁，桂林，柳州 ，百色，河池，贺州，崇左
考虑：贵港，来宾，钦州，防城港，北海，玉林，梧州

富人面对穷人的时候真正的心理：如果有一天我绝望了，我就会在朋友圈里过上你努力几辈子也得到不到的生活，**用你们的嫉妒来抚慰我破碎的灵魂**。



回忆自己第一次高考前的学习状态：完事啥都不会，因为就是手过了一遍，老师讲了啥不知道，不去思考为什么会这样，什么时候、怎么用这个知识点，这个题应该从什么角度入手，他的努力都是无效学习。还有的人学化学搞什么思维导图，天天背方程式看似很努力，但一做题就完蛋，因为他不懂原理，不懂怎么类比联系，高考题不止是课本里那些分子，它会突然弄个结构相似的“新”物质，死记硬背直接完蛋。

500以下都是态度问题，600-640可能需要点学习技巧和灵性，650以上才可能谈到天赋
	2021-01-08 17:10:51
kumika	申论	# 申论

##杂乱的复制思路


申论：
看材料，想三句话当三个分论点，最好互相之间有点递进关系



2021
大作文：一个是尊重自然，一个是老百姓，一个是科技
第一题:变化主要有人的变化和物的变化，具体表现为人的变化有观念的变化和管理的变化（具体阐述省略）物的变化有产业的变化和生态的变化（阐述省略），经过以上解决了生态保护和人生存的矛盾。
第二题:种戏是什么（阐述省略），需要怎么做（阐述省略），为什么这么做（达到什么效果）（阐述神诀）
第三题:略，字太多
第四题:存在问题有基础设施落后（具体阐述）、存在安全问题（具体阐述）和管理不到位（具体阐述）
建议:健全基础设施（规划车位，健全停车标志等各类标牌，略），摸排各类安全隐患（阐述省略），加强管理（略），扩大宣传（增强安全意识，不要占用等）
第五题:治慧
治慧需要坚持以人为本
治慧需要坚持科学发展观，可持续发展理念
治慧需要 与时俱进，善用现代科学技术手段





人民日报的句子结构和文章结构

申论的话重要的是对于答题模板的掌握和应用，我看的粉笔李梦圆的申论课学的答题模板，平时也会多看新闻，人民日报半月谈安排上，我当时是每天花一个小时看新闻，想起来了就会搭建个文章框架，三天一次大作文，还专门练了练字





要么温柔贤惠把持家里做好情感宣泄，要么美丽动人为脸买单，要么家庭显赫助力一程。


=========================================================

开头公式：

公式一，问题式开头：主要问题+分析原因+亮明观点


当前我国处于快节奏的生活状态，一切都与速度挂钩，具体表现在教育、就业等方面。(概括问题)

观来说，我国正处于发展的初级阶段，人们对于生活有改善的要求;主观来讲，快速、高效的理念深入人心，再加上社会大环境所带来的的各种压力，导致社会求快风气盛行，个人内心焦躁不安。(分析原因--主客观结合)

因此/综上所述/所以，要平衡好快与慢的关系，使两者达到一种和谐的状态。(引出中心思想)


公式二，引言式开头：引用名言+过渡+问题分析+原因分析+亮明观点


庄子曾言：“无用方为大用”，表达的就是一种慢中求进，慢中求快的智慧。(引用名言)(古人云：文武之道，一张一弛。类似的引言可替换)教育中的“冒进”造就了老态龙钟的儿童;生活中的“冒进”导致每个人生活质量的下降;企业发展中的“冒进”致使企业陷入转型深渊......(问题排比)一切都是由于求快风气所致。所以，要平衡好快与慢的关系，使两者达到一种和谐的状态。(引出中心思想)


公式三，转折递进式：好现象描述+问题描述+分析问题+亮明观点

随着经济社会发展，人们生活理念发生变化，开始追求闲适的生活节奏。社会更加成熟自信、文明。(好现象的描述)但是我们也应该看到，当前我国求快风气仍然难以挥去。工作生活压力大，频繁跳槽现象不断;快速、高效观念深入人心;并且我国仍处于发展阶段，有快速发展的内在动力。(问题描述)根本解决之道不在于放缓发展速度/节奏，而在于平衡好快速发展过程中出现的失衡。(分析问题)因而，找到适合的发展节奏，平衡好快与慢，是一种追求，更是一种智慧。(亮明观点)



分论点公式：
公式一，意义式分论点+对比分析论证+结论

简单带来便利，提高效率，省时省力，改变生活方式、生产方式、从而丰富了世界，活跃了经济，带来颠覆性发展。（分论点，论证积极意义）互联网时代的到来彻底改变了人类的生活：过去舟车劳顿，现在一日万历；过去飞个传书、书信往来，现在只需要链接WIFI微信互动；过去物质与精神双重贫瘠，现在商品、书籍琳琅满目。（引用对比论证法）。真的是没有做不到，只有想不到，简单是社会发展的恩赐，翻过来又进一步促进了时代的进步（结论分析）。



公式二，对策式分论点+原因分析法+问题分析+必要性分析+结论分析

需要完善立法，做好顶层设计，以法律来保证制度的落实。（对策式分论点）毕竟，心理问题的全面解决，不仅需要心理疏导机制的建设，更需要从从法律、制度层面予以支持和约束。（原因分析法）我国目前的心理健康工作仍不完善，（问题分析）虽然有一些机制陆续建立，但能否长远运行、能否起到应有的作用，仍然离不开规定、制度和法律的监督与约束。（必要性分析）这也是我们构建和谐社会的重要战略部署。（结论分析）


结尾公式：

公式一，引出反问句+重申论点+原因分析法+对策分析法

大千世界，是复杂的，还是简单的？（反问句）仁者见仁，智者见智，而在我看来，简单与繁琐在一定意义上是相对的（重申论点），简单累计到一定程度就是趋于繁琐，繁琐沉淀到一定程度就变得简单，唯有藏繁与简、于简见繁方是我们追求的境界！（对策分析法）


公式二，引用分析法+原因分析法+对策分析法+意义分析法

《心经》里说“心无挂碍，无挂碍故，无有恐怖，远离颠倒梦想。”（引用分析法）正是百姓内心挂碍太多、物欲太多，才有了太多的恐惧与不安。（原因分析法）而要提高百姓的“幸福指数”，既需要他们的自我调适，学会放下，学会舍得，更需要政府用完善的制度设计和心理疏导机制，消除百姓内心对当下和未来的恐惧。（对策分析法）若如此，梦想的幸福将照进现实！（意义分析法）



一条主线：是什么、为什么、怎么办五个要素：现象（背景）、原因、危害、意义、对策五个方法：1.逐字分析题干，提取关键词，明确方向（小题猜内容，大作文判断最佳立意）；2.逐句分析材料，判断要素，找到归属；3.切忌题海，少套真题多做精做，闭眼可见；4.标准答案都不是最好的答案，多家考量，自己整合最满意答案；5.适当背规范表达和用典（无需积累热点时政）。




#B站UP主
卡妹儿
小题目： 6要素------背景 ，原因，问题，危害，意义，对策

小题目的答案： 高频词，核心句，转折处之后，段首，段尾

答案推荐大点+小点。 比如：一、着力解决民生问题。就业、保险、教育、医疗、住房、养老等问题。


大作文常考：倡议书，讲话稿，演讲稿，提纲，通知，工作总结，调研报告，短评


大作文句式： 1让XXX回归本质  ，2 莫让XXX荒漠化/泡沫化 ， 3 传承红色基因担当复兴大任 ，4 助力XXX 实现XXX， 5 奏响XXX之乐  跳好XXX之舞 



大作文要有逻辑性----基本的三段论就可以了， 2个现象 XXX和YYY，把XXX和YYY联系在一起。因为考生没有实际工作经验，不会重点考察对策--怎么做，题目给的资料---是什么，这剩下的就是为什么---重点考察分析问题的能力---为什么要这样做。

政论文:是什么，为什么（重点），怎么做
策论文:是什么，为什么，怎么做（重点）

大作文就是在材料中找到观点，然后解释观点，可用栗子来论证观点，然后再正说说反说说，换个说法再说说，一个观点论证结束了，然后过渡句接着论证下一个观点，观点全部论证完之后就是总结该如何做

=================================================================================

第一步是材料问题：
我在做题中会找出来很多内容，比如考察措施，对策，呼啦啦的找出很多对策，但是字数有限，取舍难，考试和做题中就会出现焦虑不安，烦躁，情绪就严重影响思路，状态，不知道如何作答，出题人就是这么设置让我们乱阵脚。
解决方法：定位分析材料；
材料是我们提取、概括、归纳采分点的唯一来源，先跟材料交朋友；懂她，了解她，就跟大姨妈一样，熟悉；
先把定义、背景、问题、措施、危害、意义、目的、成就，还有概括原因、变化、特点，优势等考察内容搞清楚；我们其实就是在考这些，材料中会给你很多，考察一个或者几个；
定义：一个名词的内在和外在特点；就是考察特点；
背景：背景分好几种，有政策背景（出台政策，文件、法律法规），时间背景（这个要注意，很多题型是按照时间逻辑进行的，我们做答也应对应清楚），环境背景（自然和社会背景，重点讲环境背景，在公文中有时候会讲某村和某地环境咋样，优美，山清水秀，依据题干要求，很多需要做答）；环境和政策背景是申论考察的重点，很多小伙伴会忽略掉，导致丢分；
成就：可以理解为取得的成绩，获奖，得名次，颁发证书，评为XX等，考察重点，同样容易忽略，特别是在公文中；
问题：在申论中问题是我们需要解决的问题，矛盾，疑虑，担忧，是负面的；提出问题；
对策：解决问题的方法和措施，注意措施种类，我会在后面细讲措施分类；很关键很关键，有种提出对策题型，必用；
意义：对策可行性的价值，也可以理解为重要性和必要性；
目的：对策的一种，是属于宏观对策，这个要明确，很多考生根本没有这个概念；
当明白这些名词之后，材料中要分清楚，这是第一步；也是最重要一步；
特别说明考问题和措施，没有这么简单，这里先做好初步分类，后面会有针对讲解，这些还有细分，有逻辑关系；
在练习中，就拿真题即可，一句句分析，定性材料内容，逐渐提高水平和速度；一定要整篇材料进行，不要只看一段；
在做定位材料练习 的时候强迫自己搞懂为什么是，为什么不是，为什么要，为什么不要，平时练多了，就回减少考试做题时采分点定位不准 的焦虑。第一步很简单也很重哟，一定要认真对待。

这是一道2020年国考地市级第一题中的节选：
去年，老马接待群众600多人次，有家长里短，有邻里矛盾，也有基层治理中的一些问题。
（接待为动词，接待内容：家长里短、邻里矛盾、基层治理。这里要注意“有”、“也有”，表并列，三个内容全要；大家不要认为前家长里短和邻里矛盾很生活不要，光要高大上的基层治理，要看连接词“有”和“也有”，看结构关系。最后做答关键词：接待、家长里短、邻里矛盾、基层治理；有人可能会问600次需不需要关注，去年一年600次，是数量词是个统计术语，可以理解老马坚持接待；）

接待群众是门“技术活”，不仅要真诚待人，还得对政策烂熟于心。
（接待群众，不仅要，还又是个并列性词语，做答要点：接待、真诚待人、熟悉政策；多讲一句，技术活就是要真诚待人和熟悉政策，总分关系；）
“当好基层这根‘绣花针’，状态要投入，本领得过硬，我一天都不敢怠慢。”
引号内内容想想对应什么：投入状态指的是真诚待人；本领过硬指熟悉政策，一天都不敢怠慢指的内容在后面，承前启后；

虽已年过花甲，老马仍每天坚持学习3个小时。30年来，老马成功调解矛盾纠纷2000多起，写了160多本、520多万字的工作笔记。

（每天坚持学习3小时，对应不敢怠慢，做答要点，坚持学习）
30年来一句总结词：成功调解矛盾纠纷2000多起，写了160多本、520多万字的工作笔记：成绩
写工作笔记是不是定位对策；做答要点：写工作笔记；

总结这一段做答要点：
对策：接待家长里短、邻里矛盾、基层治理；接待群众真诚待人、熟悉政策；坚持学习、写工作笔记；
成绩：成功调解矛盾纠纷2000起，完成160多本，520多万字工作笔记；


在这借用老马这个事例，告诫广大考友，要坚持不懈，要认真，保持好的状态，关心国家政策，每天坚持学习，写总结；才能早日上岸；


今天更一个小知识点，是关于阅读材料的技巧，材料重要毋庸置疑，但是怎么读，读什么，能从材料中得到什么，是平时学习积累的。每一篇材料都有一个主线，还是举上面老马那道国考题为例，里面有句话为30年来，这句话看似很平常的一句话，但是确实一句总结句，再比如改革开放40年以来，恢复高考以来，千百年以来，是对前文所做的事情的总结，后面一般会出现采分点。所以大家遇到数字和时间要注意。第二有时间发展顺序的，比如1992年怎样，1999年怎样，2008年怎样，如果概括变化，则需要大家看清楚时间节点，按顺序作答，如果是概括成功经验，则只需要顶住最后最近最新的进行概括作答。具体的介绍我会用具体真题讲解，那样更准确直观。


上午有个小伙伴问了我一道题目。是背二歌内涵意义的变化。不知道大家拿过这道题目来有没有触动，只看到了变化，没有注意前面内涵和意义？这道题真正的节点不是在变化，因为文章就是分了两个时间段来讲，之前和现在，在变化上不难判定，但是要做大的内容却是有规定是作答内涵和意义的变化。何为内涵意义，在定义中分内涵和外延两部分特点，这道题目其实在考察你定义的变化，也就是定义中内涵特点的变化和定义中外延特点中意义的变化。看似不太好理解的一道题，这么解读立马会感觉清晰，祛除了内心的恐慌。这道题目考察很隐蔽，不再是单纯的考察基本功，而是饶了个弯。借这个题目是讲给大家一点，申论题目不是单个的存在，而是一个牵一发而动全身的体系。没有一个知识点是没用的，是在不经意点被我们给略掉了。



今天中午讲个材料阅读的方法；
我曾经有个疑问，疑问是如何准确定位材料，这里要注意的事与题干中主题一一对应；
例子：
问你旅游景区厕所的问题，出现城市、农村厕所存在的问题就不能做答；这么解释一下，针对XX景区的厕所改造问题提出相应措施，我们申论中问题与措施是一一对应的，提出问题+分析问题+解决问题，材料会在对应层面留坑，让我们答非所问。
不光在问题和措施上，还有问题和意义、目的，特点等；

材料分析第一步，先确定主题，然后进行分析；
例子：
1、为了解并解决快递配送从业青年在职业发展和社会融入方面面临的一些问题，今年年初，我们面向这一群体开展了一次问卷调查。
问卷调查是针对问题是快递配送从业青年在职业发展和社会融入方面；
2、结果显示，受访者中，每天工作时间超过8小时的占88.32%，其中工作8-10小时的占31.79%，工作10-12小时的占27.66%，工作12小时以上的占28.87%；每月休息时间不超过4天的占94.84%，一天都没休息的占25.09%。
这个数字多，还带有分号，确定问题就要界定问题数量，根据分号来确定，并列结构，确定问题未两个：工作时间长和休息时间少；
3、有受访者表示，当前大部分快递公司制定了完善的用工制度，但仍有一小部分快递公司存在规避劳动法、不与员工签订劳动合同等问题。受访者中，没有与公司签订劳动合同的占6.74%，与公司签订劳动合同期限为1年的占60.52%，签2年的占22.33%，签3年及以上的占10.41%；从事快递工作的时间不足1年的占48.0%，工作1-3年的占32.6%，工作3年以上的熟练工仅占19.4%。
问题总分关系；总：规避劳动法和不签劳动合同；
材料中出现总分关系，重点看总，总中有具体内容则做答总，总中无具体内容从分中提炼，注意并列结构；


---
#事业单位B类


##概念分析题


###内涵类
问法：概括XXX概念的实质/本质/内涵

标志性词汇：
关键要素，关键构成，关键点，核心，核心要素，核心内容，主要包含，主要包括，具备XXX属性，是一个XXX，是XXXX，是一种XXX等···

侧重于内在的东西。

###特征类
问法：概括XXX概念的特征/特点

基础理论：特点和特征的区别
1 特点是指：人或事物所具有的特别或特殊之处，侧重说明人或事物所具有的独特的地方

2 特征是指：一事物异于其他事物的特点，侧重于人或事物可供识别的特殊的象征或标志，侧重**外表形式上的具体内容**。
比如：农业基础设施和物质装备不断完善，抵御自然灾害能力提升（基础设施和物质装备是特征，是外在表现，能力提升是内在表现）

基本写法：
序号 + 特点特征（前置词） + 说明（根据字数以及问法决定是否对特点特征进行说明）




###定义类
问法：概括XXX概念的定义

基础理论： 定义 = 事物的特征（特征） +  本质实质（属）
如： 
等腰三角形的定义：两条边长度相同（特征）的三角形（本质实质）

基本写法：XXX 是指·····（特征）的···（属）

(先找属性或者本质，再找特征)





###归纳总结类
问法：概括从XXX方面，XXX角度介绍了YYY概念

基础理论：
从哪些方面，那些角度介绍界定了某个概念是指：概念从哪个出发点来做的，也就是看事情的出发点、观点或者是考虑某件事情的出发点。




##校阅改错题
核心：多写多改，因为多写就算错了，也不扣分了；只要求你能改对8处。

###字
错别字

**改正要写有错别字**

###词
主谓宾，主谓，动宾的用词不恰当
遗传XXX工艺---》传承XXX工艺（用词不当）
产品的不同造成了原产地的不同----》原产地的不同造成了产品的不同（语序不当）

**改正要写用词不当/语序不当
增加删减字词要写语法错误**

###句
关联词---虽然，但是，如果，因为，不仅，不管，尽管，无论，还是（转折，因果，假设，递进，条件）···
关联词的大概率（80%）都有错误

**改正要写语法错误**


###段
句与句之间的逻辑顺序：时间顺序、空间顺序、论证顺序（是什么，为什么，怎么办）、行文顺序（总分，分总，总分总）

改正要写**语句顺序不对**

###解题顺序
读文段的时候，一句句的来。
第一步： 看句子内是否有错别字
第二步： 看句子内是否有词语搭配错误（遗传XXX工艺---》传承XXX工艺）
第三步： 看句子内是否有关联词，思考关联词是否符合句子内逻辑
第四步： 看完整段后，检查文段内句子之间的逻辑关系，就像语句排序题那样检查。

写答案格式：
1 XXX句中有错别字 XXX改成XXX
2 XXX句中有语法错误（觉得有几处就写几处） XXX改成XXX，YYY改成YYY，AAA改成AAA
3 XXX句语句顺序不对，和YYY句位置交换
4 XXX句中有用词不当，XXX改成XXX
5 XXX句中语序不当，XXX和YYY交换位置



##论证评价题
逻辑推理类下定义题的解决思路。

重要的得分点是写出错误，错误的名称是只值一分的。


###1 论题（论点）错误

概念不明确
1  偷换或者混淆概念，论据中的概念和结论中的概念不一致；


2词语/语句歧义，语言文字意义不明，不只有一种解释。

###2 论据错误
论据不充分
1 论据本身错误----表现形式：根据缺乏真实性的论据推导出论点的真实性


2 论据不确定（不明确）-----表现形式：忽视论据或数据变化的可能性，根据不确定的论据推导出确定的答案

比如：预计2019到2025年全国房价一直持续上涨，由此可见未来几年全国的房价还会上涨。
解答：“预计”表明是不确定的论据，是基于预计假设，存在发生变化的可能性，无法得出确定的结论。


###3 结论错误

1 前后矛盾： 论据与结论相互矛盾，相反不一致

2 绝对化表述：在结论中出现“肯定，一定，必然，必须，必将，根本，绝对是，最”····

3 存在常识性错误，与实际不符合

4 结论不明确，模棱两可

5 结论非此即彼，非黑即白
比如：如果你考不上好大学，那么以后你将一事无成。

6 过度推断：论点脱离了条件所给的内容，得出了比条件所给的内容更深层次的结论，属于命题人主观上做的推断。
比如： 
国家非常重视XXX的发展，出台了大量扶持政策，我们有理由相信XXX会迅速得到发展。（大量的扶持政策是不能推断出迅速的速度）
2020--2021年云南旅游收入是大幅上升的，故此云南的经济收入有大幅度增长。 

###4 论证过程（论证方式）错误
推理不严密

1 以偏概全（论点和论据都不确定为真命题）：通过个别例子推导出完整的结论，个例推整体
比如：
2020--2021年大理旅游收入是大幅上升的，故此云南的经济收入有大幅度增长。 


2 滑坡论证：不合理地使用连串的因果关系，将“可能性”转化为“必然性”。
比如：预计2020--2035年XXX房价是不断上升的（论据不确定），所以赶紧去买房。


3 忽视其他原因，原因单一，论据单一。（默认结论为真）

4 因果倒置

5 类比不当（拿不同的人或者事物进行对比）
比如：
美国人喜欢喝咖啡，中国人很少喝，所以中国的速溶咖啡市场前景广阔（类比不当，美国人和中国人的饮食习惯进行对比）
美国人喜欢喝咖啡，中国人很少喝，所以中国的咖啡味果冻市场前景广阔（偷换概念，论题咖啡被换了）


6 强加因果，论据与结论不相干：诉诸众人，诉诸无知，诉诸权威，诉诸情感
诉诸无知：科学不能证明鬼不存在，所以鬼是存在的。



7 数据谬误：XXX对象的平均数，百分比，基数的数据不等于XXX对象的现期总数。

答案格式：
写出大错误（错误名称）+ 错误之处 + 错误的理由

##新类型题目

给出一段材料，让你找出XXX处论证错误。


核心思路：
1 按照每一个分句进行拆解，
2 进行上下文分析，判断谁是论点，谁是论据 
3 进行抠字眼，论点和论据的主题一个字不对，都给我死抠
4 写错误在材料的哪里，写出理由，比如论据推不出论点····






#参考：

作者：狂风彡舞蹈
链接：https://zhuanlan.zhihu.com/p/267698169
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



申论学习怎么摘抄提取关键词，断对比机构答案怎么提取关键词。作文琢磨一下范文怎么写，模仿架构，总结通用句。


申论格式：
https://zhuanlan.zhihu.com/p/129036337
https://zhuanlan.zhihu.com/p/286269428


https://bbs.qzzn.com/forum.php?mod=viewthread&tid=16722146&extra=&authorid=5471830&page=1



---
ChatGPT的核心技术是**自然语言处理（NLP）**和**深度学习**。具体而言，它基于**Transformer架构**，使用了大规模**无监督学习方法**，例如**自回归语言建模**和**掩码语言建模**，来训练一个庞大的神经网络模型。这个模型可以处理文本序列，并从中学习语言结构、语义和上下文信息。

其中，**自回归语言建模**是指通过上下文中已有的词来预测下一个词，从而学习语言的连续性和概率分布；

而**掩码语言建模**则是指将输入文本中的一些词随机遮盖，让模型来预测这些词，以此学习词与词之间的联系和语义表示。

这些训练方法可以使ChatGPT模型自动学习大量的语言知识和模式，从而在各种NLP任务中表现出色。

此外，ChatGPT模型的成功还离不开OpenAI对数据和计算资源的充分利用，以及对模型架构和训练策略的不断改进和优化


自然语言处理（NLP）和深度学习：基于Transformer架构，使用自回归语言建模，掩码语言建模···大量的无监督学习方法，构成了一个庞大的神经网络模型，这个神经网络模型的成品是ChatGPT。

假如某个人的处理文字能力接近ChatGPT，是不是一定被认为是高智商呢？ 是的。
那设计的过程中使用的方法，建模，是不是可以认为是学习中被讨论烂的学习方法论？是的。



## 监督学习、非监督学习、强化学习之间的区别[3]


|  &nbsp;  | 监督学习 | 非监督学习 | 强化学习 |
| ---- | ---------------- | ------------- | ------ |
| 数据 | 一次性给定的supervisor提供正确且严格的标签 | 没有标签 | 没有标签、supervisor，属于semi supervised learning。在智能体与环境交互的过程中得到评价反馈 或 指导性反馈，这些反馈是时间序列数据（sequential data）。如果智能体不采取某个决策动作，那么该动作对应的数据就永远无法被观测到，所以当前智能体的训练数据来自之前智能体的决策结果。| 输入要求 | 独立同分布(i.i.d.), 为了消除数据之间的相关性。 |  独立同分布(i.i.d.) | 归一化的占用度量（occupancy measure）用于衡量在一个智能体决策与一个动态环境的交互过程中，采样到一个具体的状态动作对（state-action pair）的概率分布。|
| 动作 | exploration | exploration | Trial-and-error，即存在exploration和exploitation的平衡 (不一定按照已知的最优做法去做)|
| 驱动 | 任务驱动，模型是单纯被动地获得样本并被教育(instruct)[34] | 数据驱动 | Active learning，自驱的，有目标，从错误中学习[4]，这个错误是模型与目标的距离，通过奖励函数定量判断[5]|
| 反馈 | 有反馈 | 无反馈 | 无即时反馈，反馈是稀疏且延迟的奖励,用结果的总reward用来判断这个行为是好是坏，不会明确告诉什么是正确的action（若强化信号r与Agent产生的动作A有明确的函数形式描述，可得到梯度信息r/A则可直接可以使用监督学习算法。正因为强化信号r与Agent产生的动作A没有明确的函数形式描述，所以Agent在可能动作空间中进行搜索并发现正确的动作。[6] |
| 模型 | 建立新输入对应原标签的预测模型 | 自学习映射关系，以此为模型 | 学习到从环境状态到行为的映射即决策（决策往往会带来“后果”，因此决策者需要为未来负责，在未来的时间点做出进一步的决策。），使得智能体选择的该行为能够获得环境最大的奖励reward|
| 优化目标公式 | $\text {最优预测模型} =\arg \min _{\text {模型}} \mathbb{E}_{(\text {特征,标签}) \sim \text {数据分布}}[\text {损失函数 (标签, 模型（特征）)]}$ |$p(\boldsymbol{x})$ 或带隐变量 $\boldsymbol{z}$ 的 $p(\boldsymbol{x} \mid\boldsymbol{z})$ [21]| $\text {最优策略} =\arg \max _{\text {策略}} \mathbb{E}_{(\text {状态, 动作}) \sim \text {策略的占用度量}}[\text {奖励函数 (状态, 动作)]}$|
| 解释损失函数 | 目的是使预测值和真实值之间的差距尽可能小 | 最小重构错误[21]| 目的是使总奖励的期望尽可能大|
| 任务 | 预测仅仅产生一个针对输入数据的信号，并期望它和未来可观测到的信号一致，这不会使未来情况发生任何改变。预测任务总是单轮的独立任务。| 基于数据结构的假设，去学习数据的分布模式[29] |决策往往会带来“后果”，因此决策者需要为未来负责，在未来的时间点做出进一步的决策。决策任务往往涉及多轮交互，即序贯决策[7]（多序列决策） |
| 上限（upper bound） | 传统的机器学习算法依赖人工标注好的数据，从中训练好的模型的性能上限是产生数据的模型（人类）的上限 | 可超人类 | 不受人类先验知识所限，表现可超人类 |
| 适用情况 | 任务(分类/回归) | 数据驱动(聚类) [8] | “多序列决策问题”，或者说是对应的模型未知，需要通过学习逐渐逼近真实模型的问题。并且当前的动作会影响环境的状态，即具有马尔可夫性的问题。同时应满足所有状态是可重复到达的条件，即满足**可学习条件**。 [5]|
| 通俗理解 | 记忆任务，考试 | 找规律 | 更符合现实决策 |





	2021-04-13 18:04:30
kumika	数量关系	# 数量关系

工程，行程，利润，排列，概率，容斥 这些都是常考的

基础定义知识
---

1 最大公约数：几个数公有的约数，叫做这几个数的公约数，其中**最大的一个公约数**叫做这几个数的**最大公约数**


2 最小公倍数：几个数公有的倍数叫做这几个数的公倍数，其中**最小的一个公倍数**叫做这几个数的**最小公倍数**

3 题目某些对象赋值和某些对象设置未知数，是2个不同的概念，是可以同时存在的，是可以赋值A对象数值100，同时设置B 对象为X未知数。


基础工具知识
---

###1 直接代入法

    通常做题情况： 
    题目条件---》选项
    
    
    现在代入法情况：
    选项---》题目条件


题目某些对象赋值和某些对象设置未知数，是2个不同的概念，是可以同时存在的，是可以赋值A对象数值100，同时设置B 对象为X未知数。

###2 直接倍数（不理解）

看选项，直接代入。

2，4，8能除尽的判断：  
2 看尾数，
4看倒数1，2位数，
8看倒数3位数

3，9能除尽的判断：
3--》整个数的数字相加是3的倍数
9--》整个数的数字相加是9的倍数

###3 因子倍数

在乘法运算中，乘数中有3，7，9，11，13···数字，结果中也一定有这些数字。

2，5是会在乘法中消失。


###4  比例倍数

若 $$\frac {a}{b} = \frac {m}{n}
$$ 并且m与n互质（约为最简分数），则说明
a 占 m 份，是m 的倍数**（a是m的倍数）；**
b 占 n份，是n的倍数**（b是n的倍数）；**
a+b 占 m+n 份，是m+n的倍数**（a+b是m+n的倍数）；**
a-b 占 m-n 份，是m-n的倍数**（a-b是m-n的倍数）。**




###5 化归为1

经常需要最小公倍数来计算2个变量之间的比例关系。

使用范围：
**1 变量在题目中没有提及具体数字的大小。
2 变量也不能通过其他有具体数字大小的变量计算得到。**

比如： 行程问题 S = V * T ，题目中条件给了时间，速度和路程没有具体数字，时间和速度有比例关系，所以此时就可以使用化归为1法，假设路程OR速度为1，按照比例关系进行比例倍数，最小公倍数/最大公约数计算出路程OR速度。


### 6 比例假设

化归为1的比例版， 自己假设题目中的总数，根据题目给的分变量比例关系进行放大缩小，根据比例得到题目分变量的实际数字。


题目某些对象赋值和某些对象设置未知数，是2个不同的概念，是可以同时存在的，是可以赋值A对象数值100，同时设置B 对象为X未知数。


### 7  十字交叉法

**A * a + B * b = (A+B) r** 

A，B是某类对象的具体数字，a,b,r是某类对象的百分比，平均数，XX率----相对数（自己定义的量，2个对象计算得出的数）

####题目识别标志：
出现多个百分数

条件都是在**A，B，a, b, r，A+B**这6个量中题目选择几个给出，只给出2个就是难题，r这个量应该是必给的（没它算不出）。


公式推理：
**A * a + B * b = (A+B) r** 
===》(a-r) A = ( r - b) B
===》
$$
 \frac {A}{B} = \frac {r - b}{a - r}
$$
所以可以 写成图的形式（这里技术不够无法呈现 a, r, a-r 的3个数的连线关系）
$$
 \frac {A}{B} : \frac {a}{b}:  r    \frac {r - b}{a - r}
$$

####使用范围： 
**A * a + B * b = (A+B) r** ，题目条件都是在**A，B，a, b, r，A+B**这6个量范围中。
a,b,r是要在同一个类型范围内的。

**关键是r ，题目是否直接给出。**



浓度问题： 浓度的混合问题，abr是浓度，abr是相对数。
人数问题： 
人数和平均数，已知A+B 的数，abr是平均数，abr是相对数。
购物人数比例，已知a,b,r, abr是百分数，abr是相对数。



### 8 假设代入法

当题目已知条件没有常数的时候，可以假设1个已知条件是XX常数，其他量为XYZ的未知量，然后列方程解决。


题目某些对象赋值和某些对象设置未知数，是2个不同的概念，是可以同时存在的，是可以赋值A对象数值100，同时设置B 对象为X未知数。


##方程与不定方程


**题目某些对象赋值和某些对象设置未知数，是2个不同的概念，是可以同时存在的，是可以赋值A对象数值100，同时设置B 对象为X未知数。**


###1 查找等量关系

题目类型：
1 已知XXX对象的总和
比如：2人桌子有100张，4人桌子有90张




2  A比B，A是B，A与B，A等于B，描述2个变量之间的关系，**通常用来减少未知数的个数，设置一个未知数去描述多个未知变量**
比如：A = B+5， A=2B，A/B = 2/7, A - 50 = B/2





3 隐藏的前后不变量
 缺什么设置什么为未知数
 比如某单位组织党员和积极分子分组讨论，已知如果每组分配7名党员和3名积极分子，还剩下4名党员未分配；如果每组分配5名党员和2名积极分子，还剩下2名党员未分配。
这时候就是总人数不变，党员，积极分子也不变，缺分组数量，设置分组数量为X，Y，根据总数不变列方程。




解题模式：

1 找等量关系

2 根据等量关系设置未知数（等量关系等式中缺设谁）

3 列方程求解

 
当出现读不懂题目条件的时候，圈出名词，然后考虑这个名词的同义转换，在其他条件中寻找这个同义转换
 



###2 方程与方程组


###3 不定方程

未知数的个数多于方程的个数。
常见类型：2个未知数，一个方程组；三个未知数，2个方程组。


常用解法：
1 直接代入选项进行验证

2 枚举试算（1，2，3，4，5···一个个代入去计算）

3 利用奇偶，尾数，倍数等数字特征分析；
比如：7X + 3Y  = 60 ； 12X + 5Y = 99；利用总数60，99的奇偶，尾数，倍数进行分析
倍数是总数和其中一个分项系数确定倍数关系，则另一个分项的未知数也属于这个倍数关系（奇偶性也可以在这个关系里面）。

4 特定题型可以采用赋“0”法（不定方程组使用）






###4 不定方程组

第一种解法:
1 先消元

2 按照不定方程求解 



第二种解法：
特定题型可以采用赋“0”法（本质是线性代数的思维）
满足下面全部使用条件：
1 题目出现3个未知数
2 列出2个方程组
3 求3个未知数之和/差

解法过程：
1 令任意一个未知数为0，一般令系数复杂，大的为0
2 解出未知数为0 的方程组
3 得出解，直接代入3个未知数之和




工程问题
---



基础公式：

工作总量 = 工作时间  X  工作效率



核心思想：**工程问题不会出现甲乙丙混合发生化学反应提升效率的情况，一直都是各算各的。** 

化归为一（设1或者最小公倍数法），比例假设法


使用条件：

出现工程，有YY效率，花几天完成，多几天少几天完成，多XX台机器完成，少XX台机器玩操，等字样。




使用范围：


工作总量 = 工作时间  X  工作效率

根据化归为一（设1法），题目给出的已知条件（工作量 ，工作时间 ，  工作效率 假装题目这3个中选一个是已知的）是工作时间，就可以**假设工作效率为1或者合适的最小公倍数/最大公约数**，**也可以设置工作总量为1或者合适的最小公倍数/最大公约数**，然后根据题目后续条件列出式子。

--------
个人理解：

设1法就是，工作总量 = 工作时间  X  工作效率  这个公式中3个变量已知1个（2个也行），再假设剩下2个中的1个变量的数值是1，此时题目可解。

---------
齐麟的方法：

题目识别：完成XXX工作

公式：工作总量 = 工作时间  X  工作效率

常用方法：




赋值法（一个等量关系，已知一项，赋值另一项，可求公式的结果）-----1 赋值总量 ，2赋值效率

1 赋值给总量
**使用条件:题目给出多个对象的完整工程的工作时间**，没有给出工作总量

（1）一定要赋值工作总量（假设出工作总量），可以根据题目给出的各自的工作时间求出公倍数，这个公倍数就是假设出的工作总量的值；

（2）分别求工作效率

（3）按照题目要求求谁算谁


2 赋值给效率
**使用条件:题目给出多个对象之间的工作效率比/倍数关系**；核心思想---总量不变，效率无穷个比值，只是这个比值是根据题目给出的工作时间来确定的。

（1）赋值工作效率

（2）求出工作总量

（3）按照题目要求求谁算谁


3 赋值效率的特殊情况
**使用条件：题目出现XX个人或者机器，赋值效率为1**


（1）赋值工作效率

（2）求出工作总量

（3）按照题目要求求谁算谁









---------

容斥问题
---

###1 极端容斥

公式定义：
题目给出的已知条件----总数M ，满足3个条件的**数目分别为A，B，C，**

题目提问
题型1---满足题目3个条件中的**2个条件的最多**有XX种？（二多）

答案：
$$
\frac{（A+B+C）}{2} ,结果向小的取整
$$

除外：
1 不构成3角形，等于较小的2个数之和
  三角形 就是A B C 这3个数没有构成三角形勾三股四数字（比如 2，6，10）就是较小的2个数字相加。

2 式子**A+B+C 》 2 M   等于 3 M -（A+B+C）**



题型2---满足题目全部3个条件的最少有多少种？（3少）

答案：
**（A+B+C）- 2 M** 

###2 容斥2个集合标准型

使用范围：

题目有5个量：
**1 满足条件A的量a
2 满足条件B的量b
3 同时满足条件A和条件B的量c
4 条件A和条件B都不满足的量d
5 总量e**

公式：
**a + b - c = e - d**



###3 容斥2个集合图示标数型

就是画图，然后在图上标数字整理逻辑解题。

使用范围：
题目给出条件：
 只满足条件A的数， OR  只满足条件B的数，选用2集合图示标数

关键点： 从2个图交集处入手，就是图的最中间的数字入手。



###4 容斥3个集合标准型


使用范围：
假设题目有3个条件A，B，C，题目有提供大于1个满足2个条件的数：
**1： 满足条件A，B的数a
2： 满足条件B，C的数b
3： 满足条件A，C的数c
4： 满足条件A，B，C的数d**

符号说明：
$$
\bigcup 是并集，\bigcap 是交集
$$
所以公式：
$$
A\bigcup B \bigcup C  = A+B+C -A\bigcap B -A\bigcap C -B\bigcap C+ A\bigcap B \bigcap C
$$

等于：

$$
A\bigcup B \bigcup C  = A+B+C - a  - b - c + d
$$


###5 容斥3个集合图示标数型


使用范围：

当3集合标准公式不能满足条件的时候，就使用画图法。


注意区分：
1 满足某条件， 与仅满足某条件的区别

2 有没有3个条件都不满足的情况


关键KEY： 也是从最中间的量入手。



###6 容斥3个集合整体重复型

范围：
题目给出的已知条件：满足1个条件的数，和满足2个条件的数，给了我们1个总数，而不是分项的数。


满足1个条件的数：
$$
X  =  X_1 + X_2 + X_3
$$

满足2个条件的数：
$$
Y  =  Y_1 + Y_2 + Y_3
$$

满足3个条件的数： Z = Z。


假设总数W，条件ABC  ,有2个公式：
$$
W  = X+Y+Z  =  A \bigcup B \bigcup C 
$$

$$
 A + B + C  = X + 2Y + 3Z 
$$

---
齐麟的方法:

两集合：
标准公式:
**总数 - 两者都不  = 集合A + 集合B - A交B**


三集合：
标准公式: 
**总数 - 三者都不  = 集合A + 集合B + 集合C - A交B -  A交C - B交C + A交B交C**
变形公式:
**总数 - 三者都不  = 集合A + 集合B + 集合C - 同时两者交集 -  2倍（A交B交C）**


标准公式，因为集合ABC加了三次，然后又减了三次，中间就空了，所以加A交B交C，补充完整。



画图法：
使用条件：题目给出信息中存在**只满足某一个集合条件**（只会说英语，只会某一项技能···），优先考虑画图法。

画法原则：
**从中心向外侧标注**，把图像每一个部分的人数都标注上，最后就根据题目求什么，算什么。



     





##行程问题



核心公式： 

**路程S = 速度V * 时间T**

核心假设：
根据S = VT  ，按照题目给出的已知条件列出方程，有2个路程则用S1，S2表示，然后根据方程组解。




### 1 相对速度
$$
S相遇  = (V_大 + V_小) * T相遇
$$

$$
S背离  = (V_大 + V_小) * T背离
$$


$$
S追及  = (V_大 - V_小) * T追及
$$


###2 环形运动



反向运动：
第N次**相遇路程和**为N个周长，T相遇时间
$$
环形周长 C = （V_大 + V_小） * T遇
$$


同向运动

第N次**相遇路程差**为N个周长，T相遇时间
$$
环形周长 C = （V_大 - V_小） * T遇
$$


###3 流水行船
$$
顺流路程 S = V顺 * T顺 = （V船 + V水）* T顺
$$


$$
逆流路程 S = V逆 * T逆 = （V船 - V水）* T逆
$$

---
齐麟的方法：

###基础类型

核心思路：找准每一段过程上的路程S，速度V，时间T

相向而行/相对而行：朝相反的方向行进，面对面行进；朝同一目标，面对面运动

同向而行：从同一地点，同一方向前进

相背而行：彼此的方向和目的完全相反

###火车过桥

路程S = 桥长 + 火车身长

 火车完全走在桥上的路程 = 桥长 - 火车身长


###直线单次相遇

2人的路程和（多人也要看成2人） = 2人速度和 X 时间
多人就分成2人进行分析
分析的时候都要从开始点进行分析，不能从相遇地点分析。


###环形单次相遇追及

相遇

题目识别：运动方向是相反的，相向而行/相对而行

S = （V1 + V2） X T


环形相遇
2次相遇，路程和则是2S，N次相遇，路程和则是NS

题目问相遇多少次，直接设相遇X次，然后列方程解。


追及

题目识别：运动方向是相同的，同向而行

S = （V大 - V小）X T

环形追及
2次追及，路程差则是2S，N次追及，路程差则是NS



###直线两端出发往返相遇


题目识别：**分别从A，B两地出发，第一次相遇后继续行进，到达A，B后返回**



直线路程是S，两端出发往返路程第N 次相遇，从出发到第N次相遇路程和是（2N - 1）S


题目问相遇多少次，直接设相遇X次，然后列方程解。


###直线同一端出发


题目识别：**从同一个地点出发**

直线路程是S，从出发到第N次相遇路程和 是 2N S

根据路程和题目给出的速度或者时间，进行比值（分数形式），然后得出2人的速度关系或者时间关系



###单双岸


双岸：

题目识别：题目给出相遇地点分别距离2个出发点的长度

S：整个路程

S1：第一次相遇地点距离左边A地点的路程

S2：第二次相遇地点距离右边B地点的路程

S = 3S1 - S2 ，因为具体分析路程是：S1 +2S1 -S2


单岸：

题目识别：题目给出相遇地点距离1个出发点的长度


S：整个路程

S1：第一次相遇地点距离A地点的路程

S2：第二次相遇地点距离A地点的路程


S = （3S1 +S2）/ 2


###流水行船

题目识别： XX对象存在逆行行为，**逆行速度V逆**


V顺水 = V船 + V水


V逆水 = V船 - V水






##概率问题

概率 = 满足条件的情况数 / 总的情况数



---
齐麟的方法：

1 概率 = 满足要求的情况数量 /  总的情况数量
题目识别：选符合条件的人的总数 / 随便选人的总数



2 某条件成立的概率  = 1 - 该条件不成立的概率
题目识别：比赛，射击类等

3 分步概率 = 满足条件的每个步骤的概率之积
题目识别：完成事件需要分多个步骤，其中每个步骤题目都给概率，暗示求完成该事件全部步骤乘积的积数。

4 总体（分类）概率 = 满足条件的各种情况概率之和
题目识别：完成事件可以有多种方法和方式，暗示求完成该事件的方法方式数量的总和。



题型有2种
1是利用排列组合计算概率，大多数思路是：这件事情发生的概率 = 满足要求的情况数量 /  总的情况数量；再配合枚举法/穷举
写在草稿纸上多是用组合C来列式子。


2  已知概率去求概率







学习能力，就是在短时间内高效地了解一个科研领域或者掌握一些科研方法，而一个人学习能力很大程度上就是在考验一个人对于学习工具的掌握，这些学习工具，就是那些你在本科或training阶段打下的基础，比如数学，物理，化学，英语，专业课等基础学科和各种实验仪器及其理论。
要是不牢固的解决方法：基础没打牢不需要抱着基础书看，链式学习，缺什么补什么，空闲再系统看基础类书


##植树方阵

植树：
公式：

1 单边直线型： 棵树 = （总长 / 间隔） + 1
点在直线分割后，得到的是段数/间隔数，端点数量比段数（间隔数）多1，所以加1 
题目识别：包含首尾，或者什么都没有提及。


2 单边楼间型（不要两边端点）： 棵树 = （总长 / 间隔） - 1
求的是2头端点距离之间有多少个端点，所以就不要连带计算2头的端点
题目识别：不含首尾，墙内，楼之间



3 环形型： 棵树 = 总长 / 间隔 
题目识别：种树的形状是环形，比如圆，三角形，四边形，只要是封闭图形都是。

4 双边都要种树，则是单边公式X2
题目识别：两边，两侧

5 不用移动的是间隔距离的公倍数的树

方阵:
题目识别：出现**“方阵”**字眼

方阵问题的小结论：
N阶方阵总人数 N X N

最外层人数 4N - 4

相邻两层相差8人

 




##抽屉原理

根据题目给出的条件，自己假设出与题目条件相反的条件（对象都是在题目条件内的），最后相反条件得出的结果再加1，就是答案。


###最多最少型

原理： 
问最多的抽屉，最少有多少个苹果，此时求平均数。
答案---不低于平均数的最小整数（向大的取整）就是答案。



##比例问题

原理：
根据题目已知条件得出的数 进行比，得到一个比例关系，然后根据比例关系求题目所求的对象。


###和差倍比（大杂烩）
题目中2个数的和，差，倍数，比例关系




##溶液问题
常用十字交叉法解决

公式使用的变量有**4个**，分别是**溶液，溶质，溶剂，浓度**
$$
溶液 = 溶质 + 溶剂 
$$
$$
浓度P = \frac{溶质}{溶液} = \frac{溶质}{溶质 + 溶剂} = 1 -\frac{溶剂}{溶质 + 溶剂}
$$
$$
溶液 = \frac{溶质}{浓度P}
$$
$$
溶质 = 溶液 * 浓度P
$$


举例：
糖水——溶液
糖——溶质
水——溶剂
糖占糖水溶液的百分之几——浓度

　　重点题型

　　**溶质不变型(简单溶液混合、等溶质增减溶剂、溶液比例问题)
　　溶质变化型(混合稀释问题)
　　饱和浓度型**

　　重点方法

　　**简单溶液混合：运用溶液基本概念或基础公式
　　等溶质增减溶剂：设处溶质，得出溶液，即可解决
　　溶液比例问题：运用设整思想，根据所给条件将溶质或者溶液设出
　　溶质变化混合稀释问题：抓住浓度本质，看溶质最后剩下多少就能快速得到答案**

---
齐麟的方法:
###1 蒸发稀释类型
核心思路：溶质不变

原溶液 X 浓度 = （蒸发后溶液 - 蒸发重量） X 蒸发后浓度

题目识别：出现字眼：“蒸发，加水（没有表明浓度），加入清水蒸馏水，稀释”

当题目只出现百分比数据，没有其他具体数值的时候，使用赋值法，给不变量赋值（最小公倍数），写出等量关系和等量方程。
 



###2 溶液混合类型
核心思路：总溶质不变

题目识别：2种及其2种以上的浓度不同的溶液混合
 

赋值规则：
题目里某些变量没有明确给出确定的数字，在设未知数的时候，可以随时更改，可以是X，是1，是2是9000，哪个方便方程计算就用哪个。（没有成熟的规则）


1 总溶质相等，然后列方程求混合后的**浓度P**
**A x a%  + B x b%  = (A + B )x P%** 





2 十字交叉
需要条件：混合前的各个部分溶液的浓度，混合后的浓度，求出混合前的各部分溶液重量的比值。







###3 反复操作类型

核心思路：总溶液不变

题目识别：只有一种溶液并且出现字眼：“加满，倒出”





---
##牛吃草问题

关键公式

题目已知条件：
4头牛 吃草 30 天
5头牛 吃草 20 天
6头牛 吃草 ？？ 天

https://i.loli.net/2021/08/31/rBbOAVFeDdgvMal.jpg

---
齐麟的方法：

某个对象有XXX个并且YYY小时or天，完成该对象的某个属性，比如牛吃草，抽水机抽水，售票窗口，水池蓄水

牛的数量：N
牛吃草的天数：T
原有的总量：Y
每单位时间的新增量（草增长的速度）：X，X是正数，边吃边增长，X是负数，边吃边减少
**公式：Y = （N- X ） x T** 
需要2组方法解出X和Y，然后题目问什么再代入解出XY的方程中。

当原有的总量不一致的时候，把N进行变形变成每单位Y个有多少个N，这样的目的是凑出题目2组数据之间的等量关系
**公式：单位的Y2 = [（N/Y）- X ] x T**














##排列组合问题

加法定理：

设集合S 被划分成两两不相交的部分S1,S2,S3...,Sm。则S的对象数目可以通过确定它的每一个部分的对象数目并如此相加而得到**$\mid$S$\mid$ =   $\mid$S1$\mid$ + $\mid$S2$\mid$ + $\mid$S3$\mid$ + ...+$\mid$Sm$\mid$**   



乘法定理：



令S是对象的有序对（a,b）的集合，其中第一个对象a来自大小为p的一个集合，而对于对象a的每一个选择，对象b有q种选择。 于是 S的大小为p X q；

$\mid$S$\mid$  = p X q

其实乘法定理是加法定理的一个推论。
推论过程：
设a1,a2,a3...ap是对象a的p个不同选择。我们把S划分成部分S1，S2,...,Sp,其中Si是S中第一个对象为ai(i = 1,2,...,p )的有序对的集合。每一个Si的大小为q，根据加法定理有$\mid$S$\mid$ =   $\mid$S1$\mid$ + $\mid$S2$\mid$ + $\mid$S3$\mid$ + ...+$\mid$Sp$\mid$ = q + q+...+q(就是p个q相加)= p X q

乘法就是重复的加法这样的基本事实。

减法定理：


除法定理：




基本应用公式
加法： 分类
乘法： 分步
排列： 顺序有关  ----》${A_{10}^{4}}$ = 10 X 9 X 8 X 7
组合： 顺序无关  =====》${C_{10}^{4}}$ = $$ \frac{10 * 9 * 8 * 7}{4 * 3 * 2 * 1}$$

计数问题归类：
1 计数对象的有序排列的个数或者对象的有序选择的个数
   任何对象都不重复
   允许对象重复（但可能是有限制的）
2 计数对象的无序排列数目或者对象的无序选择数目
   任何对象都不重复
   允许对象重复（但可能是有限制的）
多重集合是除其成员不必不同外与集合一样。
有3个a,1个b,2个c，4个d组成的多重集合M，即M有4种不同类型的10个元素。
M可以表示为：{3$\cdot$a, 1$\cdot$ b, 2$\cdot$ c , 4 $\cdot$ d} ,此时数3，1，2，4是多重集合M的重复数。
当集合M { $\infty$ $\cdot$a, 1$\cdot$ b, $\infty$ $\cdot$ c , 4 $\cdot$ d} 此时成员a 和c 有无穷大的重复数，b和d的重复数是2和4
1中考虑到顺序的放置或选择通常称为排列
2中与顺序无关的放置或选择称为组合。

==========================================================================
个人理解： 和算法里面的map集合结合起来，感觉组合数学的魅力。

----------------------------------------------
管理类联考的排列组合的网课的内容








------------------------------------------------------------------------------

自己网上找的内容

题目出现相邻问题，----捆绑法----**先考虑相邻元素**，后视为一个整体。比如ABCDE，AB和CDE视为2个整体。


非相邻问题-------插空法 ------**先考虑剩余元素**，后将不相邻元素插入所成间隙中。 ABC插入 DEFG中，则是$${A_{5}^{3}} $$


###1捆绑插空




###2分配插板

1 被分配的东西是相同的，只有数量上的差异

2 要求每组满足“至少一个”的条件

3 上述条件如果不能满足，需要构造使其满足 $${A_{y-1}^{x-1}} $$或者$${C_{y-1}^{x-1}} $$ 

---
###齐麟的方法：

###1 基本概念


分类：（可看成并联电路）
完成事件A有多种方法，**用加法**，把能够完成事件的多种方法数量直接相加
分类加法计数原理：
完成某件事有n类办法，在第一类中有m1种不同的方法，第二类中有m2种不同的方法，则完成这件事共有N = m1 + m2 + m3 +····+mn种不同的方法。



分步：（可看成串联电路）
完成事件A有多个步骤，**用乘法**，把能够完成事件的每一个步骤的方法数量直接相乘
分步乘法计数原理：
完成某件事有n个步骤，在第一个步骤中有m1种不同的方法，第二个步骤中有m2种不同的方法，则完成这件事共有N = m1 · m2 · m3 ·。。。·mn种不同的方法。




做题思路：
1 判断题目要求事件/对象是分类还是分步，确定使用加法还是乘法
2 该事件/对象是要进行排列还是组合，还是是排列组合一起


###2 排列组合基本概念公式

排列A  有顺序   顺序改变影响结果


组合C  没有顺序  顺序改变不影响结果


题目识别：
排列：题目出现字眼---排，安排，排队，排法，次序，顺序
组合：题目出现字眼---选，挑选，选派

题目没有明确给出是排列，还是选的时候，就要考虑题目要求本质是选，还是排

排列组合一些细节： 一定要**按照题目要求去设想**，不能自己想什么就是什么，不然就会掉进出题人老头的坑，一些思路障碍。所以一定要**根据题目要求去假设**，**不安排在同一时间就不要设想安排在同一时间段的可能。**




###3 捆绑和插空

题目识别：
捆绑：在一起，相邻，挨着
插空：不相邻，不在边上，不挨着

相邻用捆绑法，不相邻用插空法

捆绑：1 捆绑， 2排列，3解绑（计算捆绑在一起的2个对象的顺序）



###4 计算反面
正面情况：存在2种或者2种以上的复杂情况的时候，采用反面计算法


 总数 - 反面的情况数量

多位数的选择类型题目 

染色类题目


###5 插板法

插板法是计算总数，要是还有什么条件，就要细分分情况算。


题目识别：
相同的XXX对象，分成若干份给不同的P个人，每人至少YYY个

核心思路：
凑成使用条件：每一个人都有一个对象，根据人初始拥有对象的数量加减凑成拥有一个对象后，少的数量就总数增加同样数量，多的数量就总数减少同样的数量



N个对象中，有N- 1个空，分给不同的P个人，每人至少一个对象，**所以N- 1个空需要P-1个插板来隔出P份。**

$${C_{N-1}^{P-1}} $$ 

假如题目说每人至少要2个对象，则需要先给每人一个，分割的时候空的数量就是总数-人数-1，这样就凑成插板法的使用条件：每人一个对象，**空的数量N-人数-1，需要有P-1个板子，才隔出P份**

$${C_{N-人数-1}^{P-1}} $$ 

假如题目说每人至少要的对象数量都不一致，则需要分别给每一个人所要求的数量 - 1，使得每一个人差一个对象就可以达到题目要求的数量，这样就可以凑成插板法使用的条件了，这时候题目能给出空的数量就是总数-人要求的数量减少一个后的数量

比如A至少1，B至少2，C至少3，D至少4

$${C_{N-（0+1+2+3）-1}^{4-1}} = C_{N-7}^{3}$$ 

假如题目没有说明条件，则先给每一个人一个对象（没有说明条件会出现人一个对象也没有的情况），总数也要加上这些对象数量，这样就凑成插板法的使用条件：每人一个对象，有P-1个板子，然后空的数量是总数+人数 -1 

$${C_{N+人数-1}^{P-1}} $$ 


###6 环形排列

题干识别: 排成一圈

核心思路:
圆圈解开排成一条直线，在直线的状态下排序不同，但是在圆圈状态下只要元素的相对位置不变（对面和相邻元素不变），直线状态下的所有排序都只算作一种

假设有X个元素围成一圈
排成直线的情况：$$
{A_{X}^{X}} 
$$
排成圆圈的情况：
$$
 \frac{ {A_{X}^{X}} }{X}
$$



###7 全错位排列

题目识别:
XXX对象不能映射/对应这个对象的属性
比如：车位对应车，厨师对应菜，科室对应工作人员，但是题目要求A车位不能停A车，A厨师不能吃A菜，A工作人员不能回A科室

N个人对应N个东西，每个人不能（吃，用，拿，回）自己


解题模式：
有1个人的错位排列 对应 0种方式 ，简称D1 = 0

D2 = 1
D3 = 2
D4 = 9
D5 = 44
D6 = 265

###8 不同数量排序

苹果和盒子的数量不一致，比如4个苹果，要放进3个盒子，每一个盒子至少一个苹果，有多少种。

建议：先把数量多的元素进行捆绑（211中的2就是捆绑），在进行分组排序，211就是分成3组，3组对应3个盒子所以是A33。

特别注意-----当元素是一致的时候（同颜色的卡片，小球），就211中的11要除以A22了。三个数放在红,黄,绿 三个位置排序一样,所以 乘以A33，但因为它有两个数是一样的所以除以 A22。
比方说123排序时即有A33,也就是6种排法，即123,132,213,231,312,321,如果把113三个数排序（也就是把上面的2换成1）即113,132,113,131,311,311就有重复的所以要A33/A22





##经济利润


题干特征词：


常用列方程，比例假设，代入法，十字交叉法····

**常用公式：**
成本 = 进货价格(进价)
$$
利润率/毛利率 = \frac{ 利润 }{成本} = \frac{售价 - 成本}{成本}
$$


折扣 ： 8折 = 0.8 * 原价


量 * 价格 = 总额






---------------------------------------------------------------------
齐麟的方法:

没有打折题型：
题目识别：一批货按照XXX价格，按照YYY个数量或者全部出售

核心思路：根据题目给出的信息是利润等量关系，成本等量关系，还是利润率等量关系，根据这些等量关系列方程

$$
利润率/毛利率 = \frac{ 利润 }{成本} = \frac{售价 - 成本}{成本}
$$

使用资料分析内容对比：
**成本 = 基期， 售价 = 现期，利润 = 增长量 ， 利润率 = 增长率**




部分打折题型：
题目识别：一批货分多组出售并且价格不一致。比如：XXX个对象，出售了AAA个以后，打YYY折，再出售BBB个


**核心思路：总利润 = 各个部分利润之和**，根据这个等量关系列方程。
**打折 都是在 售价基础上，不是在成本上打折**







---------------------------------------------------------------------
###2级结论



1 当题目给出条件的对象有3个或者3个以上的时候，就要假设题目对象所在的逻辑数学公式里面没有出现的那个量作为假设量**（核心思想就是用一个变量描述出题目条件给的关系）**



---------------------------------------------------------------------
##日期周期星期


###周期

总数 / 周期 = 商····余数

每隔XXX天，实际上就是一个周期XXX + 余数天数

题目识别：出现字眼“循环” ，“每隔XXX个对象和YYY个对象”

星期日期的计算：

求星期几，就是当前题目给的星期几 + 计算得到的余数 - 7

平年365，闰年366，年份/4 能整除就是闰年

30天的月份：4 6  9  11  
31天的月份：1 3 5 7 8  10  12


几月几号到几月几号的计算：先算零头，再算整月，再算零头

月头几天的星期和月尾几天的星期是一样的，这几天都数字要小于7（一个周期），因为这几天不在一个完整周期内。




---------------------------------------------------------------------

##数列问题

###基础数列

使用一次加减乘除得到的数列


------------------------------
等差数列

求和：  和 = （（首项 + 末项）/ 2）X项数 = **平均数  X项数 = 中位数 X 项数**（平均数，中位数是用的最多的情况）

项数公式： 项数 = （末项 - 首项）/ 公差 + 1

第n项 = 首项 + (n - 1)X 公差


1，5，9，13，（），21

等比数列

160 ，80， 40， 20，10


质数数列：
2，3，5，7，11，13···


合数数列：
4，6，8，9，10，12···


周期数列

2，5，4，2，5，4····


递推数列

前2项和是后一项
0，1，1，2，3，5····
OR
1，0，1，1，2，3，5，8···


###5大题型

1 多级数列


2 多重数列

3 分式数列

4 幂次数列

5 递推数列







自己的2次结论
---

1 要是方程两边都相等，可以使用已知的数进行最小公倍数计算，然后约分计算。



---

##最值问题

###构造最不利

题目识别： 题目出现**“至少” + “保证”**

原则:先“气死”，再加1

步骤：
1 想要什么，别给什么

2 先要N，先给N - 1 个

3 不需要的通通都给

4 最后结果+ 1

个人理解：
根据至少XX个，满足YY条件，得出结果，结果+ 1，就是答案，也就是根据YY进行排列组合，然后这些排列组合的对象有XX个，得出的结果+1






###数列构造

题目识别：把XXX个对象，划分成YYY项，**求其中一项的最大值/最小值**。



解题步骤：

1 编号

2 求谁设谁（根据求最大最小给最小最大项赋值和设未知数）

3 按照题目要求完成构造，利用总和为定值列方程求解，最小值则是数列的数值平均，最大值则是数量数值都是增量为1



###多集合反向构造
 

题目识别：已知总量，求最中心集合的最小值

解题步骤：

1 反向集合

2 求反向集合的和

3 总量与反向集合做差







#GRE数学

##基本数论

###奇偶数

奇数odd，偶数even

奇数 + 奇数 = 偶数  ； 奇数 X 奇数 = 奇数

偶数 + 偶数 = 偶数 ； 偶数 X 偶数 = 偶数

奇数 + 偶数 = 奇数 ； 奇数 X 偶数 = 偶数

和法：看奇数的个数
乘法：结果乘积是奇数，前面都是奇数

识别考点标志： 出现类似的计算式子 -----A的平方 + B的平方 =  C的平方


###因数与质因数

6 / 3 = 2 这里面的3是6的，因数/因子/约数/除数，英文是Factor/Divisor

因数的反义词是倍数multiple

因数推出的概念：质数和合数

质数prime：只含有2个正因数，是自己本身和1的数（考试多为2357这几个数）

合数composite：含有2个以上正因数的数（一般考察2458这几个数）



###最大公约数与最小公倍数

最大公约数：Greatest common Divisors 
最小公倍数：Least common Multiples

解题模式：
1 将数字分别各自分解质因数
2 每一个质数，取较小的指数的质数，相乘得到最大公约数
3 每一个质数，取较大的指数的质数，相乘得到最小公倍数

比如 45和60


##余数remainder

找循环，一般是4个作为一组循环





###小数分数与科学计数法






###比例与比率

the ratio of A  to B 表示： A：B或者A/B 

there is twice as mush A as B 表示为: A = 2B 或者 A/B = 2


revenue 收入
cost 花费，成本，进价
profit 利润
gross profit 毛利润
net profit 净利润


proportional 比例的
proportion 比例
directly proportion  正比例
inversely proportion 反比例  = 分母 denominator


P in terms of Y 用Y的表达式子表达P


##代数计算

###指数运算rules of Exponents

base 底数   
exponent 指数

3的5次方 3 to the 5th power ； 3 power 5th（口语化）


同底数相乘 ，指数想加
同底数相除 ，指数想减

（A的平方）立方，等于A的6次方


###解方程equations

解方程的前提：设置未知数的思路-----设置未知数的时候，应该首先考虑未知数设置出来要便于理解，便于表示其他量，便于列出方程。
在某些条件下，不一定能直接设置未知数是题目所求变量，此时可以设置中间变量为未知数，或者设置某种倍数关系（2倍，4倍，10倍）的未知数，总的目标是消除方程中分数形式。



标准根公式 

韦达定理

十字相乘法

式子的平方


加法：plus，addition(add)，increase，and，
和：sum
减法：minus，subtract，
差：difference
乘法：multiply，times，
积：product
除法：divide，over
商：quotient，ratio


###不等式

对已有的不等式两边取倒数或者负数，不等号要改变方向




###数列

等差数列arithmetic Sequence

等比数列Geometric Sequence





##初等几何

###三角形和四边形

三角形的内角和180度

三角形两边之和大于第三边，两边之差小于第三边

较大的角对应的边也比较大



勾股定理


三角形，四边形的面积公式



###圆


周长

面积

弧长

扇形

圆心角与圆周角的关系：同一段圆弧所对的圆心角是圆周角的2倍



###立体几何


长方体体积公式


正方体体积公式


圆柱体体积公式




###直角坐标系

直角坐标系2点之间的距离公式

斜截式公式


斜率公式

##文字应用题

###利息问题
单利：A是本金利息和， P是本金，r是利率，n 是期数，利率和期数的时间单位要一致（年月日，季度）
A =  P（1 + n r）

复利：A是本金利息和， P是本金，r是利率，n 是期数，利率和期数的时间单位要一致（年月日，季度）
A = P 乘以（1+ r）的n 次方


###集合问题

集合set  

交集 intersection

并集 union

画表格一个个加减算




###排列组合问题
组合：不计较顺序的时候







排列（A或者P）：计较顺序







###概率问题

比值关系







###描述统计学








##比较大小题型




#参考


事业单位数量题型学习推荐合集：
https://mp.weixin.qq.com/s?__biz=MzI3MTExNTA4NA==&mid=2652692816&idx=1&sn=707a2b54c050ee272208bdcb5650dd47&chksm=f12ef773c6597e6519608bf3aee178f0f6aae04e256acd9d4e2b1bc1709a9bfa245336b4d495&mpshare=1&scene=23&srcid=0430oVZPnXLiba8ltq7KIu0J&sharer_sharetime=1682821992832&sharer_shareid=f0c46bdeb5d35620a2efb2ff11d14543#rd



数量关系优先级：
https://mp.weixin.qq.com/s?__biz=MzI3MTExNTA4NA==&mid=2652686199&idx=2&sn=99a4a387feba67dda2145422ae0aa196&chksm=f12ed154c65958428080ccbbc4b324ec8660b0e88672b13a87075e13de4c1e294b68cdbec558&scene=21#wechat_redirect



---
一本好的参考书或者教科书的判断：
正好的教科书是会还原知识研究过程的，她会先充分描述该学科知识诞生之前的迷惑状态，抛出一个研究者当初遇到的典型问题，然后从这个原初问题出发，引领读者以研究者的角度，一步步经历这个“研究过程”，最后把现在成熟的学科知识作为结论呈现出来，甚至还不讳言一些研究过程中的错误方向。这样特别符合认知论，你会看到一个学科是怎么破土而出，发芽、长大、舒展、修剪，甚至遭遇瓶颈，学生就能够理解“为什么要有这个/这套知识”。


映射：集合是利用数学语言和抽象思维来建模自然界客观存在的方式，那么映射就是建模存在方式之间的关联。数学这个学科其实是在研究客观自然存在关系，因此必需完成上述两种元素的基本建模。
理解作为一种认知活动，总是包含 “指向” 的动作（头脑中），即指向已经认知的事物。终极的理解，大概是指向元素。数学中经常会做映射，目的是通过像来认识/理解原像。可以认为：数学是通过映射来实现理解的。映射体现和规定着像和原像之间的相互作用。通常把映射写作(以二元函数为例)：z = f (x,y)。其实也可以采用“运算”形式：z=xfy。x 和 y 根据法则 f 相互作用得到 z。当然，映射本身也是数学方法：集合看作 “方”，对应关系看作“法”。数学系的问题在于：经常会遇到映射，但很少真正 “做映射”。




Energy Kyouka

ワーズ・ワース-Words Worth 3


吃亏是福是自我安慰，是自古以来既得利者为了维稳说的话，想想说这句话的一般都是什么人（老板、统治阶级）



---

行测资料分析长题干读不懂怎么办?

一般题型
EG1 :
我国境内投资者对每个当期内产生非金融类直接投资的境外企业的非金融类直接投资额均值约为多少亿元人民币？

题干分析：
我国境内投资者对每个当期内产生非金融类直接投资的境外企业的非金融类直接投资额**均值约为多少亿元人民币？**

求的是个均值，就是平均数嘛！那咱脑海里就得有平均数的公式了 ，总量/个数 
再看看总量是啥？投资额，对不对？ 
个数是啥的个数？企业数，对不对？ 





含有前提条件的题干类型
EG2：

2021年一季度，软件和信息技术服务业（这里缺少一个“在”字，也可能不缺）软件业务收入中，占比较上年同期上升的收入类别，其收入所占的比重约：

分析：

这类题型的题干前半部分是让我们根据要求确定指标，后半部分考察指标的一些基本考点。
因此，题干后半部分经常会出现“其”这个字眼用来代指我们通过前提条件找到的指标。

第一步：
一般我们可以分阶段解读题干，先根据题目前半段要求，找到符合条件的指标。
第二步：
对该指标对应的数据按照题目后面的要求进行计算或比较。

所以--------题干前半部分“软件和信息技术服务业软件业务收入中，占比较上年同期上升的收入类别”为前提条件，第一步需要找到比重上升的这一类别，可以通过判断比重变化的方法寻找。
由表可知，2021年一季度，软件和信息技术服务业软件业务收入中，只有信息技术服务收入同比增速(29.2%) > 软件业务收入同比增速(26.5%)，并且软件产品收入（23.4%） < 软件业务收入同比增速(26.5%)。
故2021年一季度，软件和信息技术服务业软件业务收入中，符合前提条件的收入类别为“信息技术服务收入”


第二步：
题干中后半段“其收入所占的比重约?”目的是让我们求解出信息技术服务收入占比，利用现期比重公式直接求解





含有假设条件的题干


EG3：
若2015年第四季度湖北省固定资产投资占全年的比重为28.6%，则2015年湖北省固定资产投资约为多少亿元?



分析：

含有假设条件的题干，一般先给出假设条件，然后让考生依据材料数据结合假设条件，对问题进行求解。

题干一般会有这样的特征：
(1)**开头经常会出现“如果”、“假若”、“假设”、“若”**等字眼。
(2)后半段题干有时会用**连接词连接(例如：“如果……那么……”、“假设……则……”)，或用逗号隔开(例如：“若……，……”)。**


解法
第一步：大概扫一眼前面的假设条件，但是不要过度关注。

第二步：重点应该放在**题干后半段题干，以连接词“则”、“那么”或者标点“，”为分界**，**重点理解后面的要求，确定考点后**，根据材料数据以及题干所给的前提条件进行求解。



所以
第一步：题干开头出现“若”这一字眼，可判断为假设型题干


第二步：重点读“则”后面的要求-----“则2015年湖北省固定资产投资约为多少亿元”

题干时间与材料时间不同，让我们求解2015年(基期)的固定资产投资。
回顾材料发现并没有给出2016年全年数据，只给出前三季度数据，这时需要**结合假设条件**“若2015年第四季度湖北省固定资产投资占全年的比重为28.6%”求解，根据假设条件可知2015年前三季度占全年比重 （1-28.6% = 71.4%）







	2021-08-21 15:58:56
kumika	题目快速判断	# 题目快速判断

做这个分类文档是为了总结---言语，推理，资料分析 这3大类题型的快速判断分析解题思路





#言语






#推理








#资料分析





	2021-11-29 11:56:03
kumika	学习之路	# 学习之路

标签（空格分隔）： 参考的都是学习视频，知乎文章



---

#【寻径03】怎么做了那么多题，成绩还是上不来？

前提知识基础：
做题是一种归纳学习。

归纳学习是通过拟合获得泛化能力。
如何获得泛化能力：
1 已知情况，未知情况===》都满足同一客观规律
2 根据已知情况（经验）构建出一个满足已知情况（旧）的规律，并且**希望恰好就是客观规律**，建构可以满足所有已知情况（旧）的规律的过程也叫做**拟合**

**拟合是指建构可以满足所有旧情况（经验）的规律的过程。**经验是建构规律的基础和依据。但是拟合不等于学习，因为拟合只可确保重现旧情况，不能确保泛化新情况。拟合是实现泛化的手段之一，而泛化是学习的唯一目标。

拟合存在两种不理想现象：**欠拟合（UnderFitting）和过拟合（OverFitting）。**

欠拟合（UnderFitting）：旧情况规律都无法满足
欠拟合的解决方式：足够多的训练。 

**过拟合（OverFitting）：能满足旧情况规律，无法满足新情况规律**
过拟合的解决方式：（1）搜集更多经验（做更多类型的题目）；（2）增加规律的通用性（奥卡姆剃刀）。



不同于记忆追求重现，学习追求**泛化**（解决从未记忆过的新情况）。
学习方式可以分为**指令学习**和**归纳学习**，做题就体现了**通过归纳学习来提升泛化能力，即“总结已见，预测未见”。**


##双例对比法：
1 选定知识，确定一个要学习的知识点

2 指令学习，先试着理解课本上的讲解，也就是用指令学习的方式确定一个大概。（知识点描述的内容）

3 做练习题，再找出很多到该知识点的习题来做。做每道题都要经过完整的思考，不能一没思路就立马看答案，这是为了让大脑明确问题是什么？以便于让大脑做好自动归纳的准备。

4 归纳比较，就是该方法的关键，**当做完两道题后，停下来比较两道题中，该知识点的共性和差异性**，同时去理解课本上的知识点，讲解。**注意在比较共性和差异性的时候，不必太过注重规律的寻找**，因为大脑会自动完成这一工作，我们只需要**确保提供给大脑充分强的感知时间和足够多的情况就好**。

5 测试新题，不做新题来测试自己的理解，以此调整自己的理解。

6 随后再重复第二到第五步，就到将自己的方法能力提高到满意的程度为止，注意自己曾经做过的旧题，也是可以拿来更新错的题做比较，这样做能极大的节约时间和提高效率，因为该方法只需要确保每次都有两道题可以用来比较即可，不论是新做的题还是很久以前做的题。

###网友现身说法
网友1：
根据学习观的说法，问题是输入，答案是输出，得到答案的方法就是考的内容，一般就是定理什么的，你用例题(例子)来重塑大脑链接，记忆定理，为了防止过拟合，多看不同类型的题目，提升自己对知识的泛化能力。
用例题帮助自己记住定理，在做题中实践自己对定理的应用，就是这样反反复复。
再给你一个好玩的方法，那就是试着自己出题目，根据自己学到的知识点，自己出一道数学题试试，我自己就是复习的时候，出着玩，结果和高考编卷子的老师想一块去了，当年选择题最后一道直接秒选，虽然题目也不难。

GBQQZ3STAVBN  TTQRSEX3BMWN

#【寻径04】明明知识都学会了，为何还是犯错？

明确 知识规律 的 **前提条件 （定义域）**，**结果结论范围（值域）**

学习任何知识，都需要明确输入范围和输出范围。
任何学习方法，都有前提条件。




#【寻径08】什么才算有效训练，为何一看就“会”，却一做就“废”？

有效训练=实际执行+反馈答案

学习指令性材料：
1 举新例子
实例性材料（没有的话自己找）+自己试图回答，最好能用该知识解决周围现象。

2 建立新旧知识之间的关联
讲知识的特性时联系到，比如：函数三要素中的定义域和哲学中真理的绝对性和相对性
知识不是建立在名字上的（Java中的一个对象名）



# 【寻径09】自己辛苦学完，结果转眼就忘？到底怎么复习和巩固知识？

新例预测，转换表述

验证的是泛化能力
怎么泛化，用建构的知识去解决新问题

1.实例性材料的验证方式
新例预测
比如：初高中时
应试新题-应试知识-应试答案

2.指令性材料的验证方式
用另一种表述方式表达意识
比如：要用自己的话来表述

3.为什么以教为学如此重要？
以教促学是两种方法的结合
举个例子+换个说法
新例预测-举个例子
转换表述-换个说法
关键就在于教学过程，既可以验证建构知识的正确性，同时提供了一个反馈信号，让大脑更好的记住，从而巩固了知识的存储。

###网友验证
网友1：
看到思维导图那节后就开始将机械设计这本书的所有要考的章节花了五个上午做了思维导图，后续看着导图做了每个章节对应的题库。然后根据题库里面所提到的知识将思维导图补充。现在 早上花40分钟左右就可以把整本书的知识进行一次回顾。上学这么多年说实话这是我第一次感觉知识可以很有条理的放在我脑子里。昨天做了几个学校的真题（包括选择填空简答）效果杠杠的。对于高数我最近采取的都是，完整思考-对比答案思路-看课本上知识点的描述-记忆-自己做一遍，找出了我许多我原来没在意的公式定理的用法。

网友2：
目录是浓缩的信息之间的关系，即知识之间的关系，即知识网络。所以不能靠背，而是学习知识，即去理解例子和现象，从中找到的共性再用自己的话表述出来，就算学会了。

=====================================================================


#学习观第一季

##学习观01

学习是什么？

学习 ！= 理解或者记忆。
学习是从**有限的例子中**找出问题和答案**规律**的一个**过程**，而所找出的规律叫知识 ，从有限的几个题目（有限的例子）中找出他的考点以及基本的思路规律，在实践中找到解决问题的大方向，学会总结经验。

**学习正是在用知识来压缩无限的信息**

##学习观02

如何学习？

学习不是记忆，知识不是信息，**学习不是记忆知识的描述，听懂了知识的描述并不是学习**，知识的描述是学习的一个药引子，起到引导作用。

学习完整步骤：

1 学习要明确 什么是问题，什么是答案；
2 用例子来帮助构建知识体系；
3 验证知识的有效性。


##学习观04

为什么你解题时毫无头绪

拆分问题，把一个不熟悉的问题拆分为多个熟悉的小问题，把小问题解决了，大问题也就解决了。
把大问题拆解成脑中存有的，能直接从输入得到输出的小问题解决，大问题也解决了。



##学习观05

思维导图原理： 先把学习的知识描述信息通过一些实际例子进行匹配认知，然后压缩成一些抽象概括信息，如果学习的对象内容过大，则可以分解成一个个自己熟悉的问题解决方式来进行分解学习。

如何设计自己的思维导图画法：
设计依据：
1 明确输入输出任务
2 将信息压缩成抽象知识
3 例子重塑大脑连接
4 二阶知识拆分知识

二阶知识：
顿第一定律告诉物体运动状态的改变过程（力的作用），牛顿第二定律告诉你力如何作用于物体（F=ma），牛顿第三定律告诉你 力的原认识——力是成对、等大出现的。这三个定律的描述是一阶知识。如何去计算一个物体自由落体所需的时间，你要先思考物体由运动落地是一个运动改变过程，需要力（牛顿第一定律，一阶知识），计算时间你要用牛顿第二定律（一阶知识）。你得到了结果，发现了一个新的知识：一个物体自由落体需要时间是t=1/2gt^2 这个新知识是对牛顿第一、第二定律的合并使用，生成了二阶知识，合成的知识，你可以将这得到的二阶知识当做一阶知识和其他的一阶知识产生联系，生成新的二阶知识，这样不断由一阶到二阶，就会形成一个大的知识体系了。
我想有人说“我们要拼图式学习”，这本质是上应该是要我们学会从一阶知识进阶到二阶知识的过程。


#学习观第二季

##学习观07

学习英文是一个运动系学习（动态规划）

原则：明确任务的输入输出，用例子重塑大脑连接。

核心思想是英文--》事物，不经过中文翻译，前几次学习单词意思的时候可以看中文，就好像假设自己是儿童学习中文的过程，没有经过英文翻译一样的过程。


学习英文步骤：（学习任何一国外文可用的学习模板）

    1 选一个英文词语，看它的英文解释  （看不懂先看中文，想象场景，之后不要看）
    2 看多个例句抓住意思
    3 选择简单句子
    4 看句子想场景-----阅读      输入：图片 ----  ----   输出：意思 （不要读 ）
    5 表示的意思----写（打字） 输入：想表示意思 ----输出：打字
    6 听句子想场景---听力         输入：声音 ----   ---   输出：意思
    7 说出句子 --说                    输入：想表示意思 --- 输出：发声


##学习观09 生活的输入输出


判断标题里面那些是在视频里面加红加粗，自己和视频进行对比，消化不是靠一两周就完成的，先完成对比，然后在慢慢消化。


例子残缺： 标题只给你输入或者输出，但绝不完整的提供输入和输出2个对象，让你的好奇心点击内容获取流量。


输入缺失


| 标题  | 输入（X变量）| 输出（Y变量） | 知识 |
| -- | -- | -- | -- |
| 网上这些招数一直把你当小猫诱骗 | 招数 X  |诱骗的   | 招数--》属性 |
| 这个东西不能乱玩，否则后悔来不及 |东西 X | 危险的  | 东西--》属性 |
|男人不育居然是这些习惯导致的  |习惯 X | 使不育   | 习惯--》结果|
| 长寿秘诀破解，最关键的因素居然是这个 | 因素 X |使长寿   | 因素--》结果|
|赵丽颖和冯绍峰结婚背后的真相竟然是。。。  |  原因 X | 使结婚  | 原因--》结果|
|  |  |  | |
红色的输入缺失，例子的输入输出是常量，知识的输入输出是变量

---                           
标题1 
自己画颜色： red--X---这些招数   blue--Y---把你当小猫诱骗

招数--》属性

视频里：
Red----这些-----输入的主体对象变量X，但是标题没写明，属于输入缺失  
Yellow-----招数----输入对象的内容或者属性 
Blue----诱骗-----输出诱骗的Y（小猫，你），输出对象变量Y在标题中有表明，是被诱骗的小猫，输出行为是诱骗，不是输出缺失

---
标题2 
自己画颜色： red--X---这个东西      blue--Y---后悔来不及


东西--》属性

视频里：
Red------这个-----输入的主体对象变量X，但是标题没写明，属于输入缺失  
Yellow-------东西----输入对象的内容或者属性  
Blue------后悔---输出危险的X，输出对象变量Y在标题中有表明，是X乱玩的后果是危险的情况，输出行为是后悔来不及，不是输出缺失



---
标题3 
自己画颜色： red--X---男人不育      blue--Y---这些习惯


习惯--》结果

视频里：
Red-----这些-----输入的主体对象变量X，但是标题没写明，属于输入缺失  
Yellow------习惯----输入对象的内容或者属性  
Blue-----不育-----输出使不育，输出对象变量Y在标题中有表明，是男人不育的原因==》这些XXX习惯，输出行为是使不育，不是输出缺失




---
标题4 
自己画颜色： red--X---长寿秘诀      blue--Y---关键的因素

因素--》结果

视频里：
Red-----这个-----输入的主体对象变量X，但是标题没写明，属于输入缺失  
Yellow------因素----输入对象的内容或者属性  
Blue-----长寿-----输出使长寿，输出对象变量Y在标题中有表明，是长寿秘诀破解，输出行为是使长寿，不是输出缺失




---
标题5 
自己画颜色： red--X---赵丽颖和冯绍峰结婚      blue--Y---结婚原因

原因--》结果

视频里：
Red-----3个点省略号”···“-----输入的主体对象变量X，但是标题没写明，属于输入缺失  
Yellow------真相----输入对象的原因
Blue-----结婚-----输出使结婚，输出对象变量Y在标题中有表明，是2人结婚，输出行为是使结婚，不是输出缺失


---
标题6 ： red--X---      blue--Y---
     

   



输出缺失



| 标题  | 输入（X变量）| 输出（Y变量） | 知识 |
| :--: | :-- | --: |:--: |
| 新手司机误把油门当刹车，结果。。。 |错踩档   | 结果  | 行为--》结果 |
|世界上最不合拍的两个星座在一起了（。。。）   | 虐恋情 | 结果  |搭配--》结果 |
| 那些辞职去考研的人，后来怎么样了  |  硬考研  | 结果  |决策--》结果 |
| 如果世界上只剩下一个女人，将会发生什么  |  坏情况  |结果   |  情况--》结果|
| 面试官问期望的薪酬时，实际上在问什么  |  问期望 |  实际  | 表象--》实际 |
|  |  |  | |

  这类标题是新闻与电影解说类居多 

---
标题1
自己画颜色： red--X---新手司机误把油门      blue--Y---结果
视频里：red--X---省略号（...）  blue--Y---结果

行为==》结果

视频里：
Red-----省略号(...)-----输出对象变量Y在标题中没有有表明，使用的是省略号作为对象进行代替，属于输出缺失
Yellow------把油门当刹车===》踩错档----输入对象的原因/行为
Blue-----结果-----因为在标题中省略号...就是输出对象Y，没有在标题中显示出来，所以是属于输出缺失



---
标题2 
自己画颜色：  red--X---两个星座      blue--Y---在一起

视频里：red--X---省略号（...）  blue--Y---标题中没有


搭配==》结果

视频里：
Red-----省略号(...)-----输出对象变量Y在标题中没有有表明，使用的是省略号作为对象进行代替，属于输出缺失
Yellow------不合拍的星座在一起----输入对象的搭配/行为
Blue-----标题中没有写-----因为在标题中省略号...就是输出对象Y，没有在标题中显示出来，所以是属于输出缺失


---
标题3 
自己画颜色： red--X---考研的人      blue--Y---怎么样


视频里：red--X---怎么样  blue--Y---后来


决策==》结果

视频里：
Red-----怎么样 -----输出对象变量Y在标题中没有有表明，使用的是提问词，构建一种情况情形作为对象进行代替，属于输出缺失
Yellow------辞职去考研----输入对象的原因/行为/决策
Blue-----怎么样-----因为在标题中“怎么样”就是输出对象Y，具体明确的对象没有在标题中显示出来，所以是属于输出缺失

---
标题4 
自己画颜色： red--X---只剩下一个女人      blue--Y---发生什么 

视频里：red--X---什么  blue--Y---发生


情况==》结果

视频里：
Red-----什么 -----输出对象变量Y在标题中没有有表明，使用的是提问词，构建一种情况情形作为对象进行代替，属于输出缺失
Yellow------只剩下一个女人----输入对象的情况
Blue-----什么-----因为在标题中“什么”就是输出对象Y，是模糊情况，具体明确的对象没有在标题中显示出来，所以是属于输出缺失

---
标题5 
自己画颜色： red--X---问期望的薪酬      blue--Y---实际上

视频里：red--X---什么  blue--Y---实际上在问


表象==》实际

视频里：
Red-----什么 -----输出对象变量Y在标题中没有有表明，使用的是提问词，构建一种情况情形作为对象进行代替，属于输出缺失
Yellow------问期望的薪酬----输入对象的表象
Blue-----什么-----因为在标题中“什么”就是输出对象Y，是模糊情况，具体明确的对象没有在标题中显示出来，所以是属于输出缺失



标题6 ： red--X---      blue--Y---

   











分类知识


| 标题  | 输入 | 输出 | 知识（B变量） |
| :-- | :-- | :-- | :-- |
|  （你）开车遇到这种情况，赶紧加速离开 |  你自己  |  停不停  |   情况依据B  |
|一个男生，真正爱你的八种表现  |   某男生 |  爱你不  | 表现依据B |
|HR教你如何判断一个公司的好坏  | 某公司   |  好或坏  |  判断依据B |
|（你）没有感冒却长期咳嗽？有这些症状快就医  | 某个人 | 该就医 |  症状依据B |
| 越没本事的男人，往往爱说下面四句话  |  某男人  | 没本事  | 言论依据B  |
|  |  |  |  |

   对分类知识，我们好奇的是判断依据

---
标题1 
自己画颜色： red--X---开车遇到      blue--Y---加速离开


视频里：red--X---这种情况  blue--Y---停不停


情况依据

视频里：
Red-----这种情况 -----输入对象做出动作的情况和原因，对环境条件的一种概括，是勾起好奇心，学习心的一种依据。
Yellow------你自己----输入对象
Blue-----离开-----因为明确写出输入对象的动作结果，所以输出对象是你自己。



---
标题2 
自己画颜色： red--X---男生      blue--Y---表现

视频里：red--X---八种表现  blue--Y---爱你不


表现依据

视频里：
Red-----八种表现 -----输入对象做出动作的表现和原因，从学习角度来看是作为一种表现依据
Yellow------某男生----输入对象
Blue-----爱你不-----输出对象，是输入对象的结果和情形。




---
标题3 
自己画颜色： red--X---HR教你判断      blue--Y---公司的好坏


视频里：red--X---如何判断    blue--Y---好或坏


判断依据

视频里：
Red-----如何判断 -----公司，能否给你带来利益的判断依据，属于知识类学习
Yellow------某公司----输入对象是一个公司
Blue-----好或坏-----输出，是输入对象的结果和情形。


---
标题4 
自己画颜色： red--X---没有感冒却长期咳嗽      blue--Y---症状快就医


视频里：red--X---这些症状    blue--Y---就医


症状依据

视频里：
Red-----这些症状 -----症状，根据症状判断疾病，属于知识类学习，症状依据
Yellow------你----输入对象
Blue-----就医-----输出，是输入对象的结果和情形。


---
标题5 
自己画颜色： red--X---本事的男人      blue--Y---爱说下面四句话

视频里：red--X---下面4句话    blue--Y---没本事


言论依据

视频里：
Red-----下面4句话 -----言语，根据言语判断本事，属于知识类学习，言语依据
Yellow------某男人----输入对象
Blue-----没本事-----输出，是输入对象的结果和情形。

---
标题6 ： red--X---      blue--Y---



     

     

   







回归知识

| 标题  | 输入 | 输出 | 知识（P变量） |
| :-- | :-- | :-- | :-- |
| 6分钟视频教你如何成为爱情高手 | 单身狗  | 大情圣  |  方法P |
| 教你怎么涂粉底液三个小诀窍摆脱墙壁脸 | 墙壁脸 | 　靓丽脸 | 　诀窍P |
| 学会这个技巧，关键时刻能救你一命 | 　快死的你　 | 　快活的你 |  技巧P |
| 像有钱人一样思考１５个秘诀让你不知不觉发财 | 贫穷的你 | 流油的你   | 秘诀P |
| 学会这一招葱姜蒜放半年都不会坏 | 易坏葱姜蒜 | 保质葱姜蒜 |  花招P  |
|  |  |  |  |


对回归知识，我们好奇的是实现步骤


---　　
 标题1 
自己画颜色： red--X---视频教你      blue--Y---成为爱情高手

视频里：red--X---如何成为    blue--Y---爱情高手


方法依据

视频里：
Red-----如何成为 -----根据方法去泡妞，属于知识类学习
Yellow------你----输入对象
Blue-----爱情高手-----输出，是输入对象的结果和情形。
 
 
---
 标题2 
自己画颜色： red--X---涂粉底液小诀窍     blue--Y---摆脱墙壁脸

视频里：red--X---三个小诀窍    blue--Y---摆脱墙壁脸


诀窍依据

视频里：
Red-----三个小诀窍 -----根据诀窍去改善脸，属于知识类学习
Yellow------粉底液----输入对象，就是自己的墙壁脸
Blue-----白净脸靓丽脸-----输出，是输入对象的结果和情形。

--- 
 标题3 
自己画颜色： red--X---技巧      blue--Y---救你一命 


视频里：red--X---这个技巧   blue--Y---快活的你


技巧依据

视频里：
Red-----这个技 -----根据技巧去救人，属于知识类学习
Yellow------你（快死的你）----输入对象
Blue-----救你一命（快活的你）-----输出，是输入对象的结果和情形。
 
 
---
 标题4 ： red--X---思考１５个秘诀      blue--Y---发财

视频里：red--X---这个技巧   blue--Y---快活的你


秘诀依据

视频里：
Red-----这个技 -----根据秘诀去救人，属于知识类学习
Yellow------你（快死的你）----输入对象
Blue-----救你一命（快活的你）-----输出，是输入对象的结果和情形。

---
 标题5 
自己画颜色： red--X---这一招      blue--Y---不会坏

视频里：red--X---这一招   blue--Y---保质葱姜


花招依据

视频里：
Red-----这一招 -----根据花招去保质葱姜，属于知识类学习
Yellow------葱姜蒜----输入对象
Blue-----不会坏（保质葱姜）-----输出，是输入对象的结果和情形。

--- 
 标题6 ： red--X---      blue--Y---


　　


   

     





广告植入

  
| 广告  | 输入 | 输出 | 观念 |
| :-- | :-- | :-- | :-- |
| 钻石恒久远，一颗永流传+爱情捆绑 |  婚戒  | 钻戒  | 输出：保值钻戒 |
| 爱她，就请她吃跟哈根达斯 | 你自己  |  是爱她的  | 依据： 哈根达斯 |
| 今年过节不收礼，收礼就收脑白金 | 脑白金  | 过节礼物  | 输入：脑白金 |
| 怕上火就喝王老吉 | 上火的你   | 下火的你  | 方法：王老吉 |
|  |  |  |  |
   
符合大脑对知识饥渴的特点
    
---
标题1 
自己画颜色 ： red--X---钻石      blue--Y---流传+爱情捆绑


视频里--------------------------------------

输入对象：婚戒

输出对象： 钻戒

观念：输出一个保值钻戒的观念。

---  
标题2 ： red--X---爱她      blue--Y---请她吃跟哈根达斯

视频里--------------------------------------

输入对象：你自己

输出对象： 是爱她的

依据：爱她的依据是哈根达斯

---
标题3 ： red--X---过节不收礼      blue--Y---收礼就收脑白金

视频里--------------------------------------

输入对象：脑白金

输出对象： 过节礼品

输入观念：脑白金是过节礼品

---
标题4 ： red--X---怕上火      blue--Y---喝王老吉

视频里--------------------------------------

输入对象：上火的你

输出对象： 正常的你

方法： 王老吉帮助你恢复正常状态


---  
标题5 ： red--X---      blue--Y---
  
标题6 ： red--X---      blue--Y---
   

     





权健帝国
| 特别案例构建荒谬观念    |   对象    |  人性 | 
| :-- | :-- | :-- |
| 权健是继承和弘扬中医文化的自然科学 | 病人  |  权威心理 |  
| 一个信息回归一个鲜活的生命，4岁女孩在自然医学的治疗下回归自然    | 与癌症斗争的人 |  救人心切 | 
| 马云就是因为相信别人不相信的才取得成功 |  想要一夜暴富的人 |  贪婪心理 | 
|  |  |  | 
     

    

     



##学习观10

信息论

计算机里面的字节bit来源：

3bits是这么来的：log（2）8＝以2为底8的对数，2的3次方，此时3次方就是3bit，（个人理解---此时Bit字节是用来进行量化信息内容的单位，是人的五官感觉信息作为输入，量化输入到计算机中，然后计算机接收到后存储在内存中，最后输出到屏幕反馈给人，表示人的五官感觉信息成功量化，成功存储到计算机中）

log（2）1，log＝0，0bit是0字节。


##学习观11

内容是信息论

定义熵与信息之间的关系（单位是Bite）----》存在不确定性的信息具有熵，100%确定的信息的熵指数为0

信息论里面信息如何计算熵的数值

##学习观12

物理学里面的热力学熵与信息论的熵进行解释，结合生命与非生命之间的区分定义，从底层开始构建生物演化学习的过程。

##学习观14

根据熵引出地球生物演化的过程。


#学习观第三季


##学习观15

大脑是如何产生的？为什么要产生大脑这个器官？

个人理解：从远古地球到现代，生物为了生存与应对快速变化的环境，演化出快速适应机制，而控制这个机制的器官就是大脑。


切入点：
计算机学习记忆与人类大脑网络记忆的区别

计算机是查询式，快速，需要知道全部的情况，内存根据硬盘大小决定。

人类大脑网络记忆，是2维3维4维等多个变量参数决定的，大脑神经元之间的连接可以视为权重，输入的变量参数根据神经元连接权重的大小，输出结果可能正确，可能不正确。原因是学习模型中，要是出现发呆，开小差，理解内容错误，推理错误-----神经元连接可能会连接到错误的神经元上，导致输出错误。

YJango视频中是把输入，神经元连接，输出，看作3个对象，3个都是可以变化的，其中神经元连接被成为权重，权重是可以随时改变的，这是可以把---记忆随着时间减弱，遇到相似物体记忆内容改变---这个现象解释清楚。


人类大脑网络记忆是提取出共同规律，一个公式。

###大脑是自己产生遗忘行为，为什么会产生遗忘机制？

概率筛选机制。

生物遇到某种自然法则是随机的，随机之间也有局部规律，遇见1次可能是特例是偶然，但是遇见次数多了，必然是某种公式，某种规律。

当出现学习模型在使用某种规律公式出现结果冲突，或者某公式低频率使用的时候，特殊规律的模型就会被弱化神经元连接，就会遗忘，遗忘就是舍弃，删除的某一类学习模型的作用。

环境是不断改变的，但是某规律公式是不变的，所以这就是为什么要重复记忆，为什么会反复遗忘。


为什么学习过记忆过的内容还是会遗忘？

学习过的内容某个规律，可能无法应对将来某个场景某个问题，可能是这个规律是局部规律


##学习观16

大脑神经元突触进行电信号交流的过程

神经工作的原理和过程


神经网的学习
神经的学习机制：重复
.
神经的筛选机制：遗忘

-----------------------------------
根据生物特性的神经网络学习的逻辑过程

原来的单细胞初级生物依靠突变和生物的数量来完成去适应环境，这个适应过程中是超越单个单细胞的生命周期的。

随着生物朝着高级复杂机构发展，不能靠生物种群数量和单个不定向突变来完成适应环境，因为高级生物的哺育生命周期长，生物死亡数量升高会导致生物种群消亡，此时大脑神经网络演化出现了。


神经网络里面突触可塑性是关键。突触增多受体，则是增强作用，加快神经信号的传递，神经递质的速度；减少受体，则可以抑制神经递质的作用，甚至可以屏蔽。

这样的调节的能力就可以无需死亡就可适应环境，此过程可归类为学习过程。

因为维持生物生命，快速掌握生活在某环境的生活规律，规律不是一下子就可以找到的，所以需要泛化能力，所以学习和学习过程需要不断尝试，不断筛选。


在神经网络中不断尝试表现就是：重复（强化使用频率高的突触连接），不断筛选就是：遗忘（弱化使用频率低的突触连接）

遗忘不是大脑的缺陷，是筛选规律的过程，是学习的一部分，正如排除不符合实验结果的假说假设或者猜想，没有遗忘，个体将会以死亡为代价进行筛选。



##学习观17  

为何你知道该做什么，却始终难以行动

情绪系统----决策层

逻辑系统----智囊团

调控监控系统===》优先级判断系统---高响应比优先调度算法

---------------------

视频里面没有对情绪系统和动机系统进行一个优先级的比较，是进行一个量化后数值的比较，例如情绪系统积攒8个积分，动机系统积攒12个积分，则优先执行动机系统的指令。


-------------

视频的逻辑链条


根据需求的迫切程度优先哪一个，演化出一个系统用作估计某个需求的迫切程度；需求满足，估计指数降低，需求不能满足，估计指数积累升高

描述此大脑需求信号的叫做动机，动机系统分为2种情况：
1 激励显著性---欲望，
2 厌恶显著性


欲望不一定带来快乐，快乐行为不一定带来欲望，诱发行为的动机并非是快乐感。例子是现实生活中存在痛并快乐着的行为，此时的快乐是欲望的满足。


动机和快乐受到不同的神经系统的不同神经递质控制，情绪的快乐感与动机的快乐感是不一致的，情绪的快乐感是能判断当前环境是有利或者有害，无法判断当前所需要的，动机的快乐感是能判断存在长期有利的，不一定判断出是当前所需的

转运体运载多巴胺完成突触神经信号的结束，可卡因会占领多巴胺在转运体的座位，使得神经信号无法结束。

-----------------
网友总结：
情绪----帮助大脑做决策----但无法决定需求优先级----通过动机系统估计需求迫切程度----选择最适合当前需求的行为------而理性无法越过动机系统做决定----欲望动机无法代表需求本身-----不能让动机系统被劫持


--------------

我和视频出现的观念冲突点：

情绪和动机系统都是可以做出当前迫切需求的指令的，是可以决定需求优先级的。问题出现在动机系统和情绪系统判断出的需求优先级一致的时候，此时我的知识有限，无法做出判断，但是视频里面也没有明确说明，现在就是很纠结。






##学习观18.5   素质教育













#参考：
B站的YJango视频学习观


学习就是根据已知情况**推理**出未知情况的正确答案


----------------

     表格的使用==》   |:--:|居中对齐、|:--|左对齐、|--:|右对齐。
     <br>是换行符
        
----------
    
<font face="黑体">我是黑体字</font>
<font face="微软雅黑">我是微软雅黑</font>
<font face="STCAIYUN">我是华文彩云</font>
<font color=red>我是红色</font>
<font color=#008000>我是绿色</font>
<font color=Blue>我是蓝色</font>
<font size=5>我是尺寸</font>
<font face="黑体" color=green size=5>我是黑体，绿色，尺寸为5</font>

	2021-12-28 18:44:44
kumika	MBA的数学	# MBA的数学

标签（空格分隔）： 未分类

---

在此输入正文




















	2022-04-25 02:21:53
kumika	2017年国考卷	# 2017年国考卷

Tags： 试卷复盘

---

#言语


---
21：

若不能XXXX，就只能YYYY，  因为存在“不能”这个否定谓语，根据第二主干大法语法规则XXX和YYY是意思相反的，所以要和千锤百炼，成年累月的含义相反

这里出现以前没注意的要点：  
若不能______缺少的是adj，前面描述主语的adj是褒义词---异曲同工之妙，所以也是需要褒义词，所以B选项的“一蹴而就”排除，它是贬义词。
D选项“灵机一动”，表示突然想出办法，一般指人很聪明，形容人的。

错误思考：研究创造，需要灵感，“灵”字与选项D中的“灵机一动”完美匹配。

正确思路：这里需要形容事情---科学研究这件事，所以不能使用形容人的词语。

考察：词意，情感色彩

---
22：

主语，宾语都在，“被”字是介词，缺少谓语，看分句的具体内容还缺动词。


整体是中性情感，所以使用中性的词语，其他选项都有情感倾向，D选项是改变方向



---


23：

A项：怕连累到自己而回避斗争的**处世态度**


C项：别人好坏我不管，我只管我自己是好的


考察：词意


---
24：

根据词语搭配，丧失竞争，A筹码，D优势是可以的，与C项机遇搭配不当，与B能力搭配使得句子程度过重。


较真的思考：筹码也可以看作能力，进行排除，因为能力没有说明是多少大小程度，筹码也是同理。

第二个空： 

定位信息，一般是搭配精准，准确，确切。



详细和确切，用来描述信息都是可以的，所以需要采取优中选优办法-----看题目中描述的主体对象是什么，填空的adj是和主体对象是有对应关系的。比如卫星一般是和精准进行搭配的。


---

25：


常识：外交语言一般是固定的，比如黑话翻译----友好交流，热烈的友好交流，双方交换了意见——各说各的，没有达成协议，；双方充分交换了意见——我们吵了一通，没摔杯子；


---

26：

第一空： “且”表示并列，“无法毕其功于一役”“多项改革”表示这个问题很复杂，所以第一个空要填写很复杂的意思，。

第二个空： 逗号后面的分句是对这个空的补充说明，“必须启动或加速”表示第二个空内容是要和速度有关的意思。



---

27：

妙不可言：形容好得难以用文字、语言表达。

独树一帜：形容与众不同，自成一家。**题目没有体现出数学的独特性唯一性，所以排除。**


其他选项：程度过重



---

28：

第一空：抽象化的能力与处理数学问题能力 是怎么个相关法，完全看作者心情 ，无法在题目信息内推出。



第二空：根据“但是”，“观点的可靠性”和后面举例爱因斯坦的内容有“似乎”表明爱因斯坦也不确定，推出一定没有否定的意思，提示填入的内容要有**质疑**的意思。

可靠性可以与质疑相搭配。

---


29：

别致：新奇，但是题目没有给出多种做法对比，也没有新奇，所以排除

无所适从：指不知依从谁才好，也指不知道怎么办才好，但是题目没有给出选择的意思，所以排除

考察词意，看词是否与题目的对象，题目意思相符合，不符合的就排除。

---

30：

根据后文“前沿概念”，推出人们对这个概念是不怎么熟悉的，所以排除“如数家珍”，“了如指掌”。

“念念不忘”：指思念，难以忘怀，一般与某人某事进行搭配。

考察词意。

---

31：

根据后文：“水自源头奔流而下”，推出流动的意思。


---

32：

这是一个根据整体句子意思进行推理的考法

根据一般解题方法就是一个分句修饰前面句子的名词，这里就直接看作修饰“特色”。然后就开始进行思考能够和“特色”进行搭配的词语。在进行匹配词语的过程中很容易把“特色”等同于“特长”，“特点”进行匹配。

**特色 拾遗补缺是行政文的固定搭配**

---

33：

第一空： 根据最后一句话的内容，“技术进步的推动与客户不断变化的需求”中的“技术推动”和“不断变化的需求”，可以推出创新是需要“渐进”，“逐步”实现的意思。


考察词意

同日而语：
指把不同的人或者事物放在同一时间比较，放在一起谈论或者看待。侧重时间上的先后，常用于否定式“不可同日而语”。

比如:古A 和今A不可同日而语（有变化了）。

等量齐观：
指对着有差别的事物同等看待。
比如:A+ 和A-不可等量齐观（量不一样了）。



相提并论：
指把不同的人或者事物不加区别地混在一起来谈论或者看待。

比如:A 和a 不可相提并论（a不如A）。




混为一谈：
指把不同的事物混在一起，当做相同的事物进行谈论。

比如: A 和B不能混为一谈（不同的事物）。


---

34：


瞻前顾后：指看看前面，又看看后面。形容做事之前考虑周密慎重；也形容顾虑太多，犹豫不决。


左支右绌：指力量不足，应付了这方面，那方面又出了问题。



力不从心：指心中想做某事而力量达不到或无力去做。

进退失据： 形容无处容身，进退两难。


手足无措：手足无措指手脚不知放到哪儿好，常用于形容举动慌张，或无法应付。


考察词意，但是带有考察词语程度的意味


---


35：

第三空： 没有舞台布景，没有灯光，说明表演环境十分简陋简单，不能说是临时，因为永久的舞台也有简单的环境。

考察题目提示


---


36：

考察词意和词语程度，词语情感色彩


---


37：


历经----兴衰

见证，目睹的主语都要人，这里不是人作主语。


考察词语搭配




---


38：

第二空： 前文出现的转折词“但”和形容词“单一乃至僵化的缺陷”对这个空进行修饰，所以填入的内容是形容内容的对立面反面，同时，后文出现“发挥了重要作用”，也提示这个空填入的意思是要有重大作用程度深的词语

只有“不可否认”符合，“显而易见”和“无独有偶”不能体现出作用大程度深


考察题目提示和词意

---

39：

拥护：指扶助；保护；簇拥；对领袖、党派、政策、措施等表示赞成并全力支持
拥护理念是搭配不当，一般是拥护领导、拥护群众等，理念前一般加名称比如创新理念、个人理念等。

不期而至：事先没有约定而意外到来。


考察词意和搭配

----

40：

根据前面的“浮躁”和“纯粹”这2个词语进行反面对比，
然后模仿这个反面对比，
第一个空根据“投机取巧”进行反面对比，
第二个空根据“专注持久”进行反面对比，
第三个空根据“优品精品”进行反面对比


考察题目提示和词意


---

41（细节题）：

思考定式导致错误，当题目没有使用句号做内容分割的时候，就是使用逗号分句作为内容分割符号。不要一直以为只有完整的一句话才是一个内容点，有时候一个分句也是一个内容点。


适用范围是一定要提出对象，这里没有提出谁是对象。所以适用范围就是答案。


---

42（意图题的新问法---给人的启示）：


题型判断： 总结原文的基础上可以引申推理，这就是意图题

农村，首要，经济协调发展，这3个词都没有在原文出现，所以是无中生有，ABC排除。

“对此”是总结句提示，有强调作用，所以选项是总结句的概括，至于**延伸的内容，一般看作是概括词语的同义转换。**

---

43（主旨类）：

题型判断： 这段文字**主要介绍/讲述/表达/说**了。

解题方法：选择选项是**对文段内容概括**，**并且没有引申推断内容的（这就是意图题和主旨题的区别）**


文段写了夏威夷火山的多个特点，答案就要选择概括这几个特点的选项，不能缺少一个，要全面的，并且没有文段中没有提及的具体的对象内容，不能无中生有。


---

44（观点类）：

给出明显观点的题型
给出隐藏观点的题型
没有给出观点的题型

题目没有给出明显的观点，也没有给出倾向性的字词，关联词，设问，就是单纯的一个客观陈述。

所以是属于第三类没有观点的题型。

解题方法1： 
**以题目都内容为准则，判断选项的内容是不是无中生有，片面，偏离主题**

解题方法2：
对段落拆分解析：
（1）在古代，对未知世界的恐惧感不只属于儿童。中世纪的绘图师们在绘制地图时，并不把未知地带留为空白，而是画上海蛇和想象中的怪兽，并标记「此处有龙」。
（2）几个世纪以来，探险家们穿越大洋，攀登高山，逐渐在地图上把这些想象替换成了真实的标记。
（3）现如今，我们可以从外太空拍摄照片，感叹地球之美。通信网络造就了「地球村」，世界变得越来越小了。

拆分后发现，（1）提到了古代对未知世界的恐惧感，（2）讲述了探险家逐渐排除未知恐惧，（3）用「外太空拍摄+通信网络」的科技组合来收尾。也就是说，本题和「克服恐惧」「科技进步」有关。

解析后可发现，C「读万卷书，行万里路」中的「读书」和D「吾生也有涯，而知也无涯」中「求知」显然不是本段的重点，直接排除。

A「科技让世界更美好」和B「知识是治疗恐惧的良药」其实都是本段所要表达的意思，「科技」和 「知识」在本段中大致是一个意思，然而「克服（治疗）恐惧」是一个有很强针对性的描述，而「让世界变的更美好」则属于一个泛泛的描述。

本题大部分都在讲述「克服恐惧」这个事情，显然针对性更强的B更适合。如果没有B选项，那A其实也是勉强合适的。

相对于B来说，A的问题是描述的面太大，用词太宽泛。「让世界更美好」总给人一种某电器、保险或者汽车广告的感觉，让人联想到让生活更舒适，让信息交流更快捷，让出行更便利等方面，和题干大部分在描述恐惧以及克服恐惧无关。

散文较难吃准核心含义，因此提炼关键词，从选项入手是破解此类题目的要点。

---

45（意图题）：

文段中间的“同时”表示并列，所以战略位置也是重点，所以战略位置一定不是总结句，所以最后一句话是总结句。




---

46（语句衔接类）：

根据“正对着地球运动”可以判断前面需要填入的内容是一定要带有方向之类的意思。


---

47（主旨类）：

文段中“这种“惑乱””，提示是文段的总结，后面的句子就是重点内容，“固然····但是····”表示转折部分内容就是重点内容，所以重点内容是文史不能分家不能混淆不能相互取代。

要是没有概括重点内容的选项，优先选择基于重点内容而采取的对策选项。



---

48（标题类）：

文段采用了“观点”+解释说明的结构。

所以色彩是主题词，珊瑚虫不是，并且“乐于奉献”在文段中没有说，属于是无中生有，排除D选项。


---

49（下文推断类）：

解题思路：
找出**尾句主体**，看选项有前文内容的排除，有无关内容的排除

B项是第一句话的内容


C项是第二三句话的内容

D项是第二三句话的内容


---

50（排序类）：


找出每个句子的主体，然后进行捆绑，最后进行排序。


---

51（排序类）：

找出每个句子的主体，然后进行捆绑，最后进行排序。


---


52（排序类）：

找出每个句子的主体，然后进行捆绑，最后进行排序。


---

53（主旨类）：

题目都是陈述句，但是“将为”提示这分句内容是对策内容，又因为没有总结句，所以对策内容是重点内容，所以答案要选择对策内容的。


---

54（意图类）：

确定重点句：根据“以此为依据”，“在此基础上”这2个“此”字带有总结意思，提示出这就是本题的重点句。重点句的内容就是答案，所以以重点句的主体对象为标准，去对比选项。


C选项使用了偷换概念中的偷换时态，题目中“实现了”是表示已然时态，C选项中“正从”表示进行时态，虽然主体对象有国家安全谋划，但是已经偷换概念了。


一定要以重点句的主体对象是谁，做什么事，这样的逻辑为标准，去看选项，这时候本质考察的还是形式逻辑的内容。

---

55（观点类）：

题目中出现“我对XXX有了XXXX认识”的句子，提示了作者观点的位置，重点看这个句子。

---

56（意图类）：


题目第二句话出现转折词“然而”，提示这句话就是重点内容，提出关键词，重视，意识。

看选项哪一个内容与重点句关键词一致就是正确答案。


---

57（代词指代类）：


根据指代词“转型升级”的上下文进行判断。

因为指代词已经是最后一句话，所以不用看下文。只需要看上一句，“理性面对····旅游的快乐”，这就是作者的观点，所以观点内容是重点，看选项哪一个符合观点内容的。



---

58（语句衔接类）：


重点句从转折词“但众所周知”开始，到文段结束，这堆都是重点。































#参考

水乡迷情 Waterland


【ZIRAN】 秋色妻
【A極振り (Sian)】 雌ガチャⅢプレビュ
【ひとのふんどし (ゆきよし真水)】 私が先に好きだったのに整体。
【ひかげもん】 女の子がある日突然サキュバスになってしまう世界の話




















	2023-08-10 19:41:57
